# Развернутые ответы на вопросы собеседования по микросервисам

## 1. 🏗️ Архитектурное проектирование

### Кейс: Декомпозиция e-commerce монолита

**Правильный подход:**

**1. Определение bounded contexts (DDD):**
- **User Management**: регистрация, профили, аутентификация
- **Product Catalog**: товары, категории, поиск
- **Shopping Cart**: корзина покупок (временное состояние)
- **Order Management**: создание и управление заказами
- **Payment Processing**: обработка платежей
- **Inventory**: управление складскими остатками
- **Notification**: email/SMS уведомления

**2. Пример разделения данных:**

```javascript
// User Service - владеет данными пользователей
{
  userId: "123",
  email: "user@example.com",
  profile: { name: "John", address: "..." }
}

// Order Service - хранит только ссылку на пользователя
{
  orderId: "ord-456",
  userId: "123", // ссылка, не дублирование
  items: [{ productId: "prod-789", quantity: 2 }],
  status: "pending"
}
```

**3. Принципы проектирования:**
- **Database per service** - каждый сервис имеет свою БД
- **Service ownership** - команда владеет сервисом от кода до продакшена
- **Business capabilities** - сервисы построены вокруг бизнес-функций

**Углубляющие ответы:**

**Q: Границы между User Service и Order Service?**
A: User Service управляет профилем и аутентификацией. Order Service управляет жизненным циклом заказа. Скидки - в отдельном Promotion Service, который участвует в расчете цены заказа через API или события.

**Q: Как Order Service получает данные пользователя?**
```javascript
// Вариант 1: Синхронный вызов с кешированием
const getUserData = async (userId) => {
  const cached = await redis.get(`user:${userId}`);
  if (cached) return JSON.parse(cached);
  
  const userData = await userService.getUser(userId);
  await redis.setex(`user:${userId}`, 300, JSON.stringify(userData));
  return userData;
};

// Вариант 2: Event-driven репликация
// User Service публикует события при изменениях
// Order Service подписывается и хранит нужные данные локально
```

---

## 2. 🔄 Коммуникация и интеграция

### Кейс: Производительность при вызове 5 сервисов

**Проблема:** Последовательные вызовы увеличивают latency
**Решения:**

**1. API Gateway с параллельными вызовами:**
```javascript
// До: последовательно 5 × 200ms = 1000ms
const product = await catalogService.getProduct(id);
const reviews = await reviewService.getReviews(id);
const inventory = await inventoryService.getStock(id);
const pricing = await pricingService.getPrice(id);
const recommendations = await mlService.getRecommendations(id);

// После: параллельно = max(200ms) = 200ms
const [product, reviews, inventory, pricing, recommendations] = 
  await Promise.all([
    catalogService.getProduct(id),
    reviewService.getReviews(id),
    inventoryService.getStock(id),
    pricingService.getPrice(id),
    mlService.getRecommendations(id)
  ]);
```

**2. BFF (Backend for Frontend) pattern:**
```javascript
// Product Page BFF - оптимизирован для фронтенда
app.get('/api/product-page/:id', async (req, res) => {
  const productId = req.params.id;
  
  try {
    const [product, inventory, pricing] = await Promise.all([
      catalogService.getProduct(productId),
      inventoryService.getStock(productId),
      pricingService.getPrice(productId)
    ]);
    
    // Aggregated response для фронтенда
    res.json({
      product: { ...product, inStock: inventory.quantity > 0 },
      price: pricing.currentPrice,
      available: inventory.quantity
    });
  } catch (error) {
    // Graceful degradation
    res.json({ product: await catalogService.getProduct(productId) });
  }
});
```

**Q: Что если один из сервисов недоступен?**
```javascript
// Circuit Breaker pattern
const CircuitBreaker = require('opossum');

const reviewsBreaker = new CircuitBreaker(reviewService.getReviews, {
  timeout: 3000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
});

reviewsBreaker.fallback(() => ({ reviews: [], message: 'Reviews temporarily unavailable' }));
```

---

## 3. 📊 Управление данными

### Кейс: Отчет "ТОП-10 товаров по выручке"

**Проблема:** Данные распределены по сервисам
**Решения:**

**1. CQRS + Read Model:**
```javascript
// Event handlers создают read model для отчетов
class SalesReportProjection {
  async handleOrderCompleted(event) {
    await this.db.query(`
      INSERT INTO sales_summary (product_id, region, revenue, order_date)
      VALUES (?, ?, ?, ?)
      ON DUPLICATE KEY UPDATE revenue = revenue + VALUES(revenue)
    `, [event.productId, event.userRegion, event.amount, event.date]);
  }
  
  async getTopProducts(region, dateFrom, dateTo) {
    return this.db.query(`
      SELECT product_id, SUM(revenue) as total_revenue
      FROM sales_summary 
      WHERE region = ? AND order_date BETWEEN ? AND ?
      GROUP BY product_id
      ORDER BY total_revenue DESC
      LIMIT 10
    `, [region, dateFrom, dateTo]);
  }
}
```

**2. Event Sourcing для аналитики:**
```javascript
// События как источник истины
const events = [
  { type: 'OrderCreated', productId: 'p1', amount: 100, region: 'EU' },
  { type: 'OrderCompleted', orderId: 'o1', completedAt: '2024-01-15' },
  { type: 'OrderCancelled', orderId: 'o2', reason: 'user_request' }
];

// Rebuild проекции из событий
const rebuildSalesReport = async () => {
  const projection = new SalesReportProjection();
  const events = await eventStore.getAllEvents();
  
  for (const event of events) {
    await projection.handle(event);
  }
};
```

**Q: GDPR и право на забвение?**
```javascript
// Crypto-shredding: шифруем PII отдельным ключом на пользователя
const encryptUserData = (userData, userKey) => encrypt(userData, userKey);

// При удалении пользователя удаляем только ключ
const forgetUser = async (userId) => {
  await keyStore.delete(`user_key_${userId}`);
  // События остаются, но PII нечитаема без ключа
};
```

---

## 4. 🚀 DevOps и деплоймент

### Кейс: Production incident с Payment Service

**Immediate response (первые 5 минут):**

```bash
# 1. Проверить health endpoints
curl https://payment-service/health
curl https://order-service/health

# 2. Быстрый rollback если критично
kubectl rollout undo deployment/payment-service

# 3. Проверить distributed traces
# Jaeger/Zipkin: найти traces с высоким latency
```

**Root cause analysis:**
```javascript
// Пример проблемы: изменился контракт API
// Payment Service v2 возвращает новое поле
{
  "status": "completed",
  "transactionId": "tx123",
  "processingTime": 250  // новое поле
}

// Order Service ожидает старый формат и падает
const result = await paymentService.processPayment(data);
console.log(result.transaction_id); // undefined! поле называется transactionId
```

**Prevention strategies:**
```javascript
// 1. Contract testing с Pact
describe('Payment Service Contract', () => {
  it('should return payment result', async () => {
    await provider
      .given('payment is processed')
      .uponReceiving('a payment request')
      .withRequest({ method: 'POST', path: '/payments' })
      .willRespondWith({
        status: 200,
        body: { status: 'completed', transaction_id: Matchers.string() }
      });
  });
});

// 2. Canary deployment
apiVersion: argoproj.io/v1alpha1
kind: Rollout
spec:
  strategy:
    canary:
      steps:
      - setWeight: 10
      - pause: {duration: 60s}
      - setWeight: 50
      - pause: {duration: 300s}
```

---

## 5. 📈 Monitoring и наблюдаемость

### Кейс: Медленные запросы (99-й перцентиль высокий)

**Distributed tracing analysis:**
```javascript
// Пример медленного trace
{
  "traceId": "abc123",
  "spans": [
    { "service": "api-gateway", "duration": 2000, "operation": "GET /product/123" },
    { "service": "catalog", "duration": 50, "operation": "get_product" },
    { "service": "pricing", "duration": 1900, "operation": "calculate_price" }, // проблема!
    { "service": "inventory", "duration": 30, "operation": "check_stock" }
  ]
}
```

**Metrics для раннего обнаружения:**
```javascript
// Custom metrics в коде
const priceCalculationTimer = prometheus.register.getSingleMetric('price_calculation_duration');

app.post('/calculate-price', async (req, res) => {
  const timer = priceCalculationTimer.startTimer();
  
  try {
    const price = await complexPriceCalculation(req.body);
    timer({ status: 'success' });
    res.json({ price });
  } catch (error) {
    timer({ status: 'error' });
    throw error;
  }
});

// Alerting правила
groups:
- name: performance
  rules:
  - alert: HighLatencyP99
    expr: histogram_quantile(0.99, price_calculation_duration) > 1000
    for: 2m
    annotations:
      summary: "Price calculation P99 latency is high"
```

**SLI/SLO определение:**
```yaml
# SLI: 99% запросов выполняются быстрее 500ms
# SLO: 99.9% uptime за месяц
# Error budget: 0.1% = ~43 минуты downtime в месяц

apiVersion: sloth.slok.dev/v1
kind: PrometheusServiceLevel
metadata:
  name: payment-service-slo
spec:
  slis:
    - name: "requests-availability"
      query: |
        sum(rate(http_requests_total{job="payment-service", code!~"5.."}[5m])) /
        sum(rate(http_requests_total{job="payment-service"}[5m]))
  objectives:
    - name: "99.9-availability"
      target: 0.999
```

---

## 6. 🔐 Безопасность

### Кейс: API для внешних партнеров

**OAuth 2.0 Client Credentials flow:**
```javascript
// 1. Партнер получает токен
POST /oauth/token
{
  "grant_type": "client_credentials",
  "client_id": "partner_a_client",
  "client_secret": "secret123",
  "scope": "orders:create"
}

// 2. JWT с claims для авторизации
{
  "sub": "partner_a",
  "scope": "orders:create",
  "partner_id": "partner_a",
  "allowed_users": ["user123", "user456"] // только эти пользователи
}
```

**Service-to-service авторизация:**
```javascript
// Middleware для проверки прав
const authorizePartner = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  
  // Проверяем что партнер может создать заказ для этого пользователя
  if (!decoded.allowed_users.includes(req.body.userId)) {
    return res.status(403).json({ error: 'User not allowed for this partner' });
  }
  
  req.partner = decoded;
  next();
};

app.post('/orders', authorizePartner, async (req, res) => {
  const order = await createOrder({
    ...req.body,
    partnerId: req.partner.partner_id
  });
  
  // Audit log
  logger.info('Order created by partner', {
    partnerId: req.partner.partner_id,
    orderId: order.id,
    userId: req.body.userId
  });
  
  res.json(order);
});
```

---

## 7. ⚡ Масштабирование

### Кейс: Viral growth (трафик вырос в 50 раз)

**Быстрые действия (5 минут):**
```bash
# 1. Увеличить replicas критичных сервисов
kubectl scale deployment catalog-service --replicas=10
kubectl scale deployment api-gateway --replicas=5

# 2. Включить кеширование на CDN/Load Balancer уровне
# 3. Увеличить connection pool limits
```

**Auto-scaling политики:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: catalog-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: catalog-service
  minReplicas: 2
  maxReplicas: 50
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**Circuit breaker для предотвращения cascade failure:**
```javascript
const catalogBreaker = new CircuitBreaker(catalogService.getProduct, {
  timeout: 1000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
});

// Fallback к кешу при перегрузке
catalogBreaker.fallback(async (productId) => {
  const cached = await redis.get(`product:${productId}`);
  return cached ? JSON.parse(cached) : { error: 'Service temporarily unavailable' };
});
```

---

## 8. 🎯 Проблемы и компромиссы

### Когда НЕ использовать микросервисы

**Конкретные примеры:**

**1. Стартап с командой 3-5 разработчиков:**
- Нет ресурсов на операционную сложность
- Лучше модульный монолит с четкими границами
- Можно мигрировать позже

**2. CRUD приложение без сложной бизнес-логики:**
```javascript
// Простое приложение для управления задачами
// Сервисы: Users, Tasks, Projects
// Взаимодействие минимально - микросервисы излишни

// Лучше: модули в одном приложении
const app = express();
app.use('/users', userRoutes);
app.use('/tasks', taskRoutes);
app.use('/projects', projectRoutes);
```

**3. Система с сильными ACID требованиями:**
```sql
-- Финансовая система: перевод денег
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
INSERT INTO transactions (from_account, to_account, amount) VALUES (1, 2, 100);
COMMIT;

-- В микросервисах потребуется сложная Saga coordination
-- Проще оставить в монолите
```

**Правило принятия решений:**
- **Team maturity**: есть ли опыт с distributed systems?
- **Business complexity**: достаточно ли сложна доменная область?
- **Scale requirements**: действительно ли нужно независимое масштабирование?
- **Operational overhead**: готовы ли вы к 10x сложности деплоймента и мониторинга?

---

## 📝 Заключение

**Ключевые принципы:**
1. **Business-first**: технические решения должны решать бизнес-проблемы
2. **Start simple**: начинайте с монолита, мигрируйте по необходимости  
3. **Conway's Law**: архитектура отражает организационную структуру
4. **Operational excellence**: микросервисы требуют зрелых DevOps практик

**Признаки готовности к микросервисам:**
- ✅ Команды > 8-10 человек
- ✅ Четкие доменные границы
- ✅ Разные требования к масштабированию
- ✅ Зрелые CI/CD и monitoring
- ✅ Опыт с distributed systems