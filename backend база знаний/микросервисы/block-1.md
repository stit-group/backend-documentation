# 📚 Блок 1: Основы и теория микросервисов

---

**⏱️ Продолжительность:** 4-6 недель  
**🎯 Цель:** Понять фундаментальные принципы микросервисной архитектуры и ее отличия от монолитных приложений  
**📈 Уровень:** Начинающий → Продвинутый новичок

---

## 🚀 Глава 1: Введение в микросервисы

### 📖 История развития архитектурных подходов

```
ЭВОЛЮЦИЯ АРХИТЕКТУРЫ ПРИЛОЖЕНИЙ
═══════════════════════════════════════════════════════════════

1990s          2000s          2010s          2020s
──────         ──────         ──────         ──────
Монолит   →    SOA      →   Микросервисы  →  Serverless
                                              Container
                                              Native
```

**Ключевые этапы:**

1. **Монолитные приложения (1990s-2000s)**
   - Одно большое приложение
   - Все компоненты в одном процессе
   - Простое развертывание, но сложное масштабирование

2. **Service-Oriented Architecture - SOA (2000s)**
   - Разделение на сервисы
   - Тяжелые протоколы (SOAP, WSDL)
   - Enterprise Service Bus (ESB)

3. **Микросервисы (2010s-настоящее время)**
   - Легковесные протоколы (REST, gRPC)
   - Автономные команды и сервисы
   - DevOps и контейнеризация

---

### ⚠️ Проблемы монолитных приложений

```
МОНОЛИТНОЕ ПРИЛОЖЕНИЕ - ТИПИЧНЫЕ ПРОБЛЕМЫ
╔══════════════════════════════════════════════════════════════╗
║                   МОНОЛИТ                                    ║
║  ┌─────────────────────────────────────────────────────────┐ ║
║  │  User Interface                                         │ ║
║  ├─────────────────────────────────────────────────────────┤ ║
║  │  Business Logic                                         │ ║
║  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────────┐│ ║
║  │  │ Orders  │ │ Users   │ │ Payment │ │ Inventory       ││ ║
║  │  │ Module  │ │ Module  │ │ Module  │ │ Module          ││ ║
║  │  └─────────┘ └─────────┘ └─────────┘ └─────────────────┘│ ║
║  ├─────────────────────────────────────────────────────────┤ ║
║  │  Database Access Layer                                  │ ║
║  └─────────────────────────────────────────────────────────┘ ║
║                           │                                  ║
║                           ▼                                  ║
║                    ┌──────────────┐                         ║
║                    │   Database   │                         ║
║                    └──────────────┘                         ║
╚══════════════════════════════════════════════════════════════╝
```

**Основные проблемы:**

🔴 **Технологическая привязка**
- Один язык программирования для всего приложения
- Сложно внедрить новые технологии
- Upgrade всей системы сразу

🔴 **Масштабирование**
- Необходимо масштабировать всё приложение целиком
- Невозможно масштабировать отдельные модули
- Неэффективное использование ресурсов

🔴 **Разработка и команды**
- Все разработчики работают с одной кодовой базой
- Конфликты при слиянии кода
- Длинные циклы релизов

🔴 **Отказоустойчивость**
- Падение одного модуля = падение всего приложения
- Каскадные отказы
- Сложность локализации проблем

---

### ✅ Что такое микросервисы и их преимущества

```
МИКРОСЕРВИСНАЯ АРХИТЕКТУРА
═══════════════════════════════════════════════════════════════

    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
    │   Frontend   │    │  API Gateway │    │ Load Balancer│
    │  (React/Vue) │    │             │    │              │
    └──────┬───────┘    └──────┬───────┘    └──────┬───────┘
           │                   │                   │
           └───────────────────┼───────────────────┘
                              │
          ┌───────────────────┼───────────────────┐
          │                  │                   │
          ▼                  ▼                   ▼
    ┌──────────┐       ┌──────────┐       ┌──────────┐
    │  User    │       │  Order   │       │ Payment  │
    │ Service  │       │ Service  │       │ Service  │
    │          │       │          │       │          │
    │ ┌──────┐ │       │ ┌──────┐ │       │ ┌──────┐ │
    │ │ API  │ │       │ │ API  │ │       │ │ API  │ │
    │ └──────┘ │       │ └──────┘ │       │ └──────┘ │
    │ ┌──────┐ │       │ ┌──────┐ │       │ ┌──────┐ │
    │ │Logic │ │       │ │Logic │ │       │ │Logic │ │
    │ └──────┘ │       │ └──────┘ │       │ └──────┘ │
    └────┬─────┘       └────┬─────┘       └────┬─────┘
         │                  │                  │
         ▼                  ▼                  ▼
    ┌──────────┐       ┌──────────┐       ┌──────────┐
    │  Users   │       │  Orders  │       │ Payments │
    │    DB    │       │    DB    │       │    DB    │
    └──────────┘       └──────────┘       └──────────┘
```

**Определение микросервиса:**
> Микросервис — это небольшое автономное приложение, которое выполняет конкретную бизнес-функцию и может быть разработано, развернуто и масштабировано независимо.

**Ключевые характеристики:**

🟢 **Единственная ответственность**
- Каждый сервис отвечает за одну бизнес-область
- Четко определенные границы
- Фокус на конкретной функциональности

🟢 **Автономность**
- Независимое развертывание
- Собственная база данных
- Отдельный жизненный цикл

🟢 **Децентрализация**
- Управление данными
- Принятие решений
- Технологический выбор

---

### ⚖️ Недостатки и сложности микросервисов

```
СЛОЖНОСТИ МИКРОСЕРВИСНОЙ АРХИТЕКТУРЫ
╔══════════════════════════════════════════════════════════════╗
║                    COMPLEXITY TRADE-OFFS                    ║
║                                                              ║
║  Монолит                          Микросервисы               ║
║  --------                         --------------              ║
║  🟢 Простая разработка             🔴 Сложная разработка      ║
║  🟢 Простое тестирование          🔴 Сложное тестирование    ║
║  🟢 Простое развертывание         🔴 Сложное развертывание   ║
║  🔴 Сложное масштабирование       🟢 Простое масштабирование ║
║  🔴 Технологическая привязка      🟢 Технологическая свобода ║
║  🔴 Каскадные отказы              🟢 Изолированные отказы    ║
╚══════════════════════════════════════════════════════════════╝
```

**Основные сложности:**

🔴 **Сетевые вызовы**
- Latency и bandwidth
- Ненадежность сети
- Необходимость retry логики

🔴 **Distributed системы**
- CAP теорема
- Eventual consistency
- Distributed transactions сложности

🔴 **Operational complexity**
- Больше движущихся частей
- Мониторинг и логирование
- Service discovery

🔴 **Testing challenges**
- Integration тестирование
- End-to-end тесты
- Test data management

---

## 🏗️ Глава 2: Принципы проектирования микросервисов

### 🎯 Single Responsibility Principle для сервисов

```
SRP В МИКРОСЕРВИСАХ
═══════════════════════════════════════════════════════════════

❌ НЕПРАВИЛЬНО - "God Service"
┌─────────────────────────────────────────────────────────────┐
│                 E-COMMERCE SERVICE                          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐│
│  │ User Mgmt   │ │ Product Mgmt│ │ Order Processing        ││
│  │ - Register  │ │ - Add Item  │ │ - Create Order          ││
│  │ - Login     │ │ - Update    │ │ - Process Payment       ││
│  │ - Profile   │ │ - Delete    │ │ - Ship Order            ││
│  │ - Password  │ │ - Search    │ │ - Track Delivery        ││
│  └─────────────┘ └─────────────┘ └─────────────────────────┘│
└─────────────────────────────────────────────────────────────┘

✅ ПРАВИЛЬНО - Separate Services
┌─────────────┐   ┌─────────────┐   ┌─────────────┐   ┌──────────────┐
│ User Service│   │Product      │   │Order Service│   │Payment       │
│- Register   │   │Service      │   │- Create     │   │Service       │
│- Login      │   │- Add Item   │   │- Update     │   │- Process     │
│- Profile    │   │- Update     │   │- Cancel     │   │- Refund      │
│- Password   │   │- Delete     │   │- Track      │   │- Validate    │
└─────────────┘   │- Search     │   └─────────────┘   └──────────────┘
                  └─────────────┘
```

**Правила выделения сервисов:**

1. **Бизнес-capability подход**
   - Один сервис = одна бизнес-функция
   - Например: управление пользователями, обработка заказов

2. **Data ownership**
   - Каждый сервис владеет своими данными
   - Нет shared databases между сервисами

3. **Team ownership**
   - Одна команда может полностью поддерживать сервис
   - "Two pizza team" rule (Amazon)

---

### 🔗 Автономность и слабая связанность

```
УРОВНИ СВЯЗАННОСТИ
══════════════════════════════════════════════════════════════

HIGH COUPLING (плохо)
Service A ←→ Service B ←→ Service C
    ↑           ↑           ↑
    └───────────┴───────────┘
    
LOW COUPLING (хорошо)
Service A → API Gateway → Service B
    ↓                         ↓
 Database A               Database B
```

**Принципы слабой связанности:**

🟢 **Interface coupling only**
- Взаимодействие только через API
- Скрытие деталей реализации
- Версионирование интерфейсов

🟢 **Temporal decoupling**
- Асинхронная коммуникация где возможно
- Message queues и events
- Не блокирующие операции

🟢 **Data coupling avoidance**
- Никаких shared databases
- Data replication where needed
- Event-driven data synchronization

---

### 🧠 Принцип "умного endpoint, глупой сети"

```
SMART ENDPOINTS VS SMART PIPES
══════════════════════════════════════════════════════════════

❌ SMART PIPES (ESB approach)
┌──────────┐    ┌─────────────────────────┐    ┌──────────┐
│Service A │◄──►│    Enterprise Service   │◄──►│Service B │
│          │    │         Bus (ESB)       │    │          │
│- Simple  │    │- Routing                │    │- Simple  │
│- Logic   │    │- Transformation         │    │- Logic   │
└──────────┘    │- Orchestration          │    └──────────┘
                │- Business Rules         │
                └─────────────────────────┘

✅ SMART ENDPOINTS (Microservices approach)
┌─────────────┐         HTTP/REST        ┌─────────────┐
│  Service A  │◄────────────────────────►│  Service B  │
│- Rich Logic │      Simple Protocol     │- Rich Logic │
│- Validation │                         │- Validation │
│- Rules      │                         │- Rules      │
│- Processing │                         │- Processing │
└─────────────┘                         └─────────────┘
```

**Ключевые аспекты:**

🧠 **Smart Endpoints:**
- Вся бизнес-логика в сервисах
- Сервисы принимают решения
- Полная автономность

🌐 **Dumb Pipes:**
- Простые протоколы (HTTP, messaging)
- Минимальная логика в infrastructure
- Фокус на delivery, не на processing

---

### 🏛️ Децентрализованное управление

```
ЦЕНТРАЛИЗОВАННОЕ vs ДЕЦЕНТРАЛИЗОВАННОЕ УПРАВЛЕНИЕ
════════════════════════════════════════════════════════════════

ЦЕНТРАЛИЗОВАННОЕ (Traditional)
┌─────────────────────────────────────────────────────────────┐
│                  CENTRAL GOVERNANCE                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐│
│  │Technology   │ │Data         │ │Deployment               ││
│  │Standards    │ │Standards    │ │Standards                ││
│  │- Java only  │ │- Oracle DB  │ │- Specific Platform      ││
│  │- Spring     │ │- Shared     │ │- Centralized Ops        ││
│  └─────────────┘ └─────────────┘ └─────────────────────────┘│
└─────────────────────────────────────────────────────────────┘

ДЕЦЕНТРАЛИЗОВАННОЕ (Microservices)
┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│  Team A     │   │  Team B     │   │  Team C     │
│- Java/Spring│   │- Node.js    │   │- Python     │
│- PostgreSQL │   │- MongoDB    │   │- Redis      │
│- Kubernetes │   │- Kubernetes │   │- Serverless │
│- CI/CD      │   │- CI/CD      │   │- CI/CD      │
└─────────────┘   └─────────────┘   └─────────────┘
```

**Принципы децентрализации:**

1. **Technology diversity**
   - Команды выбирают подходящие технологии
   - Right tool for the job
   - Evolution over standardization

2. **Data management**
   - Database per service
   - Team owns their data
   - No shared data stores

3. **Deployment autonomy**
   - Independent deployment cycles
   - Team responsible for operations
   - DevOps culture

---

## 🎨 Глава 3: Domain Driven Design (DDD) и Bounded Contexts

### 🗺️ Основы DDD

```
DOMAIN DRIVEN DESIGN OVERVIEW
═══════════════════════════════════════════════════════════════

                    ┌─────────────────────┐
                    │   BUSINESS DOMAIN   │
                    │   (E-commerce)      │
                    └──────────┬──────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
    ┌─────────────────┐ ┌─────────────┐ ┌─────────────────┐
    │  Order Context  │ │User Context │ │Product Context  │
    │                 │ │             │ │                 │
    │ ┌─────────────┐ │ │┌───────────┐│ │ ┌─────────────┐ │
    │ │   Order     │ │ ││   User    ││ │ │  Product    │ │
    │ │ ┌─────────┐ │ │ ││┌─────────┐││ │ │ ┌─────────┐ │ │
    │ │ │OrderItem│ │ │ │││ Profile │││ │ │ │Category │ │ │
    │ │ └─────────┘ │ │ ││└─────────┘││ │ │ └─────────┘ │ │
    │ └─────────────┘ │ │└───────────┘│ │ └─────────────┘ │
    └─────────────────┘ └─────────────┘ └─────────────────┘
```

**Ключевые концепции DDD:**

📋 **Domain** - предметная область бизнеса
📋 **Bounded Context** - границы модели домена  
📋 **Entity** - объект с уникальной идентичностью
📋 **Value Object** - объект без идентичности
📋 **Aggregate** - группа связанных объектов
📋 **Repository** - механизм доступа к данным

---

### 🏗️ Выделение Bounded Contexts

```
ПРОЦЕСС ВЫДЕЛЕНИЯ BOUNDED CONTEXTS
══════════════════════════════════════════════════════════════

Шаг 1: DOMAIN ANALYSIS
┌─────────────────────────────────────────────────────────────┐
│  E-COMMERCE DOMAIN                                          │
│                                                             │
│  User stories:                                              │
│  • As a customer, I want to browse products                 │
│  • As a customer, I want to add items to cart               │
│  • As a customer, I want to place an order                  │
│  • As a customer, I want to track my order                  │
│  • As an admin, I want to manage inventory                  │
│  • As an admin, I want to process payments                  │
└─────────────────────────────────────────────────────────────┘

Шаг 2: IDENTIFY CONTEXTS
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  CATALOG        │ │  SHOPPING       │ │  ORDER          │
│                 │ │                 │ │                 │
│ • Product       │ │ • Cart          │ │ • Order         │
│ • Category      │ │ • CartItem      │ │ • OrderItem     │
│ • Inventory     │ │ • Pricing       │ │ • Shipping      │
│ • Search        │ │ • Promotions    │ │ • Tracking      │
└─────────────────┘ └─────────────────┘ └─────────────────┘

┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  PAYMENT        │ │  USER           │ │  NOTIFICATION   │
│                 │ │                 │ │                 │
│ • Transaction   │ │ • Customer      │ │ • Email         │
│ • Refund        │ │ • Profile       │ │ • SMS           │
│ • Billing       │ │ • Authentication│ │ • Push          │
│ • Gateway       │ │ • Preferences   │ │ • Templates     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

**Критерии выделения:**

🎯 **Business capability alignment**
- Один контекст = одна бизнес-функция
- Команда должна понимать весь контекст

🎯 **Data cohesion**
- Данные, которые изменяются вместе
- Transactional boundaries

🎯 **Team boundaries**
- Conway's Law consideration
- Organizational structure alignment

---

### 🧩 Aggregate и Entity

```
AGGREGATE DESIGN PATTERNS
═══════════════════════════════════════════════════════════════

ORDER AGGREGATE
┌─────────────────────────────────────────────────────────────┐
│  Order (Aggregate Root)                                     │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ + orderId: OrderId                                      ││
│  │ + customerId: CustomerId                                ││
│  │ + status: OrderStatus                                   ││
│  │ + orderDate: Date                                       ││
│  │ + totalAmount: Money                                    ││
│  │                                                         ││
│  │ + addItem(productId, quantity, price)                   ││
│  │ + removeItem(orderItemId)                               ││
│  │ + updateShippingAddress(address)                        ││
│  │ + confirm()                                             ││
│  │ + cancel()                                              ││
│  └─────────────────────────────────────────────────────────┘│
│                               │                             │
│                               │ contains                    │
│                               ▼                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ OrderItem (Entity)                                      ││
│  │ ┌─────────────────────────────────────────────────────┐ ││
│  │ │ + orderItemId: OrderItemId                          │ ││
│  │ │ + productId: ProductId                              │ ││
│  │ │ + quantity: int                                     │ ││
│  │ │ + unitPrice: Money                                  │ ││
│  │ │ + lineTotal: Money                                  │ ││
│  │ └─────────────────────────────────────────────────────┘ ││
│  └─────────────────────────────────────────────────────────┘│
│                               │                             │
│                               │ contains                    │
│                               ▼                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ ShippingAddress (Value Object)                          ││
│  │ ┌─────────────────────────────────────────────────────┐ ││
│  │ │ + street: String                                    │ ││
│  │ │ + city: String                                      │ ││
│  │ │ │ + postalCode: String                              │ ││
│  │ │ + country: String                                   │ ││
│  │ └─────────────────────────────────────────────────────┘ ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

**Правила проектирования Aggregate:**

✅ **Aggregate Root**
- Единственная точка входа в Aggregate
- Обеспечивает бизнес-инварианты
- Имеет глобальную идентичность

✅ **Внутренние Entity**
- Локальная идентичность внутри Aggregate
- Доступ только через Aggregate Root
- Участвуют в бизнес-правилах

✅ **Value Objects**
- Неизменяемые объекты
- Определяются через значения
- Могут быть shared между Aggregates

---

### 🔗 Связь DDD с архитектурой микросервисов

```
DDD TO MICROSERVICES MAPPING
═══════════════════════════════════════════════════════════════

BOUNDED CONTEXT → MICROSERVICE
┌─────────────────┐           ┌─────────────────┐
│  Order Context  │    →      │ Order Service   │
│                 │           │                 │
│ • Order         │           │ • REST API      │
│ • OrderItem     │           │ • Business      │
│ • Shipping      │           │   Logic         │
│ • Tracking      │           │ • Order DB      │
└─────────────────┘           └─────────────────┘

AGGREGATE → SERVICE BOUNDARY
┌─────────────────┐           ┌─────────────────┐
│ Order Aggregate │    →      │ Transactional   │
│                 │           │ Boundary        │
│ • Consistency   │           │ • ACID          │
│ • Invariants    │           │   Properties    │
│ • Rules         │           │ • Single DB     │
└─────────────────┘           └─────────────────┘

DOMAIN EVENT → INTEGRATION EVENT
┌─────────────────┐           ┌─────────────────┐
│ OrderPlaced     │    →      │ Message Queue   │
│ DomainEvent     │           │ Event           │
│                 │           │                 │
│ • Internal      │           │ • External      │
│ • Immediate     │           │ • Async         │
└─────────────────┘           └─────────────────┘
```

**Принципы маппинга:**

🎯 **One Bounded Context = One Microservice**
- Четкие границы ответственности
- Автономность команд
- Independent deployment

🎯 **Aggregate = Transaction Boundary**
- Consistency within service
- Eventual consistency between services
- Clear data ownership

🎯 **Domain Events = Integration Events**
- Loose coupling between services
- Event-driven communication
- Eventual consistency

---

## ⚖️ Глава 4: Сравнение архитектурных подходов

### 🏗️ Монолит vs SOA vs Микросервисы

```
АРХИТЕКТУРНОЕ СРАВНЕНИЕ
═══════════════════════════════════════════════════════════════

МОНОЛИТ
┌─────────────────────────────────────────────────────────────┐
│                    SINGLE APPLICATION                      │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                 UI Layer                              │  │
│  ├───────────────────────────────────────────────────────┤  │
│  │               Business Layer                          │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────┐  │  │
│  │  │Module A │ │Module B │ │Module C │ │  Module D   │  │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────────┘  │  │
│  ├───────────────────────────────────────────────────────┤  │
│  │                 Data Layer                            │  │
│  └───────────────────────────────────────────────────────┘  │
│                           │                                 │
│                           ▼                                 │
│                   ┌───────────────┐                         │
│                   │   Database    │                         │
│                   └───────────────┘                         │
└─────────────────────────────────────────────────────────────┘

SOA (Service-Oriented Architecture)
┌─────────────────────────────────────────────────────────────┐
│               Enterprise Service Bus (ESB)                  │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ Routing │ Transform │ Orchestrate │ Monitor │ Security  ││
│  └─────────────────────────────────────────────────────────┘│
│         │              │              │              │     │
│         ▼              ▼              ▼              ▼     │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐│
│  │Service A  │  │Service B  │  │Service C  │  │Service D  ││
│  │(SOAP/WS)  │  │(SOAP/WS)  │  │(SOAP/WS)  │  │(SOAP/WS)  ││
│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘│
│        │              │              │              │     │
│        ▼              ▼              ▼              ▼     │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐│
│  │Database A │  │Database B │  │Database C │  │Database D ││
│  └───────────┘  └───────────┘  └───────────┘  └───────────┘│
└─────────────────────────────────────────────────────────────┘

МИКРОСЕРВИСЫ
              ┌─────────────┐
              │ API Gateway │
              └──────┬──────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
        ▼            ▼            ▼
┌───────────────┐ ┌──────────┐ ┌──────────────┐
│  Service A    │ │Service B │ │  Service C   │
│  (REST/gRPC)  │ │(REST/gRPC│ │ (REST/gRPC)  │
│ ┌───────────┐ │ │┌────────┐│ │┌────────────┐│
│ │Own Logic  │ │ ││Own     ││ ││Own Logic   ││
│ │Own Data   │ │ ││Logic   ││ ││Own Data    ││
│ └─────┬─────┘ │ ││Own Data││ │└──────┬─────┘│
│       ▼       │ │└───┬────┘│ │       ▼      │
│ ┌───────────┐ │ │    ▼     │ │┌────────────┐│
│ │Database A │ │ │┌────────┐│ ││Database C  ││
│ └───────────┘ │ ││Database││ │└────────────┘│
└───────────────┘ ││B       ││ └──────────────┘
                  │└────────┘│
                  └──────────┘
```

### 📊 Сравнительная таблица

| Аспект | Монолит | SOA | Микросервисы |
|--------|---------|-----|--------------|
| **Deployment** | 🔴 Целиком | 🟡 Сервисами | 🟢 Независимо |
| **Scaling** | 🔴 Все вместе | 🟡 По сервисам | 🟢 Точечно |
| **Technology** | 🔴 Один стек | 🟡 Ограничен | 🟢 Свобода выбора |
| **Complexity** | 🟢 Простой | 🟡 Средний | 🔴 Высокий |
| **Testing** | 🟢 Простое | 🟡 Среднее | 🔴 Сложное |
| **Data** | 🔴 Shared DB | 🟡 Может быть shared | 🟢 Database per service |
| **Communication** | 🟢 In-process | 🔴 Heavy protocols | 🟢 Light protocols |
| **Fault Tolerance** | 🔴 Каскадные отказы | 🟡 ESB SPOF | 🟢 Isolation |

---

### 🏛️ Модульный монолит как промежуточное решение

```
МОДУЛЬНЫЙ МОНОЛИТ
═══════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────┐
│                 MODULAR MONOLITH                            │
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   User      │  │   Order     │  │      Product        │  │
│  │   Module    │  │   Module    │  │      Module         │  │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────────────┐ │  │
│  │ │  API    │ │  │ │  API    │ │  │ │      API        │ │  │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────────────┘ │  │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────────────┐ │  │
│  │ │Business │ │  │ │Business │ │  │ │    Business     │ │  │
│  │ │  Logic  │ │  │ │  Logic  │ │  │ │     Logic       │ │  │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────────────┘ │  │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────────────┐ │  │
│  │ │  Data   │ │  │ │  Data   │ │  │ │      Data       │ │  │
│  │ │ Access  │ │  │ │ Access  │ │  │ │     Access      │ │  │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────────────┘ │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │               SHARED INFRASTRUCTURE                     ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ ││
│  │  │   Logging   │  │ Monitoring  │  │   Configuration │ ││
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ ││
│  └─────────────────────────────────────────────────────────┘│
│                             │                               │
│                             ▼                               │
│                    ┌─────────────────┐                      │
│                    │     Database    │                      │
│                    │   (Схemas по    │                      │
│                    │    модулям)     │                      │
│                    └─────────────────┘                      │
└─────────────────────────────────────────────────────────────┘
```

**Преимущества модульного монолита:**

🟢 **Эволюционный путь**
- Хорошая подготовка к микросервисам
- Четкие границы модулей
- Возможность постепенного выделения

🟢 **Баланс сложности**
- Проще чем микросервисы
- Сложнее чем обычный монолит
- Хорошие архитектурные практики

🟢 **Team alignment**
- Каждый модуль = команда
- Четкое ownership
- Подготовка к distributed teams

---

### ❌ Distributed Monolith - антипаттерн

```
DISTRIBUTED MONOLITH ANTI-PATTERN
═══════════════════════════════════════════════════════════════

❌ ЧТО НЕ НАДО ДЕЛАТЬ

Service A ←────────→ Service B ←────────→ Service C
    ↑                   ↑                   ↑
    │ синхронные вызовы  │                   │
    ↓                   ↓                   ↓
Database A ←─────── Shared DB ──────→ Database C

ПРОБЛЕМЫ:
• Все сервисы должны быть запущены одновременно
• Изменение одного сервиса требует изменения других
• Shared database создает coupling
• Невозможно независимое развертывание
• Cascading failures
• Distributed transactions

✅ ПРАВИЛЬНЫЙ ПОДХОД

Service A ──→ Message Queue ──→ Service B ──→ Message Queue ──→ Service C
    ↓                               ↓                               ↓
Database A                     Database B                     Database C

РЕШЕНИЯ:
• Асинхронная коммуникация
• Event-driven architecture  
• Database per service
• Independent deployments
• Graceful degradation
• Eventual consistency
```

**Признаки Distributed Monolith:**

🚨 **Synchronous chain calls**
- Service A → Service B → Service C
- Blocking operations
- Timeout cascades

🚨 **Shared data sources**
- Multiple services, one database
- Coupling through data
- Schema changes affect all

🚨 **Coordinated deployments**
- All services must be deployed together
- Version compatibility issues
- Rolling back requires coordination

---

## 🤔 Глава 5: Когда использовать микросервисы

### 📋 Критерии принятия решения

```
DECISION MATRIX: МИКРОСЕРВИСЫ ИЛИ МОНОЛИТ?
═══════════════════════════════════════════════════════════════

ФАКТОРЫ ПРИНЯТИЯ РЕШЕНИЯ
┌─────────────────────────────────────────────────────────────┐
│                      ОЦЕНКА ПО ШКАЛЕ 1-5                   │
│                                                             │
│  Размер команды:           [1] ←→ [5]                       │
│  (1-2 разработчика)            (10+ разработчиков)         │
│                                                             │
│  Сложность домена:         [1] ←→ [5]                       │
│  (CRUD приложение)              (Сложная бизнес-логика)     │
│                                                             │
│  Масштабирование:          [1] ←→ [5]                       │
│  (Локальное использование)      (Глобальная нагрузка)       │
│                                                             │
│  Независимость команд:     [1] ←→ [5]                       │
│  (Одна команда)                 (Множество команд)          │
│                                                             │
│  Технологическое разнообразие: [1] ←→ [5]                   │
│  (Один стек)                    (Разные технологии)         │
│                                                             │
│  Скорость изменений:       [1] ←→ [5]                       │
│  (Редкие релизы)                (Частые релизы)             │
│                                                             │
│  Доступность требований:   [1] ←→ [5]                       │
│  (Допустимы простои)            (24/7 uptime)               │
└─────────────────────────────────────────────────────────────┘

РЕЗУЛЬТАТ:
• Сумма < 15: МОНОЛИТ
• Сумма 15-25: МОДУЛЬНЫЙ МОНОЛИТ  
• Сумма > 25: МИКРОСЕРВИСЫ
```

### 👥 Размер команды и организации

```
КОМАНДЫ И АРХИТЕКТУРА (Conway's Law)
═══════════════════════════════════════════════════════════════

МАЛАЯ КОМАНДА (2-5 человек)
┌─────────────────────────────────────────────────────────────┐
│                    FULL-STACK TEAM                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  Frontend   │  │   Backend   │  │      DevOps         │  │
│  │ Developer   │  │  Developer  │  │    Engineer         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│              ОПТИМАЛЬНО: МОНОЛИТ                            │
└─────────────────────────────────────────────────────────────┘

СРЕДНЯЯ КОМАНДА (6-12 человек)
┌─────────────────────────────────────────────────────────────┐
│                 SPECIALIZED TEAMS                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  Frontend   │  │   Backend   │  │     QA & DevOps     │  │
│  │    Team     │  │    Team     │  │       Team          │  │
│  │   (2-3)     │  │   (4-5)     │  │       (2-3)         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│           ОПТИМАЛЬНО: МОДУЛЬНЫЙ МОНОЛИТ                     │
└─────────────────────────────────────────────────────────────┘

БОЛЬШАЯ ОРГАНИЗАЦИЯ (15+ человек)
┌─────────────────────────────────────────────────────────────┐
│                  MULTIPLE TEAMS                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Team A    │  │   Team B    │  │      Team C         │  │
│  │ (User Mgmt) │  │  (Orders)   │  │    (Payments)       │  │
│  │   (3-5)     │  │   (3-5)     │  │      (3-5)          │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Team D    │  │   Team E    │  │    Platform Team    │  │
│  │ (Catalog)   │  │ (Analytics) │  │   (Infrastructure)  │  │
│  │   (3-5)     │  │   (3-5)     │  │      (4-6)          │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│                                                             │
│              ОПТИМАЛЬНО: МИКРОСЕРВИСЫ                       │
└─────────────────────────────────────────────────────────────┘
```

**"Two Pizza Team" Rule (Amazon):**
> Команда должна быть настолько маленькой, чтобы ее можно было накормить двумя пиццами (~6-8 человек)

---

### 🏢 Сложность домена

```
DOMAIN COMPLEXITY ASSESSMENT
═══════════════════════════════════════════════════════════════

ПРОСТОЙ ДОМЕН (Монолит подходит)
┌─────────────────────────────────────────────────────────────┐
│                    CRUD APPLICATION                        │
│                                                             │
│  Характеристики:                                            │
│  • Простые бизнес-правила                                   │
│  • Минимальная логика                                       │
│  • Стандартные операции (Create, Read, Update, Delete)      │
│  • Небольшое количество entity                              │
│                                                             │
│  Примеры:                                                   │
│  • Блог                                                     │
│  • Каталог товаров                                          │
│  • CMS                                                      │
│  • Простая система учета                                    │
└─────────────────────────────────────────────────────────────┘

СЛОЖНЫЙ ДОМЕН (Микросервисы подходят)
┌─────────────────────────────────────────────────────────────┐
│                 COMPLEX BUSINESS DOMAIN                     │
│                                                             │
│  Характеристики:                                            │
│  • Множественные бизнес-контексты                           │
│  • Сложные бизнес-правила                                   │
│  • Различные жизненные циклы данных                         │
│  • Интеграции с внешними системами                          │
│  • Различные non-functional требования                      │
│                                                             │
│  Примеры:                                                   │
│  • E-commerce платформа                                     │
│  • Банковская система                                       │
│  • ERP система                                              │
│  • Ride-sharing приложение                                  │
│  • Trading платформа                                        │
└─────────────────────────────────────────────────────────────┘
```

### ⚙️ Технические требования

```
TECHNICAL REQUIREMENTS MATRIX
═══════════════════════════════════════════════════════════════

SCALABILITY REQUIREMENTS
┌─────────────────────────────────────────────────────────────┐
│  Low Scale (< 1K users)     │  High Scale (> 100K users)    │
│  ┌─────────────────────────┐│  ┌─────────────────────────┐   │
│  │ Монолит подходит        ││  │ Микросервисы нужны      │   │
│  │ • Простое развертывание ││  │ • Горизонтальное        │   │
│  │ • Минимальная           ││  │   масштабирование       │   │
│  │   инфраструктура        ││  │ • Разные нагрузки на    │   │
│  │ • Быстрый старт         ││  │   разные компоненты     │   │
│  └─────────────────────────┘│  └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

AVAILABILITY REQUIREMENTS  
┌─────────────────────────────────────────────────────────────┐
│  Standard Availability      │  High Availability (99.9%+)   │
│  ┌─────────────────────────┐│  ┌─────────────────────────┐   │
│  │ Монолит допустим        ││  │ Микросервисы нужны      │   │
│  │ • Planned downtime OK   ││  │ • Fault isolation       │   │
│  │ • Simple deployment     ││  │ • Rolling deployments   │   │
│  │ • Single point failure  ││  │ • Graceful degradation  │   │
│  │   acceptable            ││  │ • Circuit breakers      │   │
│  └─────────────────────────┘│  └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

TECHNOLOGY DIVERSITY
┌─────────────────────────────────────────────────────────────┐
│  Single Technology Stack    │  Multiple Technology Stacks   │
│  ┌─────────────────────────┐│  ┌─────────────────────────┐   │
│  │ Монолит предпочтительнее││  │ Микросервисы позволяют  │   │
│  │ • Один язык/фреймворк   ││  │ • Polyglot persistence  │   │
│  │ • Единые инструменты    ││  │ • Best tool for the job │   │
│  │ • Простая поддержка     ││  │ • Technology evolution  │   │
│  │ • Меньше сложности      ││  │ • Specialized teams     │   │
│  └─────────────────────────┘│  └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 📝 Практические задания

### 🔍 Задание 1: Анализ существующего монолитного приложения

**Цель:** Научиться выявлять проблемы монолитной архитектуры

**Задача:** Проанализируйте следующий код монолитного e-commerce приложения:

```java
// Пример проблемного монолитного кода
@Controller
public class ECommerceController {
    
    @Autowired
    private UserService userService;
    
    @Autowired 
    private ProductService productService;
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private PaymentService paymentService;
    
    @PostMapping("/order")
    public ResponseEntity<String> createOrder(@RequestBody OrderRequest request) {
        // Все в одном методе - нарушение SRP
        User user = userService.validateUser(request.getUserId());
        Product product = productService.checkAvailability(request.getProductId());
        
        if (product.getStock() < request.getQuantity()) {
            throw new InsufficientStockException();
        }
        
        Order order = orderService.createOrder(user, product, request.getQuantity());
        Payment payment = paymentService.processPayment(order.getTotal(), request.getPaymentDetails());
        
        if (payment.isSuccessful()) {
            productService.updateStock(product.getId(), product.getStock() - request.getQuantity());
            orderService.confirmOrder(order.getId());
            return ResponseEntity.ok("Order created successfully");
        } else {
            orderService.cancelOrder(order.getId());
            return ResponseEntity.badRequest().body("Payment failed");
        }
    }
}
```

**Что нужно найти:**
1. Нарушения принципов SOLID
2. Tight coupling между компонентами
3. Проблемы с транзакциями
4. Сложности тестирования
5. Проблемы масштабирования

**Ожидаемый результат:** Документ с анализом проблем и предложениями по их решению

---

### 🗺️ Задание 2: Выделение bounded contexts

**Цель:** Практика применения DDD для декомпозиции домена

**Сценарий:** Интернет-магазин книг со следующим функционалом:

```
ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📚 КАТАЛОГ
• Просмотр книг по категориям
• Поиск по названию, автору, ISBN
• Рекомендации на основе покупок
• Рейтинги и отзывы

👤 ПОЛЬЗОВАТЕЛИ  
• Регистрация и аутентификация
• Профиль пользователя
• История покупок
• Wishlist

🛒 КОРЗИНА И ЗАКАЗЫ
• Добавление в корзину
• Оформление заказа
• Выбор способа доставки
• Отслеживание статуса заказа

💳 ПЛАТЕЖИ
• Обработка платежей
• Возвраты
• Платежная история
• Интеграция с платежными системами

📦 СКЛАД
• Управление запасами
• Поставки от издательств
• Резервирование товаров
• Уведомления о поступлениях

📧 УВЕДОМЛЕНИЯ
• Email уведомления
• SMS уведомления  
• Push уведомления
• Персонализированные рассылки

📊 АНАЛИТИКА
• Отчеты по продажам
• Аналитика поведения пользователей
• A/B тестирование
• Бизнес-метрики
```

**Что нужно сделать:**
1. Выделить bounded contexts
2. Определить entities и value objects для каждого контекста
3. Найти aggregates и их границы
4. Определить связи между контекстами
5. Создать Context Map

**Шаблон для выполнения:**

```markdown
## Bounded Context: [НАЗВАНИЕ]

### Ответственность
- [Описание основной функции]

### Entities
- [Entity 1]: [Описание]
- [Entity 2]: [Описание]

### Value Objects  
- [Value Object 1]: [Описание]

### Aggregates
- [Aggregate Root]: [Описание бизнес-правил]

### Связи с другими контекстами
- [Контекст]: [Тип связи и описание]
```

---

### 🏗️ Задание 3: Создание диаграммы архитектуры

**Цель:** Визуализировать будущую микросервисную архитектуру

**Задача:** На основе выделенных bounded contexts создать архитектурную диаграмму

**Что должно быть включено:**
1. Микросервисы и их API
2. Базы данных для каждого сервиса
3. Способы коммуникации между сервисами
4. External dependencies
5. Infrastructure components

**Пример диаграммы:**

```
АРХИТЕКТУРА МИКРОСЕРВИСОВ - КНИЖНЫЙ МАГАЗИН
═══════════════════════════════════════════════════════════════

                    ┌─────────────┐
                    │   Client    │
                    │ (Web/Mobile)│
                    └──────┬──────┘
                           │ HTTPS
                           ▼
                    ┌─────────────┐
                    │API Gateway  │
                    │(Load Balance│
                    │Rate Limit)  │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Catalog     │    │ User        │    │ Order       │
│ Service     │    │ Service     │    │ Service     │
│             │    │             │    │             │
│ REST API    │    │ REST API    │    │ REST API    │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Catalog DB  │    │ User DB     │    │ Order DB    │
│(PostgreSQL) │    │(PostgreSQL) │    │(PostgreSQL) │
└─────────────┘    └─────────────┘    └─────────────┘

        │                                   │
        │            Message Queue          │
        │         (RabbitMQ/Kafka)          │
        └──────────────┬────────────────────┘
                       │
        ┌──────────────┼──────────────────┐
        │              │                  │
        ▼              ▼                  ▼
┌─────────────┐ ┌─────────────┐   ┌─────────────┐
│ Payment     │ │ Inventory   │   │Notification │
│ Service     │ │ Service     │   │ Service     │
│             │ │             │   │             │
│ REST API    │ │ REST API    │   │ Event-driven│
└──────┬──────┘ └──────┬──────┘   └──────┬──────┘
       │               │                 │
       ▼               ▼                 ▼
┌─────────────┐ ┌─────────────┐   ┌─────────────┐
│ Payment DB  │ │Inventory DB │   │ Email/SMS   │
│(PostgreSQL) │ │(PostgreSQL) │   │ Providers   │
└─────────────┘ └─────────────┘   └─────────────┘
```

---

## ✅ Итоговый результат

После завершения этого блока вы должны:

🎯 **Понимать основы микросервисов**
- Знать историю развития архитектурных подходов
- Понимать проблемы монолитов и как их решают микросервисы
- Знать недостатки микросервисной архитектуры

🎯 **Применять принципы проектирования**
- Single Responsibility Principle для сервисов
- Проектировать автономные и слабо связанные сервисы
- Следовать принципу "умные endpoints, глупая сеть"

🎯 **Использовать DDD для декомпозиции**
- Выделять bounded contexts
- Проектировать aggregates и entities
- Связывать DDD концепции с микросервисной архитектурой

🎯 **Принимать архитектурные решения**
- Сравнивать монолит, SOA и микросервисы
- Определять когда использовать каждый подход
- Избегать distributed monolith антипаттернов

---

## 📚 Дополнительные материалы

**Книги для углубленного изучения:**
- "Building Microservices" - Sam Newman
- "Microservices Patterns" - Chris Richardson  
- "Domain-Driven Design" - Eric Evans

**Статьи и ресурсы:**
- Martin Fowler - Microservices articles
- microservices.io - Patterns catalog
- AWS/Google Cloud микросервисы best practices

**Следующий блок:** Технологический стек и инфраструктура

---

*Готовы двигаться дальше? В следующем блоке мы изучим технологический стек и инфраструктуру для микросервисов: Docker, Kubernetes, API Gateway, Service Discovery, мониторинг и CI/CD pipeline.*

---

## 🔄 Переход к следующему блоку

**Что мы изучили:**
✅ Теоретические основы микросервисов  
✅ Принципы проектирования сервисов  
✅ Domain-Driven Design и bounded contexts  
✅ Сравнение архитектурных подходов  
✅ Критерии выбора архитектуры  

**Что изучаем дальше:**
🔜 Контейнеризация с Docker  
🔜 Оркестрация с Kubernetes  
🔜 API Gateway и Service Discovery  
🔜 Мониторинг и логирование  
🔜 CI/CD для микросервисов  

**Проверьте себя перед переходом:**
- [ ] Могу объяснить разницу между монолитом и микросервисами
- [ ] Понимаю принципы DDD и bounded contexts  
- [ ] Умею выделять сервисы по бизнес-функциям
- [ ] Знаю когда НЕ стоит использовать микросервисы
- [ ] Выполнил все практические задания блока

---

**📞 Обратная связь:** Если у вас есть вопросы по материалу этого блока, обязательно разберите их перед переходом к следующему. Практическое понимание основ критично для успешного освоения технологического стека!