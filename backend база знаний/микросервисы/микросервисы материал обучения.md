# Микросервисы: От новичка до эксперта

## 🎯 Что вы изучите

Этот материал проведет вас от понимания проблем монолитных приложений до экспертного владения микросервисной архитектурой. Фокус на концепциях, паттернах и практическом применении.

---

## Глава 1: Зачем нужны микросервисы?

### История развития архитектур

**1990-е: Монолитные приложения**
```
┌─────────────────────────────────────┐
│           ОДИН БОЛЬШОЙ WAR          │
│                                     │
│  UI + Business Logic + Data Access  │
│                                     │
└─────────────────────────────────────┘
                  │
            ┌─────▼─────┐
            │ Database  │
            └───────────┘
```

**2000-е: Service-Oriented Architecture (SOA)**
```
┌─────────┐    ┌─────────┐    ┌─────────┐
│Service A│◄──►│Service B│◄──►│Service C│
└─────────┘    └─────────┘    └─────────┘
     │              │              │
     ▼              ▼              ▼
┌─────────┐    ┌─────────┐    ┌─────────┐
│   DB    │    │   DB    │    │   DB    │
└─────────┘    └─────────┘    └─────────┘
```

**2010-е: Микросервисы**
```
     API Gateway
          │
┌─────────┼─────────┐
│         ▼         │
│ ┌───┐ ┌───┐ ┌───┐ │
│ │ A │ │ B │ │ C │ │
│ └─┬─┘ └─┬─┘ └─┬─┘ │
│   │     │     │   │
│ ┌─▼─┐ ┌─▼─┐ ┌─▼─┐ │
│ │DB │ │DB │ │DB │ │
│ └───┘ └───┘ └───┘ │
└───────────────────┘
```

### Реальный пример: Эволюция интернет-магазина

**Стартап (Монолит):**
```
┌─────────────────────────────────────────────┐
│              E-SHOP v1.0                    │
│                                             │
│ ┌─────────┐ ┌─────────┐ ┌─────────┐         │
│ │  Web UI │ │ Admin   │ │ Mobile  │         │
│ │         │ │ Panel   │ │   API   │         │
│ └────┬────┘ └────┬────┘ └────┬────┘         │
│      │           │           │             │
│ ┌────▼───────────▼───────────▼────┐        │
│ │        Business Logic           │        │
│ │ • Каталог товаров               │        │
│ │ • Управление пользователями     │        │
│ │ • Корзина и заказы              │        │
│ │ • Платежная система             │        │
│ │ • Управление складом            │        │
│ │ • Система доставки              │        │
│ │ • Аналитика и отчеты            │        │
│ └────────────┬────────────────────┘        │
│              │                             │
│ ┌────────────▼────────────────────┐        │
│ │          MySQL Database         │        │
│ │ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ │        │
│ │ │Users│ │Items│ │Order│ │ ... │ │        │
│ │ └─────┘ └─────┘ └─────┘ └─────┘ │        │
│ └─────────────────────────────────┘        │
└─────────────────────────────────────────────┘
```

**Проблемы при росте:**

1. **Команда выросла до 50 человек**
```
Developer 1 ────┐
Developer 2 ────┤
    ...         ├──► ОДИН репозиторий
Developer 49 ───┤
Developer 50 ───┘

Результат:
• Конфликты в Git
• Долгие code review  
• Сложно понять чужой код
• Боязнь что-то сломать
```

2. **Проблемы масштабирования**
```
Black Friday: 10x нагрузка на каталог

Решение в монолите:
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ E-SHOP v1.0 │  │ E-SHOP v1.0 │  │ E-SHOP v1.0 │
│ (полная     │  │ (полная     │  │ (полная     │
│  копия)     │  │  копия)     │  │  копия)     │
└─────────────┘  └─────────────┘  └─────────────┘

Проблема: Масштабируем ВСЕ, даже то что не нужно
```

3. **Технологические ограничения**
```
Хотим использовать:
• Python для ML рекомендаций
• Go для высоконагруженного API
• React для админки

Монолит: "НЕТ! Только Java везде"
```

4. **Развертывание**
```
Ошибка в модуле "Отзывы":
┌─────────────────────────────────────┐
│              E-SHOP                 │
│ Каталог ✓│Корзина ✓│Заказы ✓│Отзывы ✗│
└─────────────────────────────────────┘
              ▼
    ВСЕ ПРИЛОЖЕНИЕ НЕ РАБОТАЕТ
```

### Решение: Микросервисная архитектура

```
                    ┌─────────────┐
                    │ API Gateway │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Catalog    │    │   Orders    │    │  Payments   │
│  Service    │    │   Service   │    │   Service   │
│             │    │             │    │             │
│ • Products  │    │ • Cart      │    │ • Billing   │
│ • Search    │    │ • Checkout  │    │ • Refunds   │
│ • Reviews   │    │ • History   │    │ • Wallet    │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
┌──────▼──────┐    ┌──────▼──────┐    ┌──────▼──────┐
│ PostgreSQL  │    │   MongoDB   │    │    Redis    │
│ (Products)  │    │  (Orders)   │    │ (Sessions)  │
└─────────────┘    └─────────────┘    └─────────────┘

        ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│    Users    │    │ Inventory   │    │ Delivery    │
│   Service   │    │  Service    │    │  Service    │
│             │    │             │    │             │
│ • Auth      │    │ • Stock     │    │ • Tracking  │
│ • Profile   │    │ • Warehouse │    │ • Routes    │
│ • Preferences│   │ • Suppliers │    │ • Logistics │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
┌──────▼──────┐    ┌──────▼──────┐    ┌──────▼──────┐
│    MySQL    │    │ PostgreSQL  │    │   MongoDB   │
│   (Users)   │    │(Inventory)  │    │ (Delivery)  │
└─────────────┘    └─────────────┘    └─────────────┘
```

**Преимущества этого подхода:**

1. **Независимые команды**
```
Team Catalog ──► Catalog Service
Team Orders  ──► Orders Service  
Team Payments──► Payments Service
Team Users   ──► Users Service
```

2. **Технологическое разнообразие**
```
Catalog Service  ──► Python + Django + PostgreSQL
Orders Service   ──► Node.js + Express + MongoDB
Payments Service ──► Java + Spring + MySQL
Users Service    ──► Go + Gin + Redis
```

3. **Независимое масштабирование**
```
Black Friday нагрузка:

Catalog: 10x ──► Scale to 10 instances
Orders:  5x  ──► Scale to 5 instances  
Payments: 3x ──► Scale to 3 instances
Users:   2x  ──► Scale to 2 instances
```

4. **Изолированные сбои**
```
Payments Service ──► Down ✗
    │
    ▼
Orders Service ──► Works ✓ (degraded mode)
Catalog Service ──► Works ✓
Users Service ──► Works ✓

Пользователи могут искать и добавлять в корзину,
но не могут оплачивать (показываем соответствующее сообщение)
```

### Компромиссы и сложности

**Что усложняется:**

1. **Сетевые вызовы**
```
Монолит: method_call() // 1ns
Микросервисы: HTTP_request() // 100ms
```

2. **Распределенные транзакции**
```
Монолит:
BEGIN TRANSACTION
  UPDATE orders SET status='paid'
  UPDATE inventory SET quantity=quantity-1
  INSERT INTO payments ...
COMMIT

Микросервисы:
Orders Service ──► "How to coordinate?"
Inventory Service ──► "What if one fails?"
Payments Service ──► "How to rollback?"
```

3. **Отладка**
```
Монолит:
Error in line 42 of OrderService.java

Микросервисы:
Error somewhere in:
Orders Service ──► Inventory Service ──► Payments Service
     ↓                    ↓                    ↓
   Log A              Log B                 Log C
```

4. **Развертывание**
```
Монолит: 1 deployment unit
Микросервисы: N deployment units

N services × M environments = Complexity
```

---

## Глава 2: Основные принципы проектирования

### Принцип 1: Единственная ответственность (Single Responsibility)

**Плохой пример - "God Service":**
```
┌─────────────────────────────────────────────┐
│              User Management                │
│                                             │
│ 📝 Registration & Authentication            │
│ 📧 Email notifications                      │
│ 📊 User analytics & reporting               │
│ 💰 Discount management                      │
│ 📱 SMS notifications                        │
│ 🔒 Security & permissions                   │
│ 📈 A/B testing for users                    │
│ 🎯 Marketing campaigns                      │
│ 💳 User billing & subscriptions            │
│ 📍 Geolocation & preferences               │
└─────────────────────────────────────────────┘

Проблемы:
• Слишком много причин для изменения
• Разные команды хотят менять один сервис
• Сложно тестировать
• Сложно масштабировать
```

**Хороший пример - Разделенные сервисы:**
```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│    Users    │  │Notifications│  │  Analytics  │
│             │  │             │  │             │
│ • Register  │  │ • Email     │  │ • Reports   │
│ • Login     │  │ • SMS       │  │ • Metrics   │
│ • Profile   │  │ • Push      │  │ • Insights  │
│ • Auth      │  │ • Templates │  │ • Export    │
└─────────────┘  └─────────────┘  └─────────────┘

┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  Billing    │  │  Marketing  │  │   Security  │
│             │  │             │  │             │
│ • Payments  │  │ • Campaigns │  │ • Auth      │
│ • Invoices  │  │ • A/B Tests │  │ • Permissions│
│ • Refunds   │  │ • Targeting │  │ • Audit     │
│ • Plans     │  │ • Analytics │  │ • Compliance│
└─────────────┘  └─────────────┘  └─────────────┘
```

### Принцип 2: Автономность сервисов

**Каждый сервис должен:**

1. **Иметь свою базу данных**
```
❌ Плохо:
Service A ──┐
            ├──► Shared Database
Service B ──┘

Problems:
• Схема DB становится God Object
• Изменения влияют на все сервисы  
• Bottleneck при доступе к данным
• Невозможно выбрать оптимальную технологию

✅ Хорошо:
Service A ──► Database A (PostgreSQL)
Service B ──► Database B (MongoDB)  
Service C ──► Database C (Redis)

Benefits:
• Технологическая независимость
• Независимая эволюция схемы
• Изолированные проблемы производительности
```

2. **Быть развертываемым независимо**
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Service A   │    │ Service B   │    │ Service C   │
│ v1.2.3      │    │ v2.1.0      │    │ v1.0.5      │
└─────────────┘    └─────────────┘    └─────────────┘
       │                  │                  │
       ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Container A │    │ Container B │    │ Container C │
└─────────────┘    └─────────────┘    └─────────────┘

Каждый сервис может обновляться независимо
```

3. **Иметь четко определенный API**
```
Service A API:
├── GET /users/{id}
├── POST /users
├── PUT /users/{id}  
├── DELETE /users/{id}
└── GET /users/{id}/preferences

Service B не может:
• Напрямую читать таблицы Service A
• Вызывать internal методы Service A
• Зависеть от implementation details Service A
```

### Принцип 3: Децентрализованное управление

**Централизованное управление (SOA):**
```
┌─────────────────┐
│ Enterprise Bus  │ ◄── Все сервисы должны
│                 │     использовать этот bus
│ • Routing       │
│ • Transformation│ ◄── Бизнес-логика в bus
│ • Orchestration │
│ • Security      │
└─────────────────┘
         ▲
    ┌────┼────┐
    │    │    │
    ▼    ▼    ▼
┌─────┐ ┌─────┐ ┌─────┐
│Srv A│ │Srv B│ │Srv C│ ◄── "Тупые" сервисы
└─────┘ └─────┘ └─────┘
```

**Децентрализованное управление (Микросервисы):**
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Service A  │    │  Service B  │    │  Service C  │
│             │    │             │    │             │
│ • Business  │    │ • Business  │    │ • Business  │
│   Logic     │    │   Logic     │    │   Logic     │
│ • Data      │    │ • Data      │    │ • Data      │
│ • Security  │    │ • Security  │    │ • Security  │
│ • Monitoring│    │ • Monitoring│    │ • Monitoring│
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       └──────────────────┼──────────────────┘
                          │
              Simple Communication
              (HTTP, Messages)
```

### Принцип 4: Отказоустойчивость через изоляцию

**Bulkhead Pattern:**
```
                Ship Compartments
┌─────────────────────────────────────────────┐
│ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐     │
│ │  A  │ │  B  │ │  C  │ │  D  │ │  E  │     │
│ └─────┘ └─────┘ └──┬──┘ └─────┘ └─────┘     │
│                    │ ◄── Вода              │
│                    ▼                        │
│                 ┌─────┐                     │
│                 │  💧 │ ◄── Изолированно     │
│                 └─────┘                     │
└─────────────────────────────────────────────┘

Application Bulkheads:
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ Service A   │ │ Service B   │ │ Service C   │
│             │ │     ❌      │ │             │
│ Running ✓   │ │   Failed    │ │ Running ✓   │
│             │ │             │ │             │
└─────────────┘ └─────────────┘ └─────────────┘
       ▲               ▲               ▲
       │               │               │
   Isolated        Isolated        Isolated
   Resources       Resources       Resources
```

**Timeout Pattern:**
```
Service A ──request──► Service B
          ◄──timeout(5s)─┘

if (response_time > 5s) {
  return "Service temporarily unavailable";
}

Без timeout:
Service A ──request──► Service B (зависло)
          ──waiting──► ∞
          ──waiting──► ∞ 
          ──waiting──► ∞ ◄── Все ресурсы заблокированы
```

### Принцип 5: Организация команд

**Conway's Law:**
> "Организации, разрабатывающие системы, создают архитектуры, которые копируют коммуникационную структуру этих организаций"

**Плохо - Команды по техническим ролям:**
```
Frontend Team ────┐
Backend Team  ────┼──► Монолитная архитектура
DBA Team      ────┤    (все зависят друг от друга)
DevOps Team   ────┘

Результат:
• Много координации между командами
• Медленная доставка фич
• Сложно принимать решения
```

**Хорошо - Команды по бизнес-доменам:**
```
User Management Team ──► User Service
├── Frontend Developer
├── Backend Developer  
├── DevOps Engineer
└── Product Owner

Order Management Team ──► Order Service
├── Frontend Developer
├── Backend Developer
├── DevOps Engineer  
└── Product Owner

Payment Team ──► Payment Service
├── Frontend Developer
├── Backend Developer
├── DevOps Engineer
└── Product Owner
```

**Team Topology для микросервисов:**
```
                Stream-Aligned Teams
                      │
    ┌─────────────────┼─────────────────┐
    │                 │                 │
    ▼                 ▼                 ▼
┌─────────┐     ┌─────────┐     ┌─────────┐
│ Team A  │     │ Team B  │     │ Team C  │
│ Product │     │ Product │     │ Product │
│ Feature │     │ Feature │     │ Feature │
│Ownership│     │Ownership│     │Ownership│
└─────────┘     └─────────┘     └─────────┘
     │               │               │
     ▼               ▼               ▼
┌─────────┐     ┌─────────┐     ┌─────────┐
│Service A│     │Service B│     │Service C│
└─────────┘     └─────────┘     └─────────┘

Platform Team (enabling):
┌─────────────────────────────────────────┐
│ • CI/CD pipeline                        │
│ • Monitoring & Logging                  │
│ • Service mesh                          │
│ • Developer tools                       │
└─────────────────────────────────────────┘
```

---

## Глава 3: Декомпозиция и проектирование сервисов

### Domain-Driven Design (DDD) основы

**Что такое домен:**
```
E-commerce домен:
├── Управление продуктами
├── Управление заказами
├── Управление пользователями  
├── Платежная система
├── Система доставки
├── Управление складом
├── Аналитика и отчеты
└── Маркетинг и промо
```

**Bounded Context:**
```
┌─────────────────────────┐  ┌─────────────────────────┐
│    Catalog Context      │  │    Order Context        │
│                         │  │                         │
│ Product {               │  │ Product {               │
│   id: string           │  │   id: string           │
│   name: string         │  │   price: money         │
│   description: text    │  │   quantity: int        │
│   images: [url]        │  │ }                      │
│   categories: [id]     │  │                        │
│   attributes: json     │  │ Order {                │
│ }                      │  │   id: string           │
│                        │  │   products: [Product]  │
│                        │  │   total: money         │
│                        │  │   status: enum         │
│                        │  │ }                      │
└─────────────────────────┘  └─────────────────────────┘

Одна сущность "Product" имеет разные 
представления в разных контекстах
```

**Ubiquitous Language:**
```
❌ Технический язык:
"Создать entity ProductRecord с полями productId, 
productName в таблице products_table"

✅ Бизнес-язык:
"Добавить продукт в каталог с названием и описанием"

В коде:
class CatalogService {
  addProductToCatalog(product: Product): void
  removeProductFromCatalog(productId: string): void
  updateProductInformation(product: Product): void
}
```

### Стратегии декомпозиции

**1. По бизнес-функциям (Business Capability)**
```
E-commerce capabilities:
┌─────────────────┐
│ Product Catalog │ ──► Catalog Service
│ • Browse        │
│ • Search        │  
│ • Reviews       │
└─────────────────┘

┌─────────────────┐
│ Order Management│ ──► Order Service  
│ • Cart          │
│ • Checkout      │
│ • Fulfillment   │
└─────────────────┘

┌─────────────────┐
│ User Management │ ──► User Service
│ • Registration  │
│ • Authentication│
│ • Profile       │
└─────────────────┘
```

**2. По данным (Data)**
```
User Data:
├── Personal Info (name, email, phone)
├── Authentication (passwords, tokens)  
├── Preferences (language, notifications)
└── Address Book (shipping addresses)
         ▼
    User Service

Product Data:  
├── Basic Info (name, description, price)
├── Inventory (stock, reservations)
├── Media (images, videos)
└── Categories (taxonomy, attributes)
         ▼
    Product Service
```

**3. По нагрузке (Scalability)**
```
High Load:
┌─────────────┐     ┌─────────────┐
│ Product     │     │ Search      │
│ Catalog     │     │ Service     │ ◄── Read-heavy
│ Service     │ ──► │             │     Scale separately
└─────────────┘     └─────────────┘

Medium Load:
┌─────────────┐
│ Order       │ ◄── Moderate traffic
│ Service     │     Standard scaling
└─────────────┘

Low Load:  
┌─────────────┐
│ Admin       │ ◄── Low traffic
│ Service     │     Minimal resources
└─────────────┘
```

### Размер микросервиса

**Two Pizza Rule:**
```
Team Size = Max 8 people (что накормят 2 пиццы)
Service Size = То, что может поддерживать такая команда

Практические метрики:
• 100-1000 строк кода  
• 1-2 недели полной перезаписи
• 1-3 таблицы в БД
• 1-10 API endpoints
• 1 четко определенная бизнес-функция
```

**Single Purpose Test:**
```
Можете ли вы объяснить назначение сервиса одним предложением?

✅ Хорошо:
"User Service управляет регистрацией и аутентификацией пользователей"

❌ Плохо:  
"User Service управляет пользователями, отправляет уведомления, 
генерирует отчеты, управляет скидками и обрабатывает платежи"
```

### Выделение сервисов из монолита

**Strangler Fig Pattern (пошаговая миграция):**

**Шаг 1: Proxy Layer**
```
┌─────────────────┐     ┌─────────────────┐
│     Client      │────►│  Proxy/Router   │
└─────────────────┘     └─────────┬───────┘
                                  │
                        ┌─────────▼───────┐
                        │     Monolith    │
                        │                 │
                        │ ┌─────────────┐ │
                        │ │ User Module │ │
                        │ └─────────────┘ │
                        │ ┌─────────────┐ │
                        │ │Order Module │ │
                        │ └─────────────┘ │
                        └─────────────────┘
```

**Шаг 2: Extract First Service**
```
┌─────────────────┐     ┌─────────────────┐
│     Client      │────►│  Proxy/Router   │
└─────────────────┘     └─────────┬───────┘
                                  │
                     ┌────────────┼────────────┐
                     │            │            │
                     ▼            ▼            │
            ┌─────────────┐ ┌─────────────────┐ │
            │ User Service│ │    Monolith     │ │
            │             │ │                 │ │
            │ ┌─────────┐ │ │ ┌─────────────┐ │ │
            │ │User Data│ │ │ │Order Module │ │ │
            │ └─────────┘ │ │ └─────────────┘ │ │
            └─────────────┘ └─────────────────┘ │
                     │                          │
                     └──────────────────────────┘
```

**Шаг 3: Continue Extraction**
```
┌─────────────────┐     ┌─────────────────┐
│     Client      │────►│  API Gateway    │
└─────────────────┘     └─────────┬───────┘
                                  │
                     ┌────────────┼────────────┐
                     │            │            │
                     ▼            ▼            ▼
            ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
            │ User Service│ │Order Service│ │   Legacy    │
            └─────────────┘ └─────────────┘ │  Monolith   │
                                            │ (remaining) │
                                            └─────────────┘
```

**Database Decomposition:**

**Шаг 1: Shared Database (временно)**
```
User Service ──┐
               ├──► Shared Database
Monolith ──────┘

Pros: Простая миграция
Cons: Coupling через данные
```

**Шаг 2: Database Splitting**
```
User Service ──► User DB ──sync──► Legacy DB
Monolith ────────────────────────► Legacy DB

Pros: Постепенная миграция
Cons: Сложность синхронизации
```

**Шаг 3: Independent Databases**
```
User Service ──► User DB
Order Service ──► Order DB
Legacy Service ──► Legacy DB

Pros: Полная независимость  
Cons: Нужно решать консистентность
```

---

## Глава 4: Межсервисное взаимодействие

### Синхронное vs Асинхронное взаимодействие

**Синхронное взаимодействие (Request-Response):**
```
Client ──1. Get Order Info──► Order Service
       ◄─4. Order Response─┘        │
                                    │
                           2. Get User Info
                                    ▼
                              User Service
                                    │
                           3. User Response
                                    ▼
                              Order Service

Timeline:
├─ 0ms ─ Client Request
├─ 10ms ─ Order Service processes
├─ 20ms ─ Call to User Service  
├─ 50ms ─ User Service responds
├─ 60ms ─ Order Service responds
└─ 60ms ─ Client receives response

Total: 60ms
```

**Асинхронное взаимодействие (Event-Driven):**
```
Order Service ──"Order Created"──► Message Queue
                                        │
                         ┌──────────────┼──────────────┐
                         │              │              │
                         ▼              ▼              ▼
                 User Service   Inventory Service  Email Service
                      │              │              │
                      ▼              ▼              ▼
              "Update Stats"  "Reserve Items"  "Send Confirmation"

Timeline:
├─ 0ms ─ Order Created Event
├─ 1ms ─ Event published
├─ 2ms ─ All services receive event
├─ 5ms ─ Services process in parallel
└─ Done

Total: 5ms + независимая обработка
```

### REST API для микросервисов

**API Design Principles:**

1. **Resource-based URLs**
```javascript
// ✅ Хорошо
GET /users/123
GET /users/123/orders
POST /users/123/orders
PUT /orders/456
DELETE /orders/456

// ❌ Плохо  
GET /getUser?id=123
POST /createOrderForUser?userId=123&productId=456
```

2. **HTTP методы по назначению**
```javascript
GET    /products     // Получить список
GET    /products/123 // Получить конкретный
POST   /products     // Создать новый
PUT    /products/123 // Обновить полностью
PATCH  /products/123 // Обновить частично  
DELETE /products/123 // Удалить
```

3. **Статус коды**
```javascript
200 OK           // Успешный запрос
201 Created      // Ресурс создан
400 Bad Request  // Ошибка в запросе
401 Unauthorized // Не авторизован
404 Not Found    // Ресурс не найден
500 Server Error // Ошибка сервера
```

4. **Версионирование API**
```javascript
// Через URL
GET /v1/users/123
GET /v2/users/123

// Через заголовки
GET /users/123
Accept: application/vnd.api.v1+json

// Через параметры
GET /users/123?version=1
```

**Пример API контракта:**
```javascript
// User Service API
{
  "openapi": "3.0.0",
  "info": {
    "title": "User Service API",
    "version": "1.0.0"
  },
  "paths": {
    "/users/{id}": {
      "get": {
        "summary": "Get user by ID",
        "parameters": [
          {
            "name": "id",
            "in": "path", 
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "schema": {
              "$ref": "#/definitions/User"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "User": {
      "type": "object",
      "properties": {
        "id": {"type": "string"},
        "email": {"type": "string"},
        "name": {"type": "string"}
      }
    }
  }
}
```

### Event-Driven Architecture

**Типы событий:**

1. **Domain Events (бизнес-события)**
```javascript
{
  "eventType": "UserRegistered",
  "aggregateId": "user-123",
  "userId": "user-123", 
  "email": "john@example.com",
  "timestamp": "2025-07-01T10:00:00Z",
  "version": 1
}

{
  "eventType": "OrderCompleted",
  "aggregateId": "order-456",
  "orderId": "order-456",
  "userId": "user-123",
  "total": 99.99,
  "items": [
    {"productId": "prod-789", "quantity": 2}
  ],
  "timestamp": "2025-07-01T10:05:00Z", 
  "version": 1
}
```

2. **Integration Events (интеграционные события)**
```javascript
{
  "eventType": "PaymentProcessed",
  "paymentId": "payment-789",
  "orderId": "order-456", 
  "amount": 99.99,
  "status": "completed",
  "timestamp": "2025-07-01T10:03:00Z"
}
```

**Event Sourcing:**
```
Traditional State:
User { id: 123, name: "John", email: "john@new.com" }

Event Sourcing:
Events:
1. UserCreated { id: 123, name: "John", email: "john@old.com" }
2. EmailChanged { id: 123, email: "john@new.com" }

Current State = apply(Events[1..N])
```

**CQRS (Command Query Responsibility Segregation):**
```
Commands (Write):          Queries (Read):
┌─────────────────┐       ┌─────────────────┐
│ Write Model     │       │ Read Model      │
│                 │       │                 │
│ ┌─────────────┐ │       │ ┌─────────────┐ │
│ │ Normalized  │ │ ──events─► │ Denormalized│ │
│ │ Write DB    │ │       │ │ Read DB     │ │
│ └─────────────┘ │       │ └─────────────┘ │
└─────────────────┘       └─────────────────┘

Commands:                 Queries:
• CreateOrder             • GetOrderHistory
• UpdateOrder             • GetOrdersByUser  
• CancelOrder             • GetOrderStatistics
```

### Message Patterns

**1. Point-to-Point (Queue)**
```
Producer ──message──► Queue ──message──► Consumer
                        │
                        └──message──► Consumer (if available)

Use case: Task processing, load balancing
```

**2. Publish-Subscribe (Topic)**
```
Producer ──message──► Topic ──message──► Consumer A
                        │
                        ├──message──► Consumer B  
                        │
                        └──message──► Consumer C

Use case: Event broadcasting, notifications
```

**3. Request-Reply**
```
Client ──request──► Queue A ──request──► Service
       ◄─response─ Queue B ◄─response──

Use case: Async RPC, long-running operations
```

**Delivery Guarantees:**

1. **At-most-once (최대 한 번)**
```
Producer ──message──► Queue ──?──► Consumer
                              Lost OK

Use case: Metrics, logging (loss acceptable)
```

2. **At-least-once (최소 한 번)**  
```
Producer ──message──► Queue ──message──► Consumer
                        │         │
                        └─retry─►Consumer
                              Duplicate OK

Use case: Notifications, emails
```

3. **Exactly-once (정확히 한 번)**
```
Producer ──message──► Queue ──message──► Consumer
                   Idempotent     Idempotent
                   
Use case: Payments, orders (no loss, no duplicates)
```

---

## Глава 5: Ключевые паттерны надежности

### API Gateway Pattern

**Проблемы без API Gateway:**
```
Mobile App ────────► User Service (auth)
     │              │
     ├─────────────► Order Service  
     │              │
     ├─────────────► Product Service
     │              │  
     └─────────────► Payment Service

Problems:
• Client знает обо всех сервисах
• Множественные network calls
• Дублирование auth логики
• Сложно версионировать API
• CORS problems
```

**Решение с API Gateway:**
```
Mobile App ────► API Gateway ────► User Service
Web App    ────►      │      ────► Order Service
3rd Party  ────►      │      ────► Product Service
                      │      ────► Payment Service
                      │
            ┌─────────▼─────────┐
            │ Gateway Features  │
            │ • Authentication  │ 
            │ • Rate Limiting   │
            │ • Load Balancing  │
            │ • Request Routing │
            │ • Response Caching│
            │ • API Composition │
            └───────────────────┘
```

**API Gateway функции:**

1. **Request Routing**
```javascript
// Routes configuration
{
  "/api/v1/users/*": "user-service:8080",
  "/api/v1/orders/*": "order-service:8081", 
  "/api/v1/products/*": "product-service:8082"
}

// Request
GET /api/v1/users/123 ──► user-service:8080/users/123
```

2. **Authentication & Authorization**
```javascript
// Gateway auth flow
1. Client ──request + JWT──► Gateway
2. Gateway validates JWT
3. If valid ──► forward to service
4. If invalid ──► return 401

// Service receives authenticated request with user context
Headers: {
  "X-User-ID": "123",
  "X-User-Role": "customer",
  "Authorization": "Bearer ..."
}
```

3. **Rate Limiting**
```javascript
// Per user rate limiting
const rateLimiter = {
  "user-123": {
    requests: 98,     // Current count
    window: "10:00",  // Current minute
    limit: 100        // Max per minute
  }
}

if (requests >= limit) {
  return 429; // Too Many Requests
}
```

4. **API Composition**
```javascript
// Single endpoint, multiple services
GET /api/v1/orders/123/details

Gateway:
1. Get order ──► Order Service
2. Get user  ──► User Service (parallel)
3. Get products ──► Product Service (parallel)
4. Combine response

Response: {
  order: {...},
  user: {...}, 
  products: [...]
}
```

### Circuit Breaker Pattern

**Проблема cascading failures:**
```
Order Service ──► Payment Service (down)
      │                  ▼
      │            Timeout (30s)
      │                  ▼  
      ▼            Thread pool exhausted
Order Service            ▼
becomes slow       Order Service fails
      ▼                  ▼
All clients        Entire system down
affected
```

**Circuit Breaker решение:**
```
Order Service ──► Circuit Breaker ──► Payment Service
                       │
                  ┌────▼────┐
                  │ States: │
                  │ CLOSED  │ ◄── Normal operation
                  │ OPEN    │ ◄── Fast fail
                  │HALF_OPEN│ ◄── Testing recovery
                  └─────────┘
```

**Состояния Circuit Breaker:**

1. **CLOSED (нормальная работа)**
```
Requests ──► Circuit Breaker ──► Service
                    │
            ┌───────▼───────┐
            │ Success: 95%  │
            │ Failures: 5%  │ ◄── Below threshold
            │ Status: CLOSED│
            └───────────────┘

If failure_rate > threshold ──► OPEN
```

2. **OPEN (быстрый отказ)**
```
Requests ──► Circuit Breaker ──X──► Service
                    │               (не вызываем)
                    ▼
            Return cached response
            or error immediately

After timeout ──► HALF_OPEN
```

3. **HALF_OPEN (проверка восстановления)**
```
Limited requests ──► Circuit Breaker ──► Service
                          │
                    ┌─────▼─────┐
                    │ Test with │
                    │ 1-2 calls │
                    └─────┬─────┘
                          │
              ┌───────────┼───────────┐
              ▼                       ▼
         If success              If failure  
         ──► CLOSED              ──► OPEN
```

**Пример реализации:**
```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureThreshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.state = 'CLOSED';
    this.nextAttempt = Date.now();
  }
  
  async call(service) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await service();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN'; 
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}
```

### Service Discovery Pattern

**Static Configuration проблемы:**
```javascript
// Hardcoded service locations
const config = {
  userService: 'http://192.168.1.10:8080',
  orderService: 'http://192.168.1.11:8081',
  paymentService: 'http://192.168.1.12:8082'
}

Problems:
• IP addresses change
• Services scale up/down
• Health status unknown
• Load balancing needed
```

**Service Registry решение:**
```
Service Registry (Consul, Eureka, etc.)
┌─────────────────────────────────────┐
│ Services:                           │
│ ┌─────────────────────────────────┐ │
│ │ user-service                    │ │
│ │ ├─ instance-1: 192.168.1.10:80 │ │
│ │ ├─ instance-2: 192.168.1.11:80 │ │
│ │ └─ instance-3: 192.168.1.12:80 │ │
│ └─────────────────────────────────┘ │
│ ┌─────────────────────────────────┐ │
│ │ order-service                   │ │
│ │ ├─ instance-1: 192.168.1.20:81 │ │
│ │ └─ instance-2: 192.168.1.21:81 │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
          ▲                    ▲
          │                    │
     Registration          Discovery
          │                    │
          ▼                    ▼
┌─────────────┐      ┌─────────────┐
│   Service   │      │   Client    │
│  Instance   │      │  (Consumer) │
└─────────────┘      └─────────────┘
```

**Client-Side Discovery:**
```
1. Client ──query──► Service Registry
2. Service Registry ──list──► Client
3. Client ──request──► Service Instance (chosen by client)

Pros: Simple, no additional network hop
Cons: Client logic complexity
```

**Server-Side Discovery:**
```
1. Client ──request──► Load Balancer
2. Load Balancer ──query──► Service Registry  
3. Load Balancer ──request──► Service Instance

Pros: Simple client, centralized logic
Cons: Load balancer can be bottleneck
```

**Health Checks:**
```javascript
// Service health endpoint
GET /health

Response:
{
  "status": "UP",      // UP, DOWN, OUT_OF_SERVICE
  "timestamp": "2025-07-01T10:00:00Z",
  "dependencies": {
    "database": {
      "status": "UP",
      "responseTime": "10ms"
    },
    "cache": {
      "status": "UP", 
      "responseTime": "1ms"
    },
    "external-api": {
      "status": "DOWN",
      "error": "Connection timeout"
    }
  },
  "metrics": {
    "cpu": "45%",
    "memory": "60%",
    "disk": "30%"
  }
}
```

### Bulkhead Pattern

**Shared Resource Pool проблема:**
```
┌─────────────────────────────────┐
│        Thread Pool (10)         │
├─────────────────────────────────┤
│ ████████████████████████████    │ ◄── All threads
│ Critical API    │ Batch Jobs    │     used by 
│ (8 threads)     │ (2 threads)   │     batch jobs
└─────────────────────────────────┘
         ▲               ▲
         │               │
    Fast response   Slow processing
    required        (not critical)

Result: Critical API becomes slow
```

**Bulkhead изоляция:**
```
┌─────────────────┐    ┌─────────────────┐
│  Thread Pool A  │    │  Thread Pool B  │  
│     (6 threads) │    │     (4 threads) │
├─────────────────┤    ├─────────────────┤
│ ████████████    │    │ ████████████████│
│ Critical API    │    │   Batch Jobs    │
│                 │    │                 │
└─────────────────┘    └─────────────────┘

Result: Critical API always has resources
```

**Types of Bulkheads:**

1. **Thread Pool Isolation**
```javascript
// Separate thread pools
const criticalPool = new ThreadPool(10);
const batchPool = new ThreadPool(5);  
const reportPool = new ThreadPool(2);

// Route requests to appropriate pools
if (request.type === 'critical') {
  criticalPool.execute(request);
} else if (request.type === 'batch') {
  batchPool.execute(request);
}
```

2. **Connection Pool Isolation**
```javascript
// Separate DB connection pools
const userDbPool = new ConnectionPool('user-db', 10);
const analyticsDbPool = new ConnectionPool('analytics-db', 5);
const logsDbPool = new ConnectionPool('logs-db', 2);
```

3. **Service Instance Isolation**
```
High Priority Requests:
Client ──► Load Balancer ──► Service Instance Pool A
                              ├─ Instance A1  
                              ├─ Instance A2
                              └─ Instance A3

Low Priority Requests:
Client ──► Load Balancer ──► Service Instance Pool B
                              ├─ Instance B1
                              └─ Instance B2
```

### Retry Pattern

**Simple Retry:**
```javascript
async function callServiceWithRetry(service, maxRetries = 3) {
  let attempts = 0;
  
  while (attempts < maxRetries) {
    try {
      return await service();
    } catch (error) {
      attempts++;
      
      if (attempts >= maxRetries) {
        throw error; // Final failure
      }
      
      // Fixed delay
      await sleep(1000); // 1 second
    }
  }
}
```

**Exponential Backoff:**
```javascript
async function callServiceWithBackoff(service, maxRetries = 3) {
  let attempts = 0;
  
  while (attempts < maxRetries) {
    try {
      return await service();
    } catch (error) {
      attempts++;
      
      if (attempts >= maxRetries) {
        throw error;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = Math.pow(2, attempts) * 1000;
      await sleep(delay);
    }
  }
}
```

**Jittered Exponential Backoff:**
```javascript
async function callServiceWithJitter(service, maxRetries = 3) {
  let attempts = 0;
  
  while (attempts < maxRetries) {
    try {
      return await service();
    } catch (error) {
      attempts++;
      
      if (attempts >= maxRetries) {
        throw error;
      }
      
      // Add randomness to prevent thundering herd
      const baseDelay = Math.pow(2, attempts) * 1000;
      const jitter = Math.random() * 0.1 * baseDelay;
      const delay = baseDelay + jitter;
      
      await sleep(delay);
    }
  }
}
```

**Retry with Conditions:**
```javascript
function isRetriableError(error) {
  // Retry on temporary failures
  const retriableCodes = [500, 502, 503, 504, 429];
  return retriableCodes.includes(error.status);
}

async function smartRetry(service, maxRetries = 3) {
  let attempts = 0;
  
  while (attempts < maxRetries) {
    try {
      return await service();
    } catch (error) {
      attempts++;
      
      // Don't retry on client errors (4xx)
      if (!isRetriableError(error) || attempts >= maxRetries) {
        throw error;
      }
      
      await sleep(Math.pow(2, attempts) * 1000);
    }
  }
}
```

---

## Глава 6: Управление транзакциями

### Проблема распределенных транзакций

**ACID в монолите:**
```javascript
// Монолитная транзакция
BEGIN TRANSACTION
  INSERT INTO orders (user_id, total) VALUES (123, 99.99);
  UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 456;
  INSERT INTO payments (order_id, amount) VALUES (789, 99.99);
COMMIT

Все изменения либо применяются, либо откатываются
```

**Проблема в микросервисах:**
```
Order Service ──► Order DB (✓ Committed)
     │
     ├──► Inventory Service ──► Inventory DB (✓ Committed)  
     │
     └──► Payment Service ──► Payment DB (✗ Failed)

Result: Inconsistent state!
Order created, inventory updated, but payment failed
```

### Two-Phase Commit (2PC) проблемы

**2PC Protocol:**
```
Phase 1 - Prepare:
Coordinator ──► Service A: "Can you commit?"
            ──► Service B: "Can you commit?"
            ──► Service C: "Can you commit?"

Service A ──► "Yes, ready"
Service B ──► "Yes, ready"  
Service C ──► "No, failure"

Phase 2 - Commit/Abort:
Coordinator ──► Service A: "Abort"
            ──► Service B: "Abort"
            ──► Service C: "Abort"
```

**2PC проблемы:**
```
1. Blocking Protocol:
   Services wait for coordinator decision
   
2. Single Point of Failure:
   If coordinator crashes, all services block
   
3. Performance Impact:
   Multiple network rounds required
   
4. Doesn't work well with microservices:
   Tight coupling, reduces autonomy
```

### Saga Pattern

**Choreography Saga:**
```
Saga Steps:
1. Create Order
2. Reserve Inventory  
3. Process Payment
4. Confirm Order

Success Flow:
Order Service ──"OrderCreated"──► Event Bus
                                     │
Inventory Service ◄──────────────────┘
                   │
                   "InventoryReserved"
                   │
                   ▼
Payment Service ◄─────Event Bus
                   │
                   "PaymentProcessed"  
                   │
                   ▼
Order Service ◄────Event Bus
                   │
                   "OrderConfirmed"
```

**Compensation Flow:**
```
Failure at Payment:
Order Service ──"OrderCreated"──► ✓
Inventory Service ──"InventoryReserved"──► ✓
Payment Service ──"PaymentFailed"──► ✗

Compensation:
Payment Service ──"PaymentFailed"──► Event Bus
                                        │
Inventory Service ◄─────────────────────┘
                   │
                   "InventoryReleased" (compensate)
                   │
                   ▼
Order Service ◄────Event Bus  
                   │
                   "OrderCancelled" (compensate)
```

**Orchestration Saga:**
```
                 ┌─────────────────┐
                 │ Saga Coordinator│
                 └─────────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│Order Service│    │Inventory    │    │Payment      │
│             │    │Service      │    │Service      │
└─────────────┘    └─────────────┘    └─────────────┘

Saga Coordinator controls the flow:
1. Call Order Service
2. If success, call Inventory Service
3. If success, call Payment Service  
4. If any failure, execute compensations
```

**Пример Saga реализации:**
```javascript
class OrderSaga {
  async execute(orderData) {
    const sagaState = {
      steps: [],
      compensations: []
    };
    
    try {
      // Step 1: Create Order
      const order = await this.createOrder(orderData);
      sagaState.steps.push({step: 'CreateOrder', data: order});
      sagaState.compensations.push(() => this.cancelOrder(order.id));
      
      // Step 2: Reserve Inventory
      const reservation = await this.reserveInventory(order.items);
      sagaState.steps.push({step: 'ReserveInventory', data: reservation});
      sagaState.compensations.push(() => this.releaseInventory(reservation.id));
      
      // Step 3: Process Payment
      const payment = await this.processPayment(order.total);
      sagaState.steps.push({step: 'ProcessPayment', data: payment});
      sagaState.compensations.push(() => this.refundPayment(payment.id));
      
      // Step 4: Confirm Order
      await this.confirmOrder(order.id);
      
      return order;
      
    } catch (error) {
      // Execute compensations in reverse order
      await this.compensate(sagaState.compensations.reverse());
      throw error;
    }
  }
  
  async compensate(compensations) {
    for (const compensation of compensations) {
      try {
        await compensation();
      } catch (error) {
        // Log compensation failure, but continue
        console.error('Compensation failed:', error);
      }
    }
  }
}
```

### Eventual Consistency

**Strong Consistency (traditional):**
```
Time: ────────────────────────────────►

Database: [Data v1] ──update──► [Data v2]
                               
All reads after update return v2
```

**Eventual Consistency:**
```
Time: ────────────────────────────────►

Service A: [Data v1] ──update──► [Data v2]
Service B: [Data v1] ────────────────────► [Data v2]
Service C: [Data v1] ──────────────► [Data v2]

Different services see updates at different times,
but eventually converge to the same state
```

**Пример eventual consistency:**
```
User updates profile in User Service:
User Service ──► User DB: {name: "John Smith"} (immediately)
                    │
                    "UserUpdated" event
                    │
                    ▼
Email Service ──► Email Templates: {name: "John Doe"} (5 seconds later)
Analytics Service ──► Analytics DB: {name: "John Doe"} (10 seconds later)
Cache Service ──► Cache: {name: "John Doe"} (30 seconds later)

Period of inconsistency: 0-30 seconds
```

**Dealing with Eventual Consistency:**

1. **Read Your Own Writes**
```javascript
// After updating profile, show updated data immediately
async function updateUserProfile(userId, newData) {
  // Update in write database
  await userWriteDb.update(userId, newData);
  
  // Immediately update local cache
  cache.set(userId, newData);
  
  // Return updated data to user
  return newData;
}
```

2. **Conflict Resolution**
```javascript
// Last Writer Wins
function resolveConflict(version1, version2) {
  return version1.timestamp > version2.timestamp ? version1 : version2;
}

// Application-specific rules
function resolveUserConflict(version1, version2) {
  return {
    name: version1.name, // Prefer first version
    email: version2.email, // Prefer second version  
    timestamp: Math.max(version1.timestamp, version2.timestamp)
  };
}
```

3. **Versioning**
```javascript
// Vector clocks for conflict detection
{
  data: {name: "John"},
  version: {
    "user-service": 3,
    "profile-service": 1,
    "cache-service": 2
  }
}
```

### Outbox Pattern

**Проблема: Dual Writes**
```javascript
// ❌ Проблема: может произойти partial failure
async function createOrder(orderData) {
  // 1. Save to database
  await database.save(order);
  
  // 2. Publish event - может упасть
  await eventBus.publish('OrderCreated', order);
}

Scenarios:
• Database save ✓, Event publish ✗ → Inconsistent state
• Database save ✗, Event publish ✓ → Event without data
• Database save ✓, Event publish ✓ → Success
```

**Outbox Pattern решение:**
```
┌─────────────────────────────────────┐
│           Database                  │
│ ┌─────────────┐ ┌─────────────────┐ │
│ │   Orders    │ │     Outbox      │ │
│ │             │ │                 │ │
│ │ order_id    │ │ id              │ │
│ │ user_id     │ │ event_type      │ │
│ │ total       │ │ event_data      │ │
│ │ status      │ │ processed       │ │
│ └─────────────┘ │ created_at      │ │
│                 └─────────────────┘ │
└─────────────────────────────────────┘
         │                    │
         ▼                    ▼
  Business Data         Event Queue
```

**Outbox Pattern реализация:**
```javascript
async function createOrder(orderData) {
  const transaction = await database.beginTransaction();
  
  try {
    // 1. Save business data
    const order = await transaction.orders.create(orderData);
    
    // 2. Save event to outbox (same transaction)
    await transaction.outbox.create({
      eventType: 'OrderCreated',
      eventData: JSON.stringify(order),
      processed: false,
      createdAt: new Date()
    });
    
    // 3. Commit both changes atomically
    await transaction.commit();
    
    return order;
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}

// Separate process publishes events
async function publishOutboxEvents() {
  const events = await database.outbox.findUnprocessed();
  
  for (const event of events) {
    try {
      await eventBus.publish(event.eventType, JSON.parse(event.eventData));
      await database.outbox.markProcessed(event.id);
    } catch (error) {
      console.error('Failed to publish event:', error);
      // Will retry in next cycle
    }
  }
}

// Run publisher periodically
setInterval(publishOutboxEvents, 5000);
```

---

## Глава 7: Мониторинг и наблюдаемость

### Три столпа наблюдаемости

**1. Логи (Logs)**
```
Application logs показывают что произошло:

[2025-07-01 10:00:01.123] INFO  OrderService - Order 12345 created for user 789
[2025-07-01 10:00:02.456] DEBUG PaymentService - Processing payment for order 12345
[2025-07-01 10:00:03.789] ERROR PaymentService - Payment failed: Invalid card number
[2025-07-01 10:00:04.012] WARN  OrderService - Order 12345 payment failed, cancelling order
[2025-07-01 10:00:04.345] INFO  NotificationService - Sending cancellation email to user 789
```

**Structured Logging:**
```javascript
// ❌ Unstructured logs
console.log('User 123 ordered product 456 for $99.99');

// ✅ Structured logs  
logger.info('Order created', {
  userId: '123',
  productId: '456', 
  orderId: '789',
  amount: 99.99,
  timestamp: '2025-07-01T10:00:00Z',
  traceId: 'abc-123-def'
});
```

**Centralized Logging:**
```
Service A ──logs──► Log Aggregator ──► Search & Analytics
Service B ──logs──►       │
Service C ──logs──►       │
                          ▼
                   ┌─────────────┐
                   │ Log Storage │
                   │ (ELK Stack) │
                   └─────────────┘
```

**2. Метрики (Metrics)**
```
System metrics показывают как работает система:

order_service_requests_total{method="POST",status="200"} 1523
order_service_requests_total{method="POST",status="500"} 12
order_service_response_time_seconds{quantile="0.95"} 0.234
order_service_active_connections 45
order_service_memory_usage_bytes 524288000
```

**Типы метрик:**

**Counters (счетчики):**
```javascript
// Увеличиваются монотонно
requestsTotal.inc({method: 'GET', endpoint: '/users'});
errorsTotal.inc({service: 'payment', error_type: 'timeout'});
```

**Gauges (индикаторы):**
```javascript
// Текущее значение
activeConnections.set(42);
memoryUsage.set(process.memoryUsage().heapUsed);
queueSize.set(messageQueue.length);
```

**Histograms (гистограммы):**
```javascript
// Распределение значений
responseTime.observe(0.234); // 234ms
requestSize.observe(1024);   // 1KB request
```

**Summaries (сводки):**
```javascript
// Квантили и суммы
responseDuration.observe(0.1);   // Adds to summary
// Автоматически вычисляет percentiles: 50%, 90%, 95%, 99%
```

**Пример реализации метрик:**
```javascript
const prometheus = require('prom-client');

// Create metrics
const httpRequests = new prometheus.Counter({
  name: 'http_requests_total',
  help: 'Total HTTP requests',
  labelNames: ['method', 'route', 'status']
});

const httpDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration',
  labelNames: ['method', 'route'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

// Middleware to track metrics
function metricsMiddleware(req, res, next) {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    
    httpRequests.inc({
      method: req.method,
      route: req.route.path,
      status: res.statusCode
    });
    
    httpDuration.observe({
      method: req.method,
      route: req.route.path
    }, duration);
  });
  
  next();
}
```

**3. Трассировка (Tracing)**
```
Distributed traces показывают путь запроса через систему:

Trace ID: abc-123-def-456
│
├─ Span 1: API Gateway (10ms)
│  │
│  ├─ Span 2: Order Service (50ms)
│  │  │
│  │  ├─ Span 3: Database Query (30ms)
│  │  └─ Span 4: Cache Lookup (5ms)
│  │
│  └─ Span 5: Payment Service (200ms)
│     │
│     ├─ Span 6: External API Call (180ms)
│     └─ Span 7: Database Update (15ms)
```

**Trace Context Propagation:**
```javascript
// Request headers
{
  "X-Trace-ID": "abc-123-def-456",
  "X-Span-ID": "span-789",
  "X-Parent-Span-ID": "span-456"
}

// Service A calls Service B
async function callServiceB(data) {
  const headers = {
    'Content-Type': 'application/json',
    'X-Trace-ID': getCurrentTraceId(),
    'X-Span-ID': generateNewSpanId(),
    'X-Parent-Span-ID': getCurrentSpanId()
  };
  
  return await fetch('http://service-b/api', {
    method: 'POST',
    headers,
    body: JSON.stringify(data)
  });
}
```

### Correlation IDs

**Проблема: как связать логи разных сервисов?**
```
Service A: [10:00:01] Processing user request
Service B: [10:00:02] Database query executed  
Service C: [10:00:03] Email sent
Service A: [10:00:04] Request completed

Вопрос: какие логи относятся к одному запросу?
```

**Решение: Correlation ID**
```
Service A: [10:00:01] [correlationId=req-123] Processing user request
Service B: [10:00:02] [correlationId=req-123] Database query executed
Service C: [10:00:03] [correlationId=req-123] Email sent  
Service A: [10:00:04] [correlationId=req-123] Request completed

Теперь можно найти все логи по correlationId=req-123
```

**Реализация Correlation ID:**
```javascript
// Middleware для генерации/извлечения correlation ID
function correlationMiddleware(req, res, next) {
  // Получаем correlation ID из заголовка или генерируем новый
  const correlationId = req.headers['x-correlation-id'] || 
                        generateUUID();
  
  // Сохраняем в контексте запроса
  req.correlationId = correlationId;
  
  // Добавляем в response headers
  res.setHeader('X-Correlation-ID', correlationId);
  
  next();
}

// Logger с correlation ID
function createLogger(correlationId) {
  return {
    info: (message, ...args) => {
      console.log(`[${new Date().toISOString()}] [correlationId=${correlationId}] INFO: ${message}`, ...args);
    },
    error: (message, ...args) => {
      console.log(`[${new Date().toISOString()}] [correlationId=${correlationId}] ERROR: ${message}`, ...args);
    }
  };
}

// Использование
app.get('/orders/:id', correlationMiddleware, async (req, res) => {
  const logger = createLogger(req.correlationId);
  
  logger.info('Fetching order', { orderId: req.params.id });
  
  try {
    const order = await orderService.getOrder(req.params.id, req.correlationId);
    logger.info('Order fetched successfully');
    res.json(order);
  } catch (error) {
    logger.error('Failed to fetch order', { error: error.message });
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### Health Checks

**Simple Health Check:**
```javascript
// Basic health endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'UP',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});
```

**Detailed Health Check:**
```javascript
class HealthChecker {
  constructor() {
    this.dependencies = [
      { name: 'database', checker: this.checkDatabase },
      { name: 'redis', checker: this.checkRedis },
      { name: 'external-api', checker: this.checkExternalAPI }
    ];
  }
  
  async checkHealth() {
    const results = {
      status: 'UP',
      timestamp: new Date().toISOString(),
      dependencies: {}
    };
    
    let overallStatus = 'UP';
    
    for (const dep of this.dependencies) {
      try {
        const start = Date.now();
        await dep.checker();
        
        results.dependencies[dep.name] = {
          status: 'UP',
          responseTime: `${Date.now() - start}ms`
        };
      } catch (error) {
        results.dependencies[dep.name] = {
          status: 'DOWN',
          error: error.message
        };
        overallStatus = 'DOWN';
      }
    }
    
    results.status = overallStatus;
    return results;
  }
  
  async checkDatabase() {
    await database.query('SELECT 1');
  }
  
  async checkRedis() {
    await redis.ping();
  }
  
  async checkExternalAPI() {
    const response = await fetch('https://api.external.com/health', {
      timeout: 5000
    });
    
    if (!response.ok) {
      throw new Error(`External API returned ${response.status}`);
    }
  }
}

app.get('/health', async (req, res) => {
  try {
    const health = await healthChecker.checkHealth();
    const statusCode = health.status === 'UP' ? 200 : 503;
    res.status(statusCode).json(health);
  } catch (error) {
    res.status(503).json({
      status: 'DOWN',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

**Health Check Types:**

1. **Shallow Health Check**
```javascript
// Быстрая проверка (< 1 секунда)
GET /health/live

// Проверяет только что сервис запущен
{
  "status": "UP",
  "checks": ["process-running", "port-listening"]
}
```

2. **Deep Health Check**
```javascript
// Полная проверка (< 30 секунд)
GET /health/ready

// Проверяет готовность к обработке запросов
{
  "status": "UP", 
  "checks": {
    "database": "UP",
    "cache": "UP",
    "dependencies": "UP"
  }
}
```

### Alerting стратегии

**Alert Pyramid:**
```
                     ┌─────────┐
                     │ Pages   │ ◄── Critical alerts (wake up engineer)
                     └─────────┘
                   ┌─────────────┐
                   │ Tickets     │ ◄── Important alerts (investigate today)
                   └─────────────┘
               ┌───────────────────┐
               │ Notifications     │ ◄── Warning alerts (check tomorrow)
               └───────────────────┘
           ┌───────────────────────────┐
           │ Dashboards & Logs         │ ◄── Info (visible in dashboards)
           └───────────────────────────┘
```

**Alert Rules Examples:**
```yaml
# Critical: Service completely down
- alert: ServiceDown
  expr: up{job="order-service"} == 0
  for: 1m
  labels:
    severity: critical
  annotations:
    summary: "Order Service is down"
    action: "Page oncall engineer immediately"

# High: Error rate spike  
- alert: HighErrorRate
  expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
  for: 5m
  labels:
    severity: high
  annotations:
    summary: "High error rate detected"
    action: "Create incident ticket"

# Warning: Response time degradation
- alert: SlowResponses
  expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
  for: 10m
  labels:
    severity: warning
  annotations:
    summary: "95th percentile response time > 1s"
    action: "Investigate performance"
```

**Alert Fatigue Prevention:**
```
Принципы хороших алертов:

1. Alert на symptoms, не на causes
   ✅ "Users can't place orders" 
   ❌ "CPU usage is high"

2. Alert только на actionable проблемы
   ✅ "Payment service error rate > 5%"
   ❌ "Someone deployed new version"

3. Группировка похожих алертов
   ✅ "Multiple services down in region A"
   ❌ "Service A down", "Service B down", "Service C down"

4. Правильные пороги и временные окна
   ✅ Error rate > 5% for 5 minutes
   ❌ Error rate > 0.1% for 30 seconds
```

---

## Глава 8: Безопасность микросервисов

### Угрозы в микросервисной архитектуре

**Увеличенная поверхность атаки:**
```
Монолит:
┌─────────────────┐
│   Application   │ ◄── 1 точка входа
└─────────────────┘
         │
┌─────────────────┐
│    Database     │ ◄── 1 база данных
└─────────────────┘

Микросервисы:
┌─────┐  ┌─────┐  ┌─────┐
│Srv A│  │Srv B│  │Srv C│ ◄── N точек входа
└──┬──┘  └──┬──┘  └──┬──┘
   │        │        │
┌──▼──┐  ┌──▼──┐  ┌──▼──┐
│DB A │  │DB B │  │DB C │ ◄── N баз данных
└─────┘  └─────┘  └─────┘

Каждый сервис = потенциальная точка атаки
```

**Сетевые угрозы:**
```
Внутри монолита:
Service A ──method_call()──► Service B
           (memory access)

Между микросервисами:  
Service A ──HTTP request──► Service B
           (network call)
           
Риски:
• Man-in-the-middle attacks
• Eavesdropping 
• Network hijacking
• Replay attacks
```

### Zero Trust Architecture

**Traditional Perimeter Security:**
```
                     Firewall
                        │
    Internet ───────────┼─────────► Trusted Network
    (Untrusted)         │           │
                        │           ├─ Service A
                        │           ├─ Service B  
                        │           └─ Service C
                        │           
            "Trust but don't verify inside"
```

**Zero Trust Model:**
```
                "Never trust, always verify"
                        │
    ┌───────────────────┼───────────────────┐
    │                   │                   │
    ▼                   ▼                   ▼
┌─────────┐         ┌─────────┐         ┌─────────┐
│Service A│◄───mTLS─►│Service B│◄───mTLS─►│Service C│
│+ Auth   │         │+ Auth   │         │+ Auth   │
│+ AuthZ  │         │+ AuthZ  │         │+ AuthZ  │
└─────────┘         └─────────┘         └─────────┘

Каждое взаимодействие аутентифицируется и авторизуется
```

### Authentication в микросервисах

**JWT (JSON Web Tokens):**
```
JWT Structure:
header.payload.signature

Header:
{
  "alg": "RS256",
  "typ": "JWT"
}

Payload:
{
  "sub": "user-123",
  "iss": "auth-service",
  "exp": 1625097600,
  "iat": 1625094000,
  "scope": ["read:orders", "write:orders"]
}

Signature:
RSASHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  private_key
)
```

**Authentication Flow:**
```
1. User ──login credentials──► Auth Service
2. Auth Service validates credentials
3. Auth Service ──JWT token──► User
4. User ──request + JWT──► API Gateway
5. API Gateway validates JWT signature
6. API Gateway ──request + user context──► Service
```

**Token Validation:**
```javascript
const jwt = require('jsonwebtoken');

function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    const payload = jwt.verify(token, process.env.JWT_PUBLIC_KEY, {
      algorithms: ['RS256'],
      issuer: 'auth-service',
      maxAge: '1h'
    });
    
    req.user = {
      id: payload.sub,
      scope: payload.scope
    };
    
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid token' });
  }
}
```

### Authorization (RBAC & ABAC)

**Role-Based Access Control (RBAC):**
```
Users ──belong to──► Roles ──have──► Permissions

Examples:
User "john@company.com" 
├─ Role: "customer"
│  ├─ Permission: "read:own-orders"
│  └─ Permission: "create:orders"
└─ Role: "premium-customer"  
   ├─ Permission: "read:own-orders"
   ├─ Permission: "create:orders"
   └─ Permission: "access:priority-support"

User "admin@company.com"
└─ Role: "admin"
   ├─ Permission: "read:all-orders"
   ├─ Permission: "update:orders"
   └─ Permission: "delete:orders"
```

**Attribute-Based Access Control (ABAC):**
```javascript
// Policy: Users can read their own orders
function canReadOrder(user, order, context) {
  return user.id === order.userId || 
         user.role === 'admin' ||
         (user.role === 'support' && context.region === user.region);
}

// Policy: Orders can be cancelled within 24 hours
function canCancelOrder(user, order, context) {
  const hoursSinceCreated = (Date.now() - order.createdAt) / (1000 * 60 * 60);
  
  return (user.id === order.userId && hoursSinceCreated < 24) ||
         user.role === 'admin';
}
```

**Authorization in Services:**
```javascript
async function getOrder(req, res) {
  const orderId = req.params.id;
  const user = req.user; // From JWT
  
  try {
    const order = await orderService.findById(orderId);
    
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    
    // Check authorization
    if (!canReadOrder(user, order)) {
      return res.status(403).json({ error: 'Access denied' });
    }
    
    res.json(order);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
}

function canReadOrder(user, order) {
  // User can read their own orders
  if (user.id === order.userId) {
    return true;
  }
  
  // Admins can read all orders
  if (user.scope && user.scope.includes('admin:read:orders')) {
    return true;
  }
  
  return false;
}
```

### Service-to-Service Security

**Mutual TLS (mTLS):**
```
Service A ◄──── mTLS ────► Service B
    │                        │
    ├─ Client Certificate    ├─ Server Certificate
    ├─ Private Key          ├─ Private Key  
    └─ Trusted CA           └─ Trusted CA

Both services authenticate each other
```

**Service Tokens:**
```javascript
// Service A calls Service B
async function callServiceB(data) {
  const serviceToken = await getServiceToken('service-a', 'service-b');
  
  const response = await fetch('https://service-b/api/data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${serviceToken}`,
      'X-Service-ID': 'service-a'
    },
    body: JSON.stringify(data)
  });
  
  return response.json();
}

// Service B validates service token
function validateServiceToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  const serviceId = req.headers['x-service-id'];
  
  if (!isValidServiceToken(token, serviceId)) {
    return res.status(403).json({ error: 'Invalid service token' });
  }
  
  req.callingService = serviceId;
  next();
}
```

**API Keys for External Services:**
```javascript
// Different API keys for different clients
const apiKeys = {
  'mobile-app': {
    key: 'ak_mobile_12345',
    permissions: ['read:products', 'create:orders'],
    rateLimit: 1000 // requests per hour
  },
  'partner-integration': {
    key: 'ak_partner_67890', 
    permissions: ['read:orders', 'update:orders'],
    rateLimit: 10000
  }
};

function validateApiKey(req, res, next) {
  const apiKey = req.headers['x-api-key'];
  
  const client = Object.values(apiKeys).find(c => c.key === apiKey);
  
  if (!client) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  req.client = client;
  next();
}

function checkPermissions(permission) {
  return (req, res, next) => {
    if (!req.client.permissions.includes(permission)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
}

// Usage
app.get('/orders', 
  validateApiKey, 
  checkPermissions('read:orders'), 
  getOrders
);
```

### Data Security

**Encryption at Rest:**
```
Database Level Encryption:
┌─────────────────────────────────┐
│           Database              │
│ ┌─────────────────────────────┐ │
│ │ users_table                 │ │
│ │ ┌─────────────────────────┐ │ │
│ │ │ id: 123                 │ │ │
│ │ │ email: encrypted_blob_1 │ │ │ ◄── AES-256 encrypted
│ │ │ phone: encrypted_blob_2 │ │ │
│ │ └─────────────────────────┘ │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘

Application Level Encryption:
const crypto = require('crypto');

function encryptPII(data, key) {
  const cipher = crypto.createCipher('aes-256-gcm', key);
  let encrypted = cipher.update(data, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

function decryptPII(encryptedData, key) {
  const decipher = crypto.createDecipher('aes-256-gcm', key);
  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}
```

**Encryption in Transit:**
```
All communication must use TLS 1.3:

HTTP ──► HTTPS (TLS 1.3)
Database connections ──► TLS/SSL
Message queues ──► TLS
Service mesh ──► mTLS

Configuration:
server {
  listen 443 ssl http2;
  ssl_certificate /path/to/cert.pem;
  ssl_certificate_key /path/to/key.pem;
  ssl_protocols TLSv1.3;
  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
}
```

**Secrets Management:**
```
❌ Плохо - secrets в коде:
const config = {
  dbPassword: 'super-secret-password',
  apiKey: 'sk-1234567890abcdef'
};

❌ Плохо - secrets в environment variables:
DATABASE_PASSWORD=super-secret-password
API_KEY=sk-1234567890abcdef

✅ Хорошо - secrets в Vault:
const vault = require('node-vault');

async function getSecrets() {
  const vaultClient = vault({
    endpoint: 'https://vault.company.com',
    token: process.env.VAULT_TOKEN
  });
  
  const dbSecret = await vaultClient.read('secret/database');
  const apiSecret = await vaultClient.read('secret/external-api');
  
  return {
    dbPassword: dbSecret.data.password,
    apiKey: apiSecret.data.key
  };
}
```

---

## Глава 9: DevOps и развертывание

### Containerization

**Dockerfile для микросервиса:**
```dockerfile
# Multi-stage build для уменьшения размера
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS runtime

# Создаем non-root пользователя для безопасности
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Копируем только необходимое
COPY --from=builder /app/node_modules ./node_modules
COPY --chown=nextjs:nodejs . .

USER nextjs

EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
```

**Container Best Practices:**
```
1. Минимальный размер образа:
   ✅ Use Alpine Linux (5MB) vs Ubuntu (70MB)
   ✅ Multi-stage builds
   ✅ .dockerignore file

2. Безопасность:
   ✅ Non-root user
   ✅ Read-only file system  
   ✅ No secrets in image
   ✅ Scan for vulnerabilities

3. Производительность:
   ✅ Layer caching
   ✅ Dependency pre-install
   ✅ Health checks
```

### Deployment Strategies

**Rolling Deployment:**
```
Step 1: Deploy to 1 instance
┌─────┐ ┌─────┐ ┌─────┐
│v1.0 │ │v2.0 │ │v1.0 │
└─────┘ └─────┘ └─────┘

Step 2: Deploy to 2nd instance  
┌─────┐ ┌─────┐ ┌─────┐
│v1.0 │ │v2.0 │ │v2.0 │
└─────┘ └─────┘ └─────┘

Step 3: Deploy to 3rd instance
┌─────┐ ┌─────┐ ┌─────┐
│v2.0 │ │v2.0 │ │v2.0 │
└─────┘ └─────┘ └─────┘

Pros: Zero downtime, gradual rollout
Cons: Mixed versions during deployment
```

**Blue-Green Deployment:**
```
Current (Blue):
┌─────┐ ┌─────┐ ┌─────┐
│v1.0 │ │v1.0 │ │v1.0 │ ◄── Production traffic
└─────┘ └─────┘ └─────┘

Prepare (Green):
┌─────┐ ┌─────┐ ┌─────┐  
│v2.0 │ │v2.0 │ │v2.0 │ ◄── Testing
└─────┘ └─────┘ └─────┘

Switch traffic:
┌─────┐ ┌─────┐ ┌─────┐
│v1.0 │ │v1.0 │ │v1.0 │ ◄── Standby
└─────┘ └─────┘ └─────┘

┌─────┐ ┌─────┐ ┌─────┐
│v2.0 │ │v2.0 │ │v2.0 │ ◄── Production traffic
└─────┘ └─────┘ └─────┘

Pros: Instant rollback, full testing
Cons: Double infrastructure cost
```

**Canary Deployment:**
```
Stage 1: 5% traffic to new version
┌─────────────┐     ┌─────┐
│    95%      │     │ 5% │
│    v1.0     │     │v2.0│
│             │     │    │
└─────────────┘     └─────┘

Stage 2: 50% traffic if metrics good
┌─────────┐     ┌─────────┐
│   50%   │     │   50%   │
│  v1.0   │     │  v2.0   │
│         │     │         │
└─────────┘     └─────────┘

Stage 3: 100% traffic if no issues
                ┌─────────────┐
                │    100%     │
                │    v2.0     │
                │             │
                └─────────────┘

Pros: Gradual risk mitigation, real user feedback
Cons: Complex traffic management
```

### CI/CD Pipeline

**Pipeline for Microservice:**
```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  Code   │───►│  Build  │───►│  Test   │───►│ Deploy  │
│ Commit  │    │         │    │         │    │         │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     │              │              │              │
     ▼              ▼              ▼              ▼
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│Git Push │    │Docker   │    │Unit     │    │Staging  │
│         │    │Build    │    │Tests    │    │Deploy   │
│Triggers │    │         │    │         │    │         │
│Pipeline │    │Lint     │    │Integration│    │Smoke    │
│         │    │         │    │Tests    │    │Tests    │
│         │    │Security │    │         │    │         │
│         │    │Scan     │    │Contract │    │Production│
│         │    │         │    │Tests    │    │Deploy   │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
```

**Pipeline Configuration (GitHub Actions):**
```yaml
name: Deploy Microservice

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run unit tests
        run: npm run test:unit
        
      - name: Run integration tests
        run: npm run test:integration
        
      - name: Security audit
        run: npm audit --audit-level=high

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.REGISTRY_URL }}/order-service:${{ github.sha }} .
          
      - name: Security scan
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image ${{ secrets.REGISTRY_URL }}/order-service:${{ github.sha }}
            
      - name: Push to registry
        run: |
          echo ${{ secrets.REGISTRY_TOKEN }} | docker login ${{ secrets.REGISTRY_URL }} -u ${{ secrets.REGISTRY_USER }} --password-stdin
          docker push ${{ secrets.REGISTRY_URL }}/order-service:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/order-service \
            order-service=${{ secrets.REGISTRY_URL }}/order-service:${{ github.sha }}
          kubectl rollout status deployment/order-service
```

### Infrastructure as Code

**Kubernetes Deployment:**
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  labels:
    app: order-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
      - name: order-service
        image: registry.company.com/order-service:latest
        ports:
        - containerPort: 3000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: order-service-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: order-service-config
              key: redis-url
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi" 
            cpu: "500m"

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: ClusterIP

---
# hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: order-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: order-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**Terraform for Infrastructure:**
```hcl
# main.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# EKS Cluster
module "eks" {
  source = "terraform-aws-modules/eks/aws"
  
  cluster_name    = "microservices-cluster"
  cluster_version = "1.28"
  
  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets
  
  node_groups = {
    main = {
      desired_capacity = 3
      max_capacity     = 10
      min_capacity     = 3
      
      instance_types = ["t3.medium"]
      
      k8s_labels = {
        Environment = var.environment
        Application = "microservices"
      }
    }
  }
}

# RDS for databases
resource "aws_db_instance" "microservices_db" {
  allocated_storage    = 100
  max_allocated_storage = 1000
  storage_type         = "gp2"
  engine              = "postgres"
  engine_version      = "15.4"
  instance_class      = "db.t3.micro"
  identifier          = "microservices-db"
  
  db_name  = "microservices"
  username = "admin"
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = true
  deletion_protection = false
  
  tags = {
    Name = "microservices-db"
    Environment = var.environment
  }
}

# ElastiCache for Redis
resource "aws_elasticache_cluster" "redis" {
  cluster_id           = "microservices-redis"
  engine              = "redis"
  node_type           = "cache.t3.micro"
  num_cache_nodes     = 1
  parameter_group_name = "default.redis7"
  port                = 6379
  subnet_group_name   = aws_elasticache_subnet_group.main.name
  security_group_ids  = [aws_security_group.elasticache.id]
  
  tags = {
    Name = "microservices-redis"
    Environment = var.environment
  }
}
```

### Monitoring и Alerting в Production

**Prometheus Configuration:**
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'order-service'
    static_configs:
      - targets: ['order-service:3000']
    metrics_path: /metrics
    scrape_interval: 30s
    
  - job_name: 'user-service'
    static_configs:
      - targets: ['user-service:3001']
    metrics_path: /metrics
    scrape_interval: 30s
    
  - job_name: 'payment-service'
    static_configs:
      - targets: ['payment-service:3002']
    metrics_path: /metrics
    scrape_interval: 30s

  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
```

**Alert Rules:**
```yaml
# alert_rules.yml
groups:
  - name: microservices.rules
    rules:
    # Service down
    - alert: ServiceDown
      expr: up == 0
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "Service {{ $labels.job }} is down"
        description: "{{ $labels.job }} has been down for more than 1 minute"
        runbook_url: "https://runbooks.company.com/service-down"
        
    # High error rate
    - alert: HighErrorRate
      expr: |
        (
          rate(http_requests_total{status=~"5.."}[5m]) /
          rate(http_requests_total[5m])
        ) * 100 > 5
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate for {{ $labels.job }}"
        description: "Error rate is {{ $value }}% for {{ $labels.job }}"
        
    # High response time
    - alert: HighResponseTime
      expr: |
        histogram_quantile(0.95, 
          rate(http_request_duration_seconds_bucket[5m])
        ) > 1
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "High response time for {{ $labels.job }}"
        description: "95th percentile response time is {{ $value }}s"
        
    # High memory usage
    - alert: HighMemoryUsage
      expr: |
        (
          process_resident_memory_bytes / 
          (1024 * 1024 * 1024)
        ) > 0.8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High memory usage for {{ $labels.job }}"
        description: "Memory usage is {{ $value }}GB"
```

---

## Глава 10: Миграция от монолита

### Стратегии миграции

**Big Bang vs Incremental:**
```
Big Bang (не рекомендуется):
┌─────────────┐           ┌──┐ ┌──┐ ┌──┐
│   Monolith  │ ────────► │S1│ │S2│ │S3│
└─────────────┘           └──┘ └──┘ └──┘
     
Одномоментная замена всего приложения

Incremental (рекомендуется):
┌─────────────┐    ┌─────────────┐    ┌──┐ ┌──┐ ┌──┐
│   Monolith  │───►│ Hybrid      │───►│S1│ │S2│ │S3│
└─────────────┘    │ Architecture│    └──┘ └──┘ └──┘
                   └─────────────┘
     
Постепенная миграция по частям
```

### Strangler Fig Pattern (детально)

**Этап 1: Анализ и планирование**
```
Монолит анализ:
┌─────────────────────────────────────────┐
│               E-SHOP                    │
│                                         │
│ ┌─────────────┐ ┌─────────────────────┐ │
│ │    Users    │ │      Products       │ │
│ │ • Register  │ │ • Catalog           │ │
│ │ • Login     │ │ • Search            │ │
│ │ • Profile   │ │ • Reviews           │ │
│ └─────────────┘ │ • Inventory         │ │
│                 └─────────────────────┘ │
│ ┌─────────────┐ ┌─────────────────────┐ │
│ │   Orders    │ │     Payments        │ │
│ │ • Cart      │ │ • Billing           │ │
│ │ • Checkout  │ │ • Refunds           │ │
│ │ • History   │ │ • Invoices          │ │
│ └─────────────┘ └─────────────────────┘ │
└─────────────────────────────────────────┘

Migration Priority:
1. Users (low risk, well-defined boundaries)
2. Products (high value, independent) 
3. Orders (complex, many dependencies)
4. Payments (critical, regulatory requirements)
```

**Этап 2: Proxy Layer**
```
┌─────────┐      ┌─────────────────┐      ┌─────────────────┐
│ Client  │ ────►│  Routing Proxy  │ ────►│    Monolith     │
└─────────┘      │                 │      │                 │
                 │ Rules:          │      │ ┌─────────────┐ │
                 │ /users/* ────────────► │ │Users Module │ │
                 │ /products/* ──────────►│ │Products Mod │ │
                 │ /orders/* ────────────►│ │Orders Module│ │
                 │ /payments/* ──────────►│ │Payments Mod │ │
                 └─────────────────┘      │ └─────────────┘ │
                                          └─────────────────┘
```

**Этап 3: Extract User Service**
```
┌─────────┐      ┌─────────────────┐      
│ Client  │ ────►│  Routing Proxy  │      
└─────────┘      │                 │      
                 │ Rules:          │      
                 │ /users/* ───────┼─────┐
                 │ /products/* ────┼───┐ │
                 │ /orders/* ──────┼─┐ │ │
                 │ /payments/* ────┼┐│ │ │
                 └─────────────────┘│││ │ │
                                   │││ │ │
                        ┌──────────▼││ │ │
                        │User Service││ │ │
                        │            ││ │ │
                        │┌──────────┐││ │ │
                        ││ User DB  │││ │ │
                        │└──────────┘││ │ │
                        └────────────┘│ │ │
                                      │ │ │
                        ┌─────────────▼─┴─▼─┐
                        │    Monolith      │
                        │ (remaining)      │
                        │ ┌─────────────┐  │
                        │ │Products Mod │  │
                        │ │Orders Module│  │
                        │ │Payments Mod │  │
                        │ └─────────────┘  │
                        └──────────────────┘
```

**Этап 4: Data Migration Strategies**

**Strategy 1: Database View (for reads)**
```javascript
// Создаем view в основной БД, который читает из User Service
CREATE VIEW users_view AS 
SELECT * FROM user_service_db.users;

// Монолит продолжает читать через view
const users = await db.query('SELECT * FROM users_view WHERE active = true');

// User Service пишет в свою БД
const newUser = await userDb.users.create(userData);
```

**Strategy 2: Dual Writes (временно)**
```javascript
// Временно пишем в обе БД
async function createUser(userData) {
  const transaction = await mainDb.beginTransaction();
  
  try {
    // Пишем в основную БД (для монолита)
    const legacyUser = await transaction.users.create(userData);
    
    // Пишем в новую БД (для User Service)  
    const newUser = await userServiceDb.users.create(userData);
    
    await transaction.commit();
    return newUser;
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
```

**Strategy 3: Event-Based Sync**
```javascript
// User Service публикует события
async function createUser(userData) {
  const user = await userDb.users.create(userData);
  
  // Публикуем событие для синхронизации
  await eventBus.publish('UserCreated', {
    userId: user.id,
    email: user.email,
    name: user.name,
    createdAt: user.createdAt
  });
  
  return user;
}

// Монолит слушает события и обновляет свою БД
eventBus.subscribe('UserCreated', async (event) => {
  await legacyDb.users.upsert({
    id: event.userId,
    email: event.email,
    name: event.name,
    created_at: event.createdAt,
    migrated: true
  });
});
```

### Incremental Data Migration

**Migration Timeline:**
```
Week 1-2: Setup Infrastructure
├── Deploy User Service (read-only mode)
├── Setup data replication
├── Implement dual reads
└── Test data consistency

Week 3-4: Gradual Write Migration  
├── 10% of writes go to User Service
├── Monitor data consistency
├── Fix any sync issues
└── Increase to 50% writes

Week 5-6: Full Write Migration
├── 100% writes go to User Service
├── Legacy database becomes read-only
├── Start deprecation of legacy reads
└── Monitor for issues

Week 7-8: Read Migration
├── 10% of reads from User Service
├── Monitor performance
├── Increase to 100% reads
└── Decommission legacy user tables
```

**Feature Toggles для миграции:**
```javascript
const FeatureFlags = {
  USER_SERVICE_WRITES: {
    enabled: true,
    percentage: 100  // 100% of writes go to new service
  },
  USER_SERVICE_READS: {
    enabled: true, 
    percentage: 50   // 50% of reads from new service
  },
  LEGACY_USER_CLEANUP: {
    enabled: false   // Not ready to cleanup legacy data
  }
};

async function getUser(userId) {
  if (FeatureFlags.USER_SERVICE_READS.enabled && 
      Math.random() * 100 < FeatureFlags.USER_SERVICE_READS.percentage) {
    // Read from new User Service
    return await userService.getUser(userId);
  } else {
    // Read from legacy database
    return await legacyDb.users.findById(userId);
  }
}

async function createUser(userData) {
  if (FeatureFlags.USER_SERVICE_WRITES.enabled &&
      Math.random() * 100 < FeatureFlags.USER_SERVICE_WRITES.percentage) {
    return await userService.createUser(userData);
  } else {
    return await legacyDb.users.create(userData);
  }
}
```

### Dealing with Shared Dependencies

**Problem: Shared Utilities**
```
Monolith structure:
├── users/
├── orders/
├── payments/
└── shared/
    ├── validation.js     ◄── Used by all modules
    ├── email.js         ◄── Used by all modules  
    ├── logging.js       ◄── Used by all modules
    └── crypto.js        ◄── Used by all modules
    
How to extract services without breaking shared code?
```

**Solution 1: Duplicate Code (initially)**
```
User Service:
├── src/
│   ├── controllers/
│   ├── services/
│   └── utils/
│       ├── validation.js  ◄── Copied from shared
│       ├── email.js       ◄── Copied from shared
│       └── logging.js     ◄── Copied from shared

Order Service:  
├── src/
│   ├── controllers/
│   ├── services/
│   └── utils/
│       ├── validation.js  ◄── Copied from shared
│       ├── email.js       ◄── Copied from shared  
│       └── logging.js     ◄── Copied from shared

Pros: Fast migration, no dependencies
Cons: Code duplication, maintenance overhead
```

**Solution 2: Shared Libraries (later)**
```
NPM Private Registry:
├── @company/validation@1.0.0
├── @company/email@1.0.0
├── @company/logging@1.0.0
└── @company/crypto@1.0.0

User Service package.json:
{
  "dependencies": {
    "@company/validation": "^1.0.0",
    "@company/email": "^1.0.0",
    "@company/logging": "^1.0.0"
  }
}

Order Service package.json:
{
  "dependencies": {
    "@company/validation": "^1.0.0", 
    "@company/email": "^1.0.0",
    "@company/logging": "^1.0.0"
  }
}

Pros: DRY principle, centralized updates
Cons: Dependency coupling, versioning complexity
```

**Solution 3: Extract as Services**
```
                    Shared Services
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│Email Service│    │ Log Service │    │Auth Service │
└─────────────┘    └─────────────┘    └─────────────┘
       ▲                   ▲                   ▲
       │                   │                   │
┌──────┼───────────────────┼───────────────────┼──────┐
│      │                   │                   │      │
│      ▼                   ▼                   ▼      │
│ ┌─────────┐         ┌─────────┐         ┌─────────┐ │
│ │  User   │         │ Order   │         │Payment  │ │
│ │ Service │         │ Service │         │ Service │ │
│ └─────────┘         └─────────┘         └─────────┘ │
└───────────────────────────────────────────────────────┘

Pros: Single responsibility, reusable
Cons: Network latency, more complex
```

### Testing Strategy during Migration

**Test Pyramid for Migration:**
```
                    ┌─────────────┐
                    │   E2E Tests │ ◄── Critical user flows
                    │    (few)    │
                    └─────────────┘
                  ┌─────────────────┐
                  │ Integration     │ ◄── Service boundaries
                  │ Tests (some)    │
                  └─────────────────┘
              ┌─────────────────────────┐
              │   Unit Tests (many)     │ ◄── Business logic
              └─────────────────────────┘
            ┌───────────────────────────────┐
            │ Shadow/Parallel Tests         │ ◄── Data consistency
            └───────────────────────────────┘
```

**Shadow Testing:**
```javascript
// During migration, run both old and new code
async function getUser(userId) {
  // Primary call (current implementation)
  const primaryResult = await legacyDb.users.findById(userId);
  
  // Shadow call (new implementation) - don't affect response
  if (FeatureFlags.SHADOW_USER_SERVICE) {
    setImmediate(async () => {
      try {
        const shadowResult = await userService.getUser(userId);
        
        // Compare results and log differences
        if (!deepEqual(primaryResult, shadowResult)) {
          logger.warn('Shadow test discrepancy', {
            userId,
            primary: primaryResult,
            shadow: shadowResult
          });
        }
      } catch (error) {
        logger.error('Shadow test failed', { userId, error });
      }
    });
  }
  
  return primaryResult;
}
```

**Contract Testing:**
```javascript
// User Service contract
const userServiceContract = {
  getUser: {
    request: {
      userId: 'string'
    },
    response: {
      id: 'string',
      email: 'string', 
      name: 'string',
      createdAt: 'date'
    }
  }
};

// Test that monolith expectations match service contract
describe('User Service Contract', () => {
  it('should return user data in expected format', async () => {
    const userId = 'test-user-123';
    const user = await userService.getUser(userId);
    
    expect(user).toMatchSchema(userServiceContract.getUser.response);
  });
  
  it('should handle missing users consistently', async () => {
    const response = await userService.getUser('non-existent');
    expect(response).toBeNull();
  });
});
```

---

## Глава 11: Продвинутые паттерны

### Event Sourcing (подробно)

**Traditional State vs Event Sourcing:**
```
Traditional CRUD:
User Table:
┌────┬─────────────┬─────────────────────┬─────────────┐
│ ID │    Name     │       Email         │   Status    │
├────┼─────────────┼─────────────────────┼─────────────┤
│ 123│ John Smith  │ john@new-email.com  │   Active    │
└────┴─────────────┴─────────────────────┴─────────────┘

Lost History: Кто изменил email? Когда? Почему?

Event Sourcing:
Events Stream:
┌────┬─────────────────┬─────────────────────────────────────┬─────────────┐
│ ID │   Event Type    │           Event Data                │ Timestamp   │
├────┼─────────────────┼─────────────────────────────────────┼─────────────┤
│ 1  │ UserCreated     │ {id:123, name:"John", email:"john@old.com"} │ 10:00:00    │
│ 2  │ EmailChanged    │ {id:123, newEmail:"john@new.com"}   │ 10:30:00    │
│ 3  │ NameChanged     │ {id:123, newName:"John Smith"}      │ 11:00:00    │
│ 4  │ UserActivated   │ {id:123, activatedBy:"admin"}       │ 11:15:00    │
└────┴─────────────────┴─────────────────────────────────────┴─────────────┘

Full History: Все изменения сохранены с контекстом
```

**Event Sourcing реализация:**
```javascript
// Event Store
class EventStore {
  constructor(database) {
    this.db = database;
  }
  
  async appendEvent(streamId, event) {
    const eventData = {
      streamId,
      eventType: event.type,
      eventData: JSON.stringify(event.data),
      eventVersion: await this.getNextVersion(streamId),
      timestamp: new Date()
    };
    
    return await this.db.events.create(eventData);
  }
  
  async getEvents(streamId, fromVersion = 0) {
    return await this.db.events.findAll({
      where: {
        streamId,
        eventVersion: { $gte: fromVersion }
      },
      order: [['eventVersion', 'ASC']]
    });
  }
}

// Aggregate Root
class User {
  constructor() {
    this.id = null;
    this.name = null;
    this.email = null;
    this.status = 'inactive';
    this.version = 0;
    this.uncommittedEvents = [];
  }
  
  // Command handlers
  static create(userId, name, email) {
    const user = new User();
    user.applyEvent({
      type: 'UserCreated',
      data: { userId, name, email }
    });
    return user;
  }
  
  changeEmail(newEmail) {
    if (this.email === newEmail) {
      throw new Error('Email is the same');
    }
    
    this.applyEvent({
      type: 'EmailChanged',
      data: { userId: this.id, newEmail }
    });
  }
  
  activate() {
    if (this.status === 'active') {
      throw new Error('User already active');
    }
    
    this.applyEvent({
      type: 'UserActivated',
      data: { userId: this.id }
    });
  }
  
  // Event application
  applyEvent(event) {
    // Apply to current state
    this.when(event);
    
    // Track for persistence
    this.uncommittedEvents.push(event);
    this.version++;
  }
  
  when(event) {
    switch (event.type) {
      case 'UserCreated':
        this.id = event.data.userId;
        this.name = event.data.name;
        this.email = event.data.email;
        break;
        
      case 'EmailChanged':
        this.email = event.data.newEmail;
        break;
        
      case 'UserActivated':
        this.status = 'active';
        break;
    }
  }
  
  // Restore from events
  static fromEvents(events) {
    const user = new User();
    events.forEach(event => user.when(event));
    user.version = events.length;
    return user;
  }
  
  getUncommittedEvents() {
    return this.uncommittedEvents;
  }
  
  markEventsAsCommitted() {
    this.uncommittedEvents = [];
  }
}

// Repository
class UserRepository {
  constructor(eventStore) {
    this.eventStore = eventStore;
  }
  
  async save(user) {
    const events = user.getUncommittedEvents();
    
    for (const event of events) {
      await this.eventStore.appendEvent(user.id, event);
    }
    
    user.markEventsAsCommitted();
  }
  
  async getById(userId) {
    const events = await this.eventStore.getEvents(userId);
    
    if (events.length === 0) {
      return null;
    }
    
    const eventObjects = events.map(e => ({
      type: e.eventType,
      data: JSON.parse(e.eventData)
    }));
    
    return User.fromEvents(eventObjects);
  }
}
```

**Event Sourcing преимущества и недостатки:**
```
✅ Преимущества:
• Полная история изменений (audit trail)
• Возможность восстановления любого состояния
• Temporal queries ("как выглядели данные вчера?")
• Natural fit для event-driven архитектуры
• Debugging и troubleshooting
• Analytics и ML на historical data

❌ Недостатки:
• Сложность запросов (нужны projections)
• Растущий размер данных
• Eventual consistency
• Сложность в изучении и поддержке
• Snapshot needed для производительности
```

### CQRS (Command Query Responsibility Segregation)

**Traditional Architecture:**
```
Controller ──► Service ──► Repository ──► Database
     │             │           │            │
     ├─ Read       ├─ Read     ├─ Read      ├─ Read
     └─ Write      └─ Write    └─ Write     └─ Write

Одна модель для чтения и записи
```

**CQRS Architecture:**
```
Commands (Write Side):          Queries (Read Side):
Controller ──► Command Handler   Controller ──► Query Handler
     │              │                │              │
     ▼              ▼                ▼              ▼
Write Model ──► Write Database   Read Model ──► Read Database
     │                              ▲               │
     └──────── Events ──────────────┘               ▼
                                            Optimized for reads
```

**CQRS реализация:**
```javascript
// Command Side
class CreateUserCommand {
  constructor(userId, name, email) {
    this.userId = userId;
    this.name = name;
    this.email = email;
  }
}

class ChangeEmailCommand {
  constructor(userId, newEmail) {
    this.userId = userId;
    this.newEmail = newEmail;
  }
}

// Command Handlers
class UserCommandHandler {
  constructor(userRepository, eventBus) {
    this.userRepository = userRepository;
    this.eventBus = eventBus;
  }
  
  async handle(command) {
    switch (command.constructor.name) {
      case 'CreateUserCommand':
        return await this.createUser(command);
      case 'ChangeEmailCommand':
        return await this.changeEmail(command);
    }
  }
  
  async createUser(command) {
    const user = User.create(command.userId, command.name, command.email);
    await this.userRepository.save(user);
    
    // Publish events for read side
    const events = user.getUncommittedEvents();
    for (const event of events) {
      await this.eventBus.publish(event);
    }
  }
  
  async changeEmail(command) {
    const user = await this.userRepository.getById(command.userId);
    user.changeEmail(command.newEmail);
    await this.userRepository.save(user);
    
    const events = user.getUncommittedEvents();
    for (const event of events) {
      await this.eventBus.publish(event);
    }
  }
}

// Query Side
class UserReadModel {
  constructor() {
    this.id = null;
    this.name = null;
    this.email = null;
    this.status = null;
    this.createdAt = null;
    this.lastModified = null;
    this.totalOrders = 0;
    this.totalSpent = 0;
  }
}

class UserQueryHandler {
  constructor(readDatabase) {
    this.readDb = readDatabase;
  }
  
  async getUserById(userId) {
    return await this.readDb.users.findById(userId);
  }
  
  async getUsersByStatus(status) {
    return await this.readDb.users.findAll({
      where: { status },
      order: [['lastModified', 'DESC']]
    });
  }
  
  async getUsersWithHighSpending(minAmount) {
    return await this.readDb.users.findAll({
      where: { totalSpent: { $gte: minAmount } },
      order: [['totalSpent', 'DESC']]
    });
  }
}

// Event Handlers для обновления Read Model
class UserReadModelUpdater {
  constructor(readDatabase) {
    this.readDb = readDatabase;
  }
  
  async on(event) {
    switch (event.type) {
      case 'UserCreated':
        await this.createUserReadModel(event);
        break;
      case 'EmailChanged':
        await this.updateUserEmail(event);
        break;
      case 'UserActivated':
        await this.updateUserStatus(event);
        break;
    }
  }
  
  async createUserReadModel(event) {
    await this.readDb.users.create({
      id: event.data.userId,
      name: event.data.name,
      email: event.data.email,
      status: 'inactive',
      createdAt: new Date(),
      lastModified: new Date(),
      totalOrders: 0,
      totalSpent: 0
    });
  }
  
  async updateUserEmail(event) {
    await this.readDb.users.update(
      { 
        email: event.data.newEmail,
        lastModified: new Date()
      },
      { where: { id: event.data.userId } }
    );
  }
  
  async updateUserStatus(event) {
    await this.readDb.users.update(
      { 
        status: 'active',
        lastModified: new Date()
      },
      { where: { id: event.data.userId } }
    );
  }
}
```

**Multiple Read Models:**
```
Single Write Model → Multiple Read Models для разных use cases

Write Model:               Read Models:
┌─────────────┐           ┌─────────────────┐
│    User     │ ─events─► │ User Summary    │ ◄── For user list
│ Aggregate   │           │ • id, name,     │
└─────────────┘           │   email, status │
                          └─────────────────┘
                          ┌─────────────────┐
                          │ User Analytics  │ ◄── For reports
                          │ • id, orders,   │
                          │   revenue, etc  │
                          └─────────────────┘
                          ┌─────────────────┐
                          │ User Search     │ ◄── For search
                          │ • indexed text  │
                          │ • elasticsearch │
                          └─────────────────┘
```

### Distributed Data Management Patterns

**Shared Data Anti-Pattern:**
```
❌ НЕ делайте так:
Service A ──┐
            ├──► Shared Database
Service B ──┘
            
Problems:
• Tight coupling через schema
• Нарушение service autonomy
• Bottleneck при изменениях schema
• Сложно масштабировать
```

**Database per Service:**
```
✅ Правильно:
Service A ──► Database A
Service B ──► Database B
Service C ──► Database C

Benefits:
• Service autonomy
• Technology diversity
• Independent scaling
• Failure isolation
```

**Data Synchronization Patterns:**

**1. Shared Database View (read-only)**
```javascript
// Service A делает данные доступными через read-only view
CREATE VIEW public_users AS 
SELECT id, name, email, status 
FROM users 
WHERE status = 'active';

// Service B читает через view
const activeUsers = await database.query('SELECT * FROM public_users');
```

**2. Data Replication**
```javascript
// Master-Slave replication
Service A (Master) ──► Database A (Master)
                            │
                      Replication
                            ▼
Service B (Slave)  ──► Database A (Replica) ◄── Read-only
```

**3. Event-Driven Data Sync**
```javascript
// Service A публикует события об изменениях
class UserService {
  async updateUser(userId, userData) {
    const user = await this.userRepository.update(userId, userData);
    
    // Публикуем событие для других сервисов
    await this.eventBus.publish('UserUpdated', {
      userId: user.id,
      name: user.name,
      email: user.email,
      updatedAt: new Date()
    });
    
    return user;
  }
}

// Service B слушает и обновляет свою копию данных
class OrderService {
  constructor(eventBus) {
    eventBus.subscribe('UserUpdated', this.onUserUpdated.bind(this));
  }
  
  async onUserUpdated(event) {
    // Обновляем denormalized данные пользователя в заказах
    await this.orderRepository.updateUserInfo(
      event.userId,
      {
        userName: event.name,
        userEmail: event.email
      }
    );
  }
}
```

**4. API-Based Data Sharing**
```javascript
// Service B запрашивает данные у Service A через API
class OrderService {
  constructor(userServiceClient) {
    this.userServiceClient = userServiceClient;
  }
  
  async createOrder(orderData) {
    // Получаем актуальные данные пользователя
    const user = await this.userServiceClient.getUser(orderData.userId);
    
    if (!user || user.status !== 'active') {
      throw new Error('User not found or inactive');
    }
    
    const order = await this.orderRepository.create({
      ...orderData,
      userName: user.name,
      userEmail: user.email
    });
    
    return order;
  }
}
```

### Federated Data Queries

**Problem: Cross-Service Queries**
```
Query: "Найти все заказы активных пользователей за последний месяц"

Data location:
• Users → User Service Database
• Orders → Order Service Database  
• Status → Order Service Database

Traditional SQL:
SELECT o.* FROM orders o
JOIN users u ON o.user_id = u.id  
WHERE u.status = 'active' 
AND o.created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH)

Problem: данные в разных сервисах!
```

**Solution 1: API Composition**
```javascript
class OrderQueryService {
  constructor(userService, orderService) {
    this.userService = userService;
    this.orderService = orderService;
  }
  
  async getOrdersForActiveUsers(fromDate) {
    // Step 1: Get active users
    const activeUsers = await this.userService.getActiveUsers();
    const userIds = activeUsers.map(u => u.id);
    
    // Step 2: Get orders for these users
    const orders = await this.orderService.getOrdersByUsers(userIds, fromDate);
    
    // Step 3: Combine data
    return orders.map(order => ({
      ...order,
      user: activeUsers.find(u => u.id === order.userId)
    }));
  }
}
```

**Solution 2: CQRS Read Model**
```javascript
// Dedicated read model с denormalized данными
class OrderSummaryReadModel {
  // Содержит данные из User Service и Order Service
  schema: {
    orderId: String,
    userId: String,
    userName: String,     // ← from User Service
    userEmail: String,    // ← from User Service  
    userStatus: String,   // ← from User Service
    orderTotal: Number,   // ← from Order Service
    orderStatus: String,  // ← from Order Service
    createdAt: Date
  }
}

// Event handlers обновляют read model
class OrderSummaryUpdater {
  async onUserStatusChanged(event) {
    await this.readModel.updateMany(
      { userId: event.userId },
      { userStatus: event.newStatus }
    );
  }
  
  async onOrderCreated(event) {
    const user = await this.userService.getUser(event.userId);
    
    await this.readModel.create({
      orderId: event.orderId,
      userId: event.userId,
      userName: user.name,
      userEmail: user.email,
      userStatus: user.status,
      orderTotal: event.total,
      orderStatus: event.status,
      createdAt: event.createdAt
    });
  }
}

// Query становится простым
async function getOrdersForActiveUsers(fromDate) {
  return await orderSummaryReadModel.find({
    userStatus: 'active',
    createdAt: { $gte: fromDate }
  });
}
```

**Solution 3: GraphQL Federation**
```javascript
// User Service GraphQL Schema
const userTypeDefs = `
  type User {
    id: ID!
    name: String!
    email: String!
    status: String!
  }
  
  extend type Query {
    user(id: ID!): User
    activeUsers: [User!]!
  }
`;

// Order Service GraphQL Schema  
const orderTypeDefs = `
  type Order {
    id: ID!
    userId: ID!
    user: User! # Resolved by User Service
    total: Float!
    status: String!
    createdAt: String!
  }
  
  extend type Query {
    order(id: ID!): Order
    ordersByDateRange(from: String!, to: String!): [Order!]!
  }
`;

// Federated query
const query = `
  query GetOrdersForActiveUsers($fromDate: String!) {
    ordersByDateRange(from: $fromDate, to: "2025-07-01") {
      id
      total
      status
      createdAt
      user {
        id
        name
        status
      }
    }
  }
`;
```

---

## Глава 12: Performance и масштабирование

### Caching стратегии

**Cache Patterns:**

**1. Cache-Aside (Lazy Loading)**
```javascript
async function getUser(userId) {
  // 1. Check cache first
  let user = await cache.get(`user:${userId}`);
  
  if (user) {
    return JSON.parse(user); // Cache hit
  }
  
  // 2. Cache miss - load from database
  user = await database.users.findById(userId);
  
  if (user) {
    // 3. Store in cache
    await cache.set(`user:${userId}`, JSON.stringify(user), 3600); // 1 hour TTL
  }
  
  return user;
}

async function updateUser(userId, userData) {
  // 1. Update database
  const user = await database.users.update(userId, userData);
  
  // 2. Invalidate cache
  await cache.del(`user:${userId}`);
  
  return user;
}
```

**2. Write-Through Cache**
```javascript
async function updateUser(userId, userData) {
  // 1. Update database
  const user = await database.users.update(userId, userData);
  
  // 2. Update cache immediately
  await cache.set(`user:${userId}`, JSON.stringify(user), 3600);
  
  return user;
}
```

**3. Write-Behind Cache**
```javascript
class WriteBehindCache {
  constructor() {
    this.writeQueue = [];
    this.processing = false;
  }
  
  async updateUser(userId, userData) {
    // 1. Update cache immediately
    const user = { id: userId, ...userData, updatedAt: new Date() };
    await cache.set(`user:${userId}`, JSON.stringify(user), 3600);
    
    // 2. Queue database write
    this.writeQueue.push({ userId, userData, timestamp: Date.now() });
    
    // 3. Process queue async
    this.processWriteQueue();
    
    return user;
  }
  
  async processWriteQueue() {
    if (this.processing) return;
    this.processing = true;
    
    while (this.writeQueue.length > 0) {
      const batch = this.writeQueue.splice(0, 100); // Process in batches
      
      await Promise.all(
        batch.map(item => 
          database.users.update(item.userId, item.userData)
        )
      );
    }
    
    this.processing = false;
  }
}
```

**Cache Levels в микросервисах:**
```
Client ──► CDN ──► API Gateway ──► Service Cache ──► Database
  │         │          │              │              │
  │         │          │              │              │
Browser  Content   Gateway Cache   Redis/         PostgreSQL
Cache    Cache     (Rate limiting)  Memcached      
```

**Distributed Caching:**
```javascript
// Redis Cluster для horizontal scaling
const Redis = require('ioredis');

const cluster = new Redis.Cluster([
  { host: 'redis-node1', port: 6379 },
  { host: 'redis-node2', port: 6379 }, 
  { host: 'redis-node3', port: 6379 }
]);

// Consistent hashing автоматически распределяет ключи
await cluster.set('user:123', JSON.stringify(user));
const cachedUser = await cluster.get('user:123');
```

### Database Scaling Patterns

**Read Replicas:**
```
Write Operations:
Application ──► Master Database
                      │
                 Replication
                      ▼
Read Operations:       Replica 1
Application ──────► Replica 2
                   Replica 3

Benefits:
• Distributed read load
• Geographic distribution
• High availability
```

**Database Sharding:**
```
Horizontal Partitioning по user_id:

Shard 1 (user_id 1-1000):
┌─────────────────────────┐
│ Users: 1-1000          │
│ Orders: user_id 1-1000 │
└─────────────────────────┘

Shard 2 (user_id 1001-2000):
┌─────────────────────────┐
│ Users: 1001-2000       │
│ Orders: user_id 1001-2000│
└─────────────────────────┘

Shard 3 (user_id 2001-3000):
┌─────────────────────────┐
│ Users: 2001-3000       │
│ Orders: user_id 2001-3000│
└─────────────────────────┘
```

**Sharding реализация:**
```javascript
class ShardedDatabase {
  constructor(shards) {
    this.shards = shards; // [db1, db2, db3]
  }
  
  getShardForUser(userId) {
    const hash = this.hashFunction(userId);
    const shardIndex = hash % this.shards.length;
    return this.shards[shardIndex];
  }
  
  hashFunction(key) {
    // Simple hash function (use better one in production)
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = ((hash << 5) - hash + key.charCodeAt(i)) & 0xffffffff;
    }
    return Math.abs(hash);
  }
  
  async getUser(userId) {
    const shard = this.getShardForUser(userId);
    return await shard.users.findById(userId);
  }
  
  async createOrder(orderData) {
    const shard = this.getShardForUser(orderData.userId);
    return await shard.orders.create(orderData);
  }
  
  // Cross-shard queries are complex
  async getAllOrdersForUser(userId) {
    const shard = this.getShardForUser(userId);
    return await shard.orders.findAll({ where: { userId } });
  }
}
```

**CQRS для Query Scaling:**
```
Write Side (Normalized):           Read Side (Denormalized):
┌─────────────────────┐           ┌─────────────────────────┐
│ Users Table         │           │ Order Summary View      │
│ • id               │           │ • order_id             │
│ • name             │  ─events─► │ • user_name            │
│ • email            │           │ • user_email           │
└─────────────────────┘           │ • order_total          │
┌─────────────────────┐           │ • order_status         │
│ Orders Table        │           │ • created_at           │
│ • id               │           └─────────────────────────┘
│ • user_id          │           ┌─────────────────────────┐
│ • total            │           │ User Stats View        │
│ • status           │           │ • user_id              │
└─────────────────────┘           │ • total_orders         │
                                  │ • total_spent          │
                                  │ • last_order_date      │
                                  └─────────────────────────┘

Query Performance: O(1) vs O(n) joins
```

### Service Mesh и Performance

**Without Service Mesh:**
```
Service A ──HTTP──► Service B
    │                   │
    ├─ Retry logic      ├─ Auth logic
    ├─ Circuit breaker  ├─ Metrics
    ├─ Load balancing   ├─ Tracing
    ├─ TLS             ├─ Logging
    └─ Monitoring      └─ Rate limiting

Each service implements cross-cutting concerns
```

**With Service Mesh (Istio, Linkerd):**
```
Service A ──► Sidecar Proxy ──mTLS──► Sidecar Proxy ──► Service B
              (Envoy)                  (Envoy)
                 │                        │
                 ▼                        ▼
            Control Plane          Control Plane
            • Config               • Config
            • Metrics              • Metrics  
            • Policies             • Policies

Cross-cutting concerns handled by infrastructure
```

**Service Mesh Benefits:**
```
✅ Performance Benefits:
• Automatic load balancing
• Connection pooling
• Retries and circuit breaking
• Traffic splitting (canary deployments)
• Intelligent routing

✅ Observability:
• Automatic metrics collection
• Distributed tracing
• Traffic flow visualization

✅ Security:
• Automatic mTLS
• Policy enforcement
• Zero-trust networking
```

### Async Processing для Performance

**Background Jobs:**
```javascript
// Immediate response to user
app.post('/orders', async (req, res) => {
  const order = await orderService.createOrder(req.body);
  
  // Queue expensive operations
  await jobQueue.add('process-payment', { orderId: order.id });
  await jobQueue.add('update-inventory', { orderId: order.id });
  await jobQueue.add('send-confirmation', { orderId: order.id });
  
  // Return immediately
  res.json({ orderId: order.id, status: 'processing' });
});

// Background workers
const processPaymentWorker = async (job) => {
  const { orderId } = job.data;
  
  try {
    const payment = await paymentService.processPayment(orderId);
    await orderService.updatePaymentStatus(orderId, payment.status);
    
    if (payment.status === 'completed') {
      await jobQueue.add('fulfill-order', { orderId });
    }
  } catch (error) {
    // Retry or move to failed queue
    throw error;
  }
};

jobQueue.process('process-payment', processPaymentWorker);
```

**Event Streaming для Real-time Performance:**
```javascript
// Kafka для high-throughput event streaming
const kafka = require('kafkajs');

const client = kafka({
  clientId: 'order-service',
  brokers: ['kafka1:9092', 'kafka2:9092', 'kafka3:9092']
});

const producer = client.producer();

// Publish events asynchronously
async function createOrder(orderData) {
  const order = await orderRepository.create(orderData);
  
  // Fire-and-forget event publishing
  producer.send({
    topic: 'order-events',
    messages: [{
      key: order.id,
      value: JSON.stringify({
        eventType: 'OrderCreated',
        orderId: order.id,
        userId: order.userId,
        total: order.total,
        timestamp: new Date()
      })
    }]
  });
  
  return order;
}

// Multiple consumers process events in parallel
const consumer = client.consumer({ groupId: 'inventory-service' });

await consumer.subscribe({ topic: 'order-events' });

await consumer.run({
  eachMessage: async ({ message }) => {
    const event = JSON.parse(message.value.toString());
    
    if (event.eventType === 'OrderCreated') {
      await inventoryService.reserveItems(event.orderId);
    }
  }
});
```

---

## Глава 13: Организационные аспекты

### Conway's Law в действии

**Conway's Law:**
> "Organizations design systems that mirror their own communication structure"

**Пример влияния на архитектуру:**

**Traditional Organization:**
```
┌─────────────────────────────────────┐
│            CTO                      │
└─────────────┬───────────────────────┘
              │
    ┌─────────┼─────────┐
    │         │         │
    ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│Frontend │ │Backend  │ │   DBA   │
│  Team   │ │  Team   │ │  Team   │
└─────────┘ └─────────┘ └─────────┘

Resulting Architecture:
┌─────────────┐
│  Frontend   │
└─────┬───────┘
      │ API calls
      ▼
┌─────────────┐
│   Backend   │ ◄── Monolithic layer
└─────┬───────┘
      │ SQL
      ▼  
┌─────────────┐
│  Database   │ ◄── Single shared DB
└─────────────┘
```

**Microservices Organization:**
```
                    CTO
                     │
        ┌────────────┼────────────┐
        │            │            │
        ▼            ▼            ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   Team A    │ │   Team B    │ │   Team C    │
│ (Product)   │ │ (Order)     │ │ (User)      │
│             │ │             │ │             │
│ • Frontend  │ │ • Frontend  │ │ • Frontend  │
│ • Backend   │ │ • Backend   │ │ • Backend   │
│ • Database  │ │ • Database  │ │ • Database  │
│ • DevOps    │ │ • DevOps    │ │ • DevOps    │
└─────────────┘ └─────────────┘ └─────────────┘

Resulting Architecture:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Product     │    │ Order       │    │ User        │
│ Service     │◄──►│ Service     │◄──►│ Service     │
└─────────────┘    └─────────────┘    └─────────────┘
```

### Team Topologies

**Stream-Aligned Teams:**
```
Team Mission: End-to-end delivery of business value

Team Composition:
├── Product Owner (business domain expert)
├── Tech Lead (architecture decisions)
├── Backend Developers (2-3)
├── Frontend Developer (1)
├── DevOps Engineer (shared or embedded)
└── QA Engineer (embedded testing)

Responsibilities:
• Full product feature lifecycle
• Service ownership (build, run, maintain)
• Customer feedback loop
• Performance and reliability

Example: "Shopping Cart Team"
┌─────────────────────────────────────┐
│ Shopping Cart Team                  │
│                                     │
│ ┌─────────────────────────────────┐ │
│ │ Services Owned:                 │ │
│ │ • Cart Service                  │ │
│ │ • Wishlist Service              │ │
│ │ • Recommendation Service        │ │
│ └─────────────────────────────────┘ │
│                                     │
│ ┌─────────────────────────────────┐ │
│ │ Business Metrics:               │ │
│ │ • Cart abandonment rate         │ │
│ │ • Add-to-cart conversion        │ │
│ │ • Cross-sell effectiveness      │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

**Platform Teams:**
```
Mission: Enable stream-aligned teams to deliver faster

Platform as a Product:
┌─────────────────────────────────────┐
│ Platform Team                       │
│                                     │
│ Products:                           │
│ ┌─────────────────────────────────┐ │
│ │ • CI/CD Pipeline                │ │
│ │ • Container Registry            │ │
│ │ • Monitoring Stack              │ │
│ │ • Service Mesh                  │ │
│ │ • Database Templates            │ │
│ │ • Security Scanning             │ │
│ └─────────────────────────────────┘ │
│                                     │
│ SLA to Product Teams:               │
│ • 99.9% uptime for build pipeline  │
│ • < 30 min to provision new service│
│ • 24/7 support for critical issues │
└─────────────────────────────────────┘
```

**Enabling Teams:**
```
Mission: Build capabilities in other teams

Temporary Engagement Model:
Week 1-2: Assessment
├── Understand team's current state
├── Identify capability gaps  
├── Design learning program
└── Set success metrics

Week 3-8: Embedded Learning
├── Pair programming
├── Architecture reviews
├── Code reviews
├── Knowledge transfer sessions
└── Hands-on workshops

Week 9-10: Graduation
├── Team demonstrates capability
├── Documentation handover
├── Support model defined
└── Success metrics reviewed

Example: "Microservices Enablement"
┌─────────────────────────────────────┐
│ Backend Team (monolith)             │
│                                     │
│ Current State:                      │
│ • Monolithic application            │
│ • Shared database                   │
│ • No containerization               │
│ • Manual deployments               │
│                                     │
│ Target State:                       │
│ • 3 extracted microservices         │
│ • Independent databases             │
│ • Kubernetes deployment             │
│ • Automated CI/CD                   │
└─────────────────────────────────────┘
```

### Cognitive Load Management

**Cognitive Load Types:**

**1. Intrinsic Load (domain complexity)**
```
Example: E-commerce Domain
┌─────────────────────────────────────┐
│ Essential Complexity:               │
│                                     │
│ • Product catalog management        │
│ • Inventory tracking                │
│ • Order processing workflow         │
│ • Payment processing rules          │
│ • Tax calculation logic             │
│ • Shipping cost calculation         │
│                                     │
│ Cannot be reduced - it's the        │
│ essential business complexity       │
└─────────────────────────────────────┘
```

**2. Extraneous Load (tooling complexity)**
```
Example: Development Environment
┌─────────────────────────────────────┐
│ Accidental Complexity:              │
│                                     │
│ • 15 different config files         │
│ • 3 different deployment methods    │
│ • 5 different testing frameworks    │
│ • 8 different monitoring tools      │
│ • Custom build scripts             │
│ • Multiple authentication systems  │
│                                     │
│ Can be reduced through              │
│ standardization and automation      │
└─────────────────────────────────────┘
```

**3. Germane Load (learning and pattern recognition)**
```
Example: Team Learning Investment
┌─────────────────────────────────────┐
│ Learning Investment:                │
│                                     │
│ • New programming language          │
│ • Architecture patterns             │
│ • Domain knowledge                  │
│ • Team collaboration skills         │
│                                     │
│ Builds long-term capability         │
│ Should be managed carefully         │
└─────────────────────────────────────┘
```

**Reducing Cognitive Load:**

**Platform Standardization:**
```javascript
// Instead of each team figuring out deployment
// Platform team provides standard template

// Dockerfile template
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
HEALTHCHECK --interval=30s CMD curl -f http://localhost:3000/health
CMD ["npm", "start"]

// Kubernetes deployment template
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{SERVICE_NAME}}
spec:
  replicas: {{REPLICA_COUNT}}
  template:
    spec:
      containers:
      - name: {{SERVICE_NAME}}
        image: {{IMAGE_URL}}
        ports:
        - containerPort: 3000
        livenessProbe:
          httpGet:
            path: /health
            port: 3000

// Teams just fill in variables:
SERVICE_NAME=user-service
REPLICA_COUNT=3
IMAGE_URL=registry.company.com/user-service:v1.2.3
```

**Sensible Defaults:**
```yaml
# Platform provides pre-configured observability
# Teams get monitoring, logging, tracing out of the box

version: '3'
services:
  app:
    build: .
    environment:
      - METRICS_ENABLED=true
      - LOG_LEVEL=info
      - TRACING_ENABLED=true
      - HEALTH_CHECK_PATH=/health
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "fluentd:24224"
        tag: "{{.Name}}"

  # Automatically included sidecar containers
  metrics-exporter:
    image: prom/node-exporter
    
  jaeger-agent:
    image: jaegertracing/jaeger-agent
```

### Team Communication Patterns

**API-First Development:**
```
Traditional:
Team A ──► Implements feature
Team B ──► Waits for Team A
Team B ──► Integrates with Team A's code

API-First:
1. Teams agree on API contract
┌─────────────────────────────────────┐
│ User Service API Contract           │
│                                     │
│ GET /users/{id}                     │
│ Response: {                         │
│   id: string,                       │
│   name: string,                     │
│   email: string,                    │
│   status: "active" | "inactive"     │
│ }                                   │
└─────────────────────────────────────┘

2. Teams develop in parallel
Team A ──► Implements User Service
Team B ──► Uses mock/stub of API

3. Integration happens seamlessly
```

**Contract Testing:**
```javascript
// Consumer team defines expectations
describe('User Service Contract', () => {
  it('should return user data', async () => {
    const userResponse = await userService.getUser('123');
    
    expect(userResponse).toMatchSchema({
      type: 'object',
      properties: {
        id: { type: 'string' },
        name: { type: 'string' },
        email: { type: 'string', format: 'email' },
        status: { enum: ['active', 'inactive'] }
      },
      required: ['id', 'name', 'email', 'status']
    });
  });
});

// Provider team ensures they meet contract
describe('User Service Provider', () => {
  it('should meet consumer expectations', async () => {
    const user = await userRepository.findById('123');
    const response = formatUserResponse(user);
    
    // Contract test passes if schema matches
    expect(response).toMatchConsumerExpectations();
  });
});
```

**Documentation as Code:**
```yaml
# OpenAPI specification in version control
openapi: 3.0.0
info:
  title: User Service API
  version: 1.0.0
  description: |
    Manages user accounts and authentication
    
    ## Usage Examples
    
    ### Get user profile
    ```
    GET /users/123
    Authorization: Bearer {jwt_token}
    ```
    
    ### Update user profile  
    ```
    PUT /users/123
    Content-Type: application/json
    
    {
      "name": "John Smith",
      "email": "john@example.com"
    }
    ```
    
paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            example: "123"
      responses:
        200:
          description: User found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        404:
          description: User not found

components:
  schemas:
    User:
      type: object
      required: [id, name, email, status]
      properties:
        id:
          type: string
          example: "123"
        name:
          type: string
          example: "John Smith"
        email:
          type: string
          format: email
          example: "john@example.com"
        status:
          type: string
          enum: [active, inactive]
          example: "active"
```

---

## 🏆 Финальная дорожная карта эксперта

### Уровень 1: Новичок (1-2 месяца)
```
Цель: Понимание основ микросервисной архитектуры

✅ Теоретическая база:
□ Проблемы монолитных приложений
□ Основные принципы микросервисов  
□ Паттерны межсервисного взаимодействия
□ REST API design
□ Базовое понимание Docker

✅ Практические навыки:
□ Создание простого микросервиса
□ HTTP API между сервисами
□ Базовое логирование
□ Простое развертывание

✅ Проект:
Создать 2-3 простых сервиса (Users, Products, Orders)
с REST API и базовым взаимодействием
```

### Уровень 2: Практик (2-4 месяца)
```
Цель: Применение ключевых паттернов

✅ Архитектурные паттерны:
□ API Gateway implementation
□ Service Discovery (Consul/Eureka)
□ Circuit Breaker pattern
□ Retry and timeout strategies
□ Health checks

✅ Data Management:
□ Database per service
□ Event-driven architecture basics
□ Eventual consistency
□ Simple Saga pattern

✅ Observability:
□ Centralized logging (ELK)
□ Metrics collection (Prometheus)
□ Distributed tracing basics
□ Correlation IDs

✅ Проект:
E-commerce система с 5-7 сервисами,
API Gateway, мониторингом и событийной архитектурой
```

### Уровень 3: Архитектор (4-6 месяцев)
```
Цель: Проектирование сложных систем

✅ Advanced Patterns:
□ CQRS implementation
□ Event Sourcing
□ Sophisticated Saga orchestration
□ Advanced caching strategies
□ Database sharding

✅ Security:
□ JWT и OAuth 2.0
□ Service-to-service authentication
□ mTLS implementation
□ Zero Trust principles

✅ Performance:
□ Service mesh (Istio/Linkerd)
□ Advanced caching patterns
□ Database optimization
□ Async processing

✅ Migration:
□ Strangler Fig pattern
□ Legacy system integration
□ Data migration strategies
□ Feature toggles

✅ Проект:
Миграция существующего монолита в микросервисы
с сохранением производительности и надежности
```

### Уровень 4: Эксперт (6+ месяцев)
```
Цель: Организационное и техническое лидерство

✅ Organizational Design:
□ Conway's Law application
□ Team Topologies
□ Cognitive load management
□ Platform team strategy

✅ Advanced Architecture:
□ Multi-region deployments
□ Cross-cutting concerns design
□ Technology diversity management
□ Evolutionary architecture

✅ Business Alignment:
□ Domain-Driven Design mastery
□ Strategic vs tactical patterns
□ Cost optimization
□ Risk management

✅ Leadership Skills:
□ Architecture decision records
□ Technical strategy
□ Team enablement
□ Knowledge sharing

✅ Проект:
Разработка enterprise-уровня платформы микросервисов
для организации с многими командами
```

---

## 📋 Заключение и рекомендации

### Когда использовать микросервисы

**✅ Микросервисы подходят когда:**
```
Organizational:
• Команда больше 10-15 человек
• Несколько продуктовых команд
• Разные скорости разработки функций
• Необходимость независимых релизов

Technical:
• Разные требования к масштабированию
• Разные технологические стеки
• Сложная бизнес-логика с четкими границами
• Высокие требования к отказоустойчивости

Business:
• Быстрорастущий продукт
• Множественные интеграции
• Разные SLA для разных функций
• Необходимость экспериментов
```

**❌ Микросервисы НЕ подходят когда:**
```
Organizational:
• Команда меньше 5-8 человек
• Отсутствие DevOps культуры
• Нет опыта с распределенными системами
• Ограниченные ресурсы на инфраструктуру

Technical:
• Простая CRUD-логика
• Тесно связанная функциональность
• Низкие требования к производительности
• Монолит работает хорошо

Business:
• MVP или proof of concept
• Неопределенные требования
• Ограниченный бюджет
• Короткие сроки выхода на рынок
```

### Ключевые принципы успеха

**1. Start Small, Think Big**
```
• Начинайте с 2-3 сервисов
• Изучайте паттерны на простых примерах
• Постепенно добавляйте сложность
• Инвестируйте в автоматизацию с самого начала
```

**2. Automate Everything**
```
• CI/CD pipeline для каждого сервиса
• Автоматизированное тестирование
• Infrastructure as Code
• Автоматизированный мониторинг и алерты
```

**3. Monitor and Measure**
```
• Мониторинг business metrics
• Observability (logs, metrics, traces)
• SLA и SLO для каждого сервиса
• Постоянное измерение и улучшение
```

**4. Embrace Failure**
```
• Проектируйте для failure scenarios
• Chaos engineering
• Circuit breakers и retries
• Graceful degradation
```

**5. Foster Team Autonomy**
```
• Teams own services end-to-end
• Clear service boundaries
• API-first development
• Platform teams enable product teams
```

### Эволюция вашего пути

**Этап 1: Обучение (0-6 месяцев)**
- Изучение теории и основных паттернов
- Создание pet projects
- Участие в opensource проектах
- Чтение книг и статей

**Этап 2: Применение (6-18 месяцев)**
- Работа с микросервисами в реальных проектах
- Изучение production challenges
- Внедрение best practices
- Наставничество младших разработчиков

**Этап 3: Архитектура (1.5-3 года)**
- Проектирование систем с нуля
- Миграция legacy систем
- Техническое лидерство
- Стратегические архитектурные решения

**Этап 4: Экспертиза (3+ года)**
- Организационное влияние
- Разработка платформ и стандартов
- Конференции и публикации
- Консультирование и менторство

---

**Помните:** Микросервисы - это инструмент для решения определенных проблем, а не серебряная пуля. Главное - понимать, когда их применять и как делать это правильно.

**Удачи в изучении микросервисной архитектуры! 🚀**