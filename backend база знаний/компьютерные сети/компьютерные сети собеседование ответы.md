# Backend Developer: Network Engineering - –†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–µ –æ—Ç–≤–µ—Ç—ã
*–ü–æ–ª–Ω—ã–π —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –∫–æ–¥–∞ –∏ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ —Ä–µ—à–µ–Ω–∏—è–º–∏*

---

## 1. üåê –û—Å–Ω–æ–≤—ã —Å–µ—Ç–µ–π –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤

### TCP/IP Stack –≤ –¥–µ–π—Å—Ç–≤–∏–∏

**–í–æ–ø—Ä–æ—Å:** –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –∫–æ–≥–¥–∞ –≤–∞—à backend —Å–µ—Ä–≤–∏—Å –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç HTTP –∑–∞–ø—Ä–æ—Å –∫ –≤–Ω–µ—à–Ω–µ–º—É API?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

–ö–æ–≥–¥–∞ backend –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç HTTP –∑–∞–ø—Ä–æ—Å, –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å–ª–µ–¥—É—é—â–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å:

1. **Application Layer (HTTP)** - —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è HTTP –∑–∞–ø—Ä–æ—Å —Å headers
2. **Transport Layer (TCP)** - –¥–∞–Ω–Ω—ã–µ —Ä–∞–∑–±–∏–≤–∞—é—Ç—Å—è –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç—ã, –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è TCP headers
3. **Network Layer (IP)** - –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è IP header —Å –∞–¥—Ä–µ—Å–∞–º–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
4. **Data Link Layer** - –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è Ethernet header —Å MAC –∞–¥—Ä–µ—Å–∞–º–∏
5. **Physical Layer** - –ø–µ—Ä–µ–¥–∞—á–∞ –±–∏—Ç–æ–≤ –ø–æ —Å–µ—Ç–∏

**–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä HTTP –∫–ª–∏–µ–Ω—Ç–∞ —Å connection pooling:**

```javascript
// Node.js HTTP client —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
const http = require('http');
const https = require('https');

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ connection pooling
const httpAgent = new http.Agent({
  keepAlive: true,
  maxSockets: 50,        // –º–∞–∫—Å–∏–º—É–º 50 —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –Ω–∞ —Ö–æ—Å—Ç
  maxFreeSockets: 10,    // –¥–µ—Ä–∂–∞—Ç—å 10 —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
  timeout: 60000,        // —Ç–∞–π–º–∞—É—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  keepAliveMsecs: 30000  // keep-alive –∏–Ω—Ç–µ—Ä–≤–∞–ª
});

const httpsAgent = new https.Agent({
  keepAlive: true,
  maxSockets: 50,
  maxFreeSockets: 10,
  timeout: 60000,
  keepAliveMsecs: 30000
});

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
const options = {
  hostname: 'api.example.com',
  port: 443,
  path: '/users',
  method: 'GET',
  agent: httpsAgent,
  headers: {
    'Connection': 'keep-alive',
    'User-Agent': 'MyBackendService/1.0'
  }
};
```

**–ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:**
- **Keep-Alive** –∏–∑–±–µ–≥–∞–µ—Ç overhead —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö TCP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
- **Connection pooling** –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
- **–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ timeouts** –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç –∑–∞–≤–∏—Å–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤

---

### TCP vs UDP –≤ —Ä–µ–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö

**–í–æ–ø—Ä–æ—Å:** –ö–æ–≥–¥–∞ –≤—ã–±—Ä–∞—Ç—å UDP –¥–ª—è backend —Å–µ—Ä–≤–∏—Å–∞?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

UDP –ø–æ–¥—Ö–æ–¥–∏—Ç –∫–æ–≥–¥–∞:
- **–°–∫–æ—Ä–æ—Å—Ç—å –≤–∞–∂–Ω–µ–µ –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏** (real-time –∏–≥—Ä—ã, –≤–∏–¥–µ–æ —Å—Ç—Ä–∏–º–∏–Ω–≥)
- **–ù–µ–±–æ–ª—å—à–∏–µ –∑–∞–ø—Ä–æ—Å—ã** (DNS queries, –º–µ—Ç—Ä–∏–∫–∏)
- **Multicast/broadcast** –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è
- **–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏** –ø–æ–≤–µ—Ä—Ö UDP

**–ü—Ä–∏–º–µ—Ä: UDP —Å–µ—Ä–≤–µ—Ä –¥–ª—è –º–µ—Ç—Ä–∏–∫**

```go
// Go UDP server –¥–ª—è –ø—Ä–∏–µ–º–∞ –º–µ—Ç—Ä–∏–∫
package main

import (
    "net"
    "fmt"
    "time"
)

type MetricsServer struct {
    conn   *net.UDPConn
    buffer []byte
}

func NewMetricsServer(port int) (*MetricsServer, error) {
    addr, err := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", port))
    if err != nil {
        return nil, err
    }
    
    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        return nil, err
    }
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –±—É—Ñ–µ—Ä –¥–ª—è high-throughput
    conn.SetReadBuffer(1024 * 1024) // 1MB buffer
    
    return &MetricsServer{
        conn:   conn,
        buffer: make([]byte, 1024),
    }, nil
}

func (s *MetricsServer) Start() {
    for {
        // UDP –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –¥–æ—Å—Ç–∞–≤–∫—É, –Ω–æ —ç—Ç–æ OK –¥–ª—è –º–µ—Ç—Ä–∏–∫
        n, clientAddr, err := s.conn.ReadFromUDP(s.buffer)
        if err != nil {
            continue // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É
        }
        
        go s.processMetric(s.buffer[:n], clientAddr)
    }
}

func (s *MetricsServer) processMetric(data []byte, addr *net.UDPAddr) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ—Ç—Ä–∏–∫–∏
    // –ü–æ—Ç–µ—Ä—è –ø–∞–∫–µ—Ç–æ–≤ –¥–æ–ø—É—Å—Ç–∏–º–∞ –¥–ª—è –º–µ—Ç—Ä–∏–∫
    fmt.Printf("Metric from %s: %s\n", addr, string(data))
}
```

**–ö–æ–≥–¥–∞ –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å UDP:**
- –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
- –§–∞–π–ª–æ–≤—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä—ã
- HTTP API (—Ö–æ—Ç—è HTTP/3 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç UDP —á–µ—Ä–µ–∑ QUIC)

---

### HTTP Evolution: 1.1 ‚Üí 2 ‚Üí 3

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã —Ä–µ—à–∞–µ—Ç HTTP/2 multiplexing? –ü–æ—á–µ–º—É HTTP/3 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç UDP?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**HTTP/1.1 –ø—Ä–æ–±–ª–µ–º—ã:**
- **Head-of-line blocking** - –æ–¥–∏–Ω –º–µ–¥–ª–µ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å –±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ
- **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ TCP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è** - overhead –Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
- **–¢–µ–∫—Å—Ç–æ–≤—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª** - –±–æ–ª—å—à–µ –±–∞–π—Ç –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏

**HTTP/2 —Ä–µ—à–µ–Ω–∏—è:**
- **Multiplexing** - –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ streams –≤ –æ–¥–Ω–æ–º TCP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
- **Binary framing** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö
- **Server push** - –ø—Ä–æ–∞–∫—Ç–∏–≤–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤

**–ü—Ä–∏–º–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ HTTP/2 –≤ Node.js:**

```javascript
// HTTP/2 server —Å server push
const http2 = require('http2');
const fs = require('fs');

const server = http2.createSecureServer({
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
});

server.on('stream', (stream, headers) => {
  if (headers[':path'] === '/api/dashboard') {
    // Server push –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
    stream.pushStream({ ':path': '/api/user' }, (err, pushStream) => {
      if (!err) {
        pushStream.respond({ ':status': 200 });
        pushStream.end(JSON.stringify({ user: 'data' }));
      }
    });
    
    stream.respond({ ':status': 200 });
    stream.end(JSON.stringify({ dashboard: 'data' }));
  }
});
```

**HTTP/3 –∏ QUIC:**
- **UDP –±–∞–∑–∏—Å** - –∏–∑–±–µ–≥–∞–µ—Ç TCP head-of-line blocking
- **Built-in encryption** - TLS –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω –≤ –ø—Ä–æ—Ç–æ–∫–æ–ª
- **Connection migration** - —Å–º–µ–Ω–∞ IP –±–µ–∑ —Ä–∞–∑—Ä—ã–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
- **0-RTT** - –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ

---

## 2. üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ TLS

### HTTPS –≤ Production

**–í–æ–ø—Ä–æ—Å:** –û–±—ä—è—Å–Ω–∏—Ç–µ TLS handshake. –ö–∞–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è latency?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**TLS 1.3 Handshake (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π):**
1. **Client Hello** - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ cipher suites, extensions
2. **Server Hello + Certificate + Server Finished** - –≤—ã–±—Ä–∞–Ω–Ω—ã–π cipher, —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç, –∫–ª—é—á–∏
3. **Client Finished** - –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞

**–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:**

```nginx
# Nginx –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ TLS
server {
    listen 443 ssl http2;
    
    # –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ cipher suites (TLS 1.3)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;
    
    # Session resumption –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets on;
    
    # OCSP stapling - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /path/to/ca-bundle.crt;
    
    # Preload HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
}
```

**–ö–ª—é—á–µ–≤—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:**
- **Session resumption** - –∏–∑–±–µ–≥–∞–µ—Ç –ø–æ–ª–Ω–æ–≥–æ handshake
- **OCSP stapling** - –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
- **TLS 1.3** - —Å–æ–∫—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ round-trips

---

## 3. ‚ö° Performance –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ

### Load Balancing —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

**–í–æ–ø—Ä–æ—Å:** L4 vs L7 load balancing. –ö–æ–≥–¥–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Layer 4 (Transport Layer):**
- –†–∞–±–æ—Ç–∞–µ—Ç —Å TCP/UDP –ø–∞–∫–µ—Ç–∞–º–∏
- –ë—ã—Å—Ç—Ä–µ–µ, –º–µ–Ω—å—à–µ overhead
- –ù–µ –º–æ–∂–µ—Ç –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å HTTP content

**Layer 7 (Application Layer):**
- –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç HTTP headers, URLs, cookies
- –ë–æ–ª–µ–µ –≥–∏–±–∫–æ–µ routing
- –ë–æ–ª—å—à–µ overhead

**–ü—Ä–∏–º–µ—Ä HAProxy –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ (L7):**

```bash
# HAProxy L7 load balancer —Å —É–º–Ω—ã–º routing
global
    maxconn 4096
    
defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms
    option httplog
    
# Frontend - –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∑–∞–ø—Ä–æ—Å—ã
frontend api_frontend
    bind *:80
    bind *:443 ssl crt /etc/ssl/certs/api.pem
    
    # Routing –ø–æ URL path
    acl is_api path_beg /api/
    acl is_admin path_beg /admin/
    acl is_static path_beg /static/
    
    # Geographic routing –ø–æ IP
    acl is_eu src 10.0.1.0/24
    acl is_us src 10.0.2.0/24
    
    use_backend api_servers if is_api
    use_backend admin_servers if is_admin
    use_backend static_servers if is_static
    
# Backend pools —Å health checks
backend api_servers
    balance roundrobin
    option httpchk GET /health
    
    server api1 10.0.1.10:8080 check inter 2000ms
    server api2 10.0.1.11:8080 check inter 2000ms
    server api3 10.0.1.12:8080 check inter 2000ms

backend admin_servers
    balance source  # sticky sessions –¥–ª—è –∞–¥–º–∏–Ω–∫–∏
    server admin1 10.0.1.20:8080 check
    server admin2 10.0.1.21:8080 check
```

**–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å L4:**
- –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–Ω–∞
- Simple TCP/UDP load balancing
- –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è latency

**–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å L7:**
- –ù—É–∂–µ–Ω content-based routing
- SSL termination
- Advanced health checks

---

### Connection Management

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç connection pooling? –ö–∞–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

Connection pooling –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ—Ç TCP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è overhead —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π.

**–ü—Ä–∏–º–µ—Ä Database Connection Pool:**

```python
# Python database connection pool
import psycopg2.pool
import threading
from contextlib import contextmanager

class DatabasePool:
    def __init__(self, min_conn=5, max_conn=20):
        self.pool = psycopg2.pool.ThreadedConnectionPool(
            min_conn,
            max_conn,
            host="localhost",
            database="mydb",
            user="user",
            password="password",
            # –í–∞–∂–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è production
            connect_timeout=10,
            application_name="backend_service"
        )
        self.lock = threading.Lock()
    
    @contextmanager
    def get_connection(self):
        conn = None
        try:
            with self.lock:
                conn = self.pool.getconn()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞ stale connections
            if conn.closed:
                self.pool.putconn(conn, close=True)
                conn = self.pool.getconn()
            
            yield conn
            
        except Exception as e:
            if conn:
                # –ü—Ä–∏ –æ—à–∏–±–∫–µ - –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                self.pool.putconn(conn, close=True)
            raise
        finally:
            if conn and not conn.closed:
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–¥–æ—Ä–æ–≤–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≤ –ø—É–ª
                self.pool.putconn(conn)
    
    def execute_query(self, query, params=None):
        with self.get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute(query, params)
                return cursor.fetchall()

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
db_pool = DatabasePool(min_conn=5, max_conn=20)
result = db_pool.execute_query("SELECT * FROM users WHERE id = %s", (123,))
```

**–¢–∏–ø–∏—á–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –∏ —Ä–µ—à–µ–Ω–∏—è:**

1. **Connection leaks** - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ –ø—É–ª
   ```python
   # –ü–õ–û–•–û: —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –º–æ–∂–µ—Ç —É—Ç–µ—á—å
   conn = pool.getconn()
   cursor = conn.cursor()
   cursor.execute(query)  # –ï—Å–ª–∏ —Ç—É—Ç exception - conn –Ω–µ –≤–µ—Ä–Ω–µ—Ç—Å—è
   
   # –•–û–†–û–®–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º context manager
   with pool.get_connection() as conn:
       with conn.cursor() as cursor:
           cursor.execute(query)
   ```

2. **Stale connections** - —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Ä–∞–∑–æ—Ä–≤–∞–Ω—ã, –Ω–æ –ø—É–ª –Ω–µ –∑–Ω–∞–µ—Ç
   ```python
   # –ü—Ä–æ–≤–µ—Ä–∫–∞ health —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
   def is_connection_alive(conn):
       try:
           with conn.cursor() as cursor:
               cursor.execute("SELECT 1")
               return True
       except:
           return False
   ```

3. **Pool exhaustion** - –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–Ω—è—Ç—ã
   ```python
   # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—É–ª–∞
   def get_pool_stats(pool):
       return {
           'total_connections': len(pool._pool) + len(pool._used),
           'available': len(pool._pool),
           'in_use': len(pool._used)
       }
   ```

---

### Caching —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

**–í–æ–ø—Ä–æ—Å:** Cache-aside vs Write-through vs Write-behind. –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Cache-Aside (Lazy Loading):**
- –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫—ç—à–µ–º
- –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é

```python
# Cache-Aside pattern —Å Redis
import redis
import json
from typing import Optional

class UserService:
    def __init__(self):
        self.redis = redis.Redis(host='localhost', port=6379, db=0)
        self.db = DatabaseConnection()
    
    def get_user(self, user_id: int) -> Optional[dict]:
        cache_key = f"user:{user_id}"
        
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        cached_user = self.redis.get(cache_key)
        if cached_user:
            return json.loads(cached_user)
        
        # 2. –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –ë–î
        user = self.db.get_user(user_id)
        if user:
            # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
            self.redis.setex(
                cache_key, 
                3600,  # TTL 1 —á–∞—Å
                json.dumps(user)
            )
        
        return user
    
    def update_user(self, user_id: int, user_data: dict):
        # 1. –û–±–Ω–æ–≤–ª—è–µ–º –ë–î
        self.db.update_user(user_id, user_data)
        
        # 2. –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à
        self.redis.delete(f"user:{user_id}")
```

**Write-Through:**
- –ó–∞–ø–∏—Å—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤ –ë–î –∏ –∫—ç—à
- –î–∞–Ω–Ω—ã–µ –≤—Å–µ–≥–¥–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã

```python
class WriteThoughUserService:
    def update_user(self, user_id: int, user_data: dict):
        cache_key = f"user:{user_id}"
        
        # 1. –û–±–Ω–æ–≤–ª—è–µ–º –ë–î
        updated_user = self.db.update_user(user_id, user_data)
        
        # 2. –û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
        self.redis.setex(
            cache_key,
            3600,
            json.dumps(updated_user)
        )
        
        return updated_user
```

**Write-Behind (Write-Back):**
- –ó–∞–ø–∏—Å—å —Å–Ω–∞—á–∞–ª–∞ –≤ –∫—ç—à, –ø–æ—Ç–æ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –≤ –ë–î
- –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏

```python
import asyncio
from queue import Queue
import threading

class WriteBehindUserService:
    def __init__(self):
        self.redis = redis.Redis()
        self.db = DatabaseConnection()
        self.write_queue = Queue()
        self.start_background_writer()
    
    def update_user(self, user_id: int, user_data: dict):
        cache_key = f"user:{user_id}"
        
        # 1. –ë—ã—Å—Ç—Ä–∞—è –∑–∞–ø–∏—Å—å –≤ –∫—ç—à
        self.redis.setex(cache_key, 3600, json.dumps(user_data))
        
        # 2. –°—Ç–∞–≤–∏–º –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ë–î
        self.write_queue.put({
            'action': 'update_user',
            'user_id': user_id,
            'data': user_data
        })
        
        return user_data
    
    def start_background_writer(self):
        def worker():
            while True:
                try:
                    task = self.write_queue.get(timeout=1)
                    if task['action'] == 'update_user':
                        self.db.update_user(task['user_id'], task['data'])
                    self.write_queue.task_done()
                except:
                    continue
        
        thread = threading.Thread(target=worker, daemon=True)
        thread.start()
```

**–í—ã–±–æ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:**
- **Cache-Aside** - –¥–ª—è read-heavy –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
- **Write-Through** - –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å
- **Write-Behind** - –¥–ª—è write-heavy —Å –¥–æ–ø—É—Å—Ç–∏–º–æ–π eventual consistency

---

## 4. üîß Debugging –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

### Network Troubleshooting

**–í–æ–ø—Ä–æ—Å:** –£ –≤–∞—Å intermittent connection issues –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏. –ü–ª–∞–Ω –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**–ü–æ—à–∞–≥–æ–≤–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞:**

1. **–ü—Ä–æ–≤–µ—Ä–∫–∞ connectivity –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —É—Ä–æ–≤–Ω—è—Ö:**

```bash
#!/bin/bash
# –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–µ—Ç–µ–≤—ã—Ö –ø—Ä–æ–±–ª–µ–º

SERVICE_HOST="api.internal.com"
SERVICE_PORT="8080"

echo "=== Network Connectivity Diagnosis ==="

# 1. DNS resolution
echo "1. DNS Resolution:"
dig +short $SERVICE_HOST
nslookup $SERVICE_HOST

# 2. ICMP connectivity  
echo "2. ICMP Ping:"
ping -c 4 $SERVICE_HOST

# 3. TCP port connectivity
echo "3. TCP Port Check:"
nc -zv $SERVICE_HOST $SERVICE_PORT

# 4. HTTP response
echo "4. HTTP Health Check:"
curl -v -m 10 http://$SERVICE_HOST:$SERVICE_PORT/health

# 5. Trace route
echo "5. Network Path:"
traceroute $SERVICE_HOST

# 6. Active connections
echo "6. Current Connections:"
ss -tuln | grep :$SERVICE_PORT
```

2. **–ê–Ω–∞–ª–∏–∑ connection state:**

```python
# Python —Å–∫—Ä–∏–ø—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ TCP connections
import psutil
import time
from collections import Counter, defaultdict

class ConnectionMonitor:
    def __init__(self):
        self.connection_history = []
    
    def monitor_connections(self, duration=60):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π"""
        start_time = time.time()
        
        while time.time() - start_time < duration:
            connections = psutil.net_connections()
            
            # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—é
            states = Counter(conn.status for conn in connections)
            
            # –°—á–∏—Ç–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø–æ –ø–æ—Ä—Ç–∞–º
            ports = defaultdict(int)
            for conn in connections:
                if conn.laddr:
                    ports[conn.laddr.port] += 1
            
            snapshot = {
                'timestamp': time.time(),
                'states': dict(states),
                'ports': dict(ports),
                'total': len(connections)
            }
            
            self.connection_history.append(snapshot)
            print(f"Connections: {states}")
            
            time.sleep(5)
    
    def analyze_patterns(self):
        """–ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≤ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö"""
        if not self.connection_history:
            return
        
        # –ò—â–µ–º –∞–Ω–æ–º–∞–ª–∏–∏ –≤ TIME_WAIT —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö
        time_wait_counts = [s['states'].get('TIME_WAIT', 0) 
                           for s in self.connection_history]
        
        avg_time_wait = sum(time_wait_counts) / len(time_wait_counts)
        max_time_wait = max(time_wait_counts)
        
        print(f"TIME_WAIT analysis:")
        print(f"  Average: {avg_time_wait:.1f}")
        print(f"  Maximum: {max_time_wait}")
        
        if max_time_wait > avg_time_wait * 2:
            print("  ‚ö†Ô∏è  Potential connection pool exhaustion detected")

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
monitor = ConnectionMonitor()
monitor.monitor_connections(300)  # 5 –º–∏–Ω—É—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
monitor.analyze_patterns()
```

3. **Packet capture –∏ –∞–Ω–∞–ª–∏–∑:**

```bash
# –ó–∞—Ö–≤–∞—Ç —Ç—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
tcpdump -i any -w service_traffic.pcap \
    "host api.internal.com and port 8080"

# –ê–Ω–∞–ª–∏–∑ retransmissions —Å tshark
tshark -r service_traffic.pcap \
    -Y "tcp.analysis.retransmission" \
    -T fields -e frame.time -e ip.src -e ip.dst -e tcp.analysis.flags

# HTTP timing –∞–Ω–∞–ª–∏–∑
tshark -r service_traffic.pcap \
    -Y "http.request or http.response" \
    -T fields -e frame.time_relative -e http.request.method -e http.response.code
```

**–¢–∏–ø–∏—á–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã intermittent issues:**
- **DNS resolution delays** - –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ DNS
- **Connection pool exhaustion** - –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ pool metrics
- **Network congestion** - QoS –∏ bandwidth limiting
- **Load balancer health checks** - false positives
- **Firewall/Security groups** - intermittent blocks

---

## 5. üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ Distributed Systems

### Service Discovery

**–í–æ–ø—Ä–æ—Å:** Service Discovery: client-side vs server-side. Pros/cons?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Client-Side Service Discovery:**
–ö–ª–∏–µ–Ω—Ç —Å–∞–º –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç registry –∏ –≤—ã–±–∏—Ä–∞–µ—Ç instance.

```go
// Go client-side service discovery —Å Consul
package main

import (
    "fmt"
    "math/rand"
    "github.com/hashicorp/consul/api"
)

type ServiceDiscovery struct {
    client *api.Client
}

func NewServiceDiscovery() (*ServiceDiscovery, error) {
    client, err := api.NewClient(api.DefaultConfig())
    if err != nil {
        return nil, err
    }
    
    return &ServiceDiscovery{client: client}, nil
}

func (sd *ServiceDiscovery) GetServiceInstance(serviceName string) (string, error) {
    // –ü–æ–ª—É—á–∞–µ–º –∑–¥–æ—Ä–æ–≤—ã–µ instances
    services, _, err := sd.client.Health().Service(
        serviceName, 
        "", 
        true, // —Ç–æ–ª—å–∫–æ –∑–¥–æ—Ä–æ–≤—ã–µ
        nil,
    )
    
    if err != nil {
        return "", err
    }
    
    if len(services) == 0 {
        return "", fmt.Errorf("no healthy instances of %s", serviceName)
    }
    
    // Client-side load balancing
    instance := services[rand.Intn(len(services))]
    
    return fmt.Sprintf("%s:%d", 
        instance.Service.Address, 
        instance.Service.Port), nil
}

func (sd *ServiceDiscovery) CallService(serviceName, endpoint string) error {
    instance, err := sd.GetServiceInstance(serviceName)
    if err != nil {
        return err
    }
    
    url := fmt.Sprintf("http://%s%s", instance, endpoint)
    
    // HTTP call —Å fallback –Ω–∞ –¥—Ä—É–≥–æ–π instance
    return sd.makeHTTPCall(url, serviceName, endpoint)
}

func (sd *ServiceDiscovery) makeHTTPCall(url, serviceName, endpoint string) error {
    // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å retry logic
    maxRetries := 3
    
    for i := 0; i < maxRetries; i++ {
        err := httpCall(url)
        if err == nil {
            return nil
        }
        
        // –ü—Ä–∏ –æ—à–∏–±–∫–µ - –ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥–æ–π instance
        instance, getErr := sd.GetServiceInstance(serviceName)
        if getErr != nil {
            return getErr
        }
        url = fmt.Sprintf("http://%s%s", instance, endpoint)
    }
    
    return fmt.Errorf("failed after %d retries", maxRetries)
}
```

**Server-Side Service Discovery:**
Load balancer/proxy –¥–µ–ª–∞–µ—Ç discovery –∏ routing.

```yaml
# Kubernetes Service Discovery
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
    - port: 80
      targetPort: 8080
  type: ClusterIP

---
# Nginx Ingress —Å service discovery
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/load-balance: "round_robin"
spec:
  rules:
  - host: api.company.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: user-service
            port:
              number: 80
```

**–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤:**

| –ê—Å–ø–µ–∫—Ç | Client-Side | Server-Side |
|--------|-------------|-------------|
| **Latency** | –ú–µ–Ω—å—à–µ (–ø—Ä—è–º–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ) | –ë–æ–ª—å—à–µ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π hop) |
| **Complexity** | –í—ã—à–µ (–ª–æ–≥–∏–∫–∞ –≤ –∫–∞–∂–¥–æ–º –∫–ª–∏–µ–Ω—Ç–µ) | –ù–∏–∂–µ (—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞) |
| **Flexibility** | –í—ã—Å–æ–∫–∞—è (custom load balancing) | –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è |
| **Failure handling** | Client –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å | Proxy –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å |
| **Security** | Service-to-service auth | Centralized auth –≤ proxy |

---

### Circuit Breaker Pattern

**–í–æ–ø—Ä–æ—Å:** –ö–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Circuit Breaker –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç cascading failures?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

Circuit Breaker –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –≤—ã–∑–æ–≤—ã failing —Å–µ—Ä–≤–∏—Å–∞, –¥–∞–≤–∞—è –µ–º—É –≤—Ä–µ–º—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è.

```python
# Circuit Breaker implementation
import time
import threading
from enum import Enum
from typing import Callable, Any
from dataclasses import dataclass

class CircuitState(Enum):
    CLOSED = "CLOSED"        # –ù–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    OPEN = "OPEN"           # –ë–ª–æ–∫–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã
    HALF_OPEN = "HALF_OPEN" # –¢–µ—Å—Ç–∏—Ä—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ

@dataclass
class CircuitBreakerConfig:
    failure_threshold: int = 5      # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫ –¥–ª—è OPEN
    timeout: int = 60              # –°–µ–∫—É–Ω–¥ –≤ OPEN —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    success_threshold: int = 3      # –£—Å–ø–µ—Ö–æ–≤ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ CLOSED

class CircuitBreaker:
    def __init__(self, config: CircuitBreakerConfig):
        self.config = config
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.lock = threading.Lock()
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        with self.lock:
            if self.state == CircuitState.OPEN:
                if self._should_attempt_reset():
                    self.state = CircuitState.HALF_OPEN
                    self.success_count = 0
                else:
                    raise CircuitBreakerOpenException(
                        f"Circuit breaker is OPEN. Last failure: {self.last_failure_time}"
                    )
            
            try:
                result = func(*args, **kwargs)
                self._on_success()
                return result
                
            except Exception as e:
                self._on_failure()
                raise
    
    def _should_attempt_reset(self) -> bool:
        return (time.time() - self.last_failure_time) >= self.config.timeout
    
    def _on_success(self):
        if self.state == CircuitState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.config.success_threshold:
                self.state = CircuitState.CLOSED
                self.failure_count = 0
        
        elif self.state == CircuitState.CLOSED:
            self.failure_count = 0
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.state == CircuitState.HALF_OPEN:
            self.state = CircuitState.OPEN
        
        elif (self.state == CircuitState.CLOSED and 
              self.failure_count >= self.config.failure_threshold):
            self.state = CircuitState.OPEN
    
    def get_state(self) -> dict:
        return {
            'state': self.state.value,
            'failure_count': self.failure_count,
            'success_count': self.success_count,
            'last_failure_time': self.last_failure_time
        }

class CircuitBreakerOpenException(Exception):
    pass

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å HTTP –∫–ª–∏–µ–Ω—Ç–æ–º
import requests

class APIClient:
    def __init__(self):
        self.circuit_breaker = CircuitBreaker(
            CircuitBreakerConfig(
                failure_threshold=3,
                timeout=30,
                success_threshold=2
            )
        )
    
    def get_user(self, user_id: int) -> dict:
        def api_call():
            response = requests.get(
                f"http://user-service/users/{user_id}",
                timeout=5
            )
            response.raise_for_status()
            return response.json()
        
        try:
            return self.circuit_breaker.call(api_call)
        except CircuitBreakerOpenException:
            # Fallback strategy
            return self._get_user_fallback(user_id)
    
    def _get_user_fallback(self, user_id: int) -> dict:
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º cached –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ default response
        return {
            'id': user_id,
            'name': 'Unknown User',
            'cached': True
        }

# Monitoring circuit breaker
def monitor_circuit_breaker(api_client: APIClient):
    while True:
        state = api_client.circuit_breaker.get_state()
        print(f"Circuit Breaker State: {state}")
        
        if state['state'] == 'OPEN':
            print("‚ö†Ô∏è Circuit breaker is OPEN - service is failing")
        
        time.sleep(10)
```

**–ö–ª—é—á–µ–≤—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- **Fail-fast** - –±—ã—Å—Ç—Ä—ã–π –æ—Ç–∫–∞–∑ –≤–º–µ—Å—Ç–æ –¥–æ–ª–≥–æ–≥–æ –æ–∂–∏–¥–∞–Ω–∏—è
- **Self-healing** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
- **Cascading failure prevention** - –∑–∞—â–∏—Ç–∞ downstream —Å–µ—Ä–≤–∏—Å–æ–≤

---

## 6. üé≤ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ —Å —Ä–µ—à–µ–Ω–∏—è–º–∏

### Scenario 1: API Response Time Issue

**–ü—Ä–æ–±–ª–µ–º–∞:** "–ü–æ—Å–ª–µ –¥–µ–ø–ª–æ—è API response time —É–≤–µ–ª–∏—á–∏–ª–æ—Å—å —Å 100ms –¥–æ 500ms. Database queries –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –∑–∞ 50ms."

**–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∏ —Ä–µ—à–µ–Ω–∏–µ:**

```python
# Comprehensive latency analysis tool
import time
import psutil
import requests
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class LatencyMeasurement:
    component: str
    duration_ms: float
    timestamp: float

class LatencyProfiler:
    def __init__(self):
        self.measurements: List[LatencyMeasurement] = []
    
    def measure_request(self, user_id: int):
        """–ò–∑–º–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç request pipeline"""
        
        total_start = time.time()
        
        # 1. DNS resolution
        dns_start = time.time()
        # Simulate DNS lookup
        time.sleep(0.001)  # 1ms –¥–ª—è DNS
        dns_duration = (time.time() - dns_start) * 1000
        self.measurements.append(
            LatencyMeasurement("DNS", dns_duration, time.time())
        )
        
        # 2. TCP connection establishment
        tcp_start = time.time()
        # –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç connection pool get
        time.sleep(0.002)  # 2ms –¥–ª—è TCP
        tcp_duration = (time.time() - tcp_start) * 1000
        self.measurements.append(
            LatencyMeasurement("TCP", tcp_duration, time.time())
        )
        
        # 3. TLS handshake (–µ—Å–ª–∏ HTTPS)
        tls_start = time.time()
        time.sleep(0.020)  # 20ms –¥–ª—è TLS handshake
        tls_duration = (time.time() - tls_start) * 1000
        self.measurements.append(
            LatencyMeasurement("TLS", tls_duration, time.time())
        )
        
        # 4. HTTP request/response
        http_start = time.time()
        
        # 4a. Request serialization
        serialize_start = time.time()
        payload = {"user_id": user_id, "fields": ["name", "email", "preferences"]}
        serialize_duration = (time.time() - serialize_start) * 1000
        self.measurements.append(
            LatencyMeasurement("Serialization", serialize_duration, time.time())
        )
        
        # 4b. Network transfer
        network_start = time.time()
        time.sleep(0.050)  # 50ms network
        network_duration = (time.time() - network_start) * 1000
        self.measurements.append(
            LatencyMeasurement("Network", network_duration, time.time())
        )
        
        # 4c. Server processing (–≤–∫–ª—é—á–∞—è DB)
        server_start = time.time()
        time.sleep(0.050)  # 50ms database
        time.sleep(0.300)  # 300ms –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞!
        server_duration = (time.time() - server_start) * 1000
        self.measurements.append(
            LatencyMeasurement("Server", server_duration, time.time())
        )
        
        # 4d. Response deserialization
        deserialize_start = time.time()
        time.sleep(0.005)  # 5ms –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON
        deserialize_duration = (time.time() - deserialize_start) * 1000
        self.measurements.append(
            LatencyMeasurement("Deserialization", deserialize_duration, time.time())
        )
        
        total_duration = (time.time() - total_start) * 1000
        self.measurements.append(
            LatencyMeasurement("Total", total_duration, time.time())
        )
    
    def analyze_bottlenecks(self) -> Dict[str, float]:
        """–ê–Ω–∞–ª–∏–∑ bottlenecks"""
        component_times = {}
        
        for measurement in self.measurements:
            if measurement.component not in component_times:
                component_times[measurement.component] = []
            component_times[measurement.component].append(measurement.duration_ms)
        
        # –°—á–∏—Ç–∞–µ–º —Å—Ä–µ–¥–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∞
        avg_times = {
            component: sum(times) / len(times)
            for component, times in component_times.items()
        }
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        sorted_components = sorted(
            avg_times.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        print("Latency Breakdown:")
        for component, avg_time in sorted_components:
            percentage = (avg_time / avg_times['Total']) * 100
            print(f"  {component}: {avg_time:.1f}ms ({percentage:.1f}%)")
            
            # –§–ª–∞–≥–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º—ã
            if component == "Server" and avg_time > 100:
                print(f"    üî• SERVER BOTTLENECK DETECTED!")
                self._diagnose_server_issues()
        
        return avg_times
    
    def _diagnose_server_issues(self):
        """–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ server-side –ø—Ä–æ–±–ª–µ–º"""
        print("\nServer-side diagnostics:")
        
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        print(f"  CPU Usage: {cpu_percent}%")
        
        # Memory usage
        memory = psutil.virtual_memory()
        print(f"  Memory Usage: {memory.percent}%")
        
        # Check for potential causes
        if cpu_percent > 80:
            print("    ‚ö†Ô∏è High CPU - possible algorithmic issue or high load")
        
        if memory.percent > 80:
            print("    ‚ö†Ô∏è High memory - possible memory leak or large objects")
        
        # Check GC pressure (–¥–ª—è —è–∑—ã–∫–æ–≤ —Å GC)
        print("    üí° Check GC logs for pause times")
        print("    üí° Profile application code for hot paths")
        print("    üí° Check database query execution plans")
        print("    üí° Review external API call timeouts")

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
profiler = LatencyProfiler()

# –°–∏–º—É–ª–∏—Ä—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–∞–ø—Ä–æ—Å–æ–≤
for i in range(10):
    profiler.measure_request(i)

# –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
bottlenecks = profiler.analyze_bottlenecks()
```

**–í–µ—Ä–æ—è—Ç–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã —É–≤–µ–ª–∏—á–µ–Ω–∏—è latency:**
1. **Database connection pool exhaustion** ‚Üí —É–≤–µ–ª–∏—á–∏—Ç—å pool size
2. **New dependency —Å high latency** ‚Üí –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã
3. **GC pressure** ‚Üí optimize memory allocation
4. **Blocking I/O** ‚Üí –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ async/await
5. **Network configuration changes** ‚Üí –ø—Ä–æ–≤–µ—Ä–∏—Ç—å routing/firewall

---

### Scenario 2: Scaling Real-time Chat

**–ü—Ä–æ–±–ª–µ–º–∞:** "–ù—É–∂–Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å chat –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ 1M concurrent connections."

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:**

```javascript
// WebSocket server —Å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ–º
const WebSocket = require('ws');
const Redis = require('redis');
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

class ScalableChatServer {
    constructor(port, redisConfig) {
        this.port = port;
        this.redis = Redis.createClient(redisConfig);
        this.pubsub = Redis.createClient(redisConfig);
        this.connections = new Map();
        this.rooms = new Map();
        
        this.setupRedisSubscription();
    }
    
    start() {
        this.wss = new WebSocket.Server({ 
            port: this.port,
            perMessageDeflate: false,  // –û—Ç–∫–ª—é—á–∞–µ–º compression –¥–ª—è performance
            maxPayload: 16 * 1024,     // 16KB max message size
        });
        
        this.wss.on('connection', (ws, req) => {
            this.handleConnection(ws, req);
        });
        
        // Graceful shutdown
        process.on('SIGTERM', () => {
            console.log('Shutting down gracefully...');
            this.wss.close(() => {
                process.exit(0);
            });
        });
        
        console.log(`Chat server started on port ${this.port}`);
        console.log(`Process ${process.pid} handling connections`);
    }
    
    handleConnection(ws, req) {
        const connectionId = this.generateConnectionId();
        const userId = this.extractUserId(req);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º connection info
        this.connections.set(connectionId, {
            ws,
            userId,
            rooms: new Set(),
            lastActivity: Date.now()
        });
        
        console.log(`User ${userId} connected. Total connections: ${this.connections.size}`);
        
        ws.on('message', (data) => {
            this.handleMessage(connectionId, data);
        });
        
        ws.on('close', () => {
            this.handleDisconnect(connectionId);
        });
        
        ws.on('pong', () => {
            // Update last activity –¥–ª—è keep-alive
            const conn = this.connections.get(connectionId);
            if (conn) {
                conn.lastActivity = Date.now();
            }
        });
        
        // Send welcome message
        this.sendToConnection(connectionId, {
            type: 'connected',
            connectionId,
            serverInfo: {
                pid: process.pid,
                connections: this.connections.size
            }
        });
    }
    
    handleMessage(connectionId, rawData) {
        try {
            const message = JSON.parse(rawData);
            const connection = this.connections.get(connectionId);
            
            if (!connection) return;
            
            switch (message.type) {
                case 'join_room':
                    this.joinRoom(connectionId, message.roomId);
                    break;
                    
                case 'leave_room':
                    this.leaveRoom(connectionId, message.roomId);
                    break;
                    
                case 'chat_message':
                    this.broadcastMessage(connectionId, message);
                    break;
                    
                case 'typing':
                    this.handleTyping(connectionId, message);
                    break;
            }
            
        } catch (error) {
            console.error('Invalid message format:', error);
        }
    }
    
    joinRoom(connectionId, roomId) {
        const connection = this.connections.get(connectionId);
        if (!connection) return;
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ local room tracking
        connection.rooms.add(roomId);
        
        if (!this.rooms.has(roomId)) {
            this.rooms.set(roomId, new Set());
        }
        this.rooms.get(roomId).add(connectionId);
        
        // –ü—É–±–ª–∏–∫—É–µ–º –≤ Redis –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤
        this.redis.publish('room_events', JSON.stringify({
            type: 'user_joined',
            roomId,
            userId: connection.userId,
            serverId: process.pid
        }));
        
        this.sendToConnection(connectionId, {
            type: 'room_joined',
            roomId,
            memberCount: this.rooms.get(roomId).size
        });
    }
    
    broadcastMessage(senderConnectionId, message) {
        const senderConnection = this.connections.get(senderConnectionId);
        if (!senderConnection) return;
        
        const chatMessage = {
            type: 'chat_message',
            roomId: message.roomId,
            userId: senderConnection.userId,
            content: message.content,
            timestamp: Date.now(),
            messageId: this.generateMessageId()
        };
        
        // –õ–æ–∫–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ room
        this.sendToLocalRoom(message.roomId, chatMessage, senderConnectionId);
        
        // –ü—É–±–ª–∏–∫–∞—Ü–∏—è –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤
        this.redis.publish('chat_messages', JSON.stringify({
            ...chatMessage,
            excludeServer: process.pid
        }));
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis –¥–ª—è history
        this.redis.lpush(
            `room:${message.roomId}:history`,
            JSON.stringify(chatMessage)
        );
        this.redis.ltrim(`room:${message.roomId}:history`, 0, 1000); // –•—Ä–∞–Ω–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 1000 —Å–æ–æ–±—â–µ–Ω–∏–π
    }
    
    sendToLocalRoom(roomId, message, excludeConnectionId = null) {
        const room = this.rooms.get(roomId);
        if (!room) return;
        
        room.forEach(connectionId => {
            if (connectionId !== excludeConnectionId) {
                this.sendToConnection(connectionId, message);
            }
        });
    }
    
    sendToConnection(connectionId, message) {
        const connection = this.connections.get(connectionId);
        if (!connection || connection.ws.readyState !== WebSocket.OPEN) {
            return;
        }
        
        try {
            connection.ws.send(JSON.stringify(message));
        } catch (error) {
            console.error('Failed to send message:', error);
            this.handleDisconnect(connectionId);
        }
    }
    
    setupRedisSubscription() {
        this.pubsub.subscribe('chat_messages', 'room_events');
        
        this.pubsub.on('message', (channel, data) => {
            const message = JSON.parse(data);
            
            if (channel === 'chat_messages') {
                // –ù–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –Ω–∞—à–µ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞
                if (message.excludeServer === process.pid) return;
                
                this.sendToLocalRoom(message.roomId, message);
            }
            
            if (channel === 'room_events') {
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ room events –æ—Ç –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤
                console.log('Room event from another server:', message);
            }
        });
    }
    
    // Cleanup –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
    startHealthChecks() {
        // Ping connections –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        setInterval(() => {
            const now = Date.now();
            const staleThreshold = 60 * 1000; // 60 —Å–µ–∫—É–Ω–¥
            
            this.connections.forEach((connection, connectionId) => {
                if (now - connection.lastActivity > staleThreshold) {
                    console.log(`Closing stale connection: ${connectionId}`);
                    connection.ws.terminate();
                    this.handleDisconnect(connectionId);
                } else {
                    // Send ping
                    if (connection.ws.readyState === WebSocket.OPEN) {
                        connection.ws.ping();
                    }
                }
            });
            
            // –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            console.log(`Server ${process.pid}: ${this.connections.size} active connections`);
        }, 30000);
    }
    
    generateConnectionId() {
        return `${process.pid}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    extractUserId(req) {
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç JWT parsing –∏–ª–∏ session lookup
        const url = new URL(req.url, 'http://localhost');
        return url.searchParams.get('userId') || 'anonymous';
    }
    
    handleDisconnect(connectionId) {
        const connection = this.connections.get(connectionId);
        if (!connection) return;
        
        // –£–±–∏—Ä–∞–µ–º –∏–∑ –≤—Å–µ—Ö rooms
        connection.rooms.forEach(roomId => {
            this.leaveRoom(connectionId, roomId);
        });
        
        this.connections.delete(connectionId);
        console.log(`Connection ${connectionId} disconnected. Total: ${this.connections.size}`);
    }
    
    leaveRoom(connectionId, roomId) {
        const connection = this.connections.get(connectionId);
        if (!connection) return;
        
        connection.rooms.delete(roomId);
        
        const room = this.rooms.get(roomId);
        if (room) {
            room.delete(connectionId);
            if (room.size === 0) {
                this.rooms.delete(roomId);
            }
        }
    }
}

// Cluster setup –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
if (cluster.isMaster) {
    console.log(`Master ${process.pid} is running`);
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º worker –ø—Ä–æ—Ü–µ—Å—Å—ã
    for (let i = 0; i < numCPUs; i++) {
        const worker = cluster.fork({
            WORKER_PORT: 8080 + i
        });
    }
    
    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        cluster.fork();
    });
    
} else {
    // Worker process
    const server = new ScalableChatServer(
        process.env.WORKER_PORT,
        { host: 'localhost', port: 6379 }
    );
    
    server.start();
    server.startHealthChecks();
}
```

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è 1M connections:**

1. **Horizontal scaling** - –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ server instances
2. **Redis pub/sub** - –¥–ª—è inter-server communication
3. **Connection pooling** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ WS connections
4. **Message persistence** - Redis –¥–ª—è chat history
5. **Load balancing** - sticky sessions –ø–æ room ID
6. **Monitoring** - connection health checks –∏ cleanup

**Production considerations:**
- **Message rate limiting** - –∑–∞—â–∏—Ç–∞ –æ—Ç spam
- **Authentication/Authorization** - JWT tokens
- **Message encryption** - end-to-end –¥–ª—è privacy
- **Horizontal scaling** - Kubernetes with Redis Cluster
- **Monitoring** - Prometheus metrics –¥–ª—è connection counts

---

–≠—Ç–æ—Ç —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–µ—Ç–µ–≤—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ —Å –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –∫–æ–¥–∞, –≥–æ—Ç–æ–≤—ã–º–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ production environment.