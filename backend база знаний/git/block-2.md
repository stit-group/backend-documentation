# Блок 2: Ветвление и слияние
*Время изучения: 2 недели*

---

## 🎯 Цели блока
- Освоить работу с ветками
- Научиться решать конфликты слияния
- Понять стратегии ветвления

---

## Глава 1: Основы ветвления

### Что такое ветки и зачем они нужны?

Представьте, что вы пишете книгу. Основная сюжетная линия готова, но вы хотите поэкспериментировать с альтернативным финалом. Что делать?

**Без веток (плохой подход):**
```
Основная книга → Копия книги → Эксперименты в копии
                     ↓
               Как объединить изменения?
               Какая версия правильная?
```

**С ветками (правильный подход):**
```
Основная ветка:  A---B---C---F---G
                         \       /
Экспериментальная:        D---E-/
```

### Концептуальная модель веток в Git

**Ветка — это указатель на коммит:**

```
Коммиты в хронологическом порядке:
A ← B ← C ← D

Ветка "main":
┌──────┐     ┌─────────────┐
│ main │ ──→ │ Коммит D    │
└──────┘     └─────────────┘

Создание новой ветки "feature":
┌──────┐     ┌─────────────┐
│ main │ ──→ │ Коммит D    │ ←── ┌─────────┐
└──────┘     └─────────────┘     │ feature │
                                 └─────────┘
```

**Важно понимать:** Ветка НЕ содержит коммиты, она просто указывает на определенный коммит в истории.

### Указатель HEAD — где вы находитесь

HEAD — это специальный указатель, который показывает, где вы сейчас находитесь:

```
┌─────────┐     ┌──────┐     ┌─────────────┐
│  HEAD   │ ──→ │ main │ ──→ │ Коммит D    │
└─────────┘     └──────┘     └─────────────┘

Читается как: "HEAD указывает на ветку main, 
которая указывает на коммит D"
```

### Создание и переключение веток

**Создание ветки — создание нового указателя:**

```
До создания ветки:
A ← B ← C ← D ← main (HEAD)

Создание ветки feature:
A ← B ← C ← D ← main
                ↖
                feature (HEAD)

Оба указателя показывают на один коммит!
```

**Переключение между ветками:**

```
git checkout main:
┌─────────┐     ┌──────┐     ┌─────────────┐
│  HEAD   │ ──→ │ main │ ──→ │ Коммит D    │
└─────────┘     └──────┘     └─────────────┘

git checkout feature:
┌─────────┐     ┌─────────┐     ┌─────────────┐
│  HEAD   │ ──→ │ feature │ ──→ │ Коммит D    │
└─────────┘     └─────────┘     └─────────────┘
```

### Развитие веток независимо

**Когда вы делаете коммит на ветке:**

```
Исходное состояние:
A ← B ← C ← D ← main
                ↖
                feature (HEAD)

После коммита на feature:
A ← B ← C ← D ← main
                ↖
                 E ← feature (HEAD)

После коммита на main:
A ← B ← C ← D ← F ← main (HEAD)
                ↖
                 E ← feature
```

Теперь ветки разошлись! У каждой свой путь развития.

---

## Глава 2: Слияние веток

### Концепция объединения изменений

Когда работа в ветке завершена, нужно объединить изменения с основной веткой. Git предлагает несколько стратегий слияния.

### Fast-Forward слияние

**Когда это происходит:** Основная ветка не изменялась, пока вы работали в feature-ветке.

```
До слияния:
A ← B ← C ← D ← main
                ↖
                 E ← F ← feature (HEAD)

Fast-Forward слияние:
A ← B ← C ← D ← E ← F ← main (HEAD)
                        ↗
                   feature
```

**Суть:** Git просто перемещает указатель main вперед. Никакого нового коммита не создается.

**Аналогия:** Как будто основная книга не менялась, а вы просто дописали новые главы в конец.

### Three-Way Merge (слияние с созданием коммита)

**Когда это происходит:** Обе ветки развивались параллельно.

```
До слияния:
        C ← D ← main
       /
A ← B
       \
        E ← F ← feature

Three-Way слияние:
        C ← D ←──┐
       /         │
A ← B            M ← main (HEAD)
       \         │
        E ← F ←──┘
```

**Что происходит:**
1. Git находит общего предка (коммит B)
2. Сравнивает изменения в обеих ветках
3. Создает новый merge-коммит M
4. M имеет двух родителей: D и F

**Аналогия:** Как объединение двух версий документа, когда в каждой есть уникальные изменения.

### Понимание конфликтов слияния

**Конфликт возникает когда:**
- Один и тот же файл изменился в обеих ветках
- Git не может автоматически решить, какое изменение оставить

**Визуализация конфликта:**

```
Ветка main:           Ветка feature:
function greet() {    function greet() {
    return "Hello";       return "Hi there";
}                     }

Git не знает:
- Оставить "Hello"?
- Оставить "Hi there"?  
- Оставить оба?
- Что-то другое?
```

**Как Git показывает конфликт:**

```
function greet() {
<<<<<<< HEAD (текущая ветка)
    return "Hello";
=======
    return "Hi there";
>>>>>>> feature (сливаемая ветка)
}
```

**Разрешение конфликта — это человеческое решение:**

```
Варианты решения:
1. Оставить только "Hello"
2. Оставить только "Hi there"  
3. Объединить: return "Hello there"
4. Написать что-то новое: return "Greetings"
```

### Стратегии разрешения конфликтов

**1. Понимание контекста:**
- Какая функциональность важнее?
- Можно ли объединить изменения?
- Нужно ли обсуждение с командой?

**2. Инструменты для разрешения:**
```
Варианты работы с конфликтами:

Вручную в редакторе:
├── Простые конфликты
└── Полный контроль

Графические инструменты:
├── Сложные конфликты
├── Наглядное сравнение
└── Удобные средства навигации

Автоматические стратегии:
├── "Ours" — оставить наши изменения
├── "Theirs" — принять их изменения  
└── Для массовых операций
```

---

## Глава 3: Продвинутые техники

### Rebase — альтернатива слиянию

**Концепция rebase:**
Вместо создания merge-коммита, rebase "перемещает" вашу ветку так, как будто она была создана от последнего коммита main.

**Обычное слияние:**
```
A ← B ← C ← D ← main
         \       \
          E ← F   M (merge commit)
               \ /
             feature
```

**Rebase:**
```
A ← B ← C ← D ← E' ← F' ← main
                      ↗
                 feature
```

**Что происходит при rebase:**
1. Git временно "отсоединяет" коммиты E и F
2. Применяет их заново поверх коммита D
3. Создает новые коммиты E' и F' (с теми же изменениями, но новыми хешами)

**Плюсы rebase:**
- Линейная, чистая история
- Легче читать и понимать
- Нет лишних merge-коммитов

**Минусы rebase:**
- Изменяет историю (может быть опасно)
- Сложнее при работе в команде
- Конфликты могут возникать на каждом коммите

### Интерактивный rebase — редактирование истории

**Возможности интерактивного rebase:**

```
pick    — оставить коммит как есть
reword  — изменить сообщение коммита
edit    — остановиться для редактирования
squash  — объединить с предыдущим коммитом
drop    — удалить коммит
```

**Пример применения:**

```
Грязная история:
A ← B ← C ← D ← E ← F
    │   │   │   │   │
    │   │   │   │   └── fix typo
    │   │   │   └────── add feature
    │   │   └────────── work in progress  
    │   └────────────── fix bug
    └────────────────── initial commit

После интерактивного rebase:
A ← B ← C ← D
    │   │   │
    │   │   └────── add feature (объединили D, E, F)
    │   └────────── fix bug
    └────────────── initial commit
```

### Cherry-pick — выборочное применение коммитов

**Концепция:**
Взять конкретный коммит из одной ветки и применить его в другой.

```
Исходное состояние:
main:     A ← B ← C
feature:  A ← B ← D ← E ← F

Cherry-pick коммита E:
main:     A ← B ← C ← E'
feature:  A ← B ← D ← E ← F
```

**Когда полезно:**
- Нужно срочно применить багфикс из feature-ветки
- Выборочное портирование изменений
- Исправление ошибок в релизных ветках

### Git Stash — временное сохранение изменений

**Проблема:**
Вы работаете над функцией, но нужно срочно переключиться на другую ветку. Изменения не готовы для коммита.

**Решение — stash:**

```
Текущая ситуация:
Рабочая зона: изменения в process...
Нужно: переключиться на main

git stash:
Рабочая зона: чистая ← изменения временно сохранены
Можно: безопасно переключиться

git stash pop:
Рабочая зона: изменения восстановлены
```

**Stash как стопка тарелок:**

```
Последний stash (применится первым)
┌─────────────────────────────────┐
│ Stash 3: работа над формой      │ ← git stash pop возьмет этот
├─────────────────────────────────┤
│ Stash 2: эксперименты с CSS     │
├─────────────────────────────────┤  
│ Stash 1: незавершенная функция  │
└─────────────────────────────────┘
```

---

## Глава 4: Стратегии ветвления

### Git Flow — классическая модель

**Структура веток в Git Flow:**

```
master    ──●────●────●────●──  (продакшн)
             \        /\    /
release       \  ●───●  \  /    (подготовка релиза)
               \/       \/
develop   ──●──●────●────●────●──  (основная разработка)
              /\    /\    /\
feature      /  ●──●  \  /  ●──●  (новые функции)
            /          \/
hotfix                  ●──●     (срочные исправления)
```

**Назначение веток:**

- **master/main**: Только стабильные релизы
- **develop**: Интеграция новых функций
- **feature**: Разработка конкретных функций
- **release**: Подготовка к релизу
- **hotfix**: Срочные исправления продакшна

**Жизненный цикл функции:**
```
1. Создание feature/new-login от develop
2. Разработка функции авторизации
3. Слияние в develop
4. Создание release/v1.2.0 от develop
5. Тестирование и багфиксы в release
6. Слияние release в master и develop
7. Тег v1.2.0 на master
```

### GitHub Flow — упрощенная модель

**Принцип:** Только main ветка + feature ветки

```
main     ──●──●──●──●──●──●──●──
            \  /\  /\  /\  /
feature      ●──  ●──  ●──●   (feature ветки)
```

**Процесс разработки:**
1. Создать ветку от main
2. Разработать функцию
3. Создать Pull Request
4. Code Review
5. Слияние в main
6. Автоматический деплой

**Преимущества GitHub Flow:**
- Простота понимания
- Быстрая доставка изменений
- Подходит для веб-приложений
- Минимум сложности

### Trunk-Based Development

**Концепция:** Все разработчики работают в одной ветке (trunk/main)

```
main  ──●──●──●──●──●──●──●──●──●──
        ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
     Dev1 Dev2 Dev1 Dev3 Dev2 Dev1 Dev3 Dev2 Dev1
```

**Ключевые принципы:**
- Очень короткоживущие ветки (часы, максимум дни)
- Частые коммиты в main
- Feature flags для скрытия незавершенных функций
- Высокая автоматизация тестирования

**Когда подходит:**
- Большие команды с высокой дисциплиной
- Продукты с частыми релизами
- Высокий уровень автоматизации

### Выбор подходящей стратегии

**Факторы для выбора:**

```
Размер команды:
├── 1-3 человека → GitHub Flow
├── 4-10 человек → Git Flow / GitHub Flow
└── 10+ человек → Trunk-Based / адаптированный Git Flow

Частота релизов:
├── Ежедневно → Trunk-Based / GitHub Flow
├── Еженедельно → GitHub Flow
└── Ежемесячно+ → Git Flow

Сложность продукта:
├── Веб-приложение → GitHub Flow
├── Мобильное приложение → Git Flow
└── Системное ПО → Git Flow / адаптированная модель

Опыт команды:
├── Новички → GitHub Flow
├── Средний уровень → Git Flow
└── Эксперты → Trunk-Based / Custom
```

---

## ✅ Итоговые знания Блока 2

После изучения этого блока вы должны понимать:

### Концептуальное понимание:
- **Природу веток** как указателей на коммиты
- **Разницу между merge и rebase** и когда использовать каждый подход
- **Логику разрешения конфликтов** и стратегии их избежания
- **Философию различных моделей ветвления**

### Практические навыки:
- **Создание и управление ветками** для параллельной разработки
- **Слияние изменений** и разрешение конфликтов
- **Использование продвинутых техник** (rebase, cherry-pick, stash)
- **Выбор стратегии ветвления** под конкретный проект

### Ментальная модель:
У вас должно сформироваться понимание того, как организовать процесс разработки с использованием веток для эффективной командной работы.

---

## 🎯 Практическое задание

**Создайте учебный сценарий:**
1. Создайте ветку для добавления новой страницы на сайт
2. Одновременно внесите изменения в main (симуляция работы коллеги)
3. Создайте конфликт и научитесь его разрешать
4. Попробуйте разные стратегии слияния (merge vs rebase)
5. Поэкспериментируйте с stash при переключении веток

**Цель:** Получить практический опыт работы с ветками и понимание того, как они решают реальные задачи разработки.

---

*Следующий блок: **Удаленные репозитории и GitHub** — изучим, как Git позволяет эффективно работать в команде через облачные сервисы.*