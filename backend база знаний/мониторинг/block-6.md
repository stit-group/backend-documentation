# Блок 6: Современные подходы и экспертиза в мониторинге

```
🎯 ЦЕЛЬ БЛОКА: Освоить передовые практики и стать экспертом в области мониторинга
⏱️ ДЛИТЕЛЬНОСТЬ: 4-5 недель
📊 УРОВЕНЬ: Экспертный
```

---

## 🗺️ Roadmap блока

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           БЛОК 6: ПУТЬ К ЭКСПЕРТИЗЕ                                │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  Неделя 1-2          Неделя 3           Неделя 4           Неделя 5                │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐           │
│  │ Observa-    │    │ AI/ML в     │    │ Культура и  │    │ Будущее     │           │
│  │ bility vs   │───▶│ мониторинге │───▶│ процессы    │───▶│ мониторинга │           │
│  │ Monitoring  │    │             │    │             │    │             │           │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘           │
│         │                  │                  │                  │                  │
│         ▼                  ▼                  ▼                  ▼                  │
│  OpenTelemetry      Anomaly Detection   Incident Response   Career Paths           │
│  Distributed        Predictive          Postmortem          Technology             │
│  Tracing           Analytics           Culture             Trends                 │
│  Chaos Engineering  AIOps Platforms     Team Metrics       Vision Planning        │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 📋 Чек-лист готовности к блоку

Перед началом убедитесь, что у вас есть:

```
✅ ТЕХНИЧЕСКИЕ НАВЫКИ:
   □ Опыт работы с Prometheus + Grafana
   □ Понимание архитектуры микросервисов
   □ Базовые знания машинного обучения
   □ Опыт работы с Kubernetes

✅ ИНФРАСТРУКТУРА:
   □ Доступ к тестовому кластеру
   □ Права администратора
   □ Инструменты для разработки
   □ Доступ к облачным сервисам (желательно)

✅ ВРЕМЯ И МОТИВАЦИЯ:
   □ 8-10 часов в неделю
   □ Готовность к сложным концепциям
   □ Желание стать экспертом
```

---

# 🔍 Глава 6.1: Observability vs Monitoring

## Концептуальная основа

```
ЭВОЛЮЦИЯ ПОДХОДОВ К НАБЛЮДЕНИЮ ЗА СИСТЕМАМИ:

1970s-1990s: BASIC MONITORING
┌─────────────────────────────────────┐
│ • Простые проверки доступности      │
│ • Мониторинг ресурсов              │
│ • Реактивный подход                │
└─────────────────────────────────────┘
                   ▼
2000s-2010s: ADVANCED MONITORING  
┌─────────────────────────────────────┐
│ • Метрики производительности        │
│ • Централизованное логирование      │
│ • Алертинг по порогам              │
└─────────────────────────────────────┘
                   ▼
2010s-Now: OBSERVABILITY
┌─────────────────────────────────────┐
│ • Комплексное понимание системы     │
│ • Способность отвечать на вопросы   │
│ • Проактивный анализ               │
└─────────────────────────────────────┘
```

## Три столпа Observability

```
                    OBSERVABILITY
                    ┌─────────────┐
                    │   SYSTEM    │
                    │ UNDERSTANDING│
                    └─────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
        ▼                 ▼                 ▼
  ┌──────────┐    ┌──────────────┐    ┌──────────┐
  │ METRICS  │    │    LOGS      │    │ TRACES   │
  │          │    │              │    │          │
  │ • Числа  │    │ • События    │    │ • Путь   │
  │ • Тренды │    │ • Контекст   │    │ • Задержки│
  │ • Алерты │    │ • Ошибки     │    │ • Связи  │
  └──────────┘    └──────────────┘    └──────────┘
       │                 │                 │
       └─────────────────┼─────────────────┘
                         │
                    ┌─────────┐
                    │INSIGHTS │
                    │& ACTIONS│
                    └─────────┘
```

## Ключевые отличия

| Аспект | Monitoring | Observability |
|--------|------------|---------------|
| **Фокус** | Известные проблемы | Неизвестные проблемы |
| **Подход** | Реактивный | Проактивный |
| **Вопросы** | "Что сломалось?" | "Почему это произошло?" |
| **Данные** | Предопределенные метрики | Богатый контекст |
| **Цель** | Обнаружение проблем | Понимание поведения |

---

## 🛠️ OpenTelemetry: Стандарт наблюдаемости

### Архитектура OpenTelemetry

```
APPLICATION CODE
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│  │   Service   │    │   Service   │    │   Service   │    │   Service   │      │
│  │      A      │───▶│      B      │───▶│      C      │───▶│      D      │      │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘      │
│         │                  │                  │                  │             │
│         ▼                  ▼                  ▼                  ▼             │
│  ┌─────────────────────────────────────────────────────────────────────────────┐ │
│  │                    OTEL SDK & INSTRUMENTATION                              │ │
│  │ ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │ │
│  │ │   Traces    │  │   Metrics   │  │    Logs     │  │  Context    │        │ │
│  │ │ Generation  │  │ Collection  │  │ Correlation │  │ Propagation │        │ │
│  │ └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │ │
│  └─────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
OTEL COLLECTOR
┌─────────────────────────────────────────────────────────────────────────────────┐
│ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐       │
│ │  RECEIVERS  │───▶│ PROCESSORS  │───▶│ EXPORTERS   │    │ EXTENSIONS  │       │
│ │             │    │             │    │             │    │             │       │
│ │ • OTLP      │    │ • Batch     │    │ • Jaeger    │    │ • Health    │       │
│ │ • Prometheus│    │ • Memory    │    │ • Prometheus│    │ • Profiling │       │
│ │ • Kafka     │    │ • Attributes│    │ • Kafka     │    │ • Ballast   │       │
│ └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘       │
└─────────────────────────────────────────────────────────────────────────────────┘
                                         │
                                         ▼
BACKEND SYSTEMS
┌─────────────────────────────────────────────────────────────────────────────────┐
│ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐       │
│ │   Jaeger    │    │ Prometheus  │    │Elasticsearch│    │   Custom    │       │
│ │  (Tracing)  │    │ (Metrics)   │    │   (Logs)    │    │  Systems    │       │
│ └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘       │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Практическое внедрение OpenTelemetry

#### 1. Подготовка среды

```bash
# Создание namespace для OpenTelemetry
kubectl create namespace opentelemetry

# Установка OpenTelemetry Operator
kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml
```

#### 2. Конфигурация Collector

```yaml
# otel-collector-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: otel-collector-config
  namespace: opentelemetry
data:
  config.yaml: |
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
          http:
            endpoint: 0.0.0.0:4318
      
      prometheus:
        config:
          scrape_configs:
            - job_name: 'otel-collector'
              static_configs:
                - targets: ['localhost:8888']
    
    processors:
      batch:
        timeout: 1s
        send_batch_size: 1024
      
      memory_limiter:
        limit_mib: 512
    
    exporters:
      jaeger:
        endpoint: jaeger:14250
        tls:
          insecure: true
      
      prometheus:
        endpoint: "0.0.0.0:8889"
      
      logging:
        loglevel: debug
    
    service:
      pipelines:
        traces:
          receivers: [otlp]
          processors: [memory_limiter, batch]
          exporters: [jaeger, logging]
        
        metrics:
          receivers: [otlp, prometheus]
          processors: [memory_limiter, batch]
          exporters: [prometheus, logging]
```

#### 3. Инструментация приложения (Python)

```python
# app.py
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.instrumentation.flask import FlaskInstrumentor
from opentelemetry.instrumentation.requests import RequestsInstrumentor
from flask import Flask

# Настройка трейсинга
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# Экспорт в OTEL Collector
otlp_exporter = OTLPSpanExporter(
    endpoint="http://otel-collector:4317",
    insecure=True
)
span_processor = BatchSpanProcessor(otlp_exporter)
trace.get_tracer_provider().add_span_processor(span_processor)

# Инициализация Flask
app = Flask(__name__)

# Автоматическая инструментация
FlaskInstrumentor().instrument_app(app)
RequestsInstrumentor().instrument()

@app.route('/api/users/<user_id>')
def get_user(user_id):
    with tracer.start_as_current_span("get_user_data") as span:
        span.set_attribute("user.id", user_id)
        
        # Симуляция работы с базой данных
        user_data = fetch_user_from_db(user_id)
        
        # Добавление метрики
        span.set_attribute("user.found", user_data is not None)
        
        return user_data

def fetch_user_from_db(user_id):
    with tracer.start_as_current_span("database_query") as span:
        span.set_attribute("db.statement", f"SELECT * FROM users WHERE id = {user_id}")
        span.set_attribute("db.type", "postgresql")
        
        # Симуляция запроса
        import time
        time.sleep(0.05)  # Имитация задержки БД
        
        return {"id": user_id, "name": "John Doe"}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

---

## 🎯 Distributed Tracing

### Понимание распределенных трейсов

```
DISTRIBUTED TRACE FLOW:

Request ID: abc123
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│  [Client] ───────────────────────────────────────────────────────────────────▶ │
│     │                                                                           │
│     ▼                                                                           │
│  [API Gateway] ──────────────┐                                                 │
│     │                        │                                                 │
│     ▼                        ▼                                                 │
│  [Auth Service]           [Rate Limiter]                                       │
│     │                        │                                                 │
│     ▼                        ▼                                                 │
│  [User Service] ─────────────┐                                                 │
│     │                        │                                                 │
│     ▼                        ▼                                                 │
│  [Database]               [Cache]                                              │
│     │                        │                                                 │
│     ▼                        ▼                                                 │
│  [Response] ◀────────────────┘                                                 │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

TRACE TIMELINE:
0ms    ─────────────────────────────────────────────────────────────────────▶ 250ms
│      │     │     │     │     │     │     │     │     │     │     │     │     │
│      │     │     │     │     │     │     │     │     │     │     │     │     │
├─API Gateway────────────────────────────────────────────────────────────────────┤
│      ├─Auth Service────────────────┤                                           │
│      │     ├─Rate Limiter─────┤                                               │
│      │     │     ├─User Service──────────────────────────────────────────────┤
│      │     │     │     ├─Database─────────────┤                               │
│      │     │     │     │     ├─Cache────┤                                     │
│      │     │     │     │     │     │     │     │     │     │     │     │     │
0ms   25ms  50ms  75ms  100ms 125ms 150ms 175ms 200ms 225ms 250ms 275ms 300ms
```

### Анализ трейсов

```
TRACE ANALYSIS DASHBOARD:

┌─────────────────────────────────────────────────────────────────────────────────┐
│ Service Map                                                                     │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│     [Frontend]                                                                  │
│         │                                                                       │
│         ▼                                                                       │
│     [API Gateway] ──────────────────────┐                                      │
│         │                               │                                      │
│         ▼                               ▼                                      │
│     [Auth Service]                  [User Service]                             │
│         │                               │                                      │
│         ▼                               ▼                                      │
│     [Auth DB]                      [User DB] ──────▶ [Cache]                  │
│                                                                                 │
│ Метрики:                                                                        │
│ • Requests/sec: 1,234                                                          │
│ • P95 Latency: 245ms                                                           │
│ • Error Rate: 0.1%                                                             │
│ • Services: 6                                                                  │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│ Trace Details                                                                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ Trace ID: abc123-def456-ghi789                                                 │
│ Duration: 247ms                                                                │
│ Services: 6                                                                    │
│ Spans: 12                                                                      │
│                                                                                 │
│ Критический путь:                                                              │
│ ┌─────────────────────────────────────────────────────────────────────────────┐ │
│ │ API Gateway → Auth Service → User Service → Database                        │ │
│ │     15ms    →     45ms     →     25ms     →   162ms                        │ │
│ └─────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
│ Потенциальные проблемы:                                                        │
│ ⚠️  Database query слишком медленный (162ms)                                   │
│ ⚠️  Auth Service имеет высокую вариативность латенции                          │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔥 Chaos Engineering и мониторинг

### Принципы Chaos Engineering

```
CHAOS ENGINEERING WORKFLOW:

1. STEADY STATE
┌─────────────────────────────────────────────────────────────────────────────────┐
│ Определение нормального состояния системы                                       │
│ • SLI метрики в пределах нормы                                                  │
│ • Пользователи получают ожидаемый опыт                                         │
│ • Бизнес-метрики стабильны                                                     │
└─────────────────────────────────────────────────────────────────────────────────┘
                                    ▼
2. HYPOTHESIS
┌─────────────────────────────────────────────────────────────────────────────────┐
│ Формулирование гипотезы о поведении системы при отказах                        │
│ "Если откажет сервис аутентификации, система продолжит работу                   │
│  в degraded режиме с кэшированными токенами"                                    │
└─────────────────────────────────────────────────────────────────────────────────┘
                                    ▼
3. INJECT FAILURE
┌─────────────────────────────────────────────────────────────────────────────────┐
│ Внесение контролируемых отказов                                                 │
│ • Отключение сервисов                                                          │
│ • Увеличение латенции                                                          │
│ • Потребление ресурсов                                                         │
│ • Сетевые проблемы                                                             │
└─────────────────────────────────────────────────────────────────────────────────┘
                                    ▼
4. OBSERVE & LEARN
┌─────────────────────────────────────────────────────────────────────────────────┐
│ Мониторинг поведения системы                                                    │
│ • Подтверждение или опровержение гипотезы                                      │
│ • Выявление слабых мест                                                        │
│ • Улучшение мониторинга                                                        │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Практический пример с Chaos Monkey

```yaml
# chaos-experiment.yaml
apiVersion: chaos-mesh.org/v1alpha1
kind: PodChaos
metadata:
  name: auth-service-chaos
  namespace: production
spec:
  selector:
    namespaces:
      - default
    labelSelectors:
      app: auth-service
  
  mode: one
  action: pod-kill
  
  duration: "60s"
  
  scheduler:
    cron: "0 10 * * MON-FRI"  # Каждый будний день в 10:00
```

### Мониторинг во время Chaos экспериментов

```
CHAOS EXPERIMENT MONITORING:

┌─────────────────────────────────────────────────────────────────────────────────┐
│ Experiment: Auth Service Failure                                               │
│ Status: RUNNING                                                                │
│ Duration: 03:42 / 05:00                                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ KEY METRICS:                                                                    │
│ ┌─────────────────────┬─────────────────────┬─────────────────────────────────┐ │
│ │ Metric             │ Before Chaos        │ During Chaos                    │ │
│ ├─────────────────────┼─────────────────────┼─────────────────────────────────┤ │
│ │ Request Rate       │ 1,234 req/sec       │ 1,156 req/sec ↓6.3%           │ │
│ │ Success Rate       │ 99.8%               │ 97.2% ↓2.6%                    │ │
│ │ P95 Latency        │ 245ms               │ 1,234ms ↑404%                  │ │
│ │ Error Rate         │ 0.2%                │ 2.8% ↑2.6%                     │ │
│ │ Active Users       │ 15,678              │ 14,892 ↓5.0%                   │ │
│ └─────────────────────┴─────────────────────┴─────────────────────────────────┘ │
│                                                                                 │
│ CIRCUIT BREAKERS:                                                              │
│ ┌─────────────────────┬─────────────────────┬─────────────────────────────────┐ │
│ │ Service            │ Status              │ Fallback Active                 │ │
│ ├─────────────────────┼─────────────────────┼─────────────────────────────────┤ │
│ │ User Service       │ 🟡 DEGRADED         │ ✅ Cache serving               │ │
│ │ Payment Service    │ 🟢 HEALTHY          │ ❌ Not needed                  │ │
│ │ Notification       │ 🔴 FAILING          │ ❌ Queue overflow              │ │
│ └─────────────────────┴─────────────────────┴─────────────────────────────────┘ │
│                                                                                 │
│ ISSUES DISCOVERED:                                                             │
│ 🚨 Notification service doesn't have proper fallback                          │
│ ⚠️  Payment service shows increased latency                                    │
│ ℹ️  Cache hit rate increased from 85% to 94%                                  │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 💡 Практическое задание 6.1

**Цель:** Внедрить OpenTelemetry в микросервисное приложение

### Задание:
1. Развернуть тестовое приложение с 3 микросервисами
2. Настроить OpenTelemetry Collector
3. Инструментировать приложения для сбора трейсов
4. Провести Chaos эксперимент
5. Проанализировать результаты

### Критерии успеха:
- [ ] Все сервисы отправляют трейсы
- [ ] Визуализация service map
- [ ] Успешный chaos эксперимент
- [ ] Документированы найденные проблемы

---

# 🤖 Глава 6.2: AI/ML в мониторинге

## Эволюция интеллектуального мониторинга

```
EVOLUTION OF INTELLIGENT MONITORING:

2000s: STATIC THRESHOLDS
┌─────────────────────────────────────────────────────────────────────────────────┐
│ IF cpu_usage > 80% THEN alert                                                  │
│ ┌─────────────────────────────────────────────────────────────────────────────┐ │
│ │ Problems:                                                                   │ │
│ │ • Много ложных срабатываний                                                 │ │
│ │ • Не учитывает контекст                                                     │ │
│ │ • Требует постоянной настройки                                             │ │
│ └─────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘
                                    ▼
2010s: DYNAMIC THRESHOLDS
┌─────────────────────────────────────────────────────────────────────────────────┐
│ IF cpu_usage > (average_last_7_days + 2*std_dev) THEN alert                    │
│ ┌─────────────────────────────────────────────────────────────────────────────┐ │
│ │ Improvements:                                                               │ │
│ │ • Учитывает исторические данные                                            │ │
│ │ • Автоматическая корректировка                                             │ │
│ │ • Меньше ложных срабатываний                                               │ │
│ └─────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘
                                    ▼
2020s: AI/ML BASED MONITORING
┌─────────────────────────────────────────────────────────────────────────────────┐
│ Machine Learning Model analyzes patterns and predicts anomalies                │
│ ┌─────────────────────────────────────────────────────────────────────────────┐ │
│ │ Capabilities:                                                               │ │
│ │ • Обнаружение сложных паттернов                                            │ │
│ │ • Предсказание проблем                                                     │ │
│ │ • Корреляционный анализ                                                    │ │
│ │ • Автоматическое обучение                                                  │ │
│ └─────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 🔍 Anomaly Detection

### Типы аномалий

```
TYPES OF ANOMALIES:

1. POINT ANOMALIES (Выбросы)
   ┌─────────────────────────────────────────────────────────────────────────────┐
   │ Metrics                                                                     │
   │    ▲                                                                        │
   │    │                                                                        │
   │ 100│                                    ●  ← Аномальный пик                │
   │    │                                   ╱│╲                                 │
   │  80│ ●     ●     ●     ●     ●     ●  ╱ │ ╲ ●     ●     ●                  │
   │    │  ╲   ╱ ╲   ╱ ╲   ╱ ╲   ╱ ╲   ╱ ╲   │  ╲   ╱ ╲   ╱ ╲   ╱             │
   │  60│   ╲ ╱   ╲ ╱   ╲ ╱   ╲ ╱   ╲ ╱   ╲  │   ╲ ╱   ╲ ╱   ╲ ╱               │
   │    │    ●     ●     ●     ●     ●     ●│    ●     ●     ●                  │
   │    └────────────────────────────────────┼─────────────────────────────────▶ │
   │                                        Time                                │
   └─────────────────────────────────────────────────────────────────────────────┘

2. CONTEXTUAL ANOMALIES (Контекстные)
   ┌─────────────────────────────────────────────────────────────────────────────┐
   │ CPU Usage                                                                   │
   │    ▲                                                                        │
   │    │     Day Pattern        Night Pattern                                   │
   │ 100│   ●─────●─────●       ●─────●─────●                                    │
   │    │  ╱       ╲   ╱       ╱       ╲   ╱                                     │
   │  80│ ╱         ╲ ╱       ╱         ╲ ╱                                      │
   │    │╱           ●       ╱           ●                                       │
   │  60│                  ╱                                                     │
   │    │                 ╱                                                      │
   │  40│                ╱                                                       │
   │    │               ╱                                                        │
   │  20│              ╱                                                         │
   │    │             ●  ← Аномально высокая нагрузка ночью                     │
   │    └─────────────────────────────────────────────────────────────────────▶ │
   │                                                                    Time    │
   └─────────────────────────────────────────────────────────────────────────────┘

3. COLLECTIVE ANOMALIES (Коллективные)
   ┌─────────────────────────────────────────────────────────────────────────────┐
   │ Response Time                                                               │
   │    ▲                                                                        │
   │    │                                                                        │
   │ 500│                           ●●●●●●●●●●●●●●●●●●  ← Аномальный период       │
   │    │                          ╱                ╲                            │
   │ 400│                         ╱                  ╲                           │
   │    │                        ╱                    ╲                          │
   │ 300│                       ╱                      ╲                         │
   │    │                      ╱                        ╲                        │
   │ 200│ ●●●●●●●●●●●●●●●●●●●●●●                          ●●●●●●●●●●●●●●●●●●●●●● │
   │    │                                                                        │
   │ 100│                                                                        │
   │    └─────────────────────────────────────────────────────────────────────▶ │
   │                                                                    Time    │
   └─────────────────────────────────────────────────────────────────────────────┘
```

### Алгоритмы обнаружения аномалий

```
ANOMALY DETECTION ALGORITHMS:

┌─────────────────────────────────────────────────────────────────────────────────┐
│ STATISTICAL METHODS                                                             │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ 1. Z-Score (Standard Deviation)                                                │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ z = (x - μ) / σ                                                         │ │
│    │ IF |z| > threshold THEN anomaly                                         │ │
│    │                                                                         │ │
│    │ Pros: Простой, быстрый                                                  │ │
│    │ Cons: Требует нормального распределения                                 │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
│ 2. Interquartile Range (IQR)                                                  │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ IQR = Q3 - Q1                                                           │ │
│    │ Outliers: < Q1 - 1.5*IQR OR > Q3 + 1.5*IQR                            │ │
│    │                                                                         │ │
│    │ Pros: Не требует нормального распределения                              │ │
│    │ Cons: Статический подход                                                │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│ MACHINE LEARNING METHODS                                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ 1. Isolation Forest                                                            │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ • Изолирует аномалии путем случайного разделения                        │ │
│    │ • Аномалии требуют меньше разделений                                    │ │
│    │ • Хорошо работает с высокоразмерными данными                            │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
│ 2. One-Class SVM                                                              │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ • Обучается только на "нормальных" данных                               │ │
│    │ • Создает границу вокруг нормального поведения                          │ │
│    │ • Хорошо для сложных паттернов                                          │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
│ 3. Autoencoders                                                               │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ • Нейронные сети для сжатия и восстановления данных                     │ │
│    │ • Аномалии плохо восстанавливаются                                      │ │
│    │ • Отлично для временных рядов                                           │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│ TIME SERIES SPECIFIC                                                            │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ 1. ARIMA (AutoRegressive Integrated Moving Average)                            │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ • Моделирует временные ряды                                             │ │
│    │ • Предсказывает будущие значения                                        │ │
│    │ • Отклонения от прогноза = аномалии                                     │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
│ 2. LSTM (Long Short-Term Memory)                                               │
│    ┌─────────────────────────────────────────────────────────────────────────┐ │
│    │ • Рекуррентные нейронные сети                                           │ │
│    │ • Учитывают долгосрочные зависимости                                    │ │
│    │ • Хорошо для сложных паттернов                                          │ │
│    └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 📊 Практическая реализация ML-мониторинга

### Система обнаружения аномалий с Prometheus

```python
# anomaly_detector.py
import numpy as np
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
from prometheus_client import start_http_server, Counter, Histogram, Gauge
import time
import requests
from datetime import datetime, timedelta

class PrometheusAnomalyDetector:
    def __init__(self, prometheus_url="http://localhost:9090"):
        self.prometheus_url = prometheus_url
        self.model = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
        
        # Prometheus метрики
        self.anomaly_counter = Counter('anomalies_detected_total', 
                                     'Total anomalies detected', 
                                     ['metric_name', 'severity'])
        self.anomaly_score = Gauge('anomaly_score', 
                                  'Anomaly score for metrics', 
                                  ['metric_name'])
        
    def fetch_metrics(self, query, days=7):
        """Получение метрик из Prometheus"""
        end_time = datetime.now()
        start_time = end_time - timedelta(days=days)
        
        params = {
            'query': query,
            'start': start_time.isoformat(),
            'end': end_time.isoformat(),
            'step': '5m'
        }
        
        response = requests.get(f"{self.prometheus_url}/api/v1/query_range", 
                               params=params)
        return response.json()
    
    def prepare_features(self, data):
        """Подготовка признаков для ML модели"""
        df = pd.DataFrame(data)
        
        # Основные статистические признаки
        features = []
        for window in [5, 10, 30]:  # окна в минутах
            features.extend([
                df['value'].rolling(window=window).mean(),
                df['value'].rolling(window=window).std(),
                df['value'].rolling(window=window).min(),
                df['value'].rolling(window=window).max(),
            ])
        
        # Временные признаки
        df['hour'] = df['timestamp'].dt.hour
        df['day_of_week'] = df['timestamp'].dt.dayofweek
        df['is_weekend'] = df['day_of_week'].isin([5, 6]).astype(int)
        
        features.extend([
            df['hour'],
            df['day_of_week'],
            df['is_weekend']
        ])
        
        # Тренд и сезонность
        fea