# Блок 3: Нелинейные структуры данных

---

**⏱️ Длительность:** 4-5 недель  
**🎯 Цель:** Изучить иерархические и сетевые структуры для сложной организации данных

---

## 📋 Содержание блока

```
Блок 3: Нелинейные структуры данных
├── 3.1 Деревья
│   ├── Бинарные деревья поиска
│   ├── Обходы деревьев
│   ├── Сбалансированные деревья
│   └── B-деревья
├── 3.2 Кучи и приоритетные очереди
│   ├── Двоичные кучи
│   ├── Биномиальные кучи
│   └── Фибоначчиевы кучи
├── 3.3 Графы
│   ├── Представление графов
│   ├── Алгоритмы поиска
│   └── Кратчайшие пути
└── 3.4 Хеш-таблицы
    ├── Функции хеширования
    ├── Разрешение коллизий
    └── Динамическое изменение размера
```

---

## 🌳 Глава 3.1: Деревья

### Введение в деревья

Дерево - это нелинейная иерархическая структура данных, состоящая из узлов, связанных ребрами.

```
Основные термины:
┌─────────────────────────────────────────┐
│  Root (Корень)                          │
│    ├── Child (Дочерний)                 │
│    │   ├── Leaf (Лист)                  │
│    │   └── Leaf                         │
│    └── Child                            │
│        ├── Subtree (Поддерево)          │
│        └── Subtree                      │
│                                         │
│  Height (Высота): максимальный путь     │
│  Depth (Глубина): расстояние от корня   │
│  Level (Уровень): все узлы на глубине n │
└─────────────────────────────────────────┘
```

### Бинарные деревья поиска (BST)

**Свойство BST:** Для каждого узла все значения в левом поддереве меньше значения узла, а все значения в правом поддереве больше.

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

Поиск элемента 6:
8 → 3 → 6 ✓
```

#### Реализация базовых операций

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BST {
private:
    TreeNode* root;
    
    TreeNode* insert(TreeNode* node, int val) {
        if (!node) return new TreeNode(val);
        
        if (val < node->val)
            node->left = insert(node->left, val);
        else if (val > node->val)
            node->right = insert(node->right, val);
            
        return node;
    }
    
    TreeNode* search(TreeNode* node, int val) {
        if (!node || node->val == val) return node;
        
        return (val < node->val) ? 
               search(node->left, val) : 
               search(node->right, val);
    }
};
```

**Сложность операций:**
```
┌──────────┬─────────────┬──────────────┐
│ Операция │ Лучший случай│ Худший случай │
├──────────┼─────────────┼──────────────┤
│ Поиск    │ O(log n)    │ O(n)         │
│ Вставка  │ O(log n)    │ O(n)         │
│ Удаление │ O(log n)    │ O(n)         │
└──────────┴─────────────┴──────────────┘
```

### Обходы деревьев

```
      Дерево:    1
                / \
               2   3
              / \
             4   5

┌─────────────────────────────────────────┐
│ In-order (Симметричный):                │
│ Левое поддерево → Корень → Правое       │
│ Результат: 4, 2, 5, 1, 3               │
│                                         │
│ Pre-order (Прямой):                     │
│ Корень → Левое поддерево → Правое       │
│ Результат: 1, 2, 4, 5, 3               │
│                                         │
│ Post-order (Обратный):                  │
│ Левое поддерево → Правое → Корень       │
│ Результат: 4, 5, 2, 3, 1               │
└─────────────────────────────────────────┘
```

### Сбалансированные деревья

#### AVL дерево

**Свойство:** Для каждого узла высоты левого и правого поддеревьев различаются не более чем на 1.

```
Вращения в AVL дереве:

Левое вращение (Left Rotation):
    y                x
   / \              / \
  x   C    --->    A   y
 / \                  / \
A   B                B   C

Правое вращение (Right Rotation):
  x                  y
 / \                / \
y   C    --->      A   x
/ \                   / \
A   B                B   C
```

#### Red-Black дерево

**Свойства:**
1. Каждый узел либо красный, либо черный
2. Корень черный
3. Все листья (NIL) черные
4. Красный узел имеет только черных детей
5. Все пути от узла до листьев содержат одинаковое количество черных узлов

```
Пример Red-Black дерева:
       B(13)
      /     \
   R(8)    B(17)
   /  \       \
B(1) B(11)   R(25)
              /
           B(22)

B = Black, R = Red
```

---

## 🔺 Глава 3.2: Кучи и приоритетные очереди

### Двоичная куча (Binary Heap)

**Свойства кучи:**
- Структурное свойство: полное бинарное дерево
- Порядковое свойство: каждый родитель ≥ детей (max-heap) или ≤ детей (min-heap)

```
Max-Heap:           Min-Heap:
     16                 1
   /    \             /   \
  14     10          3     6
 / \    /  \        / \   / \
4   8  7    9      5   9 8   10

Представление в массиве:
Max-Heap: [16, 14, 10, 4, 8, 7, 9]
Индексы:   0   1   2  3  4  5  6

Для элемента с индексом i:
├── Родитель: (i-1)/2
├── Левый ребенок: 2*i+1  
└── Правый ребенок: 2*i+2
```

#### Операции с кучей

```cpp
class MaxHeap {
private:
    vector<int> heap;
    
    void heapifyUp(int index) {
        if (index == 0) return;
        
        int parent = (index - 1) / 2;
        if (heap[parent] < heap[index]) {
            swap(heap[parent], heap[index]);
            heapifyUp(parent);
        }
    }
    
    void heapifyDown(int index) {
        int largest = index;
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        
        if (left < heap.size() && heap[left] > heap[largest])
            largest = left;
        if (right < heap.size() && heap[right] > heap[largest])
            largest = right;
            
        if (largest != index) {
            swap(heap[index], heap[largest]);
            heapifyDown(largest);
        }
    }
    
public:
    void insert(int val) {
        heap.push_back(val);
        heapifyUp(heap.size() - 1);
    }
    
    int extractMax() {
        if (heap.empty()) throw runtime_error("Heap is empty");
        
        int max = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        heapifyDown(0);
        return max;
    }
};
```

### Биномиальные кучи

```
Биномиальные деревья:
B₀:    ●

B₁:    ●
       |
       ●

B₂:    ●
      / \
     ●   ●
         |
         ●

B₃:    ●
      /|\
     ● ● ●
    /|   |
   ● ●   ●
         |
         ●

Свойства:
- Bₖ имеет 2ᵏ узлов
- Высота Bₖ равна k
- Корень Bₖ имеет степень k
```

---

## 🌐 Глава 3.3: Графы

### Представление графов

```
Граф:     A ──── B
          |    / |
          |   /  |
          |  /   |
          | /    |
          C ──── D

┌─────────────────────────────────────────┐
│ Матрица смежности:                      │
│     A  B  C  D                          │
│ A [ 0  1  1  0 ]                        │
│ B [ 1  0  1  1 ]                        │
│ C [ 1  1  0  1 ]                        │
│ D [ 0  1  1  0 ]                        │
│                                         │
│ Списки смежности:                       │
│ A: [B, C]                               │
│ B: [A, C, D]                            │
│ C: [A, B, D]                            │
│ D: [B, C]                               │
└─────────────────────────────────────────┘
```

**Сравнение представлений:**
```
┌─────────────────┬──────────────┬─────────────────┐
│ Операция        │ Матрица      │ Списки          │
├─────────────────┼──────────────┼─────────────────┤
│ Память          │ O(V²)        │ O(V + E)        │
│ Добавить ребро  │ O(1)         │ O(1)            │
│ Удалить ребро   │ O(1)         │ O(degree)       │
│ Проверить ребро │ O(1)         │ O(degree)       │
│ Найти соседей   │ O(V)         │ O(degree)       │
└─────────────────┴──────────────┴─────────────────┘
```

### Алгоритмы поиска

#### Поиск в ширину (BFS)

```
Процесс BFS:
Граф:    A ──── B ──── E
         |      |
         |      |
         C ──── D

Шаг 1: Очередь: [A]           Посещено: {A}
Шаг 2: Очередь: [B, C]        Посещено: {A, B, C}
Шаг 3: Очередь: [C, E, D]     Посещено: {A, B, C, E, D}
Шаг 4: Очередь: [E, D]        Посещено: {A, B, C, E, D}
...

Результат: A → B → C → E → D
```

#### Поиск в глубину (DFS)

```cpp
void dfs(vector<vector<int>>& graph, int start, vector<bool>& visited) {
    visited[start] = true;
    cout << start << " ";
    
    for (int neighbor : graph[start]) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}
```

### Алгоритм Дейкстры

```
Поиск кратчайшего пути:

Граф:      A ──5── B
          /|       |\
         2 |       | 1
        /  3       |  \
       C ──4──── D ──2── E

Процесс алгоритма Дейкстры от A:

┌──────┬─────┬─────┬─────┬─────┬─────┐
│ Шаг  │  A  │  B  │  C  │  D  │  E  │
├──────┼─────┼─────┼─────┼─────┼─────┤
│  0   │  0  │  ∞  │  ∞  │  ∞  │  ∞  │
│  1   │  0* │  5  │  2  │  3  │  ∞  │
│  2   │  0* │  5  │  2* │  3  │  ∞  │
│  3   │  0* │  5  │  2* │  3* │  5  │
│  4   │  0* │  5* │  2* │  3* │  5  │
│  5   │  0* │  5* │  2* │  3* │  5* │
└──────┴─────┴─────┴─────┴─────┴─────┘

* = обработано
Кратчайшие пути: A→C:2, A→D:3, A→B:5, A→E:5
```

---

## # Глава 3.4: Хеш-таблицы

### Основы хеширования

```
Концепция хеш-таблицы:

Ключ → Хеш-функция → Индекс в массиве

Пример:
"apple"  → hash("apple")  → 3
"banana" → hash("banana") → 7
"cherry" → hash("cherry") → 1

Таблица:
┌───┬─────────┐
│ 0 │         │
│ 1 │ cherry  │
│ 2 │         │
│ 3 │ apple   │
│ 4 │         │
│ 5 │         │
│ 6 │         │
│ 7 │ banana  │
└───┴─────────┘
```

### Функции хеширования

```cpp
// Простая хеш-функция для строк
size_t simpleHash(const string& key, size_t tableSize) {
    size_t hash = 0;
    for (char c : key) {
        hash = (hash * 31 + c) % tableSize;
    }
    return hash;
}

// Более сложная: FNV-1a
size_t fnvHash(const string& key, size_t tableSize) {
    const size_t FNV_PRIME = 1099511628211ULL;
    const size_t FNV_OFFSET = 14695981039346656037ULL;
    
    size_t hash = FNV_OFFSET;
    for (char c : key) {
        hash ^= c;
        hash *= FNV_PRIME;
    }
    return hash % tableSize;
}
```

### Разрешение коллизий

#### Метод цепочек

```
Коллизии: "john" и "jane" попадают в индекс 2

┌───┬─────────────────────────────┐
│ 0 │                             │
│ 1 │ "bob" → null                │
│ 2 │ "john" → "jane" → null      │
│ 3 │ "alice" → null              │
│ 4 │                             │
└───┴─────────────────────────────┘

Поиск "jane":
1. hash("jane") = 2
2. Идем по цепочке: "john" ≠ "jane", "jane" = "jane" ✓
```

#### Открытая адресация

```
Линейное зондирование:
Вставляем "john" (hash = 2), но индекс 2 занят

┌───┬─────────┐      ┌───┬─────────┐
│ 0 │         │      │ 0 │         │
│ 1 │ "bob"   │  →   │ 1 │ "bob"   │
│ 2 │ "alice" │      │ 2 │ "alice" │
│ 3 │         │      │ 3 │ "john"  │ ← вставили сюда
│ 4 │         │      │ 4 │         │
└───┴─────────┘      └───┴─────────┘

Квадратичное зондирование:
Проверяем позиции: hash + 1², hash + 2², hash + 3²...

Двойное хеширование:
Используем вторую хеш-функцию для вычисления шага
```

### Динамическое изменение размера

```
Load Factor = количество элементов / размер таблицы

┌────────────────┬─────────────────────────────┐
│ Load Factor    │ Производительность          │
├────────────────┼─────────────────────────────┤
│ < 0.5          │ Отличная, много свободного  │
│                │ места                       │
│ 0.5 - 0.75     │ Хорошая                     │
│ 0.75 - 0.9     │ Приемлемая                  │
│ > 0.9          │ Плохая, много коллизий      │
└────────────────┴─────────────────────────────┘

Процесс rehashing:
1. Создать новую таблицу (обычно в 2 раза больше)
2. Пересчитать хеши для всех элементов
3. Переместить элементы в новую таблицу
4. Заменить старую таблицу новой
```

---

## 📋 Практические задания

### Задание 1: Файловая система на основе B-дерева

```
Цель: Реализовать простую файловую систему

Требования:
├── Поддержка операций: создать, удалить, найти файл
├── Эффективный поиск по имени файла
├── Поддержка директорий
└── Метаданные файлов (размер, дата создания)

Структура файла:
┌──────────────────────────────────────┐
│ struct FileEntry {                   │
│     string name;                     │
│     bool isDirectory;                │
│     size_t size;                     │
│     time_t created;                  │
│     vector<FileEntry> children;      │
│ };                                   │
└──────────────────────────────────────┘
```

### Задание 2: Социальная сеть с алгоритмами поиска

```
Возможности:
├── Добавление пользователей и связей
├── Поиск кратчайшего пути между пользователями
├── Поиск общих друзей
├── Рекомендации друзей
└── Поиск влиятельных пользователей

Метрики для анализа:
┌─────────────────────┬─────────────────────┐
│ Степень узла        │ Количество друзей   │
│ Кратчайший путь     │ Степень разделения  │
│ Кластеризация       │ Плотность сообщества│
│ Центральность       │ Влиятельность       │
└─────────────────────┴─────────────────────┘
```

### Задание 3: Кэш с LRU политикой

```cpp
class LRUCache {
private:
    struct Node {
        int key, value;
        Node* prev, *next;
        Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    int capacity;
    unordered_map<int, Node*> cache;
    Node* head, *tail;
    
    void addToHead(Node* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
public:
    LRUCache(int cap) : capacity(cap) {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        auto it = cache.find(key);
        if (it == cache.end()) return -1;
        
        Node* node = it->second;
        removeNode(node);
        addToHead(node);
        return node->value;
    }
};
```

---

## ✅ Итоговый результат блока

После изучения данного блока вы должны:

```
┌─────────────────────────────────────────────────────┐
│ ✓ Понимать принципы работы нелинейных структур      │
│ ✓ Уметь выбирать оптимальную структуру для задачи   │
│ ✓ Реализовывать деревья, графы и хеш-таблицы        │
│ ✓ Анализировать сложность операций                  │
│ ✓ Оптимизировать производительность структур        │
│ ✓ Применять алгоритмы поиска и сортировки           │
└─────────────────────────────────────────────────────┘
```

**Следующий этап:** Переход к блоку 4 "Оптимизация и продвинутые техники" для изучения методов повышения производительности.