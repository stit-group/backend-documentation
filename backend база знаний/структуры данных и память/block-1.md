# 📚 Блок 1: Основы памяти и базовые концепции

**⏱️ Длительность:** 4-6 недель  
**🎯 Цель:** Понять, как работает память компьютера и заложить фундамент для изучения структур данных

---

## 🏗️ Глава 1.1: Архитектура памяти компьютера

### 📋 Иерархия памяти

```
┌─────────────────────────────────────────────────┐
│                 ПРОЦЕССОР                       │
├─────────────────────────────────────────────────┤
│  Регистры (1-4 байта, ~1 такт)                 │
│  ├── Скорость: ~0.3 нс                         │
│  └── Размер: 32-64 регистра                    │
├─────────────────────────────────────────────────┤
│  L1 Кэш (32-64 КБ, ~1-3 такта)                │
│  ├── Скорость: ~1 нс                           │
│  └── Раздельный для данных и инструкций        │
├─────────────────────────────────────────────────┤
│  L2 Кэш (256 КБ - 1 МБ, ~10-20 тактов)        │
│  ├── Скорость: ~3-10 нс                        │
│  └── Общий для данных и инструкций             │
├─────────────────────────────────────────────────┤
│  L3 Кэш (2-32 МБ, ~40-75 тактов)              │
│  ├── Скорость: ~15-50 нс                       │
│  └── Разделяется между ядрами                  │
├─────────────────────────────────────────────────┤
│  ОЗУ (4-128 ГБ, ~200-300 тактов)              │
│  ├── Скорость: ~100 нс                         │
│  └── Основная рабочая память                   │
├─────────────────────────────────────────────────┤
│  SSD (256 ГБ - 8 ТБ)                           │
│  ├── Скорость: ~100 мкс                        │
│  └── Постоянное хранение                       │
├─────────────────────────────────────────────────┤
│  HDD (500 ГБ - 20 ТБ)                          │
│  ├── Скорость: ~10 мс                          │
│  └── Массовое хранение                         │
└─────────────────────────────────────────────────┘
```

### 🧩 Виртуальная память и страничная организация

**Концепция виртуальной памяти:**

```
Виртуальный адрес ──────┐
    (32/64 бита)        │
                        ▼
    ┌─────────────────────────┐
    │   Таблица страниц       │
    │  ┌─────┬─────┬─────┐    │
    │  │Page │Frame│Flags│    │
    │  │  0  │  3  │ R/W │    │
    │  │  1  │  7  │ R/W │    │
    │  │  2  │ N/A │  -  │    │ ← Страница не в памяти
    │  │  3  │  1  │ R/W │    │
    │  └─────┴─────┴─────┘    │
    └─────────────────────────┘
                        │
                        ▼
    ┌─────────────────────────┐
    │   Физическая память     │
    │  ┌─────────────────┐    │
    │  │    Frame 0      │    │
    │  ├─────────────────┤    │
    │  │    Frame 1      │ ◄─ Страница 3
    │  ├─────────────────┤    │
    │  │    Frame 2      │    │
    │  ├─────────────────┤    │
    │  │    Frame 3      │ ◄─ Страница 0
    │  ├─────────────────┤    │
    │  │      ...        │    │
    │  └─────────────────┘    │
    └─────────────────────────┘
```

**Размеры страниц:**
- x86: 4 КБ (стандарт), 2 МБ, 1 ГБ (huge pages)
- ARM: 4 КБ, 16 КБ, 64 КБ
- RISC-V: 4 КБ (стандарт)

---

## 🗂️ Организация памяти процесса

### 📊 Схема памяти процесса

```
Высокие адреса (0xFFFFFFFF)
┌─────────────────────────────────┐
│         СИСТЕМНАЯ ОБЛАСТЬ       │
│      (недоступна программе)     │
├─────────────────────────────────┤ ← 0xC0000000 (Linux)
│             СТЕК               │
│    ┌─────────────────────┐      │
│    │   Локальные         │      │
│    │   переменные        │      │ ↓ Растет вниз
│    │   Параметры функций │      │
│    │   Адреса возврата   │      │
│    └─────────────────────┘      │
├─────────────────────────────────┤
│                                 │
│         НЕИСПОЛЬЗУЕМАЯ          │
│           ОБЛАСТЬ               │
│                                 │
├─────────────────────────────────┤
│             КУЧА                │ ↑ Растет вверх
│    ┌─────────────────────┐      │
│    │   Динамически       │      │
│    │   выделенные        │      │
│    │   объекты           │      │
│    │   (malloc/new)      │      │
│    └─────────────────────┘      │
├─────────────────────────────────┤
│         BSS СЕГМЕНТ             │
│   (неинициализированные         │
│    глобальные переменные)       │
├─────────────────────────────────┤
│        DATA СЕГМЕНТ             │
│   (инициализированные           │
│    глобальные переменные)       │
├─────────────────────────────────┤
│        TEXT СЕГМЕНТ             │
│      (код программы)            │
│     [только для чтения]         │
└─────────────────────────────────┘
Низкие адреса (0x00000000)
```

### 💡 Пример кода для демонстрации сегментов

```c
#include <stdio.h>
#include <stdlib.h>

// DATA сегмент - инициализированные глобальные
int global_init = 42;
char string_literal[] = "Hello, World!";

// BSS сегмент - неинициализированные глобальные
int global_uninit;
static int static_uninit;

// TEXT сегмент - код функции
void demonstrate_memory() {
    // СТЕК - локальные переменные
    int local_var = 10;
    char local_array[100];
    
    // КУЧА - динамически выделенная память
    int* heap_ptr = malloc(sizeof(int) * 10);
    
    printf("Адреса в памяти:\n");
    printf("TEXT (функция):        %p\n", (void*)demonstrate_memory);
    printf("DATA (global_init):    %p\n", (void*)&global_init);
    printf("BSS (global_uninit):   %p\n", (void*)&global_uninit);
    printf("СТЕК (local_var):      %p\n", (void*)&local_var);
    printf("КУЧА (heap_ptr):       %p\n", (void*)heap_ptr);
    
    free(heap_ptr);
}
```

---

## 🔧 Глава 1.2: Указатели и ссылки

### 🎯 Концепция адресации памяти

```
Память как массив байтов:

Адрес:  0x1000  0x1001  0x1002  0x1003  0x1004  0x1005  0x1006  0x1007
       ┌───────┬───────┬───────┬───────┬───────┬───────┬───────┬───────┐
Байты: │  0x42 │  0x00 │  0x00 │  0x00 │  0x24 │  0x68 │  0x65 │  0x6C │
       └───────┴───────┴───────┴───────┴───────┴───────┴───────┴───────┘
         ↑                               ↑
    int value = 66              char str[] = "$hel"
    (4 байта, little-endian)    
```

### 🧮 Арифметика указателей

```c
int arr[] = {10, 20, 30, 40, 50};
int* ptr = arr;  // ptr указывает на arr[0]

// Визуализация массива в памяти:
// ┌────┬────┬────┬────┬────┐
// │ 10 │ 20 │ 30 │ 40 │ 50 │
// └────┴────┴────┴────┴────┘
//   ↑
//  ptr

printf("ptr:     %p, значение: %d\n", ptr, *ptr);        // arr[0] = 10
printf("ptr+1:   %p, значение: %d\n", ptr+1, *(ptr+1)); // arr[1] = 20
printf("ptr+2:   %p, значение: %d\n", ptr+2, *(ptr+2)); // arr[2] = 30

// Эквивалентные записи:
// ptr[i] == *(ptr + i) == *(i + ptr) == i[ptr]
```

### 🔗 Указатели на функции

```c
// Объявление типа указателя на функцию
typedef int (*operation_t)(int, int);

int add(int a, int b) { return a + b; }
int multiply(int a, int b) { return a * b; }

void demonstrate_function_pointers() {
    // Таблица функций
    operation_t operations[] = {add, multiply};
    char* names[] = {"сложение", "умножение"};
    
    for (int i = 0; i < 2; i++) {
        int result = operations[i](5, 3);
        printf("%s: %d\n", names[i], result);
    }
}
```

---

## 🏗️ Глава 1.3: Управление памятью

### 📍 Статическое vs Динамическое выделение

```
СТАТИЧЕСКОЕ ВЫДЕЛЕНИЕ:
┌─────────────────────────────────┐
│  Время компиляции               │
│  ┌─────────────────────────┐    │
│  │ int arr[100];           │    │ ← Размер известен заранее
│  │ char buffer[1024];      │    │
│  └─────────────────────────┘    │
│  Автоматическое освобождение    │
└─────────────────────────────────┘

ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ:
┌─────────────────────────────────┐
│  Время выполнения               │
│  ┌─────────────────────────┐    │
│  │ int* arr = malloc(      │    │ ← Размер определяется в runtime
│  │   sizeof(int) * size);  │    │
│  │ free(arr);              │    │ ← Ручное освобождение
│  └─────────────────────────┘    │
└─────────────────────────────────┘
```

### 🔄 Жизненный цикл динамической памяти

```c
#include <stdlib.h>

void memory_lifecycle_demo() {
    // 1. ВЫДЕЛЕНИЕ
    size_t size = 10;
    int* ptr = malloc(sizeof(int) * size);
    
    if (ptr == NULL) {
        // Обработка ошибки выделения
        fprintf(stderr, "Ошибка: не удалось выделить память\n");
        return;
    }
    
    // 2. ИСПОЛЬЗОВАНИЕ
    for (size_t i = 0; i < size; i++) {
        ptr[i] = i * i;  // Инициализация
    }
    
    // 3. ИЗМЕНЕНИЕ РАЗМЕРА (опционально)
    size = 20;
    int* new_ptr = realloc(ptr, sizeof(int) * size);
    if (new_ptr != NULL) {
        ptr = new_ptr;
        // Инициализация новых элементов
        for (size_t i = 10; i < size; i++) {
            ptr[i] = i * i;
        }
    }
    
    // 4. ОСВОБОЖДЕНИЕ
    free(ptr);
    ptr = NULL;  // Предотвращение dangling pointer
}
```

### ⚠️ Типичные ошибки управления памятью

```c
// ❌ УТЕЧКА ПАМЯТИ
void memory_leak() {
    int* ptr = malloc(sizeof(int) * 100);
    // Забыли вызвать free(ptr)!
    return;  // Память потеряна навсегда
}

// ❌ DOUBLE FREE
void double_free_error() {
    int* ptr = malloc(sizeof(int) * 10);
    free(ptr);
    free(ptr);  // ОШИБКА: повторное освобождение!
}

// ❌ USE AFTER FREE
void use_after_free() {
    int* ptr = malloc(sizeof(int) * 10);
    free(ptr);
    *ptr = 42;  // ОШИБКА: использование после освобождения!
}

// ❌ BUFFER OVERFLOW
void buffer_overflow() {
    int* ptr = malloc(sizeof(int) * 10);
    ptr[15] = 42;  // ОШИБКА: выход за границы!
    free(ptr);
}

// ✅ ПРАВИЛЬНЫЙ ПОДХОД
void correct_approach() {
    int* ptr = malloc(sizeof(int) * 10);
    if (ptr == NULL) return;
    
    // Безопасное использование
    for (int i = 0; i < 10; i++) {
        ptr[i] = i;
    }
    
    free(ptr);
    ptr = NULL;  // Обнуление указателя
}
```

---

## 📊 Глава 1.4: Анализ сложности алгоритмов

### 🎯 Big O нотация

```
O(1) - Константная сложность
┌─────────────────┐
│ time ═══════════ │  Независимо от размера входных данных
│                 │
│                 │
└─────────────────┘
     input size

O(log n) - Логарифмическая сложность
┌─────────────────┐
│ time      ╱╱╱╱  │  Бинарный поиск, сбалансированные деревья
│         ╱╱      │
│       ╱╱        │
│     ╱╱          │
└─────────────────┘
     input size

O(n) - Линейная сложность
┌─────────────────┐
│ time        ╱   │  Простой поиск, обход массива
│           ╱     │
│         ╱       │
│       ╱         │
└─────────────────┘
     input size

O(n log n) - Линейно-логарифмическая
┌─────────────────┐
│ time       ╱╱╱  │  Эффективная сортировка (merge sort, heap sort)
│         ╱╱╱     │
│      ╱╱╱        │
│   ╱╱╱           │
└─────────────────┘
     input size

O(n²) - Квадратичная сложность
┌─────────────────┐
│ time    ╱╱╱╱╱╱  │  Bubble sort, простые алгоритмы с вложенными циклами
│       ╱╱╱       │
│     ╱╱          │
│   ╱╱            │
└─────────────────┘
     input size

O(2ⁿ) - Экспоненциальная сложность
┌─────────────────┐
│ time        │   │  Перебор всех подмножеств, некоторые рекурсивные алгоритмы
│             │   │
│           ╱╱│   │
│         ╱╱  │   │
│       ╱╱    │   │
└─────────────────┘
     input size
```

### 🔍 Примеры анализа сложности

```c
// O(1) - Константная сложность
int get_first_element(int arr[], int size) {
    if (size > 0) {
        return arr[0];  // Одна операция независимо от размера
    }
    return -1;
}

// O(n) - Линейная сложность
int linear_search(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {  // В худшем случае n итераций
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

// O(log n) - Логарифмическая сложность
int binary_search(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        
        if (arr[mid] < target) {
            left = mid + 1;   // Исключаем половину элементов
        } else {
            right = mid - 1;  // Исключаем половину элементов
        }
    }
    return -1;
}

// O(n²) - Квадратичная сложность
void bubble_sort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {        // n итераций
        for (int j = 0; j < size - i - 1; j++) { // n итераций в худшем случае
            if (arr[j] > arr[j + 1]) {
                // Обмен элементов
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

### ⚡ Амортизированный анализ

```c
// Пример: динамический массив с удвоением размера
typedef struct {
    int* data;
    size_t size;      // Текущее количество элементов
    size_t capacity;  // Выделенная емкость
} dynamic_array_t;

void push_back(dynamic_array_t* arr, int value) {
    // Если нужно расширение
    if (arr->size >= arr->capacity) {
        size_t new_capacity = arr->capacity * 2;  // Удваиваем размер
        int* new_data = realloc(arr->data, new_capacity * sizeof(int));
        
        if (new_data == NULL) {
            // Обработка ошибки
            return;
        }
        
        arr->data = new_data;
        arr->capacity = new_capacity;
    }
    
    arr->data[arr->size++] = value;
}

/*
Анализ амортизированной сложности:
- Обычная вставка: O(1)
- Вставка с расширением: O(n) - копирование всех элементов
- Но расширение происходит редко: при размерах 1, 2, 4, 8, 16, 32...
- Амортизированная сложность: O(1)

Последовательность операций расширения:
Вставка 1: размер 1 → 2    (копируем 1 элемент)
Вставка 2: размер 2 → 4    (копируем 2 элемента)
Вставка 4: размер 4 → 8    (копируем 4 элемента)
Вставка 8: размер 8 → 16   (копируем 8 элементов)

Общая стоимость n вставок: n + 1 + 2 + 4 + 8 + ... ≤ n + 2n = 3n = O(n)
Амортизированная стоимость одной вставки: O(n)/n = O(1)
*/
```

---

## 🎯 Практические задания

### 📝 Задание 1: Простой аллокатор памяти

```c
#define POOL_SIZE 1024

typedef struct block {
    size_t size;
    int is_free;
    struct block* next;
} block_t;

static char memory_pool[POOL_SIZE];
static block_t* free_list = NULL;
static int initialized = 0;

void* simple_malloc(size_t size);
void simple_free(void* ptr);
void init_allocator();
```

### 📝 Задание 2: Детектор утечек памяти

```c
typedef struct allocation {
    void* ptr;
    size_t size;
    const char* file;
    int line;
    struct allocation* next;
} allocation_t;

// Макросы для отслеживания
#define TRACKED_MALLOC(size) tracked_malloc(size, __FILE__, __LINE__)
#define TRACKED_FREE(ptr) tracked_free(ptr, __FILE__, __LINE__)

void* tracked_malloc(size_t size, const char* file, int line);
void tracked_free(void* ptr, const char* file, int line);
void print_leaks();
```

### 📝 Задание 3: Бенчмарк производительности

```c
#include <time.h>

typedef struct {
    double time_taken;
    size_t operations;
    size_t memory_used;
} benchmark_result_t;

benchmark_result_t benchmark_algorithm(void (*func)(void), 
                                     const char* name, 
                                     int iterations);
```

---

## ✅ Контрольные вопросы

### 🤔 Теоретические вопросы:
1. Объясните разницу между физической и виртуальной памятью
2. Почему кэш L1 быстрее, но меньше по размеру, чем L3?
3. Что происходит при переполнении стека?
4. В чем разница между сегментацией и страничной организацией памяти?
5. Почему важно выравнивание данных в памяти?

### 💻 Практические задачи:
1. Напишите функцию, которая определяет, находится ли указатель в стеке или куче
2. Реализуйте функцию подсчета размера структуры с учетом padding
3. Создайте программу для демонстрации различных типов утечек памяти
4. Напишите бенчмарк для сравнения скорости доступа к разным уровням кэша

---

## 📚 Дополнительные ресурсы

### 📖 Рекомендуемая литература:
- "Computer Systems: A Programmer's Perspective" - Bryant & O'Hallaron
- "What Every Programmer Should Know About Memory" - Ulrich Drepper
- "Memory Management: Algorithms and Implementation in C/C++" - Bill Blunden

### 🔧 Полезные инструменты:
- **Valgrind** - детектор утечек памяти и ошибок
- **AddressSanitizer** - быстрый детектор ошибок памяти
- **Perf** - профилировщик производительности Linux
- **Intel VTune** - продвинутый профилировщик

### 🌐 Онлайн ресурсы:
- CPU Cache визуализация: https://www.7-cpu.com/
- Интерактивные примеры указателей: https://pythontutor.com/
- Memory Layout Explorer: https://godbolt.org/

---

## 🎖️ Критерии оценки блока

### Минимальный уровень (3/5):
- Понимание основных концепций памяти
- Умение работать с указателями
- Знание базовых принципов управления памятью

### Хороший уровень (4/5):
- Понимание иерархии памяти и оптимизации
- Навыки отладки проблем с памятью
- Анализ простых алгоритмов

### Отличный уровень (5/5):
- Глубокое понимание архитектуры памяти
- Способность оптимизировать код с учетом особенностей памяти
- Создание собственных инструментов для работы с памятью

---

**Переход к следующему блоку:** После успешного освоения основ памяти можно переходить к изучению линейных структур данных, которые строятся на этих фундаментальных принципах.