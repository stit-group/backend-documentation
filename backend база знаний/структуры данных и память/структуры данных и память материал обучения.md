# 🎯 Структуры данных для бэкенд-разработчика
## От новичка до эксперта

---

## 📋 О курсе

**Цель:** Понять, когда и зачем использовать каждую структуру данных  
**Подход:** Концепция → Визуализация → Код → Применение  
**Время:** 6-12 месяцев самостоятельного изучения

---

# 🏗️ ЧАСТЬ 1: ОСНОВЫ ПАМЯТИ

## 1.1 Как работает память

### Концепция
Память в программе - это как большой склад с адресами. Каждая "полка" имеет номер (адрес) и может хранить данные.

### Стек vs Куча

```
СТЕК (Stack)              КУЧА (Heap)
┌─────────────┐          ┌─────────────┐
│ func3()     │ ←─ top   │ [obj1]      │
├─────────────┤          │    [obj2]   │
│ func2()     │          │  [obj3]     │
├─────────────┤          │      [obj4] │
│ func1()     │          │ [obj5]      │
├─────────────┤          └─────────────┘
│ main()      │
└─────────────┘
```

**Стек:**
- Быстрый доступ
- Автоматическое освобождение
- Ограниченный размер
- LIFO (Last In, First Out)

**Куча:**
- Большой объем
- Ручное управление памятью
- Медленнее доступ
- Произвольный порядок

### Код
```python
# Стек - локальные переменные
def function():
    x = 10  # На стеке
    y = 20  # На стеке
    return x + y

# Куча - объекты
def create_list():
    big_list = [0] * 1000000  # В куче
    return big_list
```

### Применение в бэкенде
- **Стек:** Рекурсивные вызовы, локальные переменные
- **Куча:** Кэш данных, пользовательские сессии, большие объекты

---

# 📊 ЧАСТЬ 2: ЛИНЕЙНЫЕ СТРУКТУРЫ

## 2.1 Массивы (Arrays)

### Концепция
Массив - это последовательность элементов в памяти. Как дома на улице с номерами.

### Визуализация
```
Индексы:  0   1   2   3   4
         ┌───┬───┬───┬───┬───┐
Массив:  │ 5 │ 2 │ 8 │ 1 │ 9 │
         └───┴───┴───┴───┴───┘
Адреса: 100 104 108 112 116
```

**Доступ по индексу: O(1)**
```
arr[2] → сразу идем по адресу 100 + 2*4 = 108
```

**Вставка в середину: O(n)**
```
Вставить 7 в позицию 2:
До:  │ 5 │ 2 │ 8 │ 1 │ 9 │
     └───┴───┴───┴───┴───┘
           ↓ сдвигаем всё вправо
После: │ 5 │ 2 │ 7 │ 8 │ 1 │ 9 │
       └───┴───┴───┴───┴───┴───┘
```

### Код
```python
# Создание и основные операции
arr = [5, 2, 8, 1, 9]

# O(1) - доступ
value = arr[2]  # 8

# O(n) - поиск
def find_element(arr, target):
    for i, value in enumerate(arr):
        if value == target:
            return i
    return -1

# O(n) - вставка
arr.insert(2, 7)  # [5, 2, 7, 8, 1, 9]
```

### Применение в бэкенде
- **Кэш последних запросов** (фиксированный размер)
- **Batch обработка данных**
- **Конфигурационные списки**

### Когда использовать
✅ Нужен быстрый доступ по индексу  
✅ Редко изменяется размер  
❌ Частые вставки/удаления в середине

---

## 2.2 Связные списки (Linked Lists)

### Концепция
Элементы связаны указателями. Как цепочка, где каждое звено знает, где следующее.

### Визуализация
```
Односвязный список:
┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬────┐
│ 5 │ ●─┼──→│ 2 │ ●─┼──→│ 8 │ ●─┼──→│ 1 │null│
└───┴───┘   └───┴───┘   └───┴───┘   └───┴────┘
head

Двусвязный список:
┌────┬───┬───┐   ┌───┬───┬───┐   ┌───┬───┬────┐
│null│ 5 │ ●─┼──→│ ● │ 2 │ ●─┼──→│ ● │ 8 │null│
└────┴───┴───┘   └───┴───┴───┘   └───┴───┴────┘
      ↑             ↑               ↑
      └─────────────┘               │
            └───────────────────────┘
```

**Вставка в начало: O(1)**
```
Добавить 9:
┌───┬───┐   ┌───┬───┐
│ 9 │ ●─┼──→│ 5 │ ●─┼──→ ...
└───┴───┘   └───┴───┘
new_head    old_head
```

### Код
```python
class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    # O(1) - вставка в начало
    def prepend(self, val):
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
    
    # O(n) - поиск
    def find(self, val):
        current = self.head
        while current:
            if current.val == val:
                return current
            current = current.next
        return None
    
    # O(n) - удаление
    def delete(self, val):
        if not self.head:
            return
        
        if self.head.val == val:
            self.head = self.head.next
            return
        
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                return
            current = current.next
```

### Применение в бэкенде
- **История действий пользователя** (легко добавлять новые)
- **Playlist/очередь задач** (динамический размер)
- **Undo/Redo функциональность**

### Когда использовать
✅ Частые вставки/удаления в начале  
✅ Неизвестный размер данных  
❌ Нужен доступ по индексу  
❌ Нужен случайный доступ

---

## 2.3 Стеки (Stacks)

### Концепция
LIFO - Last In, First Out. Как стопка тарелок: берем всегда сверху.

### Визуализация
```
    push(4)         pop()
       ↓             ↑
┌─────────┐    ┌─────────┐
│    4    │ ←─ │ (empty) │ ← top
├─────────┤    ├─────────┤
│    3    │    │    3    │
├─────────┤    ├─────────┤
│    2    │    │    2    │
├─────────┤    ├─────────┤
│    1    │    │    1    │
└─────────┘    └─────────┘
```

### Код
```python
class Stack:
    def __init__(self):
        self.items = []
    
    # O(1)
    def push(self, item):
        self.items.append(item)
    
    # O(1)
    def pop(self):
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        return self.items.pop()
    
    # O(1)
    def peek(self):
        if self.is_empty():
            return None
        return self.items[-1]
    
    def is_empty(self):
        return len(self.items) == 0

# Пример: проверка скобок
def is_valid_parentheses(s):
    stack = Stack()
    pairs = {'(': ')', '[': ']', '{': '}'}
    
    for char in s:
        if char in pairs:  # открывающая скобка
            stack.push(char)
        elif char in pairs.values():  # закрывающая
            if stack.is_empty():
                return False
            if pairs[stack.pop()] != char:
                return False
    
    return stack.is_empty()

# "(())" → True, "([)]" → False
```

### Применение в бэкенде
- **Call stack** (вызовы функций)
- **Undo операции** в приложениях
- **Парсинг выражений** (калькуляторы, JSON)
- **Навигация по страницам** (browser history)

### Когда использовать
✅ Нужна LIFO логика  
✅ Временное хранение данных  
✅ Обработка вложенных структур

---

## 2.4 Очереди (Queues)

### Концепция
FIFO - First In, First Out. Как очередь в магазине: кто пришел первым, тот первым обслуживается.

### Визуализация
```
enqueue(4)                    dequeue()
    ↓                             ↑
┌─────────────────────┐    ┌─────────────────┐
│ 4 │ 3 │ 2 │ 1      │    │ 4 │ 3 │ 2      │
└─────────────────────┘    └─────────────────┘
  ↑                 ↑        ↑             ↑
rear              front    rear          front
```

### Код
```python
from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()
    
    # O(1)
    def enqueue(self, item):
        self.items.append(item)
    
    # O(1)
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Dequeue from empty queue")
        return self.items.popleft()
    
    def is_empty(self):
        return len(self.items) == 0

# Пример: BFS обход
def bfs_tree(root):
    if not root:
        return []
    
    result = []
    queue = Queue()
    queue.enqueue(root)
    
    while not queue.is_empty():
        node = queue.dequeue()
        result.append(node.val)
        
        if node.left:
            queue.enqueue(node.left)
        if node.right:
            queue.enqueue(node.right)
    
    return result
```

### Применение в бэкенде
- **Task queues** (Celery, RQ)
- **Message queues** (RabbitMQ, Apache Kafka)
- **Rate limiting** (обработка запросов)
- **Breadth-First Search** в графах

### Когда использовать
✅ Нужна FIFO обработка  
✅ Асинхронная обработка задач  
✅ Буферизация данных

---

# 🗂️ ЧАСТЬ 3: ХЕШИРОВАНИЕ

## 3.1 Хеш-таблицы (Hash Tables)

### Концепция
Превращаем ключи в индексы массива с помощью хеш-функции. Как телефонная книга: по имени быстро находим номер.

### Визуализация
```
Hash Function: hash(key) % 7

Ключи → hash() → Индексы
"cat"  →  3   →    3
"dog"  →  1   →    1  
"fish" →  5   →    5
"bird" →  3   →    3  ← Коллизия!

Хеш-таблица:
  0  ┌─────────┐
  1  │ dog:5   │
  2  ├─────────┤
  3  │ cat:2 → bird:8 │ ← Цепочки для коллизий
  4  ├─────────┤
  5  │ fish:3  │
  6  └─────────┘
```

**Разрешение коллизий:**
```
1. Цепочки (Chaining):
   bucket[3] → [cat:2] → [bird:8] → null

2. Открытая адресация:
   Если bucket[3] занят, пробуем bucket[4], bucket[5]...
```

### Код
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]
    
    def _hash(self, key):
        return hash(key) % self.size
    
    # O(1) средний случай
    def put(self, key, value):
        index = self._hash(key)
        bucket = self.table[index]
        
        # Обновляем существующий ключ
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        
        # Добавляем новый
        bucket.append((key, value))
    
    # O(1) средний случай
    def get(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        raise KeyError(key)
    
    def delete(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return
        
        raise KeyError(key)

# Использование
ht = HashTable()
ht.put("user_123", {"name": "John", "age": 30})
ht.put("user_456", {"name": "Jane", "age": 25})

user = ht.get("user_123")  # O(1)
```

### Применение в бэкенде
- **Кэш данных** (Redis, Memcached)
- **Session storage** 
- **Database indexing**
- **URL shorteners** (bit.ly)
- **Rate limiting по IP**

### Сложность
| Операция | Средний | Худший |
|----------|---------|--------|
| Поиск    | O(1)    | O(n)   |
| Вставка  | O(1)    | O(n)   |
| Удаление | O(1)    | O(n)   |

### Когда использовать
✅ Нужен быстрый поиск по ключу  
✅ Нет необходимости в сортировке  
✅ Ключи уникальны

---

## 3.2 LRU Cache

### Концепция
Least Recently Used - удаляем то, что дольше всего не использовалось. Комбинация хеш-таблицы и двусвязного списка.

### Визуализация
```
Capacity = 3

Последовательность операций:
put(1,1) put(2,2) put(3,3) put(4,4) get(2)

HashMap:           Doubly Linked List:
┌─────────┐       ┌──────────────────────┐
│ 2 → ●   │   ┌──→│ head → 2 → 3 → 4 ← tail │
│ 3 → ●   │   │   └──────────────────────┘
│ 4 → ●   │   │          ↑           ↑
└─────────┘   │       recent      oldest
              │
              └── указатели на узлы

После get(2):
HashMap:           Doubly Linked List:
┌─────────┐       ┌──────────────────────┐
│ 2 → ●   │   ┌──→│ head → 2 → 3 → 4 ← tail │
│ 3 → ●   │   │   └──────────────────────┘
│ 4 → ●   │   │          ↑
└─────────┘   │       moved to front
```

### Код
```python
class Node:
    def __init__(self, key=0, val=0):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> node
        
        # Создаем dummy головы и хвосты
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_node(self, node):
        """Добавить узел после головы"""
        node.prev = self.head
        node.next = self.head.next
        
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """Удалить узел"""
        prev_node = node.prev
        new_node = node.next
        
        prev_node.next = new_node
        new_node.prev = prev_node
    
    def _move_to_head(self, node):
        """Переместить в начало (most recent)"""
        self._remove_node(node)
        self._add_node(node)
    
    def _pop_tail(self):
        """Удалить последний узел"""
        last_node = self.tail.prev
        self._remove_node(last_node)
        return last_node
    
    def get(self, key):
        node = self.cache.get(key)
        
        if node:
            # Перемещаем в начало
            self._move_to_head(node)
            return node.val
        
        return -1
    
    def put(self, key, value):
        node = self.cache.get(key)
        
        if node:
            # Обновляем значение
            node.val = value
            self._move_to_head(node)
        else:
            new_node = Node(key, value)
            
            if len(self.cache) >= self.capacity:
                # Удаляем LRU
                tail = self._pop_tail()
                del self.cache[tail.key]
            
            self.cache[key] = new_node
            self._add_node(new_node)

# Использование
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # 1
cache.put(3, 3)      # evicts key 2
print(cache.get(2))  # -1 (not found)
```

### Применение в бэкенде
- **Database query cache**
- **Web page cache**
- **API response cache**
- **Image/file cache**

---

# 🌳 ЧАСТЬ 4: ДЕРЕВЬЯ

## 4.1 Бинарные деревья поиска (BST)

### Концепция
Каждый узел больше всех в левом поддереве и меньше всех в правом. Как отсортированная структура для быстрого поиска.

### Визуализация
```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

Поиск 6:
8 > 6, идем влево
3 < 6, идем вправо
6 = 6, найдено!

Путь: 8 → 3 → 6 (3 сравнения)
```

**Вставка:**
```
Вставить 5:
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
         /
        5  ← новый узел
```

### Код
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        self.root = self._insert(self.root, val)
    
    def _insert(self, node, val):
        if not node:
            return TreeNode(val)
        
        if val < node.val:
            node.left = self._insert(node.left, val)
        else:
            node.right = self._insert(node.right, val)
        
        return node
    
    def search(self, val):
        return self._search(self.root, val)
    
    def _search(self, node, val):
        if not node or node.val == val:
            return node
        
        if val < node.val:
            return self._search(node.left, val)
        else:
            return self._search(node.right, val)
    
    def inorder(self):
        """Возвращает отсортированный список"""
        result = []
        self._inorder(self.root, result)
        return result
    
    def _inorder(self, node, result):
        if node:
            self._inorder(node.left, result)
            result.append(node.val)
            self._inorder(node.right, result)

# Использование
bst = BST()
for val in [8, 3, 10, 1, 6, 14, 4, 7, 13]:
    bst.insert(val)

print(bst.search(6))      # найдено
print(bst.inorder())      # [1, 3, 4, 6, 7, 8, 10, 13, 14]
```

### Обходы дерева
```
        8
       / \
      3   10
     / \    \
    1   6    14

Inorder (левый, корень, правый):   1, 3, 6, 8, 10, 14
Preorder (корень, левый, правый):  8, 3, 1, 6, 10, 14  
Postorder (левый, правый, корень): 1, 6, 3, 14, 10, 8
```

### Применение в бэкенде
- **Database indexing** (B-trees)
- **File systems** (directory structure)
- **Priority queues**
- **Range queries** (найти все элементы между X и Y)

### Сложность
| Операция | Средний | Худший |
|----------|---------|--------|
| Поиск    | O(log n)| O(n)   |
| Вставка  | O(log n)| O(n)   |
| Удаление | O(log n)| O(n)   |

### Когда использовать
✅ Нужны отсортированные данные  
✅ Range queries  
✅ Динамическая сортировка  
❌ Данные могут быть несбалансированными

---

## 4.2 Кучи (Heaps)

### Концепция
Полное бинарное дерево, где родитель больше/меньше детей. Быстро находим минимум/максимум.

### Визуализация
```
Max Heap:
        9
       / \
      7   8
     / \ / \
    3  5 6  4
   /
  1

Массив: [9, 7, 8, 3, 5, 6, 4, 1]
Индексы: 0  1  2  3  4  5  6  7

Связи:
parent(i) = (i-1)//2
left(i) = 2*i + 1  
right(i) = 2*i + 2
```

**Операция heapify (восстановление свойства кучи):**
```
Добавили 10:
        9
       / \
      7   8
     / \ / \
    3  5 6  4
   / \
  1  10  ← нарушение!

Поднимаем 10:
       10
       / \
      9   8
     / \ / \
    3  7 6  4
   / \
  1   5
```

### Код
```python
import heapq

class MinHeap:
    def __init__(self):
        self.heap = []
    
    def push(self, val):
        heapq.heappush(self.heap, val)
    
    def pop(self):
        if not self.heap:
            raise IndexError("pop from empty heap")
        return heapq.heappop(self.heap)
    
    def peek(self):
        if not self.heap:
            return None
        return self.heap[0]
    
    def size(self):
        return len(self.heap)

# Max Heap (инвертируем значения)
class MaxHeap:
    def __init__(self):
        self.heap = []
    
    def push(self, val):
        heapq.heappush(self.heap, -val)
    
    def pop(self):
        if not self.heap:
            raise IndexError("pop from empty heap")
        return -heapq.heappop(self.heap)
    
    def peek(self):
        if not self.heap:
            return None
        return -self.heap[0]

# Пример: K largest elements
def k_largest(nums, k):
    min_heap = MinHeap()
    
    for num in nums:
        min_heap.push(num)
        if min_heap.size() > k:
            min_heap.pop()
    
    return [min_heap.pop() for _ in range(min_heap.size())]

print(k_largest([3,2,1,5,6,4], 2))  # [5, 6]
```

### Применение в бэкенде
- **Priority queues** (task scheduling)
- **Top K problems** (trending posts, popular products)
- **Median finding** (streaming data)
- **Dijkstra's algorithm** (shortest path)
- **Load balancing** (выбор сервера с наименьшей нагрузкой)

### Сложность
| Операция | Время    |
|----------|----------|
| Peek     | O(1)     |
| Push     | O(log n) |
| Pop      | O(log n) |
| Build    | O(n)     |

### Когда использовать
✅ Нужен быстрый доступ к min/max  
✅ Priority queue functionality  
✅ Streaming data processing

---

# 🕸️ ЧАСТЬ 5: ГРАФЫ

## 5.1 Представление графов

### Концепция
Граф - это узлы (vertices) соединенные ребрами (edges). Как социальная сеть или карта дорог.

### Визуализация
```
Граф:
    A --- B
    |     |
    D --- C

Матрица смежности:
     A B C D
  A [0 1 0 1]
  B [1 0 1 0]  
  C [0 1 0 1]
  D [1 0 1 0]

Список смежности:
A: [B, D]
B: [A, C]
C: [B, D]  
D: [A, C]
```

### Код
```python
# Матрица смежности
class GraphMatrix:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]
    
    def add_edge(self, u, v):
        self.matrix[u][v] = 1
        self.matrix[v][u] = 1  # для неориентированного графа
    
    def has_edge(self, u, v):
        return self.matrix[u][v] == 1

# Список смежности (более эффективен)
class GraphList:
    def __init__(self):
        self.graph = {}
    
    def add_vertex(self, vertex):
        if vertex not in self.graph:
            self.graph[vertex] = []
    
    def add_edge(self, u, v):
        if u not in self.graph:
            self.add_vertex(u)
        if v not in self.graph:
            self.add_vertex(v)
        
        self.graph[u].append(v)
        self.graph[v].append(u)  # для неориентированного
    
    def get_neighbors(self, vertex):
        return self.graph.get(vertex, [])
    
    def has_edge(self, u, v):
        return v in self.graph.get(u, [])

# Использование
graph = GraphList()
graph.add_edge('A', 'B')
graph.add_edge('B', 'C')
graph.add_edge('C', 'D')
graph.add_edge('D', 'A')

print(graph.get_neighbors('A'))  # ['B', 'D']
```

### Сравнение представлений
| Операция         | Матрица | Список |
|------------------|---------|--------|
| Память           | O(V²)   | O(V+E) |
| Добавить ребро   | O(1)    | O(1)   |
| Проверить ребро  | O(1)    | O(V)   |
| Найти соседей    | O(V)    | O(1)   |

---

## 5.2 Обход графов

### Depth-First Search (DFS)
```
Концепция: идем как можно глубже, затем возвращаемся

Граф:     A --- B
          |     |
          D --- C

DFS от A: A → B → C → D

Стек вызовов:
visit(A) → visit(B) → visit(C) → visit(D)
    ↑         ↑         ↑         ↑
  start    A→B       B→C       C→D
```

### Breadth-First Search (BFS)
```
Концепция: сначала все соседи, потом соседи соседей

BFS от A: A → B,D → C

Очередь:
[A] → [B,D] → [D,C] → [C] → []
 ↑      ↑       ↑      ↑
visit  visit   visit  visit
 A      B       D      C
```

### Код
```python
from collections import deque

def dfs_recursive(graph, start, visited=None):
    if visited is None:
        visited = set()
    
    visited.add(start)
    print(start, end=' ')
    
    for neighbor in graph.get_neighbors(start):
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=' ')
            
            # Добавляем соседей в стек
            for neighbor in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    stack.append(neighbor)

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Пример: поиск пути
def find_path_bfs(graph, start, end):
    if start == end:
        return [start]
    
    visited = {start}
    queue = deque([(start, [start])])
    
    while queue:
        vertex, path = queue.popleft()
        
        for neighbor in graph.get_neighbors(vertex):
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == end:
                    return new_path
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return None  # путь не найден

# Использование
graph = GraphList()
graph.add_edge('A', 'B')
graph.add_edge('B', 'C')
graph.add_edge('C', 'D')
graph.add_edge('D', 'A')

print("DFS:", end=' ')
dfs_recursive(graph, 'A')  # A B C D
print("\nBFS:", end=' ')
bfs(graph, 'A')           # A B D C
print("\nPath A→C:", find_path_bfs(graph, 'A', 'C'))  # ['A', 'B', 'C']
```

### Применение в бэкенде
**DFS:**
- **Поиск циклов** в зависимостях
- **Топологическая сортировка**
- **Обход файловой системы**

**BFS:**
- **Кратчайший путь** в невзвешенном графе
- **Social network**: друзья на расстоянии N
- **Web crawling** (по уровням)
- **Распространение изменений** в системе

---

# 🔥 ЧАСТЬ 6: ПРОДВИНУТЫЕ СТРУКТУРЫ

## 6.1 Trie (Префиксное дерево)

### Концепция
Дерево для хранения строк с общими префиксами. Как словарь с быстрым поиском по началу слова.

### Визуализация
```
Слова: cat, car, card, care, careful, dogs

         root
        /    \
       c      d
       |      |
       a      o
       |      |
       t*     g
      /       |
     r        s*
     |        
     d*       
    /         
   (*)        
   
Звездочка (*) = конец слова

Путь для "car": root → c → a → r → (*)
Путь для "card": root → c → a → r → d → (*)
```

### Код
```python
class TrieNode:
    def __init__(self):
        self.children = {}  # символ -> TrieNode
        self.is_end_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        
        node.is_end_word = True
    
    def search(self, word):
        node = self.root
        
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return node.is_end_word
    
    def starts_with(self, prefix):
        """Есть ли слова с данным префиксом"""
        node = self.root
        
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        
        return True
    
    def get_words_with_prefix(self, prefix):
        """Все слова с данным префиксом"""
        node = self.root
        
        # Находим узел префикса
        for char in prefix:
            if char not in node.children:
                return []
            node = node.children[char]
        
        # Собираем все слова из этого узла
        words = []
        self._collect_words(node, prefix, words)
        return words
    
    def _collect_words(self, node, current_word, words):
        if node.is_end_word:
            words.append(current_word)
        
        for char, child_node in node.children.items():
            self._collect_words(child_node, current_word + char, words)

# Пример: автодополнение
class AutoComplete:
    def __init__(self):
        self.trie = Trie()
    
    def add_word(self, word):
        self.trie.insert(word.lower())
    
    def get_suggestions(self, prefix, max_suggestions=5):
        suggestions = self.trie.get_words_with_prefix(prefix.lower())
        return suggestions[:max_suggestions]

# Использование
ac = AutoComplete()
words = ["apple", "application", "apply", "appreciate", "approach", "banana"]

for word in words:
    ac.add_word(word)

print(ac.get_suggestions("app"))  # ['apple', 'application', 'apply', 'appreciate', 'approach']
print(ac.get_suggestions("appl")) # ['apple', 'application', 'apply']
```

### Применение в бэкенде
- **Автодополнение** в поисковых системах
- **Spell checkers**
- **IP routing tables**
- **Словари и переводчики**
- **Валидация префиксов** (телефонные коды)

### Сложность
| Операция | Время | Память |
|----------|-------|--------|
| Вставка  | O(m)  | O(m)   |
| Поиск    | O(m)  | -      |
| Префикс  | O(p)  | -      |

где m - длина слова, p - длина префикса

### Когда использовать
✅ Много строк с общими префиксами  
✅ Нужен поиск по префиксу  
✅ Автодополнение функциональность

---

## 6.2 Union-Find (Disjoint Set Union)

### Концепция
Отслеживает разделение элементов на непересекающиеся множества. Быстро определяет, связаны ли элементы.

### Визуализация
```
Начальное состояние:
{1} {2} {3} {4} {5}

union(1, 2):
{1, 2} {3} {4} {5}

union(3, 4):
{1, 2} {3, 4} {5}

union(2, 3):
{1, 2, 3, 4} {5}

Дерево представление:
    1
    |
    2
   / \
  3   
  |   
  4   

find(4): 4 → 3 → 2 → 1 (корень)
```

### Код
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))  # каждый элемент - свой родитель
        self.rank = [0] * n           # высота дерева
        self.components = n           # количество компонент
    
    def find(self, x):
        """Найти корень с path compression"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # сжатие пути
        return self.parent[x]
    
    def union(self, x, y):
        """Объединить множества x и y"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # уже в одном множестве
        
        # Union by rank - присоединяем меньшее к большему
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.components -= 1
        return True
    
    def connected(self, x, y):
        """Проверить, связаны ли элементы"""
        return self.find(x) == self.find(y)
    
    def count_components(self):
        return self.components

# Пример: поиск количества островов
def num_islands(grid):
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    uf = UnionFind(rows * cols)
    
    # Подсчитываем изначально только воду
    water_cells = 0
    
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '0':  # вода
                water_cells += 1
            else:  # земля, проверяем соседей
                # Соединяем с соседними землями
                for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
                    ni, nj = i + di, j + dj
                    if (0 <= ni < rows and 0 <= nj < cols and 
                        grid[ni][nj] == '1'):
                        uf.union(i * cols + j, ni * cols + nj)
    
    # Общее количество компонент минус водные клетки
    return uf.count_components() - water_cells

# Пример: проверка связности графа
def is_connected_graph(n, edges):
    uf = UnionFind(n)
    
    for u, v in edges:
        uf.union(u, v)
    
    return uf.count_components() == 1

# Использование
grid = [
    ['1','1','0','0','0'],
    ['1','1','0','0','0'], 
    ['0','0','1','0','0'],
    ['0','0','0','1','1']
]
print(num_islands(grid))  # 3

print(is_connected_graph(5, [(0,1), (1,2), (3,4)]))  # False
print(is_connected_graph(5, [(0,1), (1,2), (2,3), (3,4)]))  # True
```

### Применение в бэкенде
- **Network connectivity** (проверка связности серверов)
- **Social networks** (друзья друзей)
- **Image processing** (connected components)
- **Distributed systems** (группировка узлов)
- **Kruskal's algorithm** (минимальное остовное дерево)

### Сложность
| Операция | Время       |
|----------|-------------|
| Find     | O(α(n))     |
| Union    | O(α(n))     |

где α(n) - обратная функция Аккермана (практически константа)

### Когда использовать
✅ Динамическая связность  
✅ Группировка элементов  
✅ Проверка циклов в графе

---

# 🎯 ЧАСТЬ 7: ПРИМЕНЕНИЕ В БЭКЕНДЕ

## 7.1 Выбор структуры данных

### Чек-лист выбора

**Нужен быстрый поиск?**
- По ключу → HashMap/HashTable
- В отсортированных данных → BST/Binary Search
- По префиксу → Trie

**Нужен определенный порядок?**
- FIFO → Queue
- LIFO → Stack  
- Priority → Heap
- Sorted → BST

**Часто изменяется размер?**
- Да → Linked List, Dynamic Array
- Нет → Static Array

**Нужны range queries?**
- Да → Segment Tree, BST
- Нет → HashMap быстрее

### Паттерны использования

```python
# Кэширование результатов
class APICache:
    def __init__(self, max_size=1000):
        self.cache = {}  # HashMap для O(1) доступа
        self.access_order = []  # Для LRU
        self.max_size = max_size
    
    def get(self, key):
        if key in self.cache:
            # Обновляем порядок доступа
            self.access_order.remove(key)
            self.access_order.append(key)
            return self.cache[key]
        return None
    
    def put(self, key, value):
        if len(self.cache) >= self.max_size:
            # Удаляем LRU
            oldest = self.access_order.pop(0)
            del self.cache[oldest]
        
        self.cache[key] = value
        self.access_order.append(key)

# Rate Limiting
from collections import deque
import time

class RateLimiter:
    def __init__(self, max_requests=100, window_seconds=3600):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = {}  # user_id -> deque of timestamps
    
    def is_allowed(self, user_id):
        now = time.time()
        
        if user_id not in self.requests:
            self.requests[user_id] = deque()
        
        user_requests = self.requests[user_id]
        
        # Удаляем старые запросы
        while user_requests and user_requests[0] < now - self.window_seconds:
            user_requests.popleft()
        
        if len(user_requests) < self.max_requests:
            user_requests.append(now)
            return True
        
        return False

# Task Queue
import heapq

class TaskQueue:
    def __init__(self):
        self.tasks = []  # Min heap по priority
        self.counter = 0  # Для stable sorting
    
    def add_task(self, priority, task_func, *args):
        # Меньшее число = выше приоритет
        heapq.heappush(self.tasks, (priority, self.counter, task_func, args))
        self.counter += 1
    
    def get_next_task(self):
        if not self.tasks:
            return None
        
        priority, counter, task_func, args = heapq.heappop(self.tasks)
        return task_func, args
    
    def has_tasks(self):
        return bool(self.tasks)
```

---

## 7.2 Производительность и оптимизация

### Big O в реальности

**Константы имеют значение:**
```python
# O(1) но медленно - хеш коллизии
large_dict = {i: i for i in range(100000)}
# vs
# O(log n) но быстро - хорошая локальность памяти
sorted_list = list(range(100000))

# Поиск 50000
# dict: O(1) но возможны коллизии
# binary search: O(log n) ≈ 17 сравнений, но cache-friendly
```

**Профилирование:**
```python
import time
import sys

def measure_time(func):
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        end = time.perf_counter()
        print(f"{func.__name__}: {end - start:.6f} seconds")
        return result
    return wrapper

def measure_memory(obj):
    return sys.getsizeof(obj)

# Сравнение структур данных
@measure_time
def test_list_append():
    lst = []
    for i in range(100000):
        lst.append(i)
    return lst

@measure_time  
def test_dict_insert():
    d = {}
    for i in range(100000):
        d[i] = i
    return d
```

### Оптимизация памяти

**Используйте правильные типы:**
```python
# Плохо - лишняя память
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        # Python создает __dict__ для каждого объекта

# Хорошо - экономия памяти
class User:
    __slots__ = ['name', 'age']  # Фиксированные атрибуты
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Для миллионов пользователей разница существенна
```

**Ленивые вычисления:**
```python
# Генераторы вместо списков
def fibonacci_list(n):
    result = []
    a, b = 0, 1
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result  # Вся последовательность в памяти

def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b  # По одному элементу
```

---

## 7.3 Практические примеры

### Система уведомлений
```python
from collections import defaultdict, deque
import heapq
import time

class NotificationSystem:
    def __init__(self):
        # Пользователи и их подписки
        self.followers = defaultdict(set)  # user_id -> set of followers
        self.feeds = defaultdict(deque)    # user_id -> deque of notifications
        self.trending = []                 # min heap для trending topics
        self.max_feed_size = 1000
    
    def follow(self, follower_id, user_id):
        self.followers[user_id].add(follower_id)
    
    def post_notification(self, user_id, message, priority=1):
        timestamp = time.time()
        notification = {
            'user_id': user_id,
            'message': message,
            'timestamp': timestamp,
            'priority': priority
        }
        
        # Добавляем в ленты всех подписчиков
        for follower_id in self.followers[user_id]:
            self._add_to_feed(follower_id, notification)
        
        # Обновляем trending
        heapq.heappush(self.trending, (-priority, timestamp, message))
    
    def _add_to_feed(self, user_id, notification):
        feed = self.feeds[user_id]
        feed.append(notification)
        
        # Ограничиваем размер ленты
        if len(feed) > self.max_feed_size:
            feed.popleft()
    
    def get_feed(self, user_id, limit=10):
        feed = self.feeds[user_id]
        # Возвращаем последние N уведомлений
        return list(feed)[-limit:]
    
    def get_trending(self, limit=5):
        # Топ trending уведомлений
        trending = heapq.nsmallest(limit, self.trending)
        return [message for _, _, message in trending]

# Использование
notifications = NotificationSystem()
notifications.follow(1, 2)  # user 1 follows user 2
notifications.follow(3, 2)  # user 3 follows user 2

notifications.post_notification(2, "Hello world!", priority=5)
print(notifications.get_feed(1))  # Уведомления для user 1
```

### Система поиска
```python
class SearchEngine:
    def __init__(self):
        self.documents = {}        # doc_id -> content
        self.word_index = defaultdict(set)  # word -> set of doc_ids
        self.trie = Trie()        # Для автодополнения
        self.doc_scores = {}      # doc_id -> relevance score
    
    def add_document(self, doc_id, content):
        self.documents[doc_id] = content
        words = content.lower().split()
        
        # Индексируем слова
        for word in set(words):  # Уникальные слова
            self.word_index[word].add(doc_id)
            self.trie.insert(word)
        
        # Простой scoring: количество уникальных слов
        self.doc_scores[doc_id] = len(set(words))
    
    def search(self, query):
        query_words = query.lower().split()
        
        if not query_words:
            return []
        
        # Находим документы, содержащие все слова
        result_docs = self.word_index[query_words[0]].copy()
        
        for word in query_words[1:]:
            result_docs &= self.word_index[word]  # Пересечение множеств
        
        # Сортируем по релевантности
        scored_docs = [(self.doc_scores[doc_id], doc_id) 
                      for doc_id in result_docs]
        scored_docs.sort(reverse=True)
        
        return [doc_id for _, doc_id in scored_docs]
    
    def autocomplete(self, prefix):
        return self.trie.get_words_with_prefix(prefix)[:5]
    
    def get_document(self, doc_id):
        return self.documents.get(doc_id)

# Использование
search = SearchEngine()
search.add_document(1, "Python programming language tutorial")
search.add_document(2, "Java programming basics")
search.add_document(3, "Python data structures and algorithms")

print(search.search("Python programming"))  # [3, 1]
print(search.autocomplete("prog"))          # ['programming']
```

---

# 🎓 ЗАКЛЮЧЕНИЕ

## Резюме по структурам данных

| Структура | Поиск | Вставка | Удаление | Использование |
|-----------|-------|---------|----------|---------------|
| Array     | O(n)  | O(n)    | O(n)     | Индексный доступ |
| Linked List| O(n) | O(1)    | O(1)     | Динамический размер |
| Stack     | -     | O(1)    | O(1)     | LIFO операции |
| Queue     | -     | O(1)    | O(1)     | FIFO операции |
| Hash Table| O(1)  | O(1)    | O(1)     | Быстрый поиск |
| BST       | O(log n)| O(log n)| O(log n)| Отсортированные данные |
| Heap      | O(1)*  | O(log n)| O(log n)| Priority queue |
| Trie      | O(m)  | O(m)    | O(m)     | Строковые операции |
| Graph     | O(V+E)| O(1)    | O(V)     | Связи между объектами |

*Поиск min/max элемента

## Ключевые принципы

1. **Нет универсальной структуры** - каждая решает свои задачи
2. **Анализируйте паттерны доступа** - как часто читаете vs пишете
3. **Учитывайте размер данных** - константы важны для больших объемов
4. **Помните о памяти** - не только время, но и место
5. **Профилируйте в реальных условиях** - теория vs практика

## Что дальше?

1. **Реализуйте все структуры** самостоятельно
2. **Решайте задачи** на LeetCode/HackerRank
3. **Изучайте конкретные библиотеки** вашего языка
4. **Читайте код** популярных open-source проектов
5. **Применяйте в реальных проектах**

**Помните:** Лучший способ изучить структуры данных - использовать их для решения реальных задач в ваших проектах!

---

*Успехов в изучении! Каждый эксперт когда-то был новичком. 🚀*