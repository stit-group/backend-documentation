# Ğ‘Ğ»Ğ¾Ğº 4: ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¸ĞºĞ¸

**â±ï¸ Ğ”Ğ»Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ:** 3-4 Ğ½ĞµĞ´ĞµĞ»Ğ¸  
**ğŸ¯ Ğ¦ĞµĞ»ÑŒ:** ĞĞ°ÑƒÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Ğ¿Ğ¾Ğ²Ñ‹ÑˆĞ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ

---

## Ğ“Ğ»Ğ°Ğ²Ğ° 4.1: ĞšÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### ğŸ“š Ğ¢ĞµĞ¾Ñ€ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¾ÑĞ½Ğ¾Ğ²Ñ‹

#### Ğ˜ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ ĞºĞ¾Ğ¼Ğ¿ÑŒÑÑ‚ĞµÑ€Ğ°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Ğ˜Ğ•Ğ ĞĞ Ğ¥Ğ˜Ğ¯ ĞŸĞĞœĞ¯Ğ¢Ğ˜                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñ‹ CPU      â”‚ ~1 Ñ†Ğ¸ĞºĞ»     â”‚ ~1 KB    â”‚ Ğ¡Ğ°Ğ¼Ğ°Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ°Ñ  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L1 Cache          â”‚ ~4 Ñ†Ğ¸ĞºĞ»Ğ°    â”‚ ~64 KB   â”‚ â†‘ Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L2 Cache          â”‚ ~10 Ñ†Ğ¸ĞºĞ»Ğ¾Ğ²  â”‚ ~1 MB    â”‚ â†‘              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L3 Cache          â”‚ ~40 Ñ†Ğ¸ĞºĞ»Ğ¾Ğ²  â”‚ ~30 MB   â”‚ â†‘              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ĞĞ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒâ”‚ ~200 Ñ†Ğ¸ĞºĞ»Ğ¾Ğ² â”‚ ~16 GB   â”‚ â†“              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SSD               â”‚ ~25,000     â”‚ ~1 TB    â”‚ â†“              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HDD               â”‚ ~10,000,000 â”‚ ~10 TB   â”‚ â†“ ĞœĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

**Spatial Locality (ĞŸÑ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ):**
```
ĞĞ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº Ğ°Ğ´Ñ€ĞµÑÑƒ X â†’ Ğ²Ñ‹ÑĞ¾ĞºĞ° Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ñ Ğº X+1, X+2, ...

ĞŸĞ°Ğ¼ÑÑ‚ÑŒ: [A][B][C][D][E][F][G][H]
         â†‘
    ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ğ»Ğ¸ÑÑŒ Ğº A
    
ĞšÑÑˆ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµÑ‚: [A][B][C][D] - Ñ†ĞµĞ»ÑƒÑ cache line (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ 64 Ğ±Ğ°Ğ¹Ñ‚Ğ°)
```

**Temporal Locality (Ğ’Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ):**
```
ĞĞ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº Ğ°Ğ´Ñ€ĞµÑÑƒ X â†’ Ğ²Ñ‹ÑĞ¾ĞºĞ° Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ñ Ğº X

Ğ’Ñ€ĞµĞ¼Ñ:  t1    t2    t3    t4    t5
Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ: [A] â†’ [B] â†’ [A] â†’ [C] â†’ [A]
              â†‘           â†‘           â†‘
          Cache hit   Cache hit   Cache hit
```

### ğŸ”§ Cache-friendly Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

#### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 1: ĞĞ±Ñ…Ğ¾Ğ´ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ°

**âŒ ĞŸĞ»Ğ¾Ñ…Ğ¾ (cache miss):**
```cpp
// ĞĞ±Ñ…Ğ¾Ğ´ Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ°Ğ¼ - Ğ¼Ğ½Ğ¾Ğ³Ğ¾ cache miss'Ğ¾Ğ²
int matrix[1000][1000];
int sum = 0;

for (int col = 0; col < 1000; col++) {
    for (int row = 0; row < 1000; row++) {
        sum += matrix[row][col];  // ĞŸÑ€Ñ‹Ğ¶ĞºĞ¸ Ğ¿Ğ¾ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸!
    }
}
```

**âœ… Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¾ (cache hit):**
```cpp
// ĞĞ±Ñ…Ğ¾Ğ´ Ğ¿Ğ¾ ÑÑ‚Ñ€Ğ¾ĞºĞ°Ğ¼ - Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ spatial locality
int matrix[1000][1000];
int sum = 0;

for (int row = 0; row < 1000; row++) {
    for (int col = 0; col < 1000; col++) {
        sum += matrix[row][col];  // ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿
    }
}
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸:**
```
ĞŸĞ»Ğ¾Ñ…Ğ¾Ğ¹ Ğ¾Ğ±Ñ…Ğ¾Ğ´ (Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ»Ğ±Ñ†Ğ°Ğ¼):
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 1 â”‚ 4 â”‚ 7 â”‚...â”‚ â† Cache line 1
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚ 2 â”‚ 5 â”‚ 8 â”‚...â”‚ â† Cache line 2
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚ 3 â”‚ 6 â”‚ 9 â”‚...â”‚ â† Cache line 3
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
ĞšĞ°Ğ¶Ğ´Ğ¾Ğµ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ = Ğ½Ğ¾Ğ²Ğ°Ñ cache line!

Ğ¥Ğ¾Ñ€Ğ¾ÑˆĞ¸Ğ¹ Ğ¾Ğ±Ñ…Ğ¾Ğ´ (Ğ¿Ğ¾ ÑÑ‚Ñ€Ğ¾ĞºĞ°Ğ¼):
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ â† Cache line 1
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚ 5 â”‚ 6 â”‚ 7 â”‚ 8 â”‚ â† Cache line 2
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚ 9 â”‚10 â”‚11 â”‚12 â”‚ â† Cache line 3
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
ĞĞ´Ğ½Ğ° cache line = 4 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°!
```

#### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 2: Structure of Arrays vs Array of Structures

**âŒ Array of Structures (AoS):**
```cpp
struct Particle {
    float x, y, z;     // position
    float vx, vy, vz;  // velocity
    float mass;
    int id;
};

Particle particles[1000];

// ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
for (int i = 0; i < 1000; i++) {
    particles[i].x += particles[i].vx;
    particles[i].y += particles[i].vy;
    particles[i].z += particles[i].vz;
}
```

**ĞŸĞ°Ğ¼ÑÑ‚ÑŒ Ğ²Ñ‹Ğ³Ğ»ÑĞ´Ğ¸Ñ‚ Ñ‚Ğ°Ğº:**
```
[x,y,z,vx,vy,vz,mass,id][x,y,z,vx,vy,vz,mass,id][x,y,z,vx,vy,vz,mass,id]...
 â””â”€â”€â”€â”€â”€â”€â”€ 32 Ğ±Ğ°Ğ¹Ñ‚Ğ° â”€â”€â”€â”€â”€â”€â”˜
 
Cache line (64 Ğ±Ğ°Ğ¹Ñ‚Ğ°) Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 2 ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹,
Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 24 Ğ±Ğ°Ğ¹Ñ‚Ğ° Ğ¸Ğ· 64!
```

**âœ… Structure of Arrays (SoA):**
```cpp
struct ParticleSystem {
    float x[1000], y[1000], z[1000];        // positions
    float vx[1000], vy[1000], vz[1000];     // velocities
    float mass[1000];
    int id[1000];
};

ParticleSystem particles;

// ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
for (int i = 0; i < 1000; i++) {
    particles.x[i] += particles.vx[i];
    particles.y[i] += particles.vy[i];
    particles.z[i] += particles.vz[i];
}
```

**ĞŸĞ°Ğ¼ÑÑ‚ÑŒ Ğ²Ñ‹Ğ³Ğ»ÑĞ´Ğ¸Ñ‚ Ñ‚Ğ°Ğº:**
```
X Ğ¼Ğ°ÑÑĞ¸Ğ²: [x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15]...
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Cache line (64 Ğ±Ğ°Ğ¹Ñ‚Ğ°) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           
Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ’Ğ¡Ğ• 64 Ğ±Ğ°Ğ¹Ñ‚Ğ° cache line!
16 float'Ğ¾Ğ² Ğ·Ğ° Ñ€Ğ°Ğ· Ğ²Ğ¼ĞµÑÑ‚Ğ¾ 6!
```

### ğŸ“Š Ğ˜Ğ·Ğ¼ĞµÑ€ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ ĞºÑÑˆĞ°

#### Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµÑ€ĞµĞ½Ğ¸Ñ cache miss'Ğ¾Ğ²:

```cpp
#include <chrono>
#include <iostream>
#include <vector>

void benchmark_cache_locality() {
    const int SIZE = 1024 * 1024;  // 1M ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
    std::vector<int> data(SIZE);
    
    // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    for (int i = 0; i < SIZE; i++) {
        data[i] = i;
    }
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (cache-friendly)
    long sum1 = 0;
    for (int i = 0; i < SIZE; i++) {
        sum1 += data[i];
    }
    
    auto mid = std::chrono::high_resolution_clock::now();
    
    // Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ (cache-unfriendly)
    long sum2 = 0;
    for (int i = 0; i < SIZE; i++) {
        sum2 += data[(i * 16777213) % SIZE];  // ĞŸÑĞµĞ²Ğ´Ğ¾ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ Ğ¸Ğ½Ğ´ĞµĞºÑ
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    
    auto seq_time = std::chrono::duration_cast<std::chrono::microseconds>(mid - start);
    auto rand_time = std::chrono::duration_cast<std::chrono::microseconds>(end - mid);
    
    std::cout << "ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿: " << seq_time.count() << " Î¼s\n";
    std::cout << "Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿: " << rand_time.count() << " Î¼s\n";
    std::cout << "Ğ Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ°: " << (float)rand_time.count() / seq_time.count() << "x\n";
}
```

---

## Ğ“Ğ»Ğ°Ğ²Ğ° 4.2: ĞŸÑƒĞ»Ñ‹ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ custom allocators

### ğŸ“š ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ñ… Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²

#### Ğ¤Ñ€Ğ°Ğ³Ğ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸

```
ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ĞºÑƒÑ‡Ğ¸:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞ                      â”‚ 1MB
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞŸĞ¾ÑĞ»Ğµ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ñ… malloc/free:
â”Œâ”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”
â”‚F â”‚ U  â”‚F â”‚ U   â”‚F â”‚ U    â”‚F â”‚   U    â”‚F â”‚ U â”‚
â””â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”€â”˜
F = Free (Ñ„Ñ€Ğ°Ğ³Ğ¼ĞµĞ½Ñ‚), U = Used

ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: ĞœĞ½Ğ¾Ğ³Ğ¾ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… Ñ„Ñ€Ğ°Ğ³Ğ¼ĞµĞ½Ñ‚Ğ¾Ğ², 
Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ±Ğ»Ğ¾Ğº!
```

#### Object Pool (ĞŸÑƒĞ» Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²)

**Ğ˜Ğ´ĞµÑ:** Ğ—Ğ°Ñ€Ğ°Ğ½ĞµĞµ Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ¸Ğ¼ ÑĞ°Ğ¼Ğ¾ÑÑ‚Ğ¾ÑÑ‚ĞµĞ»ÑŒĞ½Ğ¾

```cpp
template<typename T, size_t PoolSize>
class ObjectPool {
private:
    // Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ´Ğ»Ñ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
    alignas(T) char storage[sizeof(T) * PoolSize];
    
    // Ğ¡Ñ‚ĞµĞº ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
    T* free_objects[PoolSize];
    size_t free_count;
    
public:
    ObjectPool() : free_count(PoolSize) {
        // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚ĞµĞº ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
        for (size_t i = 0; i < PoolSize; i++) {
            free_objects[i] = reinterpret_cast<T*>(storage + i * sizeof(T));
        }
    }
    
    T* allocate() {
        if (free_count == 0) {
            return nullptr;  // ĞŸÑƒĞ» Ğ¸ÑÑ‡ĞµÑ€Ğ¿Ğ°Ğ½
        }
        return free_objects[--free_count];
    }
    
    void deallocate(T* ptr) {
        if (free_count < PoolSize) {
            free_objects[free_count++] = ptr;
        }
    }
    
    template<typename... Args>
    T* construct(Args&&... args) {
        T* ptr = allocate();
        if (ptr) {
            new(ptr) T(std::forward<Args>(args)...);
        }
        return ptr;
    }
    
    void destroy(T* ptr) {
        if (ptr) {
            ptr->~T();
            deallocate(ptr);
        }
    }
};
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Object Pool:**

```
Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ:
Storage:  [Obj1][Obj2][Obj3][Obj4][Obj5]
FreeList: [  5  ][  4  ][  3  ][  2  ][  1  ] â† free_count = 5
             â†‘
           Top

ĞŸĞ¾ÑĞ»Ğµ allocate():
Storage:  [Obj1][Obj2][Obj3][Obj4][Obj5]
           Used   Free   Free   Free   Free
FreeList: [  -  ][  4  ][  3  ][  2  ][  1  ] â† free_count = 4
                    â†‘
                  Top

ĞŸĞ¾ÑĞ»Ğµ deallocate(Obj1):
Storage:  [Obj1][Obj2][Obj3][Obj4][Obj5]
           Free   Free   Free   Free   Free
FreeList: [  1  ][  4  ][  3  ][  2  ][  1  ] â† free_count = 5
             â†‘
           Top
```

#### Memory Pool (ĞŸÑƒĞ» Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸)

```cpp
class MemoryPool {
private:
    struct Block {
        Block* next;
    };
    
    char* memory;
    Block* free_head;
    size_t block_size;
    size_t block_count;
    
public:
    MemoryPool(size_t block_size, size_t block_count) 
        : block_size(std::max(block_size, sizeof(Block)))
        , block_count(block_count) {
        
        // Ğ’Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
        memory = new char[this->block_size * block_count];
        
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ²ÑĞ·Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
        free_head = reinterpret_cast<Block*>(memory);
        Block* current = free_head;
        
        for (size_t i = 0; i < block_count - 1; i++) {
            current->next = reinterpret_cast<Block*>(
                memory + (i + 1) * this->block_size
            );
            current = current->next;
        }
        current->next = nullptr;
    }
    
    void* allocate() {
        if (!free_head) {
            return nullptr;  // ĞĞµÑ‚ ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
        }
        
        Block* allocated = free_head;
        free_head = free_head->next;
        return allocated;
    }
    
    void deallocate(void* ptr) {
        if (!ptr) return;
        
        Block* block = static_cast<Block*>(ptr);
        block->next = free_head;
        free_head = block;
    }
    
    ~MemoryPool() {
        delete[] memory;
    }
};
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Memory Pool:**

```
Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (block_size=16, count=5):

Memory: [Block0][Block1][Block2][Block3][Block4]
         â”‚      â”‚      â”‚      â”‚      â”‚
         â–¼      â–¼      â–¼      â–¼      â–¼
        Next   Next   Next   Next   NULL

free_head â†’ Block0 â†’ Block1 â†’ Block2 â†’ Block3 â†’ Block4 â†’ NULL

ĞŸĞ¾ÑĞ»Ğµ allocate():
free_head â†’ Block1 â†’ Block2 â†’ Block3 â†’ Block4 â†’ NULL
            (Block0 Ğ²Ñ‹Ğ´Ğ°Ğ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ)

ĞŸĞ¾ÑĞ»Ğµ deallocate(Block0):
free_head â†’ Block0 â†’ Block1 â†’ Block2 â†’ Block3 â†’ Block4 â†’ NULL
            (Block0 Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½ Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¿Ğ¸ÑĞºĞ°)
```

#### Stack Allocator (Ğ¡Ñ‚ĞµĞºĞ¾Ğ²Ñ‹Ğ¹ Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ‚Ğ¾Ñ€)

```cpp
class StackAllocator {
private:
    char* memory;
    size_t size;
    size_t offset;
    
public:
    StackAllocator(size_t size) : size(size), offset(0) {
        memory = new char[size];
    }
    
    void* allocate(size_t bytes) {
        // Ğ’Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğµ Ğ¼Ğ°ÑˆĞ¸Ğ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ğ²Ğ°
        size_t aligned_bytes = (bytes + 7) & ~7;
        
        if (offset + aligned_bytes > size) {
            return nullptr;  // ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¼ĞµÑÑ‚Ğ°
        }
        
        void* result = memory + offset;
        offset += aligned_bytes;
        return result;
    }
    
    // ĞÑ‚ĞºĞ°Ñ‚ Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¼Ñƒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
    void reset(size_t new_offset = 0) {
        offset = new_offset;
    }
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ (Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ°)
    size_t get_marker() const {
        return offset;
    }
    
    ~StackAllocator() {
        delete[] memory;
    }
};
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Stack Allocator:**

```
ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞ                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
offset = 0

ĞŸĞ¾ÑĞ»Ğµ allocate(100):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ğ—ĞĞĞ¯Ğ¢Ğ   â”‚           Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞ            â”‚
â”‚ 100 Ğ±Ğ°Ğ¹Ñ‚ â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
offset = 100

ĞŸĞ¾ÑĞ»Ğµ allocate(200):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ğ—ĞĞĞ¯Ğ¢Ğ   â”‚   Ğ—ĞĞĞ¯Ğ¢Ğ    â”‚    Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞ     â”‚
â”‚ 100 Ğ±Ğ°Ğ¹Ñ‚ â”‚  200 Ğ±Ğ°Ğ¹Ñ‚   â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
offset = 300

ĞŸĞ¾ÑĞ»Ğµ reset(100):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ğ—ĞĞĞ¯Ğ¢Ğ   â”‚           Ğ¡Ğ’ĞĞ‘ĞĞ”ĞĞ            â”‚
â”‚ 100 Ğ±Ğ°Ğ¹Ñ‚ â”‚      (200 Ğ±Ğ°Ğ¹Ñ‚ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¾)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
offset = 100
```

### ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ

**Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°:** Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ³Ñ€Ğ¾Ğ²ÑƒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ† Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ

```cpp
class ParticleSystem {
private:
    struct Particle {
        float x, y, z;           // Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        float vx, vy, vz;        // ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ
        float life;              // Ğ²Ñ€ĞµĞ¼Ñ Ğ¶Ğ¸Ğ·Ğ½Ğ¸
        float size;              // Ñ€Ğ°Ğ·Ğ¼ĞµÑ€
    };
    
    ObjectPool<Particle, 10000> particle_pool;
    std::vector<Particle*> active_particles;
    
public:
    void spawn_particle(float x, float y, float z) {
        Particle* p = particle_pool.construct();
        if (p) {
            p->x = x; p->y = y; p->z = z;
            p->vx = (rand() % 200 - 100) / 100.0f;
            p->vy = (rand() % 200 - 100) / 100.0f;
            p->vz = (rand() % 200 - 100) / 100.0f;
            p->life = 5.0f;
            p->size = 1.0f;
            
            active_particles.push_back(p);
        }
    }
    
    void update(float dt) {
        for (auto it = active_particles.begin(); it != active_particles.end();) {
            Particle* p = *it;
            
            // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸Ğ·Ğ¸ĞºÑƒ
            p->x += p->vx * dt;
            p->y += p->vy * dt;
            p->z += p->vz * dt;
            p->life -= dt;
            
            if (p->life <= 0) {
                // Ğ§Ğ°ÑÑ‚Ğ¸Ñ†Ğ° ÑƒĞ¼ĞµÑ€Ğ»Ğ° - Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ² Ğ¿ÑƒĞ»
                particle_pool.destroy(p);
                it = active_particles.erase(it);
            } else {
                ++it;
            }
        }
    }
};
```

---

## Ğ“Ğ»Ğ°Ğ²Ğ° 4.3: ĞšĞ¾Ğ¼Ğ¿Ñ€ĞµÑÑĞ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸

### ğŸ“š Bit arrays Ğ¸ bit fields

#### Bit Array (Ğ‘Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ°ÑÑĞ¸Ğ²)

```cpp
class BitArray {
private:
    std::vector<uint64_t> data;
    size_t bit_count;
    
    static const size_t BITS_PER_WORD = 64;
    
public:
    BitArray(size_t bits) : bit_count(bits) {
        size_t words = (bits + BITS_PER_WORD - 1) / BITS_PER_WORD;
        data.resize(words, 0);
    }
    
    void set(size_t index) {
        if (index >= bit_count) return;
        
        size_t word_index = index / BITS_PER_WORD;
        size_t bit_index = index % BITS_PER_WORD;
        
        data[word_index] |= (1ULL << bit_index);
    }
    
    void clear(size_t index) {
        if (index >= bit_count) return;
        
        size_t word_index = index / BITS_PER_WORD;
        size_t bit_index = index % BITS_PER_WORD;
        
        data[word_index] &= ~(1ULL << bit_index);
    }
    
    bool test(size_t index) const {
        if (index >= bit_count) return false;
        
        size_t word_index = index / BITS_PER_WORD;
        size_t bit_index = index % BITS_PER_WORD;
        
        return (data[word_index] & (1ULL << bit_index)) != 0;
    }
};
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ BitArray:**

```
Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ 100 Ğ±Ğ¸Ñ‚ Ğ² BitArray:

Word 0 (Ğ±Ğ¸Ñ‚Ñ‹ 0-63):
â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”
â”‚0â”‚1â”‚0â”‚1â”‚1â”‚0â”‚1â”‚0â”‚0â”‚1â”‚1â”‚1â”‚0â”‚0â”‚1â”‚0â”‚1â”‚1â”‚0â”‚1â”‚0â”‚0â”‚1â”‚1â”‚1â”‚0â”‚1â”‚0â”‚1â”‚1â”‚0â”‚1â”‚
â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜
 0 1 2 3 4 5 6 7 8 9...                                     62 63

Word 1 (Ğ±Ğ¸Ñ‚Ñ‹ 64-99):
â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”
â”‚1â”‚0â”‚1â”‚1â”‚0â”‚1â”‚0â”‚0â”‚1â”‚1â”‚1â”‚0â”‚0â”‚1â”‚0â”‚1â”‚1â”‚0â”‚1â”‚0â”‚0â”‚1â”‚1â”‚1â”‚0â”‚1â”‚0â”‚1â”‚ â”‚ â”‚ â”‚ â”‚
â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜
64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91

set(67): Word 1, bit 3
data[1] |= (1ULL << 3)  // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ 3-Ğ¹ Ğ±Ğ¸Ñ‚ Ğ² 1
```

#### Ğ‘Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¿Ğ°ĞºÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ

```cpp
// ĞĞ±Ñ‹Ñ‡Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° - 16 Ğ±Ğ°Ğ¹Ñ‚
struct GameObjectNormal {
    bool is_visible;      // 1 Ğ±Ğ°Ğ¹Ñ‚ (+ 3 Ğ±Ğ°Ğ¹Ñ‚Ğ° padding)
    bool is_solid;        // 1 Ğ±Ğ°Ğ¹Ñ‚ (+ 3 Ğ±Ğ°Ğ¹Ñ‚Ğ° padding)
    bool is_animated;     // 1 Ğ±Ğ°Ğ¹Ñ‚ (+ 3 Ğ±Ğ°Ğ¹Ñ‚Ğ° padding)
    uint8_t health;       // 1 Ğ±Ğ°Ğ¹Ñ‚ (+ 3 Ğ±Ğ°Ğ¹Ñ‚Ğ° padding)
};

// ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° - 4 Ğ±Ğ°Ğ¹Ñ‚Ğ°
struct GameObjectCompact {
    uint32_t is_visible : 1;    // 1 Ğ±Ğ¸Ñ‚
    uint32_t is_solid : 1;      // 1 Ğ±Ğ¸Ñ‚
    uint32_t is_animated : 1;   // 1 Ğ±Ğ¸Ñ‚
    uint32_t health : 8;        // 8 Ğ±Ğ¸Ñ‚ (0-255)
    uint32_t object_type : 4;   // 4 Ğ±Ğ¸Ñ‚Ğ° (16 Ñ‚Ğ¸Ğ¿Ğ¾Ğ²)
    uint32_t level : 4;         // 4 Ğ±Ğ¸Ñ‚Ğ° (16 ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹)
    uint32_t unused : 12;       // 12 Ğ±Ğ¸Ñ‚ Ñ€ĞµĞ·ĞµÑ€Ğ²
};
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹:**

```
GameObjectCompact (32 Ğ±Ğ¸Ñ‚Ğ° = 4 Ğ±Ğ°Ğ¹Ñ‚Ğ°):

â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”
â”‚ unused (12 Ğ±Ğ¸Ñ‚)       â”‚levelâ”‚object_typeâ”‚  health (8)   â”‚Aâ”‚Sâ”‚Vâ”‚
â”‚                       â”‚ (4) â”‚    (4)    â”‚               â”‚nâ”‚oâ”‚iâ”‚
â”‚                       â”‚     â”‚           â”‚               â”‚iâ”‚lâ”‚sâ”‚
â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜
31                    20  19  16  15      8   7    4  3  2  1  0

Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ: 16 Ğ±Ğ°Ğ¹Ñ‚ â†’ 4 Ğ±Ğ°Ğ¹Ñ‚Ğ° = 75% ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ğ¸ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸!
```

### ğŸ”§ SIMD Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

#### Ğ’ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹

```cpp
#include <immintrin.h>  // SSE/AVX

// ĞĞ±Ñ‹Ñ‡Ğ½Ğ¾Ğµ ÑĞ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ¾Ğ²
void add_arrays_scalar(const float* a, const float* b, float* result, size_t count) {
    for (size_t i = 0; i < count; i++) {
        result[i] = a[i] + b[i];
    }
}

// SIMD Ğ²ĞµÑ€ÑĞ¸Ñ (Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ 8 float Ğ·Ğ° Ñ€Ğ°Ğ·)
void add_arrays_simd(const float* a, const float* b, float* result, size_t count) {
    const size_t simd_count = count & ~7;  // ĞšÑ€Ğ°Ñ‚Ğ½Ğ¾ 8
    
    for (size_t i = 0; i < simd_count; i += 8) {
        __m256 va = _mm256_load_ps(&a[i]);     // Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ 8 float
        __m256 vb = _mm256_load_ps(&b[i]);     // Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ 8 float
        __m256 vresult = _mm256_add_ps(va, vb); // Ğ¡ĞºĞ»Ğ°Ğ´Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²ÑĞµ 8 Ğ·Ğ° Ñ€Ğ°Ğ·
        _mm256_store_ps(&result[i], vresult);   // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
    }
    
    // ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸ĞµÑÑ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹
    for (size_t i = simd_count; i < count; i++) {
        result[i] = a[i] + b[i];
    }
}
```

**Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ SIMD Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹:**

```
Ğ¡ĞºĞ°Ğ»ÑÑ€Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°:
a[0] + b[0] = result[0]  â† 1 Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ
a[1] + b[1] = result[1]  â† 1 Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ  
a[2] + b[2] = result[2]  â† 1 Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ
...
Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: N Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹

SIMD Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° (AVX):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚a[0] â”‚a[1] â”‚a[2] â”‚a[3] â”‚a[4] â”‚a[5] â”‚a[6] â”‚a[7] â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
       +       +       +       +       +       +       +       +
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚b[0] â”‚b[1] â”‚b[2] â”‚b[3] â”‚b[4] â”‚b[5] â”‚b[6] â”‚b[7] â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
       =       =       =       =       =       =       =       =
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚r[0] â”‚r[1] â”‚r[2] â”‚r[3] â”‚r[4] â”‚r[5] â”‚r[6] â”‚r[7] â”‚ â† 1 Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ!
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

Ğ˜Ñ‚Ğ¾Ğ³Ğ¾: N/8 Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ (ÑƒÑĞºĞ¾Ñ€ĞµĞ½Ğ¸Ğµ Ğ² ~8 Ñ€Ğ°Ğ·)
```

---

## Ğ“Ğ»Ğ°Ğ²Ğ° 4.4: ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ°

### ğŸ“Š Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

#### ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ°Ğ¹Ğ»ĞµÑ€ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸

```cpp
class Timer {
private:
    std::chrono::high_resolution_clock::time_point start_time;
    std::string name;
    
public:
    Timer(const std::string& name) : name(name) {
        start_time = std::chrono::high_resolution_clock::now();
    }
    
    ~Timer() {
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end_time - start_time
        );
        std::cout << name << ": " << duration.count() << " Î¼s\n";
    }
};

#define PROFILE_SCOPE(name) Timer timer(name)
#define PROFILE_FUNCTION() Timer timer(__FUNCTION__)

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:
void expensive_function() {
    PROFILE_FUNCTION();
    
    {
        PROFILE_SCOPE("Memory allocation");
        std::vector<int> big_vector(1000000);
    }
    
    {
        PROFILE_SCOPE("Computation");
        for (int i = 0; i < 1000000; i++) {
            // Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ
        }
    }
}
```

#### ĞŸÑ€Ğ¾Ñ„Ğ°Ğ¹Ğ»ĞµÑ€ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸

```cpp
class MemoryProfiler {
private:
    struct AllocationInfo {
        size_t size;
        std::string file;
        int line;
        std::chrono::time_point<std::chrono::steady_clock> timestamp;
    };
    
    std::unordered_map<void*, AllocationInfo> allocations;
    std::mutex mutex;
    size_t total_allocated = 0;
    size_t peak_allocated = 0;
    
public:
    static MemoryProfiler& instance() {
        static MemoryProfiler instance;
        return instance;
    }
    
    void record_allocation(void* ptr, size_t size, const char* file, int line) {
        std::lock_guard<std::mutex> lock(mutex);
        
        allocations[ptr] = {
            size, 
            file, 
            line, 
            std::chrono::steady_clock::now()
        };
        
        total_allocated += size;
        peak_allocated = std::max(peak_allocated, total_allocated);
    }
    
    void record_deallocation(void* ptr) {
        std::lock_guard<std::mutex> lock(mutex);
        
        auto it = allocations.find(ptr);
        if (it != allocations.end()) {
            total_allocated -= it->second.size;
            allocations.erase(it);
        }
    }
    
    void report_leaks() {
        std::lock_guard<std::mutex> lock(mutex);
        
        if (!allocations.empty()) {
            std::cout << "=== MEMORY LEAKS DETECTED ===\n";
            for (const auto& [ptr, info] : allocations) {
                std::cout << "Leak: " << info.size << " bytes at " 
                         << info.file << ":" << info.line << "\n";
            }
        }
        
        std::cout << "Peak memory usage: " << peak_allocated << " bytes\n";
        std::cout << "Current memory usage: " << total_allocated << " bytes\n";
    }
};

// ĞœĞ°ĞºÑ€Ğ¾ÑÑ‹ Ğ´Ğ»Ñ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ
#define TRACKED_NEW(size) \
    ([&](size_t s) { \
        void* ptr = malloc(s); \
        MemoryProfiler::instance().record_allocation(ptr, s, __FILE__, __LINE__); \
        return ptr; \
    })(size)

#define TRACKED_DELETE(ptr) \
    do { \
        MemoryProfiler::instance().record_deallocation(ptr); \
        free(ptr); \
    } while(0)
```

### ğŸ” ĞŸĞ¾Ğ¸ÑĞº ÑƒĞ·ĞºĞ¸Ñ… Ğ¼ĞµÑÑ‚

#### CPU Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ sampling

```cpp
class SamplingProfiler {
private:
    struct Sample {
        std::string function_name;
        std::chrono::time_point<std::chrono::steady_clock> timestamp;
    };
    
    std::vector<Sample> samples;
    std::atomic<bool> profiling{false};
    std::thread sampling_thread;
    
    void sampling_loop() {
        while (profiling) {
            // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑÑ‚ĞµĞº Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² (ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ)
            samples.push_back({get_current_function(), std::chrono::steady_clock::now()});
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    }
    
    std::string get_current_function() {
        // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ÑŒ ÑÑ‚ĞµĞº Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²
        // Ğ—Ğ´ĞµÑÑŒ ÑƒĞ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ
        return "unknown_function";
    }
    
public:
    void start_profiling() {
        profiling = true;
        sampling_thread = std::thread(&SamplingProfiler::sampling_loop, this);
    }
    
    void stop_profiling() {
        profiling = false;
        if (sampling_thread.joinable()) {
            sampling_thread.join();
        }
    }
    
    void generate_report() {
        std::unordered_map<std::string, int> function_counts;
        
        for (const auto& sample : samples) {
            function_counts[sample.function_name]++;
        }
        
        std::vector<std::pair<std::string, int>> sorted_functions(
            function_counts.begin(), function_counts.end()
        );
        
        std::sort(sorted_functions.begin(), sorted_functions.end(),
                 [](const auto& a, const auto& b) { return a.second > b.second; });
        
        std::cout << "=== CPU PROFILING REPORT ===\n";
        for (const auto& [func, count] : sorted_functions) {
            float percentage = (float)count / samples.size() * 100.0f;
            std::cout << func << ": " << percentage << "% (" << count << " samples)\n";
        }
    }
};
```

### ğŸ“ˆ Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

```
ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ° Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°:

=== PERFORMANCE REPORT ===

Hotspots (most time consuming):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ matrix_multiply()     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 45.2% (2.1s) â”‚
â”‚ vector_normalize()    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 28.7% (1.3s)           â”‚
â”‚ collision_detect()    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 15.1% (0.7s)                  â”‚
â”‚ render_particles()    â–ˆâ–ˆ 8.9% (0.4s)                        â”‚
â”‚ input_processing()    â–Œ 2.1% (0.1s)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Memory usage over time:
     MB
  100 â”¤                                          â•­â”€â•®
   90 â”¤                                      â•­â”€â”€â”€â•¯ â•°â”€â•®
   80 â”¤                              â•­â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â•®
   70 â”¤                      â•­â”€â”€â”€â”€â”€â”€â”€â•¯                 â•°â”€â•®
   60 â”¤              â•­â”€â”€â”€â”€â”€â”€â”€â•¯                           â•°â”€â•®
   50 â”¤      â•­â”€â”€â”€â”€â”€â”€â”€â•¯                                     â•°â”€â•®
   40 â”¤  â•­â”€â”€â”€â•¯                                               â•°â”€
   30 â”¤â•­â”€â•¯
   20 â”¼â•¯
      â””â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬
       0    10    20    30    40    50    60    70    80    90  sec

Cache miss rate:
L1: 2.3% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
L2: 8.7% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
L3: 23.1% â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
```

---

## ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ

### Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 1: ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¼Ğ°Ñ‚Ñ€Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ÑƒĞ¼Ğ½Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ¸ ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ¾Ğ²:

1. **ĞĞ°Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼** (O(nÂ³))
2. **Cache-friendly Ğ²ĞµÑ€ÑĞ¸Ñ** (Ğ±Ğ»Ğ¾Ñ‡Ğ½Ğ¾Ğµ ÑƒĞ¼Ğ½Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ)
3. **SIMD Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ**

### Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 2: Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ Ğ´Ğ»Ñ Ğ¸Ğ³Ñ€Ñ‹

Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ complete memory management system Ğ´Ğ»Ñ 2D Ğ¸Ğ³Ñ€Ñ‹:

1. **Object pools** Ğ´Ğ»Ñ Ğ¸Ğ³Ñ€Ğ¾Ğ²Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
2. **Stack allocator** Ğ´Ğ»Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ĞºĞ°Ğ´Ñ€Ğ°
3. **Memory tracker** Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸ ÑƒÑ‚ĞµÑ‡ĞµĞº

### Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ 3: Ğ’Ñ‹ÑĞ¾ĞºĞ¾Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€ÑĞµÑ€ JSON

ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ°Ñ€ÑĞµÑ€ JSON Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼:

1. **ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ allocations**
2. **Cache-friendly Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼**
3. **SIMD Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹ Ğ´Ğ»Ñ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…**

---

## âœ… ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹

1. ĞĞ±ÑŠÑÑĞ½Ğ¸Ñ‚Ğµ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ spatial Ğ¸ temporal locality
2. ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Structure of Arrays Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ Array of Structures?
3. ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Object Pool, Ğ° ĞºĞ¾Ğ³Ğ´Ğ° Memory Pool?
4. ĞšĞ°Ğº Ğ±Ğ¸Ñ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°ÑÑ‚ ÑĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ?
5. ĞšĞ°ĞºĞ¸Ğµ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸ Ğ²Ğ°Ğ¶Ğ½Ñ‹ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸?

---

## ğŸ“š Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ€ĞµÑÑƒÑ€ÑÑ‹

- **Intel Optimization Manual** - Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ğ¾ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ´ x86
- **Agner Fog's optimization manuals** - Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑĞ¾Ğ²ĞµÑ‚Ñ‹
- **"Computer Systems: A Programmer's Perspective"** - Ğ³Ğ»ÑƒĞ±Ğ¾ĞºĞ¾Ğµ Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹
- **Chandler Carruth's CppCon talks** - ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¸ĞºĞ¸ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

**Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ğ±Ğ»Ğ¾Ğº:** Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… â†’