    // 2. Go built-in map (–±–µ–∑ eviction)
    goMap := make(map[string]string)
    start = time.Now()
    mapHits := 0
    
    for _, key := range keys {
        if _, found := goMap[key]; found {
            mapHits++
        } else {
            goMap[key] = fmt.Sprintf("value_%s", key)
        }
    }
    mapTime := time.Since(start)
    
    // 3. –ü—Ä–æ—Å—Ç–æ–π FIFO cache
    type FIFOCache struct {
        items    map[string]string
        keys     []string
        capacity int
    }
    
    fifoCache := &FIFOCache{
        items:    make(map[string]string),
        keys:     make([]string, 0),
        capacity: 100,
    }
    
    start = time.Now()
    fifoHits := 0
    
    for _, key := range keys {
        if _, found := fifoCache.items[key]; found {
            fifoHits++
        } else {
            if len(fifoCache.keys) >= fifoCache.capacity {
                // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç (FIFO)
                oldKey := fifoCache.keys[0]
                delete(fifoCache.items, oldKey)
                fifoCache.keys = fifoCache.keys[1:]
            }
            fifoCache.items[key] = fmt.Sprintf("value_%s", key)
            fifoCache.keys = append(fifoCache.keys, key)
        }
    }
    fifoTime := time.Since(start)
    
    fmt.Printf("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã (%d –æ–ø–µ—Ä–∞—Ü–∏–π):\n", operations)
    fmt.Printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n")
    fmt.Printf("‚îÇ –°—Ç—Ä–∞—Ç–µ–≥–∏—è       ‚îÇ –í—Ä–µ–º—è   ‚îÇ Hits    ‚îÇ Hit Rate    ‚îÇ\n")
    fmt.Printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n")
    fmt.Printf("‚îÇ LRU Cache       ‚îÇ %7v ‚îÇ %7d ‚îÇ %9.1f%% ‚îÇ\n", lruTime, lruHits, float64(lruHits)/float64(operations)*100)
    fmt.Printf("‚îÇ Go Map          ‚îÇ %7v ‚îÇ %7d ‚îÇ %9.1f%% ‚îÇ\n", mapTime, mapHits, float64(mapHits)/float64(operations)*100)
    fmt.Printf("‚îÇ FIFO Cache      ‚îÇ %7v ‚îÇ %7d ‚îÇ %9.1f%% ‚îÇ\n", fifoTime, fifoHits, float64(fifoHits)/float64(operations)*100)
    fmt.Printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n")
    
    fmt.Println("\nüí° –í—ã–≤–æ–¥—ã:")
    fmt.Println("‚Ä¢ Go Map —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π, –Ω–æ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–∞–º—è—Ç–∏")
    fmt.Println("‚Ä¢ LRU Cache –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ª—É—á—à–∏–π hit rate –±–ª–∞–≥–æ–¥–∞—Ä—è locality")
    fmt.Println("‚Ä¢ FIFO Cache –ø—Ä–æ—â–µ, –Ω–æ –º–µ–Ω–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –¥–ª—è temporal locality")
}

---

## –ú–æ–¥—É–ª—å 13: Message Queues –∏ Event Sourcing

### üì® Message Queue –ø–∞—Ç—Ç–µ—Ä–Ω—ã

```
MESSAGE QUEUE - –ê–°–ò–ù–•–†–û–ù–ù–ê–Ø –°–í–Ø–ó–¨ –ú–ï–ñ–î–£ –°–ï–†–í–ò–°–ê–ú–ò:

POINT-TO-POINT (–û—á–µ—Ä–µ–¥—å):
Producer ‚Üí [Queue] ‚Üí Consumer
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ M1  ‚îÇ ‚Üê –°–æ–æ–±—â–µ–Ω–∏—è –∂–¥—É—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏
           ‚îÇ M2  ‚îÇ   –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω consumer –ø–æ–ª—É—á–∞–µ—Ç –∫–∞–∂–¥–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
           ‚îÇ M3  ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

PUBLISH-SUBSCRIBE (–¢–æ–ø–∏–∫):
                  Consumer A
                     ‚Üë
Producer ‚Üí [Topic] ‚Üí Consumer B
                     ‚Üì
                  Consumer C
                  
–í—Å–µ –ø–æ–¥–ø–∏—Å—á–∏–∫–∏ –ø–æ–ª—É—á–∞—é—Ç –∫–æ–ø–∏—é –∫–∞–∂–¥–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è

–û–°–ù–û–í–ù–´–ï –ì–ê–†–ê–ù–¢–ò–ò:
‚Ä¢ AT-LEAST-ONCE: —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –º–∏–Ω–∏–º—É–º –æ–¥–∏–Ω —Ä–∞–∑
‚Ä¢ AT-MOST-ONCE: —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –º–∞–∫—Å–∏–º—É–º –æ–¥–∏–Ω —Ä–∞–∑  
‚Ä¢ EXACTLY-ONCE: —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω —Ä–∞–∑ (—Å–ª–æ–∂–Ω–æ!)

BACKPRESSURE:
Producer ‚Üí [Full Queue] ‚Üê Consumer (–º–µ–¥–ª–µ–Ω–Ω—ã–π)
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ M1 M2 M3‚îÇ ‚Üê –û—á–µ—Ä–µ–¥—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞
           ‚îÇ M4 M5 M6‚îÇ   –ß—Ç–æ –¥–µ–ª–∞—Ç—å?
           ‚îÇ M7 M8 M9‚îÇ   ‚Ä¢ –ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å producer
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚Ä¢ –û—Ç–±—Ä–∞—Å—ã–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
                         ‚Ä¢ Scaling consumers
```

### üîÑ Ring Buffer –¥–ª—è –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã—Ö –æ—á–µ—Ä–µ–¥–µ–π

```go
package main

import (
    "errors"
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// üîÑ LOCK-FREE RING BUFFER
type RingBuffer struct {
    buffer   []interface{}
    capacity int64
    head     int64 // –ò–Ω–¥–µ–∫—Å –¥–ª—è –∑–∞–ø–∏—Å–∏
    tail     int64 // –ò–Ω–¥–µ–∫—Å –¥–ª—è —á—Ç–µ–Ω–∏—è
    mask     int64 // –ú–∞—Å–∫–∞ –¥–ª—è –∫–æ–ª—å—Ü–µ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π (capacity - 1)
}

func NewRingBuffer(capacity int) *RingBuffer {
    // Capacity –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç–µ–ø–µ–Ω—å—é –¥–≤–æ–π–∫–∏ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    if capacity&(capacity-1) != 0 {
        panic("Capacity –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å—Ç–µ–ø–µ–Ω—å—é –¥–≤–æ–π–∫–∏")
    }
    
    return &RingBuffer{
        buffer:   make([]interface{}, capacity),
        capacity: int64(capacity),
        head:     0,
        tail:     0,
        mask:     int64(capacity) - 1,
    }
}

// ‚úçÔ∏è –ó–ê–ü–ò–°–¨ –í –ë–£–§–ï–†
func (rb *RingBuffer) Enqueue(item interface{}) bool {
    head := atomic.LoadInt64(&rb.head)
    tail := atomic.LoadInt64(&rb.tail)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω –ª–∏ –±—É—Ñ–µ—Ä
    if head-tail >= rb.capacity {
        return false // –ë—É—Ñ–µ—Ä –ø–æ–ª–æ–Ω
    }
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç
    rb.buffer[head&rb.mask] = item
    
    // –ê—Ç–æ–º–∞—Ä–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º head
    atomic.StoreInt64(&rb.head, head+1)
    return true
}

// üìñ –ß–¢–ï–ù–ò–ï –ò–ó –ë–£–§–ï–†–ê
func (rb *RingBuffer) Dequeue() (interface{}, bool) {
    head := atomic.LoadInt64(&rb.head)
    tail := atomic.LoadInt64(&rb.tail)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—É—Å—Ç –ª–∏ –±—É—Ñ–µ—Ä
    if tail >= head {
        return nil, false // –ë—É—Ñ–µ—Ä –ø—É—Å—Ç
    }
    
    // –ß–∏—Ç–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç
    item := rb.buffer[tail&rb.mask]
    
    // –ê—Ç–æ–º–∞—Ä–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º tail
    atomic.StoreInt64(&rb.tail, tail+1)
    return item, true
}

// üìä –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –°–û–°–¢–û–Ø–ù–ò–ò
func (rb *RingBuffer) Size() int64 {
    head := atomic.LoadInt64(&rb.head)
    tail := atomic.LoadInt64(&rb.tail)
    return head - tail
}

func (rb *RingBuffer) IsEmpty() bool {
    return rb.Size() == 0
}

func (rb *RingBuffer) IsFull() bool {
    return rb.Size() >= rb.capacity
}

// üéØ –ü–û–¢–û–ö–û–ë–ï–ó–û–ü–ê–°–ù–ê–Ø –û–ß–ï–†–ï–î–¨ –ù–ê –û–°–ù–û–í–ï RING BUFFER
type ThreadSafeQueue struct {
    buffer *RingBuffer
    mutex  sync.Mutex
    cond   *sync.Cond
}

func NewThreadSafeQueue(capacity int) *ThreadSafeQueue {
    tsq := &ThreadSafeQueue{
        buffer: NewRingBuffer(capacity),
    }
    tsq.cond = sync.NewCond(&tsq.mutex)
    return tsq
}

func (tsq *ThreadSafeQueue) Enqueue(item interface{}) {
    tsq.mutex.Lock()
    defer tsq.mutex.Unlock()
    
    // –ñ–¥–µ–º, –ø–æ–∫–∞ –≤ –±—É—Ñ–µ—Ä–µ –Ω–µ –ø–æ—è–≤–∏—Ç—Å—è –º–µ—Å—Ç–æ
    for tsq.buffer.IsFull() {
        tsq.cond.Wait()
    }
    
    tsq.buffer.Enqueue(item)
    tsq.cond.Signal() // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–µ–π
}

func (tsq *ThreadSafeQueue) Dequeue() interface{} {
    tsq.mutex.Lock()
    defer tsq.mutex.Unlock()
    
    // –ñ–¥–µ–º, –ø–æ–∫–∞ –±—É—Ñ–µ—Ä –Ω–µ —Å—Ç–∞–Ω–µ—Ç –Ω–µ–ø—É—Å—Ç—ã–º
    for tsq.buffer.IsEmpty() {
        tsq.cond.Wait()
    }
    
    item, _ := tsq.buffer.Dequeue()
    tsq.cond.Signal() // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ–∂–∏–¥–∞—é—â–∏—Ö –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–µ–π
    return item
}

func (tsq *ThreadSafeQueue) TryDequeue() (interface{}, bool) {
    tsq.mutex.Lock()
    defer tsq.mutex.Unlock()
    
    return tsq.buffer.Dequeue()
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø RING BUFFER
func ringBufferDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Ring Buffer ===")
    
    buffer := NewRingBuffer(8) // Capacity = 8
    
    fmt.Println("–î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã:")
    for i := 1; i <= 10; i++ {
        success := buffer.Enqueue(fmt.Sprintf("item_%d", i))
        if success {
            fmt.Printf("  Enqueue item_%d ‚úÖ (size: %d)\n", i, buffer.Size())
        } else {
            fmt.Printf("  Enqueue item_%d ‚ùå (buffer full)\n", i)
        }
    }
    
    fmt.Println("\n–ò–∑–≤–ª–µ–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã:")
    for i := 0; i < 5; i++ {
        if item, success := buffer.Dequeue(); success {
            fmt.Printf("  Dequeue %v ‚úÖ (size: %d)\n", item, buffer.Size())
        } else {
            fmt.Printf("  Dequeue ‚ùå (buffer empty)\n")
        }
    }
    
    fmt.Println("\n–î–æ–±–∞–≤–ª—è–µ–º –µ—â–µ —ç–ª–µ–º–µ–Ω—Ç—ã (–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–ª—å—Ü–µ–≤–æ–≥–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è):")
    for i := 11; i <= 15; i++ {
        success := buffer.Enqueue(fmt.Sprintf("item_%d", i))
        if success {
            fmt.Printf("  Enqueue item_%d ‚úÖ (size: %d)\n", i, buffer.Size())
        } else {
            fmt.Printf("  Enqueue item_%d ‚ùå (buffer full)\n", i)
        }
    }
}

// üì® MESSAGE QUEUE –° –ü–†–ò–û–†–ò–¢–ï–¢–ê–ú–ò
type PriorityMessage struct {
    Content  string
    Priority int
    ID       int
}

type PriorityMessageQueue struct {
    messages []*PriorityMessage
    mutex    sync.RWMutex
    cond     *sync.Cond
    nextID   int
}

func NewPriorityMessageQueue() *PriorityMessageQueue {
    pmq := &PriorityMessageQueue{
        messages: make([]*PriorityMessage, 0),
        nextID:   1,
    }
    pmq.cond = sync.NewCond(&pmq.mutex)
    return pmq
}

func (pmq *PriorityMessageQueue) Send(content string, priority int) {
    pmq.mutex.Lock()
    defer pmq.mutex.Unlock()
    
    message := &PriorityMessage{
        Content:  content,
        Priority: priority,
        ID:       pmq.nextID,
    }
    pmq.nextID++
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É)
    inserted := false
    for i, existing := range pmq.messages {
        if priority > existing.Priority {
            // –í—Å—Ç–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–¥ —Ç–µ–∫—É—â–∏–º —ç–ª–µ–º–µ–Ω—Ç–æ–º
            pmq.messages = append(pmq.messages[:i], append([]*PriorityMessage{message}, pmq.messages[i:]...)...)
            inserted = true
            break
        }
    }
    
    if !inserted {
        pmq.messages = append(pmq.messages, message)
    }
    
    pmq.cond.Signal() // –£–≤–µ–¥–æ–º–ª—è–µ–º –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–µ–π
}

func (pmq *PriorityMessageQueue) Receive() *PriorityMessage {
    pmq.mutex.Lock()
    defer pmq.mutex.Unlock()
    
    // –ñ–¥–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
    for len(pmq.messages) == 0 {
        pmq.cond.Wait()
    }
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∞–∏–≤—ã—Å—à–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
    message := pmq.messages[0]
    pmq.messages = pmq.messages[1:]
    
    return message
}

func (pmq *PriorityMessageQueue) Size() int {
    pmq.mutex.RLock()
    defer pmq.mutex.RUnlock()
    return len(pmq.messages)
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø PRIORITY MESSAGE QUEUE
func priorityMessageQueueDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Priority Message Queue ===")
    
    queue := NewPriorityMessageQueue()
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ä–∞–∑–Ω—ã–º–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
    messages := []struct {
        content  string
        priority int
    }{
        {"Regular task", 1},
        {"Important notification", 5},
        {"Critical system alert", 10},
        {"Another regular task", 2},
        {"High priority order", 7},
        {"System maintenance", 3},
    }
    
    fmt.Println("–û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è:")
    for _, msg := range messages {
        queue.Send(msg.content, msg.priority)
        fmt.Printf("  Sent: '%s' (priority: %d)\n", msg.content, msg.priority)
    }
    
    fmt.Printf("\n–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞:\n")
    for queue.Size() > 0 {
        message := queue.Receive()
        fmt.Printf("  Received: '%s' (priority: %d, ID: %d)\n", 
            message.Content, message.Priority, message.ID)
    }
}

// üìä EVENT SOURCING - –•–†–ê–ù–ï–ù–ò–ï –°–û–ë–´–¢–ò–ô
type Event struct {
    AggregateID string
    EventType   string
    Data        map[string]interface{}
    Version     int
    Timestamp   time.Time
    ID          string
}

type EventStore struct {
    events map[string][]*Event // aggregateID -> []Event
    mutex  sync.RWMutex
    nextEventID int
}

func NewEventStore() *EventStore {
    return &EventStore{
        events: make(map[string][]*Event),
        nextEventID: 1,
    }
}

func (es *EventStore) AppendEvent(aggregateID, eventType string, data map[string]interface{}) error {
    es.mutex.Lock()
    defer es.mutex.Unlock()
    
    events := es.events[aggregateID]
    
    event := &Event{
        AggregateID: aggregateID,
        EventType:   eventType,
        Data:        data,
        Version:     len(events) + 1,
        Timestamp:   time.Now(),
        ID:          fmt.Sprintf("event_%d", es.nextEventID),
    }
    es.nextEventID++
    
    es.events[aggregateID] = append(events, event)
    
    fmt.Printf("üìù Event stored: %s (%s v%d)\n", eventType, aggregateID, event.Version)
    return nil
}

func (es *EventStore) GetEvents(aggregateID string, fromVersion int) []*Event {
    es.mutex.RLock()
    defer es.mutex.RUnlock()
    
    allEvents := es.events[aggregateID]
    if fromVersion <= 1 {
        return allEvents
    }
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º —Å–æ–±—ã—Ç–∏—è –Ω–∞—á–∏–Ω–∞—è —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    var filteredEvents []*Event
    for _, event := range allEvents {
        if event.Version >= fromVersion {
            filteredEvents = append(filteredEvents, event)
        }
    }
    
    return filteredEvents
}

func (es *EventStore) GetLatestVersion(aggregateID string) int {
    es.mutex.RLock()
    defer es.mutex.RUnlock()
    
    events := es.events[aggregateID]
    if len(events) == 0 {
        return 0
    }
    
    return events[len(events)-1].Version
}

// üè™ AGGREGATE - –†–ï–ö–û–ù–°–¢–†–£–ö–¶–ò–Ø –°–û–°–¢–û–Ø–ù–ò–Ø –ò–ó –°–û–ë–´–¢–ò–ô
type BankAccount struct {
    ID      string
    Balance float64
    Status  string
    Version int
}

func (ba *BankAccount) ApplyEvent(event *Event) {
    switch event.EventType {
    case "AccountOpened":
        ba.ID = event.AggregateID
        ba.Balance = 0
        ba.Status = "active"
        
    case "MoneyDeposited":
        amount := event.Data["amount"].(float64)
        ba.Balance += amount
        
    case "MoneyWithdrawn":
        amount := event.Data["amount"].(float64)
        ba.Balance -= amount
        
    case "AccountClosed":
        ba.Status = "closed"
    }
    
    ba.Version = event.Version
}

func ReconstructBankAccount(eventStore *EventStore, accountID string) *BankAccount {
    account := &BankAccount{}
    events := eventStore.GetEvents(accountID, 0)
    
    for _, event := range events {
        account.ApplyEvent(event)
    }
    
    return account
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø EVENT SOURCING
func eventSourcingDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Event Sourcing ===")
    
    eventStore := NewEventStore()
    accountID := "account_123"
    
    // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏–π
    fmt.Println("\n–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏–π:")
    
    // 1. –û—Ç–∫—Ä—ã—Ç–∏–µ —Å—á–µ—Ç–∞
    eventStore.AppendEvent(accountID, "AccountOpened", map[string]interface{}{
        "ownerName": "John Doe",
    })
    
    // 2. –î–µ–ø–æ–∑–∏—Ç—ã
    eventStore.AppendEvent(accountID, "MoneyDeposited", map[string]interface{}{
        "amount": 1000.0,
    })
    
    eventStore.AppendEvent(accountID, "MoneyDeposited", map[string]interface{}{
        "amount": 500.0,
    })
    
    // 3. –°–Ω—è—Ç–∏–µ
    eventStore.AppendEvent(accountID, "MoneyWithdrawn", map[string]interface{}{
        "amount": 200.0,
    })
    
    // 4. –ï—â–µ –æ–¥–∏–Ω –¥–µ–ø–æ–∑–∏—Ç
    eventStore.AppendEvent(accountID, "MoneyDeposited", map[string]interface{}{
        "amount": 300.0,
    })
    
    // –†–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–∑ —Å–æ–±—ã—Ç–∏–π
    fmt.Println("\nüîÑ –†–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å—á–µ—Ç–∞:")
    account := ReconstructBankAccount(eventStore, accountID)
    
    fmt.Printf("ID: %s\n", account.ID)
    fmt.Printf("–ë–∞–ª–∞–Ω—Å: $%.2f\n", account.Balance)
    fmt.Printf("–°—Ç–∞—Ç—É—Å: %s\n", account.Status)
    fmt.Printf("–í–µ—Ä—Å–∏—è: %d\n", account.Version)
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è
    fmt.Println("\nüìã –ò—Å—Ç–æ—Ä–∏—è —Å–æ–±—ã—Ç–∏–π:")
    events := eventStore.GetEvents(accountID, 0)
    for _, event := range events {
        fmt.Printf("  v%d: %s at %s\n", event.Version, event.EventType, 
            event.Timestamp.Format("15:04:05"))
        for key, value := range event.Data {
            fmt.Printf("    %s: %v\n", key, value)
        }
    }
    
    // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏
    fmt.Println("\n‚è∞ –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Å–ª–µ –≤–µ—Ä—Å–∏–∏ 3:")
    partialAccount := &BankAccount{}
    partialEvents := eventStore.GetEvents(accountID, 0)[:3] // –ü–µ—Ä–≤—ã–µ 3 —Å–æ–±—ã—Ç–∏—è
    
    for _, event := range partialEvents {
        partialAccount.ApplyEvent(event)
    }
    
    fmt.Printf("–ë–∞–ª–∞–Ω—Å –Ω–∞ —Ç–æ—Ç –º–æ–º–µ–Ω—Ç: $%.2f\n", partialAccount.Balance)
}

// üîÑ SAGA PATTERN –î–õ–Ø –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ù–´–• –¢–†–ê–ù–ó–ê–ö–¶–ò–ô
type SagaStep struct {
    Name           string
    Execute        func() error
    Compensate     func() error
    Executed       bool
    CompensateData map[string]interface{}
}

type Saga struct {
    Name  string
    Steps []*SagaStep
    eventStore *EventStore
}

func NewSaga(name string, eventStore *EventStore) *Saga {
    return &Saga{
        Name:  name,
        Steps: make([]*SagaStep, 0),
        eventStore: eventStore,
    }
}

func (s *Saga) AddStep(step *SagaStep) {
    s.Steps = append(s.Steps, step)
}

func (s *Saga) Execute() error {
    fmt.Printf("üöÄ –ó–∞–ø—É—Å–∫ Saga: %s\n", s.Name)
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –Ω–∞—á–∞–ª–∞ Saga
    s.eventStore.AppendEvent(s.Name, "SagaStarted", map[string]interface{}{
        "totalSteps": len(s.Steps),
    })
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º —à–∞–≥–∏
    for i, step := range s.Steps {
        fmt.Printf("  –®–∞–≥ %d: %s\n", i+1, step.Name)
        
        err := step.Execute()
        if err != nil {
            fmt.Printf("  ‚ùå –û—à–∏–±–∫–∞ –≤ —à–∞–≥–µ %s: %v\n", step.Name, err)
            
            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –æ—à–∏–±–∫–∏
            s.eventStore.AppendEvent(s.Name, "SagaFailed", map[string]interface{}{
                "failedStep": step.Name,
                "error":      err.Error(),
            })
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—é
            s.compensate(i)
            return err
        }
        
        step.Executed = true
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —à–∞–≥–∞
        s.eventStore.AppendEvent(s.Name, "SagaStepCompleted", map[string]interface{}{
            "stepName": step.Name,
            "stepNumber": i + 1,
        })
        
        fmt.Printf("  ‚úÖ –®–∞–≥ %s –≤—ã–ø–æ–ª–Ω–µ–Ω\n", step.Name)
    }
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    s.eventStore.AppendEvent(s.Name, "SagaCompleted", map[string]interface{}{
        "completedSteps": len(s.Steps),
    })
    
    fmt.Printf("‚úÖ Saga %s –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ\n", s.Name)
    return nil
}

func (s *Saga) compensate(failedStepIndex int) {
    fmt.Printf("üîÑ –ó–∞–ø—É—Å–∫ –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏ –¥–ª—è Saga: %s\n", s.Name)
    
    // –ö–æ–º–ø–µ–Ω—Å–∏—Ä—É–µ–º –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    for i := failedStepIndex - 1; i >= 0; i-- {
        step := s.Steps[i]
        if step.Executed && step.Compensate != nil {
            fmt.Printf("  –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —à–∞–≥–∞: %s\n", step.Name)
            
            err := step.Compensate()
            if err != nil {
                fmt.Printf("  ‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏ %s: %v\n", step.Name, err)
                
                s.eventStore.AppendEvent(s.Name, "SagaCompensationFailed", map[string]interface{}{
                    "stepName": step.Name,
                    "error":    err.Error(),
                })
            } else {
                fmt.Printf("  ‚úÖ –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è %s –≤—ã–ø–æ–ª–Ω–µ–Ω–∞\n", step.Name)
                
                s.eventStore.AppendEvent(s.Name, "SagaStepCompensated", map[string]interface{}{
                    "stepName": step.Name,
                })
            }
        }
    }
    
    s.eventStore.AppendEvent(s.Name, "SagaCompensated", map[string]interface{}{})
    fmt.Printf("üîÑ –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è Saga %s –∑–∞–≤–µ—Ä—à–µ–Ω–∞\n", s.Name)
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø SAGA PATTERN
func sagaDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Saga Pattern ===")
    
    eventStore := NewEventStore()
    
    // –°–æ–∑–¥–∞–µ–º Saga –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–∫–∞–∑–∞
    orderSaga := NewSaga("order_saga_001", eventStore)
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º –≤–Ω–µ—à–Ω–∏–µ —Å–µ—Ä–≤–∏—Å—ã
    var reservedInventory bool
    var chargedPayment bool
    var reservedShipping bool
    
    // –®–∞–≥ 1: –†–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
    orderSaga.AddStep(&SagaStep{
        Name: "ReserveInventory",
        Execute: func() error {
            fmt.Println("    –†–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º —Ç–æ–≤–∞—Ä –≤ inventory service...")
            reservedInventory = true
            return nil // –£—Å–ø–µ—Ö
        },
        Compensate: func() error {
            fmt.Println("    –û—Ç–º–µ–Ω—è–µ–º —Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞...")
            reservedInventory = false
            return nil
        },
    })
    
    // –®–∞–≥ 2: –û–ø–ª–∞—Ç–∞
    orderSaga.AddStep(&SagaStep{
        Name: "ChargePayment",
        Execute: func() error {
            fmt.Println("    –°–ø–∏—Å—ã–≤–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ —Å –∫–∞—Ä—Ç—ã...")
            chargedPayment = true
            return nil // –£—Å–ø–µ—Ö
        },
        Compensate: func() error {
            fmt.Println("    –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –Ω–∞ –∫–∞—Ä—Ç—É...")
            chargedPayment = false
            return nil
        },
    })
    
    // –®–∞–≥ 3: –†–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (—Å–∏–º—É–ª–∏—Ä—É–µ–º –æ—à–∏–±–∫—É)
    orderSaga.AddStep(&SagaStep{
        Name: "ReserveShipping",
        Execute: func() error {
            fmt.Println("    –†–µ–∑–µ—Ä–≤–∏—Ä—É–µ–º —Å–ª–æ—Ç –¥–æ—Å—Ç–∞–≤–∫–∏...")
            return errors.New("shipping service unavailable") // –û—à–∏–±–∫–∞!
        },
        Compensate: func() error {
            fmt.Println("    –û—Ç–º–µ–Ω—è–µ–º —Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–∫–∏...")
            reservedShipping = false
            return nil
        },
    })
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º Saga
    err := orderSaga.Execute()
    
    fmt.Printf("\n–†–µ–∑—É–ª—å—Ç–∞—Ç:\n")
    fmt.Printf("  –¢–æ–≤–∞—Ä –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω: %t\n", reservedInventory)
    fmt.Printf("  –û–ø–ª–∞—Ç–∞ —Å–ø–∏—Å–∞–Ω–∞: %t\n", chargedPayment)
    fmt.Printf("  –î–æ—Å—Ç–∞–≤–∫–∞ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∞: %t\n", reservedShipping)
    fmt.Printf("  Saga –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π: %t\n", err != nil)
    
    fmt.Println("\nüìã –°–æ–±—ã—Ç–∏—è Saga:")
    events := eventStore.GetEvents("order_saga_001", 0)
    for _, event := range events {
        fmt.Printf("  %s at %s\n", event.EventType, event.Timestamp.Format("15:04:05"))
        for key, value := range event.Data {
            fmt.Printf("    %s: %v\n", key, value)
        }
    }
}

// ‚ö° –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨ MESSAGE QUEUES
func messageQueuePerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ Message Queues ===")
    
    const messages = 100000
    
    // 1. Ring Buffer
    ringBuffer := NewRingBuffer(1024)
    start := time.Now()
    
    // Producer
    go func() {
        for i := 0; i < messages; i++ {
            for !ringBuffer.Enqueue(fmt.Sprintf("msg_%d", i)) {
                // Spin until space available
            }
        }
    }()
    
    // Consumer
    consumed := 0
    for consumed < messages {
        if _, ok := ringBuffer.Dequeue(); ok {
            consumed++
        }
    }
    
    ringBufferTime := time.Since(start)
    
    // 2. Go channel
    ch := make(chan string, 1024)
    start = time.Now()
    
    // Producer
    go func() {
        for i := 0; i < messages; i++ {
            ch <- fmt.Sprintf("msg_%d", i)
        }
        close(ch)
    }()
    
    // Consumer
    consumed = 0
    for range ch {
        consumed++
    }
    
    channelTime := time.Since(start)
    
    // 3. Thread-safe queue
    tsQueue := NewThreadSafeQueue(1024)
    start = time.Now()
    
    // Producer
    go func() {
        for i := 0; i < messages; i++ {
            tsQueue.Enqueue(fmt.Sprintf("msg_%d", i))
        }
    }()
    
    // Consumer
    consumed = 0
    for consumed < messages {
        tsQueue.Dequeue()
        consumed++
    }
    
    tsQueueTime := time.Since(start)
    
    fmt.Printf("–û–±—Ä–∞–±–æ—Ç–∫–∞ %d —Å–æ–æ–±—â–µ–Ω–∏–π:\n", messages)
    fmt.Printf("  Ring Buffer:        %v\n", ringBufferTime)
    fmt.Printf("  Go Channel:         %v\n", channelTime)
    fmt.Printf("  Thread-Safe Queue:  %v\n", tsQueueTime)
    
    fmt.Printf("\n–¢hroughput (—Å–æ–æ–±—â–µ–Ω–∏–π/—Å–µ–∫):\n")
    fmt.Printf("  Ring Buffer:        %.0f\n", float64(messages)/ringBufferTime.Seconds())
    fmt.Printf("  Go Channel:         %.0f\n", float64(messages)/channelTime.Seconds())
    fmt.Printf("  Thread-Safe Queue:  %.0f\n", float64(messages)/tsQueueTime.Seconds())
}

---

# üèóÔ∏è –§–∞–∑–∞ 5: Performance –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è

## –ú–æ–¥—É–ª—å 14: –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –±–µ–Ω—á–º–∞—Ä–∫–∏–Ω–≥

### üìä Go benchmarking –∏ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ

```go
package main

import (
    "fmt"
    "math/rand"
    "runtime"
    "sort"
    "testing"
    "time"
)

// üèÉ‚Äç‚ôÇÔ∏è –ë–ï–ù–ß–ú–ê–†–ö–ò –î–õ–Ø –°–¢–†–£–ö–¢–£–† –î–ê–ù–ù–´–•
func BenchmarkArrayAccess(b *testing.B) {
    size := 10000
    arr := make([]int, size)
    for i := 0; i < size; i++ {
        arr[i] = rand.Intn(1000)
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = arr[i%size] // O(1) –¥–æ—Å—Ç—É–ø
    }
}

func BenchmarkSliceSearch(b *testing.B) {
    size := 10000
    slice := make([]int, size)
    for i := 0; i < size; i++ {
        slice[i] = rand.Intn(1000)
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        target := rand.Intn(1000)
        // –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ O(n)
        for _, val := range slice {
            if val == target {
                break
            }
        }
    }
}

func BenchmarkMapAccess(b *testing.B) {
    size := 10000
    m := make(map[int]int)
    for i := 0; i < size; i++ {
        m[i] = rand.Intn(1000)
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _ = m[i%size] // O(1) –¥–æ—Å—Ç—É–ø –≤ —Å—Ä–µ–¥–Ω–µ–º
    }
}

func BenchmarkMapSearch(b *testing.B) {
    size := 10000
    m := make(map[int]bool)
    for i := 0; i < size; i++ {
        m[rand.Intn(1000)] = true
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        target := rand.Intn(1000)
        _ = m[target] // O(1) –ø–æ–∏—Å–∫
    }
}

// üìä MEMORY ALLOCATION BENCHMARKS
func BenchmarkSliceAppend(b *testing.B) {
    b.ReportAllocs() // –û—Ç—á–µ—Ç –æ –≤—ã–¥–µ–ª–µ–Ω–∏–∏ –ø–∞–º—è—Ç–∏
    
    for i := 0; i < b.N; i++ {
        var slice []int
        for j := 0; j < 1000; j++ {
            slice = append(slice, j) // –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
        }
    }
}

func BenchmarkSlicePrealloc(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        slice := make([]int, 0, 1000) // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
        for j := 0; j < 1000; j++ {
            slice = append(slice, j) // –ë–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
        }
    }
}

func BenchmarkStringConcat(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        var result string
        for j := 0; j < 100; j++ {
            result += fmt.Sprintf("item_%d", j) // –ú–µ–¥–ª–µ–Ω–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
        }
    }
}

func BenchmarkStringBuilder(b *testing.B) {
    b.ReportAllocs()
    
    for i := 0; i < b.N; i++ {
        var builder strings.Builder
        for j := 0; j < 100; j++ {
            builder.WriteString(fmt.Sprintf("item_%d", j)) // –ë—ã—Å—Ç—Ä–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
        }
        _ = builder.String()
    }
}

// üîç –ü–†–û–§–ò–õ–ò–†–û–í–ê–ù–ò–ï CPU –ò –ü–ê–ú–Ø–¢–ò
func profileDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è ===")
    
    // CPU –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ pprof)
    start := time.Now()
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º CPU-intensive —Ä–∞–±–æ—Ç—É
    data := make([]int, 1000000)
    for i := 0; i < len(data); i++ {
        data[i] = rand.Intn(1000)
    }
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (CPU intensive)
    sort.Ints(data)
    
    cpuTime := time.Since(start)
    
    // Memory –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º memory-intensive —Ä–∞–±–æ—Ç—É
    var bigSlices [][]int
    for i := 0; i < 1000; i++ {
        slice := make([]int, 1000)
        for j := range slice {
            slice[j] = rand.Intn(1000)
        }
        bigSlices = append(bigSlices, slice)
    }
    
    runtime.ReadMemStats(&m2)
    
    fmt.Printf("CPU –≤—Ä–µ–º—è –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ 1M —á–∏—Å–µ–ª: %v\n", cpuTime)
    fmt.Printf("–ü–∞–º—è—Ç—å –¥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è: %d KB\n", m1.Alloc/1024)
    fmt.Printf("–ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ –≤—ã–¥–µ–ª–µ–Ω–∏—è: %d KB\n", m2.Alloc/1024)
    fmt.Printf("–í—ã–¥–µ–ª–µ–Ω–æ –ø–∞–º—è—Ç–∏: %d KB\n", (m2.Alloc-m1.Alloc)/1024)
    fmt.Printf("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ GC —Ü–∏–∫–ª–æ–≤: %d\n", m2.NumGC-m1.NumGC)
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
    bigSlices = nil
    runtime.GC()
    
    var m3 runtime.MemStats
    runtime.ReadMemStats(&m3)
    fmt.Printf("–ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ GC: %d KB\n", m3.Alloc/1024)
}

// üéØ CACHE-FRIENDLY –ü–†–û–ì–†–ê–ú–ú–ò–†–û–í–ê–ù–ò–ï
func cacheFriendlyDemo() {
    fmt.Println("=== Cache-friendly vs Cache-unfriendly –¥–æ—Å—Ç—É–ø ===")
    
    const size = 1000
    matrix := make([][]int, size)
    for i := range matrix {
        matrix[i] = make([]int, size)
        for j := range matrix[i] {
            matrix[i][j] = i*size + j
        }
    }
    
    // Cache-friendly: –¥–æ—Å—Ç—É–ø –ø–æ —Å—Ç—Ä–æ–∫–∞–º
    start := time.Now()
    sum1 := 0
    for i := 0; i < size; i++ {
        for j := 0; j < size; j++ {
            sum1 += matrix[i][j] // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø
        }
    }
    rowWiseTime := time.Since(start)
    
    // Cache-unfriendly: –¥–æ—Å—Ç—É–ø –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º  
    start = time.Now()
    sum2 := 0
    for j := 0; j < size; j++ {
        for i := 0; i < size; i++ {
            sum2 += matrix[i][j] // –°–ª—É—á–∞–π–Ω—ã–π –¥–æ—Å—Ç—É–ø
        }
    }
    columnWiseTime := time.Since(start)
    
    fmt.Printf("–†–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã: %dx%d\n", size, size)
    fmt.Printf("Row-wise –¥–æ—Å—Ç—É–ø (cache-friendly): %v\n", rowWiseTime)
    fmt.Printf("Column-wise –¥–æ—Å—Ç—É–ø (cache-unfriendly): %v\n", columnWiseTime)
    fmt.Printf("–†–∞–∑–Ω–∏—Ü–∞: %.2fx –º–µ–¥–ª–µ–Ω–Ω–µ–µ\n", float64(columnWiseTime)/float64(rowWiseTime))
    fmt.Printf("–°—É–º–º—ã —Ä–∞–≤–Ω—ã: %t\n", sum1 == sum2)
    
    fmt.Println("\nüí° –û–±—ä—è—Å–Ω–µ–Ω–∏–µ:")
    fmt.Println("Row-wise –¥–æ—Å—Ç—É–ø –∏—Å–ø–æ–ª—å–∑—É–µ—Ç spatial locality:")
    fmt.Println("  –ö–æ–≥–¥–∞ CPU –∑–∞–≥—Ä—É–∂–∞–µ—Ç matrix[i][j], –æ–Ω —Ç–∞–∫–∂–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç")
    fmt.Println("  matrix[i][j+1], matrix[i][j+2], etc. –≤ cache line")
    fmt.Println("Column-wise –¥–æ—Å—Ç—É–ø –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç elements:")
    fmt.Println("  matrix[i][j] –∏ matrix[i+1][j] –Ω–∞—Ö–æ–¥—è—Ç—Å—è –¥–∞–ª–µ–∫–æ –≤ –ø–∞–º—è—Ç–∏")
    fmt.Println("  –ö–∞–∂–¥—ã–π –¥–æ—Å—Ç—É–ø –≤—ã–∑—ã–≤–∞–µ—Ç cache miss")
}

// üßÆ –ê–õ–ì–û–†–ò–¢–ú–ò–ß–ï–°–ö–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø
func algorithmicOptimizationDemo() {
    fmt.Println("=== –ê–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è ===")
    
    const n = 100000
    data := make([]int, n)
    for i := 0; i < n; i++ {
        data[i] = rand.Intn(1000)
    }
    
    // Naive –ø–æ–∏—Å–∫ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ O(n¬≤)
    start := time.Now()
    duplicatesNaive := make([]int, 0)
    for i := 0; i < len(data); i++ {
        for j := i + 1; j < len(data); j++ {
            if data[i] == data[j] {
                duplicatesNaive = append(duplicatesNaive, data[i])
                break
            }
        }
    }
    naiveTime := time.Since(start)
    
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ O(n) —Å HashMap
    start = time.Now()
    seen := make(map[int]bool)
    duplicatesOptimized := make([]int, 0)
    
    for _, val := range data {
        if seen[val] {
            duplicatesOptimized = append(duplicatesOptimized, val)
        } else {
            seen[val] = true
        }
    }
    optimizedTime := time.Since(start)
    
    fmt.Printf("–ü–æ–∏—Å–∫ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –≤ %d —ç–ª–µ–º–µ–Ω—Ç–∞—Ö:\n", n)
    fmt.Printf("Naive O(n¬≤):      %v (%d –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)\n", naiveTime, len(duplicatesNaive))
    fmt.Printf("HashMap O(n):     %v (%d –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)\n", optimizedTime, len(duplicatesOptimized))
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: %.0fx\n", float64(naiveTime)/float64(optimizedTime))
}

// üéõÔ∏è GOROUTINE POOL –î–õ–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò
type WorkerPool struct {
    workers    int
    jobQueue   chan func()
    quit       chan bool
}

func NewWorkerPool(workers int, queueSize int) *WorkerPool {
    return &WorkerPool{
        workers:  workers,
        jobQueue: make(chan func(), queueSize),
        quit:     make(chan bool),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workers; i++ {
        go func(workerID int) {
            for {
                select {
                case job := <-wp.jobQueue:
                    job() // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–¥–∞—á—É
                case <-wp.quit:
                    return
                }
            }
        }(i)
    }
}

func (wp *WorkerPool) Submit(job func()) {
    wp.jobQueue <- job
}

func (wp *WorkerPool) Stop() {
    close(wp.quit)
}

func workerPoolDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Worker Pool ===")
    
    const tasks = 10000
    const workers = 4
    
    // –ë–µ–∑ worker pool - —Å–æ–∑–¥–∞–µ–º goroutine –¥–ª—è –∫–∞–∂–¥–æ–π –∑–∞–¥–∞—á–∏
    start := time.Now()
    var wg sync.WaitGroup
    
    for i := 0; i < tasks; i++ {
        wg.Add(1)
        go func(taskID int) {
            defer wg.Done()
            // –ò–º–∏—Ç–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É
            time.Sleep(time.Microsecond * 100)
        }(i)
    }
    
    wg.Wait()
    noPoolTime := time.Since(start)
    
    // –° worker pool
    start = time.Now()
    pool := NewWorkerPool(workers, 100)
    pool.Start()
    
    var wg2 sync.WaitGroup
    for i := 0; i < tasks; i++ {
        wg2.Add(1)
        pool.Submit(func() {
            defer wg2.Done()
            // –ò–º–∏—Ç–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É
            time.Sleep(time.Microsecond * 100)
        })
    }
    
    wg2.Wait()
    pool.Stop()
    poolTime := time.Since(start)
    
    fmt.Printf("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ %d –∑–∞–¥–∞—á:\n", tasks)
    fmt.Printf("Without pool (%d goroutines): %v\n", tasks, noPoolTime)
    fmt.Printf("With pool (%d workers):       %v\n", workers, poolTime)
    fmt.Printf("–£–ª—É—á—à–µ–Ω–∏–µ: %.2fx\n", float64(noPoolTime)/float64(poolTime))
    
    fmt.Println("\nüí° Worker Pool –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:")
    fmt.Println("‚Ä¢ –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ goroutines")
    fmt.Println("‚Ä¢ –°–Ω–∏–∂–∞–µ—Ç overhead —Å–æ–∑–¥–∞–Ω–∏—è/—É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è goroutines")
    fmt.Println("‚Ä¢ –õ—É—á—à–µ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤")
    fmt.Println("‚Ä¢ –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç exhaustion —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤")
}

---

## –ú–æ–¥—É–ª—å 15: –í—ã–±–æ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö - Decision Framework

### üéØ –ß—Ç–æ –≤—ã –∏–∑—É—á–∏–ª–∏

**–§–∞–∑–∞ 1: –û—Å–Ω–æ–≤—ã –ø–∞–º—è—Ç–∏**
- –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–∞–º—è—Ç–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ (—Å—Ç–µ–∫, –∫—É—á–∞, –∫–µ—à–∏)
- Garbage Collection –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
- Memory pools –∏ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è

**–§–∞–∑–∞ 2: –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã**
- –ú–∞—Å—Å–∏–≤—ã –∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –º–∞—Å—Å–∏–≤—ã
- –°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –∏ –∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç—ã
- –°—Ç–µ–∫–∏ –∏ –æ—á–µ—Ä–µ–¥–∏ –¥–ª—è LIFO/FIFO –æ–±—Ä–∞–±–æ—Ç–∫–∏
- –î–µ—Ä–µ–≤—å—è –∏ –±–∏–Ω–∞—Ä–Ω—ã–µ –¥–µ—Ä–µ–≤—å—è –ø–æ–∏—Å–∫–∞
- –•–µ—à-—Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞

**–§–∞–∑–∞ 3: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã**
- –ö—É—á–∏ –¥–ª—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö –æ—á–µ—Ä–µ–¥–µ–π
- Trie –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Å—Ç—Ä–æ–∫
- Union-Find –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —Å –º–Ω–æ–∂–µ—Å—Ç–≤–∞–º–∏

**–§–∞–∑–∞ 4: Backend –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è**
- B+ Tree –∏ LSM-Tree –¥–ª—è –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö
- LRU Cache –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
- Message Queues –∏ Event Sourcing

**–§–∞–∑–∞ 5: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è**
- –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –±–µ–Ω—á–º–∞—Ä–∫–∏–Ω–≥
- –í—ã–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

### üèÜ –ö–ª—é—á–µ–≤—ã–µ –Ω–∞–≤—ã–∫–∏

‚úÖ **–ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏** - –ø–æ–Ω–∏–º–∞–Ω–∏–µ Big O notation –∏ trade-offs  
‚úÖ **Memory management** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏  
‚úÖ **Performance optimization** - –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è  
‚úÖ **Architecture decisions** - –≤—ã–±–æ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è –∑–∞–¥–∞—á–∏  
‚úÖ **Production readiness** - –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö  

### üöÄ –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

**–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç–µ–º—ã –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è:**
- **Distributed Systems**: Consistent hashing, CAP theorem, Consensus
- **Database Internals**: Query optimization, Storage engines
- **Concurrent Structures**: Lock-free algorithms, Memory models
- **Specialized Structures**: Spatial indexing, Streaming algorithms

**–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–µ–∫—Ç—ã:**
1. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–≤–æ—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö —Å B+ Tree –∏–Ω–¥–µ–∫—Å–∞–º–∏
2. –°–æ–∑–¥–∞–π—Ç–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π cache —Å consistent hashing
3. –ü–æ—Å—Ç—Ä–æ–π—Ç–µ –ø–æ–∏—Å–∫–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É —Å Trie –∏ ranking
4. –†–∞–∑—Ä–∞–±–æ—Ç–∞–π—Ç–µ message queue —Å –≥–∞—Ä–∞–Ω—Ç–∏—è–º–∏ –¥–æ—Å—Ç–∞–≤–∫–∏

### üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

**–ö–Ω–∏–≥–∏:**
- "Introduction to Algorithms" (CLRS) - —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π —É—á–µ–±–Ω–∏–∫
- "Database System Concepts" - –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è database internals
- "Designing Data-Intensive Applications" - –¥–ª—è —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω–∞

**–ü—Ä–∞–∫—Ç–∏–∫–∞:**
- LeetCode - –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏
- Coursera Algorithm Specialization
- –°–∏—Å—Ç–µ–º—ã —Ä–µ–∞–ª—å–Ω–æ–≥–æ –º–∏—Ä–∞ (–∏–∑—É—á–∞–π—Ç–µ –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ Redis, PostgreSQL)

### üíé –ì–ª–∞–≤–Ω—ã–µ –≤—ã–≤–æ–¥—ã

1. **–ù–µ—Ç —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è** - –∫–∞–∂–¥–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ—à–∞–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∑–∞–¥–∞—á–∏
2. **–ò–∑–º–µ—Ä—è–π—Ç–µ, –Ω–µ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–π—Ç–µ** - –ø—Ä–æ—Ñ–∏–ª–∏—Ä—É–π—Ç–µ —Ä–µ–∞–ª—å–Ω—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
3. **Trade-offs –≤–µ–∑–¥–µ** - –≤—Ä–µ–º—è vs –ø–∞–º—è—Ç—å, –ø—Ä–æ—Å—Ç–æ—Ç–∞ vs –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
4. **–ö–æ–Ω—Ç–µ–∫—Å—Ç —Ä–µ—à–∞–µ—Ç** - —Ä–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö, access patterns, —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã
5. **–ù–∞—á–∏–Ω–∞–π—Ç–µ –ø—Ä–æ—Å—Ç–æ** - –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è - –∫–æ—Ä–µ–Ω—å –∑–ª–∞

### üåü –ó–∞–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–∞—è –º—ã—Å–ª—å

–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö - —ç—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∞—è —Ç–µ–æ—Ä–∏—è. –≠—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–µ–ª–∞—é—Ç —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É –º–µ–¥–ª–µ–Ω–Ω—ã–º –∏ –±—ã—Å—Ç—Ä—ã–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º, –º–µ–∂–¥—É —Å–∏—Å—Ç–µ–º–æ–π, –∫–æ—Ç–æ—Ä–∞—è –ø–∞–¥–∞–µ—Ç –ø–æ–¥ –Ω–∞–≥—Ä—É–∑–∫–æ–π, –∏ —Ç–æ–π, –∫–æ—Ç–æ—Ä–∞—è –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è –Ω–∞ –º–∏–ª–ª–∏–æ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.

**–¢–µ–ø–µ—Ä—å —É –≤–∞—Å –µ—Å—Ç—å —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∏–Ω—è—Ç–∏—è –æ—Å–æ–∑–Ω–∞–Ω–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ backend —Å–∏—Å—Ç–µ–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–∏ –∑–Ω–∞–Ω–∏—è –º—É–¥—Ä–æ!**

---

*"–î–∞–Ω–Ω—ã–µ - —ç—Ç–æ –Ω–æ–≤–∞—è –Ω–µ—Ñ—Ç—å, –Ω–æ –±–µ–∑ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —Å—ã—Ä–∞—è –Ω–µ—Ñ—Ç—å."*

**–£–¥–∞—á–∏ –≤ –≤–∞—à–µ–º –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–∏ backend —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞! üöÄ**

 Decision Tree –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```
–í–´–ë–û–† –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• - DECISION TREE:

üìä –ß–¢–û –í–´ –î–ï–õ–ê–ï–¢–ï –° –î–ê–ù–ù–´–ú–ò?
‚îú‚îÄ –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞ –ø–æ –∫–ª—é—á—É?
‚îÇ  ‚îú‚îÄ –ù—É–∂–Ω—ã range queries? ‚Üí B+ Tree, Segment Tree
‚îÇ  ‚îú‚îÄ –¢–æ–ª—å–∫–æ exact match? ‚Üí Hash Table, Map
‚îÇ  ‚îî‚îÄ Prefix –ø–æ–∏—Å–∫? ‚Üí Trie
‚îÇ
‚îú‚îÄ –î–æ—Å—Ç—É–ø –ø–æ –ø–æ–∑–∏—Ü–∏–∏?
‚îÇ  ‚îú‚îÄ –ò–∑–≤–µ—Å—Ç–µ–Ω —Ä–∞–∑–º–µ—Ä? ‚Üí Array
‚îÇ  ‚îú‚îÄ –†–∞—Å—Ç—É—â–∏–π —Ä–∞–∑–º–µ—Ä? ‚Üí Dynamic Array (Slice)
‚îÇ  ‚îî‚îÄ –ú–Ω–æ–≥–æ –≤—Å—Ç–∞–≤–æ–∫ –≤ —Å–µ—Ä–µ–¥–∏–Ω—É? ‚Üí Linked List
‚îÇ
‚îú‚îÄ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø?
‚îÇ  ‚îú‚îÄ –ù—É–∂–µ–Ω min/max? ‚Üí Heap
‚îÇ  ‚îú‚îÄ LIFO –ø–æ—Ä—è–¥–æ–∫? ‚Üí Stack
‚îÇ  ‚îî‚îÄ FIFO –ø–æ—Ä—è–¥–æ–∫? ‚Üí Queue
‚îÇ
‚îú‚îÄ –ò–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ?
‚îÇ  ‚îú‚îÄ –ù—É–∂–Ω–∞ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞? ‚Üí BST
‚îÇ  ‚îú‚îÄ Parent-child —Å–≤—è–∑–∏? ‚Üí Tree
‚îÇ  ‚îî‚îÄ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏/–≥—Ä—É–ø–ø—ã? ‚Üí Union-Find
‚îÇ
‚îî‚îÄ String –æ–ø–µ—Ä–∞—Ü–∏–∏?
   ‚îú‚îÄ Autocomplete? ‚Üí Trie
   ‚îú‚îÄ Pattern matching? ‚Üí Suffix Tree
   ‚îî‚îÄ Simple –ø–æ–∏—Å–∫? ‚Üí Hash Table

üíæ –ö–ê–ö–ò–ï –í–ê–®–ò –¢–†–ï–ë–û–í–ê–ù–ò–Ø?
‚îú‚îÄ Memory –æ–≥—Ä–∞–Ω–∏—á–µ–Ω? ‚Üí Compact —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (Array, Ring Buffer)
‚îú‚îÄ Speed –∫—Ä–∏—Ç–∏—á–Ω–∞? ‚Üí Hash Table, Array
‚îú‚îÄ Concurrent –¥–æ—Å—Ç—É–ø? ‚Üí Thread-safe —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
‚îî‚îÄ Persistence –Ω—É–∂–Ω–∞? ‚Üí Database-backed —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
```

### üìä –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –≤—Å–µ—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä

```go
package main

import (
    "fmt"
)

type DataStructureInfo struct {
    Name        string
    Search      string
    Insert      string
    Delete      string
    Memory      string
    BestFor     []string
    WorstFor    []string
}

func getDataStructureComparison() []DataStructureInfo {
    return []DataStructureInfo{
        {
            Name:     "Array/Slice",
            Search:   "O(n)",
            Insert:   "O(n)",
            Delete:   "O(n)", 
            Memory:   "Excellent",
            BestFor:  []string{"Index access", "Cache locality", "Small datasets", "Memory efficiency"},
            WorstFor: []string{"Dynamic size", "Middle insertions", "Search operations"},
        },
        {
            Name:     "Linked List",
            Search:   "O(n)",
            Insert:   "O(1)*",
            Delete:   "O(1)*",
            Memory:   "Good",
            BestFor:  []string{"Unknown size", "Frequent insertions", "Stack/Queue implementation"},
            WorstFor: []string{"Random access", "Cache performance", "Memory overhead"},
        },
        {
            Name:     "Hash Table",
            Search:   "O(1)*",
            Insert:   "O(1)*", 
            Delete:   "O(1)*",
            Memory:   "Good",
            BestFor:  []string{"Fast lookup", "Key-value pairs", "Set operations", "Caching"},
            WorstFor: []string{"Ordered data", "Range queries", "Memory predictability"},
        },
        {
            Name:     "Binary Search Tree",
            Search:   "O(log n)",
            Insert:   "O(log n)",
            Delete:   "O(log n)",
            Memory:   "Good", 
            BestFor:  []string{"Sorted data", "Range queries", "Balanced operations"},
            WorstFor: []string{"Worst-case performance", "Cache locality", "Simple lookups"},
        },
        {
            Name:     "Heap",
            Search:   "O(n)",
            Insert:   "O(log n)",
            Delete:   "O(log n)",
            Memory:   "Excellent",
            BestFor:  []string{"Priority queues", "Finding min/max", "Heap sort", "Streaming data"},
            WorstFor: []string{"General search", "Random access", "Static data"},
        },
        {
            Name:     "Trie",
            Search:   "O(m)**",
            Insert:   "O(m)**",
            Delete:   "O(m)**",
            Memory:   "Fair",
            BestFor:  []string{"String search", "Autocomplete", "Prefix matching", "Dictionaries"},
            WorstFor: []string{"Numeric data", "Memory usage", "Non-string keys"},
        },
        {
            Name:     "Union-Find",
            Search:   "O(Œ±(n))",
            Insert:   "O(Œ±(n))",
            Delete:   "N/A",
            Memory:   "Excellent",
            BestFor:  []string{"Graph connectivity", "Set operations", "Clustering", "MST algorithms"},
            WorstFor: []string{"General purpose", "Complex queries", "Dynamic deletion"},
        },
    }
}

func printComparisonTable() {
    fmt.Println("=== –ü–æ–ª–Ω–∞—è —Å—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö ===")
    
    structures := getDataStructureComparison()
    
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –°—Ç—Ä—É–∫—Ç—É—Ä–∞       ‚îÇ Search  ‚îÇ Insert  ‚îÇ Delete  ‚îÇ Memory  ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    
    for _, ds := range structures {
        fmt.Printf("‚îÇ %-15s ‚îÇ %-7s ‚îÇ %-7s ‚îÇ %-7s ‚îÇ %-7s ‚îÇ\n",
            ds.Name, ds.Search, ds.Insert, ds.Delete, ds.Memory)
    }
    
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è")
    fmt.Println("** m = –¥–ª–∏–Ω–∞ –∫–ª—é—á–∞")
    fmt.Println("Œ±(n) = inverse Ackermann function (–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞)")
}

func printUseCaseRecommendations() {
    fmt.Println("\n=== –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—é ===")
    
    structures := getDataStructureComparison()
    
    for _, ds := range structures {
        fmt.Printf("\nüîß %s:\n", ds.Name)
        
        fmt.Println("  ‚úÖ –õ—É—á—à–µ –≤—Å–µ–≥–æ –¥–ª—è:")
        for _, use := range ds.BestFor {
            fmt.Printf("    ‚Ä¢ %s\n", use)
        }
        
        fmt.Println("  ‚ùå –ò–∑–±–µ–≥–∞—Ç—å –¥–ª—è:")
        for _, avoid := range ds.WorstFor {
            fmt.Printf("    ‚Ä¢ %s\n", avoid)
        }
    }
}

// üé™ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –°–¶–ï–ù–ê–†–ò–ò –í–´–ë–û–†–ê
func practicalScenarios() {
    fmt.Println("=== –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –≤—ã–±–æ—Ä–∞ ===")
    
    scenarios := []struct {
        scenario     string
        requirements []string
        recommended  string
        explanation  string
    }{
        {
            scenario:     "üõçÔ∏è E-commerce –∫–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤",
            requirements: []string{"–ü–æ–∏—Å–∫ –ø–æ ID", "–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏", "–í—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å"},
            recommended:  "Hash Table + B+ Tree –∏–Ω–¥–µ–∫—Å—ã",
            explanation:  "Hash Table –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ ID, B+ Tree –¥–ª—è range queries –ø–æ —Ü–µ–Ω–µ/–∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
        },
        {
            scenario:     "üéÆ Leaderboard –≤ –∏–≥—Ä–µ",
            requirements: []string{"–¢–æ–ø-N –∏–≥—Ä–æ–∫–æ–≤", "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç–∞", "–†–∞–Ω–≥–∏"},
            recommended:  "Max Heap + Hash Table",
            explanation:  "Max Heap –¥–ª—è —Ç–æ–ø–∞, Hash Table –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞",
        },
        {
            scenario:     "üì± Autocomplete –≤ –ø–æ–∏—Å–∫–µ",
            requirements: []string{"–ü–æ–∏—Å–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É", "–ë—ã—Å—Ç—Ä—ã–π –æ—Ç–∫–ª–∏–∫", "–ú–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞"},
            recommended:  "Trie",
            explanation:  "Trie –æ–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è prefix matching –∏ autocomplete —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏",
        },
        {
            scenario:     "üíæ LRU Cache",
            requirements: []string{"O(1) –¥–æ—Å—Ç—É–ø", "Eviction policy", "Memory limit"},
            recommended:  "Hash Table + Doubly Linked List",
            explanation:  "HashMap –¥–ª—è O(1) access, DLL –¥–ª—è O(1) move-to-front –∏ eviction",
        },
        {
            scenario:     "üìä Real-time –º–µ—Ç—Ä–∏–∫–∏",
            requirements: []string{"Time series data", "Range queries", "High writes"},
            recommended:  "LSM-Tree",
            explanation:  "LSM-Tree –æ–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è write-heavy workloads —Å occasional range queries",
        },
        {
            scenario:     "üåê Social network connections",
            requirements: []string{"Find mutual friends", "Degrees of separation", "Dynamic graph"},
            recommended:  "Adjacency List + Union-Find",
            explanation:  "Adjacency List –¥–ª—è graph traversal, Union-Find –¥–ª—è connectivity queries",
        },
        {
            scenario:     "‚è∞ Task scheduler",
            requirements: []string{"Priority tasks", "Deadlines", "Fair scheduling"},
            recommended:  "Min Heap (–ø–æ –≤—Ä–µ–º–µ–Ω–∏) + Priority Queue",
            explanation:  "Min Heap –¥–ª—è deadline scheduling, Priority Queue –¥–ª—è –≤–∞–∂–Ω–æ—Å—Ç–∏ –∑–∞–¥–∞—á",
        },
        {
            scenario:     "üìù Text editor with undo/redo",
            requirements: []string{"Command history", "Undo operations", "Memory efficiency"},
            recommended:  "Two Stacks",
            explanation:  "–û–¥–∏–Ω stack –¥–ª—è undo, –¥—Ä—É–≥–æ–π –¥–ª—è redo operations",
        },
    }
    
    for i, scenario := range scenarios {
        fmt.Printf("\n%d. %s\n", i+1, scenario.scenario)
        fmt.Println("   –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:")
        for _, req := range scenario.requirements {
            fmt.Printf("   ‚Ä¢ %s\n", req)
        }
        fmt.Printf("   üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: %s\n", scenario.recommended)
        fmt.Printf("   üí° –û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ: %s\n", scenario.explanation)
    }
}

// üö® –ê–ù–¢–ò-–ü–ê–¢–¢–ï–†–ù–´ –ò –†–ê–°–ü–†–û–°–¢–†–ê–ù–ï–ù–ù–´–ï –û–®–ò–ë–ö–ò
func commonMistakes() {
    fmt.Println("=== –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏ –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö ===")
    
    mistakes := []struct {
        mistake     string
        why         string
        better      string
    }{
        {
            mistake: "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ ArrayList –¥–ª—è —á–∞—Å—Ç—ã—Ö –≤—Å—Ç–∞–≤–æ–∫ –≤ —Å–µ—Ä–µ–¥–∏–Ω—É",
            why:     "O(n) –≤—Ä–µ–º—è –Ω–∞ –∫–∞–∂–¥—É—é –≤—Å—Ç–∞–≤–∫—É –∏–∑-–∑–∞ —Å–¥–≤–∏–≥–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤",
            better:  "Linked List –∏–ª–∏ Deque –¥–ª—è —á–∞—Å—Ç—ã—Ö –≤—Å—Ç–∞–≤–æ–∫",
        },
        {
            mistake: "HashMap –¥–ª—è –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ–±—Ö–æ–¥–∏—Ç—å –≤ –ø–æ—Ä—è–¥–∫–µ",
            why:     "HashMap –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ø–æ—Ä—è–¥–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤",
            better:  "TreeMap –∏–ª–∏ LinkedHashMap –¥–ª—è —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö",
        },
        {
            mistake: "BST –±–µ–∑ –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏ –¥–ª—è –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö",
            why:     "–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫, O(n) –æ–ø–µ—Ä–∞—Ü–∏–∏",
            better:  "AVL Tree, Red-Black Tree –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –º–∞—Å—Å–∏–≤ —Å binary search",
        },
        {
            mistake: "Trie –¥–ª—è –Ω–µ–±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å—Ç—Ä–æ–∫",
            why:     "Overhead —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –±–æ–ª—å—à–µ –≤—ã–≥–æ–¥—ã –æ—Ç prefix sharing",
            better:  "Hash Set –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫",
        },
        {
            mistake: "Linked List –¥–ª—è –¥–∞–Ω–Ω—ã—Ö —Å —á–∞—Å—Ç—ã–º random access",
            why:     "O(n) –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É, –ø–ª–æ—Ö–∞—è cache locality",
            better:  "Dynamic Array (vector/slice) –¥–ª—è random access",
        },
        {
            mistake: "Heap –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤",
            why:     "Heap –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è min/max, –æ–±—â–∏–π –ø–æ–∏—Å–∫ O(n)",
            better:  "Hash Table –∏–ª–∏ BST –¥–ª—è –æ–±—â–µ–≥–æ –ø–æ–∏—Å–∫–∞",
        },
        {
            mistake: "Stack/Queue –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞—Å—Å–∏–≤–∞ –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥—Ä–∞–Ω–∏—Ü",
            why:     "–ú–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—é –∏–ª–∏ segfault",
            better:  "Circular buffer –∏–ª–∏ dynamic array —Å proper bounds checking",
        },
        {
            mistake: "Union-Find –±–µ–∑ path compression",
            why:     "–î–µ–≥—Ä–∞–¥–∏—Ä—É–µ—Ç –¥–æ O(n) –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ",
            better:  "Union-Find —Å path compression –∏ union by rank",
        },
    }
    
    for i, mistake := range mistakes {
        fmt.Printf("\n‚ùå %d. %s\n", i+1, mistake.mistake)
        fmt.Printf("   –ü—Ä–æ–±–ª–µ–º–∞: %s\n", mistake.why)
        fmt.Printf("   ‚úÖ –õ—É—á—à–µ: %s\n", mistake.better)
    }
}

// üéì –ò–¢–û–ì–û–í–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò
func finalRecommendations() {
    fmt.Println("=== –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è Backend —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ ===")
    
    fmt.Println("\nüèÜ –¢–æ–ø-5 —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –∑–∞–¥–∞—á:")
    fmt.Println("1. Hash Table/Map - –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ –∫–ª—é—á—É")
    fmt.Println("2. Dynamic Array/Slice - –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
    fmt.Println("3. Heap - –¥–ª—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö –∑–∞–¥–∞—á")
    fmt.Println("4. Tree (BST/B+) - –¥–ª—è —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
    fmt.Println("5. Queue/Stack - –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ")
    
    fmt.Println("\nüìã –ü—Ä–æ—Ü–µ—Å—Å –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:")
    fmt.Println("1. üéØ –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:")
    fmt.Println("   ‚Ä¢ –ß—Ç–æ –≤—ã –¥–µ–ª–∞–µ—Ç–µ —á–∞—â–µ –≤—Å–µ–≥–æ?")
    fmt.Println("   ‚Ä¢ –ö–∞–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫—Ä–∏—Ç–∏—á–Ω—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏?")
    
    fmt.Println("\n2. üìä –û—Ü–µ–Ω–∏—Ç–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö:")
    fmt.Println("   ‚Ä¢ –†–∞–∑–º–µ—Ä dataset'–∞")
    fmt.Println("   ‚Ä¢ –°—Ç–∞—Ç–∏—á–Ω—ã–µ –∏–ª–∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ")
    fmt.Println("   ‚Ä¢ –ù—É–∂–µ–Ω –ª–∏ –ø–æ—Ä—è–¥–æ–∫")
    
    fmt.Println("\n3. ‚ö° –£—á—Ç–∏—Ç–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:")
    fmt.Println("   ‚Ä¢ Latency vs Throughput")
    fmt.Println("   ‚Ä¢ Memory constraints")
    fmt.Println("   ‚Ä¢ Concurrent access patterns")
    
    fmt.Println("\n4. üîß –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç:")
    fmt.Println("   ‚Ä¢ Single-threaded vs Multi-threaded")
    fmt.Println("   ‚Ä¢ In-memory vs Persistent")
    fmt.Println("   ‚Ä¢ Read-heavy vs Write-heavy")
    
    fmt.Println("\nüí° –ó–æ–ª–æ—Ç—ã–µ –ø—Ä–∞–≤–∏–ª–∞:")
    fmt.Println("‚Ä¢ –ù–∞—á–∏–Ω–∞–π—Ç–µ —Å –ø—Ä–æ—Å—Ç–µ–π—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –∫–æ—Ç–æ—Ä–∞—è —Ä–µ—à–∞–µ—Ç –∑–∞–¥–∞—á—É")
    fmt.Println("‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏")
    fmt.Println("‚Ä¢ –£—á–∏—Ç—ã–≤–∞–π—Ç–µ trade-offs –º–µ–∂–¥—É –≤—Ä–µ–º–µ–Ω–µ–º –∏ –ø–∞–º—è—Ç—å—é")
    fmt.Println("‚Ä¢ –ü–æ–º–Ω–∏—Ç–µ: –ª—É—á—à–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ = —Ä–µ—à–∞–µ—Ç –≤–∞—à—É –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –∑–∞–¥–∞—á—É")
    
    fmt.Println("\nüöÄ –î–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞:")
    fmt.Println("‚Ä¢ –í—Å–µ–≥–¥–∞ benchmark'—Ç–µ –≤–∞—à –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π use case")
    fmt.Println("‚Ä¢ –£—á–∏—Ç—ã–≤–∞–π—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ access patterns")
    fmt.Println("‚Ä¢ –ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞—Ä–∞–Ω–µ–µ")
    fmt.Println("‚Ä¢ –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –ø—Ä–∏—á–∏–Ω—ã –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã")
}

// üèÉ‚Äç‚ôÇÔ∏è –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –í–°–ï–• –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ô
func runRecommendations() {
    printComparisonTable()
    printUseCaseRecommendations()
    practicalScenarios()
    commonMistakes()
    finalRecommendations()
}

---

## üéâ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –æ—Ç –æ—Å–Ω–æ–≤ —Ä–∞–±–æ—Ç—ã —Å –ø–∞–º—è—Ç—å—é –¥–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –∏—Ö –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤ backend —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.

### üéØ---

## –ú–æ–¥—É–ª—å 10: Union-Find (Disjoint Set) - –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤

### üîó –ö–æ–Ω—Ü–µ–ø—Ü–∏—è Union-Find

```
UNION-FIND - –°–¢–†–£–ö–¢–£–†–ê –î–õ–Ø –†–ê–ë–û–¢–´ –° –ù–ï–ü–ï–†–ï–°–ï–ö–ê–Æ–©–ò–ú–ò–°–Ø –ú–ù–û–ñ–ï–°–¢–í–ê–ú–ò:

–ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï (–∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Å–≤–æ–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ):
{0} {1} {2} {3} {4} {5} {6} {7}

–û–ü–ï–†–ê–¶–ò–Ø UNION(1, 3) - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ 1 –∏ 3:
{0} {1, 3} {2} {4} {5} {6} {7}

–û–ü–ï–†–ê–¶–ò–Ø UNION(4, 5) - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ 4 –∏ 5:  
{0} {1, 3} {2} {4, 5} {6} {7}

–û–ü–ï–†–ê–¶–ò–Ø UNION(1, 4) - –æ–±—ä–µ–¥–∏–Ω—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ 1 –∏ 4:
{0} {1, 3, 4, 5} {2} {6} {7}

–û–ü–ï–†–ê–¶–ò–Ø FIND(3) - –Ω–∞—Ö–æ–¥–∏–º –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ 3:
–†–µ–∑—É–ª—å—Ç–∞—Ç: –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª—å –º–Ω–æ–∂–µ—Å—Ç–≤–∞ {1, 3, 4, 5}

–ü–†–ï–î–°–¢–ê–í–õ–ï–ù–ò–ï –í –í–ò–î–ï –î–ï–†–ï–í–ê:
–ü–æ—Å–ª–µ –æ–ø–µ—Ä–∞—Ü–∏–π –≤—ã—à–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–∂–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫:

    1 (–∫–æ—Ä–µ–Ω—å)        0    2    6    7
   /|\
  3 4
    |
    5

–ú–ê–°–°–ò–í –†–û–î–ò–¢–ï–õ–ï–ô:
parent[0] = 0  (—Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å)
parent[1] = 1  (—Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å - –∫–æ—Ä–µ–Ω—å)  
parent[2] = 2  (—Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å)
parent[3] = 1  (—Ä–æ–¥–∏—Ç–µ–ª—å - —É–∑–µ–ª 1)
parent[4] = 1  (—Ä–æ–¥–∏—Ç–µ–ª—å - —É–∑–µ–ª 1)  
parent[5] = 4  (—Ä–æ–¥–∏—Ç–µ–ª—å - —É–∑–µ–ª 4)
parent[6] = 6  (—Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å)
parent[7] = 7  (—Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å)
```

### üöÄ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ Union-Find

```
–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø 1: UNION BY RANK (–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ —Ä–∞–Ω–≥—É)
================================================

–ü—Ä–æ–±–ª–µ–º–∞: –¥–µ—Ä–µ–≤–æ –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å —Å–ª–∏—à–∫–æ–º –≥–ª—É–±–æ–∫–∏–º
–†–µ—à–µ–Ω–∏–µ: –≤—Å–µ–≥–¥–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –¥–µ—Ä–µ–≤–æ –º–µ–Ω—å—à–µ–≥–æ —Ä–∞–Ω–≥–∞ –∫ –∫–æ—Ä–Ω—é –¥–µ—Ä–µ–≤–∞ –±–æ–ª—å—à–µ–≥–æ —Ä–∞–Ω–≥–∞

–ü–õ–û–•–û (naive union):          –•–û–†–û–®–û (union by rank):
    1                             1
    |                            / \
    2                           2   3
    |                               |
    3                               4
    |
    4
–í—ã—Å–æ—Ç–∞: 4                     –í—ã—Å–æ—Ç–∞: 3

–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø 2: PATH COMPRESSION (—Å–∂–∞—Ç–∏–µ –ø—É—Ç–µ–π)
===============================================

–ü—Ä–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ FIND —Å–∂–∏–º–∞–µ–º –ø—É—Ç—å –¥–æ –∫–æ—Ä–Ω—è:

–î–û path compression:          –ü–û–°–õ–ï path compression:
    1                             1
   /|\                           /||\
  2 3 4                         2 3 4 5
    |                           
    5

FIND(5):
1. –ò–¥–µ–º 5 ‚Üí 4 ‚Üí 1 (–ø—É—Ç—å –¥–ª–∏–Ω–æ–π 2)
2. –î–µ–ª–∞–µ–º parent[5] = 1 (–ø—Ä—è–º–∞—è —Å–≤—è–∑—å —Å –∫–æ—Ä–Ω–µ–º)
3. –¢–µ–ø–µ—Ä—å FIND(5) —Ä–∞–±–æ—Ç–∞–µ—Ç –∑–∞ O(1)!

–†–ï–ó–£–õ–¨–¢–ê–¢ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ô:
‚Ä¢ –ë–µ–∑ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π: O(n) –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—é –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ
‚Ä¢ –° –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏: O(Œ±(n)) –≥–¥–µ Œ± - inverse Ackermann function
‚Ä¢ –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ: –ø–æ—á—Ç–∏ O(1) –¥–ª—è –ª—é–±—ã—Ö —Ä–∞–∑—É–º–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ –¥–∞–Ω–Ω—ã—Ö
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Union-Find –≤ Go

```go
package main

import (
    "fmt"
)

// üîó UNION-FIND –°–¢–†–£–ö–¢–£–†–ê
type UnionFind struct {
    parent []int // parent[i] = —Ä–æ–¥–∏—Ç–µ–ª—å —ç–ª–µ–º–µ–Ω—Ç–∞ i
    rank   []int // rank[i] = –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞ —Å –∫–æ—Ä–Ω–µ–º i
    count  int   // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    rank := make([]int, n)
    
    // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç - —Å–∞–º —Å–µ–±–µ —Ä–æ–¥–∏—Ç–µ–ª—å
    for i := 0; i < n; i++ {
        parent[i] = i
        rank[i] = 0
    }
    
    return &UnionFind{
        parent: parent,
        rank:   rank,
        count:  n, // –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ n –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    }
}

// üîç FIND –° PATH COMPRESSION
func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        // Path compression: –¥–µ–ª–∞–µ–º —Ä–æ–¥–∏—Ç–µ–ª–µ–º –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

// üîó UNION BY RANK
func (uf *UnionFind) Union(x, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    
    // –ï—Å–ª–∏ —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ
    if rootX == rootY {
        return false
    }
    
    // Union by rank: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º –º–µ–Ω—å—à–µ–µ –¥–µ—Ä–µ–≤–æ –∫ –±–æ–ª—å—à–µ–º—É
    if uf.rank[rootX] < uf.rank[rootY] {
        uf.parent[rootX] = rootY
    } else if uf.rank[rootX] > uf.rank[rootY] {
        uf.parent[rootY] = rootX
    } else {
        // –û–¥–∏–Ω–∞–∫–æ–≤—ã–π rank: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º Y –∫ X –∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º rank X
        uf.parent[rootY] = rootX
        uf.rank[rootX]++
    }
    
    uf.count-- // –£–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    return true
}

// ‚ùì –ü–†–û–í–ï–†–ö–ê –°–í–Ø–ó–ù–û–°–¢–ò
func (uf *UnionFind) IsConnected(x, y int) bool {
    return uf.Find(x) == uf.Find(y)
}

// üìä –ò–ù–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ï –ú–ï–¢–û–î–´
func (uf *UnionFind) GetComponentCount() int {
    return uf.count
}

func (uf *UnionFind) GetComponentSize(x int) int {
    root := uf.Find(x)
    size := 0
    
    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Å —Ç–µ–º –∂–µ –∫–æ—Ä–Ω–µ–º
    for i := 0; i < len(uf.parent); i++ {
        if uf.Find(i) == root {
            size++
        }
    }
    
    return size
}

// üìã –ü–û–õ–£–ß–ò–¢–¨ –í–°–ï –ö–û–ú–ü–û–ù–ï–ù–¢–´
func (uf *UnionFind) GetComponents() map[int][]int {
    components := make(map[int][]int)
    
    for i := 0; i < len(uf.parent); i++ {
        root := uf.Find(i)
        components[root] = append(components[root], i)
    }
    
    return components
}

// üñ®Ô∏è –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –°–û–°–¢–û–Ø–ù–ò–Ø
func (uf *UnionFind) Print() {
    fmt.Println("=== Union-Find —Å–æ—Å—Ç–æ—è–Ω–∏–µ ===")
    fmt.Printf("–†–æ–¥–∏—Ç–µ–ª–∏: %v\n", uf.parent)
    fmt.Printf("–†–∞–Ω–≥–∏:    %v\n", uf.rank)
    fmt.Printf("–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤: %d\n", uf.count)
    
    components := uf.GetComponents()
    fmt.Println("–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:")
    for root, members := range components {
        fmt.Printf("  –ö–æ—Ä–µ–Ω—å %d: %v\n", root, members)
    }
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø UNION-FIND
func unionFindDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Union-Find ===")
    
    // –°–æ–∑–¥–∞–µ–º Union-Find –¥–ª—è 8 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    uf := NewUnionFind(8)
    
    fmt.Println("–ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:")
    uf.Print()
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è
    operations := [][]int{
        {1, 3}, {4, 5}, {1, 4}, {0, 2}, {6, 7}, {2, 6},
    }
    
    fmt.Println("\n–í—ã–ø–æ–ª–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ Union:")
    for _, op := range operations {
        x, y := op[0], op[1]
        wasConnected := uf.IsConnected(x, y)
        uf.Union(x, y)
        
        fmt.Printf("Union(%d, %d) - –±—ã–ª–∏ —Å–≤—è–∑–∞–Ω—ã: %t\n", x, y, wasConnected)
        fmt.Printf("  –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤: %d\n", uf.GetComponentCount())
    }
    
    fmt.Println("\n–§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:")
    uf.Print()
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç—å
    fmt.Println("\n=== –¢–µ—Å—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏ ===")
    testPairs := [][]int{{1, 5}, {0, 7}, {2, 3}, {0, 1}}
    
    for _, pair := range testPairs {
        x, y := pair[0], pair[1]
        connected := uf.IsConnected(x, y)
        fmt.Printf("–°–≤—è–∑–∞–Ω—ã –ª–∏ %d –∏ %d? %t\n", x, y, connected)
    }
}

// üåâ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –ê–õ–ì–û–†–ò–¢–ú –ö–†–£–°–ö–ê–õ–ê (MST)
type Edge struct {
    From   int
    To     int
    Weight int
}

func KruskalMST(n int, edges []Edge) ([]Edge, int) {
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä—ë–±—Ä–∞ –ø–æ –≤–µ—Å—É
    sortedEdges := make([]Edge, len(edges))
    copy(sortedEdges, edges)
    
    // –ü—Ä–æ—Å—Ç–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø—É–∑—ã—Ä—å–∫–æ–º –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    for i := 0; i < len(sortedEdges); i++ {
        for j := 0; j < len(sortedEdges)-1-i; j++ {
            if sortedEdges[j].Weight > sortedEdges[j+1].Weight {
                sortedEdges[j], sortedEdges[j+1] = sortedEdges[j+1], sortedEdges[j]
            }
        }
    }
    
    uf := NewUnionFind(n)
    mst := make([]Edge, 0)
    totalWeight := 0
    
    fmt.Println("–ê–ª–≥–æ—Ä–∏—Ç–º –ö—Ä—É—Å–∫–∞–ª–∞ (–ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ MST):")
    fmt.Println("–†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º —Ä—ë–±—Ä–∞ –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è –≤–µ—Å–∞:")
    
    for _, edge := range sortedEdges {
        // –ï—Å–ª–∏ –≤–µ—Ä—à–∏–Ω—ã –Ω–µ —Å–≤—è–∑–∞–Ω—ã, –¥–æ–±–∞–≤–ª—è–µ–º —Ä–µ–±—Ä–æ –≤ MST
        if !uf.IsConnected(edge.From, edge.To) {
            uf.Union(edge.From, edge.To)
            mst = append(mst, edge)
            totalWeight += edge.Weight
            
            fmt.Printf("  –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–±—Ä–æ (%d-%d) –≤–µ—Å %d\n", 
                edge.From, edge.To, edge.Weight)
        } else {
            fmt.Printf("  –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–µ–±—Ä–æ (%d-%d) –≤–µ—Å %d (—Å–æ–∑–¥–∞—ë—Ç —Ü–∏–∫–ª)\n", 
                edge.From, edge.To, edge.Weight)
        }
        
        // MST —Å–æ–¥–µ—Ä–∂–∏—Ç n-1 —Ä—ë–±–µ—Ä
        if len(mst) == n-1 {
            break
        }
    }
    
    return mst, totalWeight
}

func mstDemo() {
    fmt.Println("=== –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –æ—Å—Ç–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ (MST) ===")
    
    // –ì—Ä–∞—Ñ:     0
    //          /|\
    //      4  / | \ 2
    //        /  |  \
    //       1   |8  3
    //       |\ /|  /|
    //     7 | X | /3| 9
    //       |/ \|/  |
    //       2---4---5
    //         1   5
    
    edges := []Edge{
        {0, 1, 4}, {0, 2, 8}, {0, 3, 2},
        {1, 2, 7}, {1, 4, 6}, {2, 4, 1},
        {3, 4, 3}, {3, 5, 9}, {4, 5, 5},
    }
    
    fmt.Println("–ò—Å—Ö–æ–¥–Ω—ã–π –≥—Ä–∞—Ñ:")
    for _, edge := range edges {
        fmt.Printf("  %d-%d (–≤–µ—Å %d)\n", edge.From, edge.To, edge.Weight)
    }
    
    mst, totalWeight := KruskalMST(6, edges)
    
    fmt.Printf("\n–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –æ—Å—Ç–æ–≤–Ω–æ–µ –¥–µ—Ä–µ–≤–æ:\n")
    for _, edge := range mst {
        fmt.Printf("  %d-%d (–≤–µ—Å %d)\n", edge.From, edge.To, edge.Weight)
    }
    fmt.Printf("–û–±—â–∏–π –≤–µ—Å MST: %d\n", totalWeight)
}

// üèùÔ∏è –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –ü–û–ò–°–ö –û–°–¢–†–û–í–û–í –í –ú–ê–¢–†–ò–¶–ï
func findIslands(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    
    rows, cols := len(grid), len(grid[0])
    uf := NewUnionFind(rows * cols)
    waterCells := 0
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 2D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ 1D –∏–Ω–¥–µ–∫—Å
    getIndex := func(r, c int) int {
        return r*cols + c
    }
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ—Å–µ–¥–µ–π (–≤–≤–µ—Ä—Ö, –≤–Ω–∏–∑, –≤–ª–µ–≤–æ, –≤–ø—Ä–∞–≤–æ)
    directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
    
    fmt.Println("–ò—Å—Ö–æ–¥–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞:")
    for i, row := range grid {
        fmt.Printf("  %d: %v\n", i, row)
    }
    
    fmt.Println("\n–û–±—ä–µ–¥–∏–Ω—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ —É—á–∞—Å—Ç–∫–∏ —Å—É—à–∏:")
    
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == 0 {
                waterCells++
                continue
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π
            for _, dir := range directions {
                newR, newC := r+dir[0], c+dir[1]
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –∏ —á—Ç–æ —Å–æ—Å–µ–¥ —Ç–æ–∂–µ —Å—É—à–∞
                if newR >= 0 && newR < rows && newC >= 0 && newC < cols && grid[newR][newC] == 1 {
                    index1 := getIndex(r, c)
                    index2 := getIndex(newR, newC)
                    
                    if uf.Union(index1, index2) {
                        fmt.Printf("  –û–±—ä–µ–¥–∏–Ω—è–µ–º (%d,%d) —Å (%d,%d)\n", r, c, newR, newC)
                    }
                }
            }
        }
    }
    
    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤
    islands := 0
    visited := make(map[int]bool)
    
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == 1 {
                root := uf.Find(getIndex(r, c))
                if !visited[root] {
                    visited[root] = true
                    islands++
                }
            }
        }
    }
    
    return islands
}

func islandsDemo() {
    fmt.Println("=== –ü–æ–∏—Å–∫ –æ—Å—Ç—Ä–æ–≤–æ–≤ –≤ –º–∞—Ç—Ä–∏—Ü–µ ===")
    
    grid := [][]int{
        {1, 1, 0, 0, 0},
        {1, 1, 0, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 0, 1, 1},
    }
    
    islands := findIslands(grid)
    fmt.Printf("\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤: %d\n", islands)
    
    fmt.Println("\n–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:")
    fmt.Println("1. –ö–∞–∂–¥–∞—è –∫–ª–µ—Ç–∫–∞ –ø–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID")
    fmt.Println("2. –°–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ —Å '1' –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –≤ –æ–¥–∏–Ω –∫–æ–º–ø–æ–Ω–µ–Ω—Ç")
    fmt.Println("3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤")
}

// üåê –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –°–û–¶–ò–ê–õ–¨–ù–ê–Ø –°–ï–¢–¨
type SocialNetwork struct {
    uf    *UnionFind
    users map[int]string // ID -> –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
}

func NewSocialNetwork(userCount int) *SocialNetwork {
    return &SocialNetwork{
        uf:    NewUnionFind(userCount),
        users: make(map[int]string),
    }
}

func (sn *SocialNetwork) AddUser(id int, name string) {
    sn.users[id] = name
}

func (sn *SocialNetwork) AddFriendship(user1, user2 int) {
    if sn.uf.Union(user1, user2) {
        fmt.Printf("üë• %s –∏ %s —Ç–µ–ø–µ—Ä—å –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ –¥—Ä—É–∑–µ–π\n", 
            sn.users[user1], sn.users[user2])
    } else {
        fmt.Printf("üë´ %s –∏ %s —É–∂–µ –±—ã–ª–∏ –≤ –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ\n", 
            sn.users[user1], sn.users[user2])
    }
}

func (sn *SocialNetwork) AreFriendsConnected(user1, user2 int) bool {
    return sn.uf.IsConnected(user1, user2)
}

func (sn *SocialNetwork) GetFriendGroups() {
    components := sn.uf.GetComponents()
    
    fmt.Println("\nüë• –ì—Ä—É–ø–ø—ã –¥—Ä—É–∑–µ–π:")
    groupNum := 1
    for _, members := range components {
        if len(members) > 1 {
            fmt.Printf("  –ì—Ä—É–ø–ø–∞ %d: ", groupNum)
            for i, userID := range members {
                if i > 0 {
                    fmt.Print(", ")
                }
                fmt.Print(sn.users[userID])
            }
            fmt.Println()
            groupNum++
        }
    }
}

func socialNetworkDemo() {
    fmt.Println("=== –°–æ—Ü–∏–∞–ª—å–Ω–∞—è —Å–µ—Ç—å —Å Union-Find ===")
    
    sn := NewSocialNetwork(8)
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    users := []string{"–ê–ª–∏—Å–∞", "–ë–æ–±", "–ß–∞—Ä–ª–∏", "–î–∏–∞–Ω–∞", "–ï–≤–∞", "–§—Ä—ç–Ω–∫", "–ì—Ä–µ–π—Å", "–ì–µ–Ω—Ä–∏"}
    for i, name := range users {
        sn.AddUser(i, name)
    }
    
    fmt.Println("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ —Å–∏—Å—Ç–µ–º—É")
    
    // –î–æ–±–∞–≤–ª—è–µ–º –¥—Ä—É–∂–µ—Å–∫–∏–µ —Å–≤—è–∑–∏
    fmt.Println("\n–î–æ–±–∞–≤–ª—è–µ–º –¥—Ä—É–∂–µ—Å–∫–∏–µ —Å–≤—è–∑–∏:")
    friendships := [][]int{
        {0, 1}, // –ê–ª–∏—Å–∞ - –ë–æ–±
        {1, 2}, // –ë–æ–± - –ß–∞—Ä–ª–∏  
        {3, 4}, // –î–∏–∞–Ω–∞ - –ï–≤–∞
        {5, 6}, // –§—Ä—ç–Ω–∫ - –ì—Ä–µ–π—Å
        {0, 2}, // –ê–ª–∏—Å–∞ - –ß–∞—Ä–ª–∏ (—á–µ—Ä–µ–∑ –ë–æ–±–∞ —É–∂–µ —Å–≤—è–∑–∞–Ω—ã)
        {4, 5}, // –ï–≤–∞ - –§—Ä—ç–Ω–∫ (–æ–±—ä–µ–¥–∏–Ω—è–µ–º –≥—Ä—É–ø–ø—ã)
    }
    
    for _, friendship := range friendships {
        sn.AddFriendship(friendship[0], friendship[1])
    }
    
    sn.GetFriendGroups()
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤—è–∑–Ω–æ—Å—Ç–∏
    fmt.Println("\nüîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–Ω–æ—Å—Ç–∏:")
    tests := [][]int{{0, 2}, {0, 4}, {3, 6}, {7, 0}}
    
    for _, test := range tests {
        user1, user2 := test[0], test[1]
        connected := sn.AreFriendsConnected(user1, user2)
        fmt.Printf("–°–≤—è–∑–∞–Ω—ã –ª–∏ %s –∏ %s? %t\n", 
            sn.users[user1], sn.users[user2], connected)
    }
}

// üéØ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: PERCOLATION
func percolationDemo() {
    fmt.Println("=== –ó–∞–¥–∞—á–∞ Percolation ===")
    
    // –ú–æ–¥–µ–ª–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º—É —Å –±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏/–æ—Ç–∫—Ä—ã—Ç—ã–º–∏ —è—á–µ–π–∫–∞–º–∏
    n := 5
    grid := [][]bool{
        {true, false, true, true, false},
        {true, true, false, true, false},
        {false, true, true, true, true},
        {false, false, true, false, true},
        {true, false, true, true, true},
    }
    
    fmt.Println("–°–∏—Å—Ç–µ–º–∞ (true = –æ—Ç–∫—Ä—ã—Ç–æ, false = –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ):")
    for i, row := range grid {
        fmt.Printf("  %d: %v\n", i, row)
    }
    
    // –°–æ–∑–¥–∞–µ–º Union-Find —Å –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–º–∏ –≤–µ—Ä—Ö–Ω–∏–º –∏ –Ω–∏–∂–Ω–∏–º —É–∑–ª–∞–º–∏
    // n*n —è—á–µ–µ–∫ + 2 –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —É–∑–ª–∞
    uf := NewUnionFind(n*n + 2)
    topVirtual := n * n     // –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–∑–µ–ª
    bottomVirtual := n*n + 1 // –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –Ω–∏–∂–Ω–∏–π —É–∑–µ–ª
    
    getIndex := func(row, col int) int {
        return row*n + col
    }
    
    directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –æ—Ç–∫—Ä—ã—Ç—É—é —è—á–µ–π–∫—É
    for row := 0; row < n; row++ {
        for col := 0; col < n; col++ {
            if !grid[row][col] {
                continue // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
            }
            
            index := getIndex(row, col)
            
            // –°–æ–µ–¥–∏–Ω—è–µ–º —Å –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–º–∏ —É–∑–ª–∞–º–∏
            if row == 0 {
                uf.Union(index, topVirtual)
            }
            if row == n-1 {
                uf.Union(index, bottomVirtual)
            }
            
            // –°–æ–µ–¥–∏–Ω—è–µ–º —Å –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ —Å–æ—Å–µ–¥—è–º–∏
            for _, dir := range directions {
                newRow, newCol := row+dir[0], col+dir[1]
                
                if newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] {
                    neighborIndex := getIndex(newRow, newCol)
                    uf.Union(index, neighborIndex)
                }
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º percolation
    percolates := uf.IsConnected(topVirtual, bottomVirtual)
    fmt.Printf("\n–°–∏—Å—Ç–µ–º–∞ percolates (–µ—Å—Ç—å –ø—É—Ç—å —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑): %t\n", percolates)
    
    if percolates {
        fmt.Println("üíß –ñ–∏–¥–∫–æ—Å—Ç—å –º–æ–∂–µ—Ç –ø—Ä–æ—Ç–µ—á—å —á–µ—Ä–µ–∑ —Å–∏—Å—Ç–µ–º—É!")
    } else {
        fmt.Println("üö´ –ü—É—Ç—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω")
    }
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func unionFindPerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ Union-Find ===")
    
    const n = 100000
    const operations = 200000
    
    // –ù–∞–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (–±–µ–∑ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π)
    type NaiveUF struct {
        id []int
    }
    
    newNaiveUF := func(n int) *NaiveUF {
        id := make([]int, n)
        for i := 0; i < n; i++ {
            id[i] = i
        }
        return &NaiveUF{id: id}
    }
    
    naiveFind := func(uf *NaiveUF, p int) int {
        return uf.id[p]
    }
    
    naiveUnion := func(uf *NaiveUF, p, q int) {
        pid := uf.id[p]
        qid := uf.id[q]
        
        if pid == qid {
            return
        }
        
        // –ó–∞–º–µ–Ω—è–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å pid –Ω–∞ qid
        for i := 0; i < len(uf.id); i++ {
            if uf.id[i] == pid {
                uf.id[i] = qid
            }
        }
    }
    
    // –¢–µ—Å—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    optimizedUF := NewUnionFind(n)
    start := time.Now()
    
    for i := 0; i < operations; i++ {
        p, q := i%n, (i+1)%n
        if i%2 == 0 {
            optimizedUF.Union(p, q)
        } else {
            optimizedUF.Find(p)
        }
    }
    
    optimizedTime := time.Since(start)
    
    // –¢–µ—Å—Ç –Ω–∞–∏–≤–Ω–æ–π –≤–µ—Ä—Å–∏–∏ (–º–µ–Ω—å—à–µ –æ–ø–µ—Ä–∞—Ü–∏–π –∏–∑-–∑–∞ O(n) —Å–ª–æ–∂–Ω–æ—Å—Ç–∏)
    naiveUF := newNaiveUF(n / 10)
    start = time.Now()
    
    for i := 0; i < operations/100; i++ { // –ì–æ—Ä–∞–∑–¥–æ –º–µ–Ω—å—à–µ –æ–ø–µ—Ä–∞—Ü–∏–π
        p, q := i%(n/10), (i+1)%(n/10)
        if i%2 == 0 {
            naiveUnion(naiveUF, p, q)
        } else {
            naiveFind(naiveUF, p)
        }
    }
    
    naiveTime := time.Since(start)
    
    fmt.Printf("–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è Union-Find (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations, optimizedTime)
    fmt.Printf("–ù–∞–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations/100, naiveTime)
    
    // –≠–∫—Å—Ç—Ä–∞–ø–æ–ª–∏—Ä—É–µ–º –≤—Ä–µ–º—è –Ω–∞–∏–≤–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    estimatedNaiveTime := time.Duration(float64(naiveTime) * 100 * 10) // –£—á–∏—Ç—ã–≤–∞–µ–º O(n) –∏ –º–µ–Ω—å—à–µ –æ–ø–µ—Ä–∞—Ü–∏–π
    fmt.Printf("–†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞–∏–≤–Ω–æ–π –≤–µ—Ä—Å–∏–∏ –¥–ª—è %d –æ–ø–µ—Ä–∞—Ü–∏–π: %v\n", operations, estimatedNaiveTime)
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: ~%.0fx\n", float64(estimatedNaiveTime)/float64(optimizedTime))
    
    fmt.Println("\nüìä –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π Union-Find:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è          ‚îÇ Find    ‚îÇ Union   ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –ù–∞–∏–≤–Ω–∞—è             ‚îÇ O(1)    ‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îÇ Weighted Quick Union‚îÇ O(log n)‚îÇ O(log n)‚îÇ")
    fmt.Println("‚îÇ + Path Compression  ‚îÇ O(Œ±(n)) ‚îÇ O(Œ±(n)) ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("Œ±(n) - inverse Ackermann function, –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞")
}

---

# üèóÔ∏è –§–∞–∑–∞ 4: Backend –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è

## –ú–æ–¥—É–ª—å 11: Database –∏–Ω–¥–µ–∫—Å—ã - –£—Å–∫–æ—Ä–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤

### üóÉÔ∏è B+ Tree –≤ –±–∞–∑–∞—Ö –¥–∞–Ω–Ω—ã—Ö

```
B+ TREE - –û–°–ù–û–í–ê –ë–û–õ–¨–®–ò–ù–°–¢–í–ê DATABASE –ò–ù–î–ï–ö–°–û–í:

–û–¢–õ–ò–ß–ò–Ø –û–¢ –û–ë–´–ß–ù–û–ì–û BST:
‚Ä¢ –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π –≤ –æ–¥–Ω–æ–º —É–∑–ª–µ (–Ω–µ —Ç–æ–ª—å–∫–æ 2)
‚Ä¢ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –ª–∏—Å—Ç—å—è—Ö
‚Ä¢ –õ–∏—Å—Ç—å—è —Å–≤—è–∑–∞–Ω—ã –º–µ–∂–¥—É —Å–æ–±–æ–π (–¥–ª—è range scan)
‚Ä¢ –í—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–∞ (—à–∏—Ä–æ–∫–æ–µ, –Ω–æ –Ω–∏–∑–∫–æ–µ)

–°–¢–†–£–ö–¢–£–†–ê B+ TREE (–ø–æ—Ä—è–¥–æ–∫ = 3):

                [10, 20]              ‚Üê ROOT (–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —É–∑–µ–ª)
               /    |    \
        [5, 8]    [13, 16]   [25, 30] ‚Üê –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —É–∑–ª—ã
       /  |  \    /  |   \    /  |   \
   [1,3] [5,7] [8,9] ... (–ª–∏—Å—Ç—å—è —Å –¥–∞–Ω–Ω—ã–º–∏)
     ‚Üï     ‚Üï     ‚Üï
   data  data  data

–õ–ò–°–¢–¨–Ø –°–í–Ø–ó–ê–ù–´ –í –°–ü–ò–°–û–ö:
[1,3] ‚Üî [5,7] ‚Üî [8,9] ‚Üî [10,12] ‚Üî [13,15] ‚Üî ...

–ü–û–ß–ï–ú–£ B+ TREE –ò–î–ï–ê–õ–ï–ù –î–õ–Ø –ë–î:
‚úÖ –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ disk I/O –æ–ø–µ—Ä–∞—Ü–∏–π
‚úÖ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π range scan (SELECT * WHERE age BETWEEN 20 AND 30)
‚úÖ –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º
‚úÖ –í—ã—Å–æ–∫–∏–π branching factor = –Ω–∏–∑–∫–∞—è –≤—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞

–ü–†–ò–ú–ï–† –ü–û–ò–°–ö–ê –í B+ TREE:
–ò—â–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ —Å –∫–ª—é—á–æ–º –æ—Ç 13 –¥–æ 25:

1. –ù–∞—á–∏–Ω–∞–µ–º —Å –∫–æ—Ä–Ω—è [10, 20]
2. 13 > 10 –∏ 13 < 20, –∏–¥–µ–º –≤ —Å—Ä–µ–¥–Ω–∏–π —É–∑–µ–ª [13, 16]
3. 13 = 13, –∏–¥–µ–º –∫ –ª–µ–≤–æ–º—É –ª–∏—Å—Ç—É
4. –°–∫–∞–Ω–∏—Ä—É–µ–º –ª–∏—Å—Ç—å—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ: [13,15] ‚Üí [16,18] ‚Üí [20,22] ‚Üí [25,27]
  
–í—Å–µ–≥–æ disk reads: ~3-4 (–≤–º–µ—Å—Ç–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ —Ç—ã—Å—è—á –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞)
```

### üíæ LSM-Trees –≤ NoSQL

```
LSM-TREE (LOG-STRUCTURED MERGE TREE) - –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –î–õ–Ø –ó–ê–ü–ò–°–ò:

–ê–†–•–ò–¢–ï–ö–¢–£–†–ê:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê MEMTABLE (in memory)
‚îÇ Red-Black   ‚îÇ   –ë—ã—Å—Ç—Ä—ã–µ –∑–∞–ø–∏—Å–∏: O(log n)
‚îÇ Tree        ‚îÇ   –ü—Ä–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏ ‚Üí flush –Ω–∞ –¥–∏—Å–∫
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì flush
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê LEVEL 0 (–¥–∏—Å–∫)
‚îÇ SSTable 1   ‚îÇ   Sorted String Tables
‚îÇ SSTable 2   ‚îÇ   Immutable —Ñ–∞–π–ª—ã
‚îÇ SSTable 3   ‚îÇ   
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì compaction
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê LEVEL 1 (–¥–∏—Å–∫)
‚îÇ SSTable 4   ‚îÇ   –ë–æ–ª—å—à–µ, –Ω–æ –º–µ–Ω—å—à–µ —Ñ–∞–π–ª–æ–≤
‚îÇ SSTable 5   ‚îÇ   
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì compaction
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê LEVEL 2+ (–¥–∏—Å–∫)
‚îÇ SSTable 6   ‚îÇ   –ï—â–µ –±–æ–ª—å—à–µ —Ñ–∞–π–ª—ã
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

WRITE PATH (–ø—É—Ç—å –∑–∞–ø–∏—Å–∏):
1. –ó–∞–ø–∏—Å—å ‚Üí MemTable (–±—ã—Å—Ç—Ä–æ, –≤ –ø–∞–º—è—Ç–∏)
2. MemTable –∑–∞–ø–æ–ª–Ω–µ–Ω ‚Üí flush –≤ SSTable Level 0
3. Background compaction –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç SSTables

READ PATH (–ø—É—Ç—å —á—Ç–µ–Ω–∏—è):
1. –ü—Ä–æ–≤–µ—Ä—è–µ–º MemTable
2. –ü—Ä–æ–≤–µ—Ä—è–µ–º Level 0 SSTables (–æ—Ç –Ω–æ–≤—ã—Ö –∫ —Å—Ç–∞—Ä—ã–º)
3. –ü—Ä–æ–≤–µ—Ä—è–µ–º Level 1, Level 2... –¥–æ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è

–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
‚Ä¢ Bloom Filters: –±—ã—Å—Ç—Ä–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º "—Ç–æ—á–Ω–æ –ù–ï–¢" –∫–ª—é—á–∞ –≤ SSTable
‚Ä¢ Block Index: –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –≤–Ω—É—Ç—Ä–∏ SSTable
‚Ä¢ Compression: —ç–∫–æ–Ω–æ–º–∏–º –º–µ—Å—Ç–æ –Ω–∞ –¥–∏—Å–∫–µ

–ü–†–ò–ú–ï–ù–ï–ù–ò–ï:
‚Ä¢ Cassandra, RocksDB, LevelDB
‚Ä¢ –û—Ç–ª–∏—á–Ω–æ –¥–ª—è write-heavy workloads
‚Ä¢ –•–æ—Ä–æ—à–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö datasets
```

### üíª –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è LSM-Tree –≤ Go

```go
package main

import (
    "fmt"
    "sort"
    "sync"
    "time"
)

// üìù ENTRY –í LSM-TREE
type LSMEntry struct {
    Key       string
    Value     string
    Timestamp int64
    Deleted   bool // –¥–ª—è tombstone –∑–∞–ø–∏—Å–µ–π
}

// üå≥ MEMTABLE (–≤ –ø–∞–º—è—Ç–∏)
type MemTable struct {
    entries map[string]*LSMEntry
    size    int
    maxSize int
    mutex   sync.RWMutex
}

func NewMemTable(maxSize int) *MemTable {
    return &MemTable{
        entries: make(map[string]*LSMEntry),
        size:    0,
        maxSize: maxSize,
    }
}

func (mt *MemTable) Set(key, value string) {
    mt.mutex.Lock()
    defer mt.mutex.Unlock()
    
    entry := &LSMEntry{
        Key:       key,
        Value:     value,
        Timestamp: time.Now().UnixNano(),
        Deleted:   false,
    }
    
    mt.entries[key] = entry
    mt.size++
}

func (mt *MemTable) Get(key string) (*LSMEntry, bool) {
    mt.mutex.RLock()
    defer mt.mutex.RUnlock()
    
    entry, exists := mt.entries[key]
    return entry, exists
}

func (mt *MemTable) Delete(key string) {
    mt.mutex.Lock()
    defer mt.mutex.Unlock()
    
    // Tombstone –∑–∞–ø–∏—Å—å
    entry := &LSMEntry{
        Key:       key,
        Value:     "",
        Timestamp: time.Now().UnixNano(),
        Deleted:   true,
    }
    
    mt.entries[key] = entry
    mt.size++
}

func (mt *MemTable) IsFull() bool {
    mt.mutex.RLock()
    defer mt.mutex.RUnlock()
    return mt.size >= mt.maxSize
}

func (mt *MemTable) GetSortedEntries() []*LSMEntry {
    mt.mutex.RLock()
    defer mt.mutex.RUnlock()
    
    entries := make([]*LSMEntry, 0, len(mt.entries))
    for _, entry := range mt.entries {
        entries = append(entries, entry)
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–ª—é—á—É
    sort.Slice(entries, func(i, j int) bool {
        return entries[i].Key < entries[j].Key
    })
    
    return entries
}

// üìÅ SSTABLE (–Ω–∞ –¥–∏—Å–∫–µ - —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –≤ –ø–∞–º—è—Ç–∏)
type SSTable struct {
    entries   []*LSMEntry
    level     int
    id        string
    bloomFilter map[string]bool // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π Bloom filter
}

func NewSSTable(entries []*LSMEntry, level int, id string) *SSTable {
    // –°–æ–∑–¥–∞–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π Bloom filter
    bloomFilter := make(map[string]bool)
    for _, entry := range entries {
        bloomFilter[entry.Key] = true
    }
    
    return &SSTable{
        entries:     entries,
        level:       level,
        id:          id,
        bloomFilter: bloomFilter,
    }
}

func (sst *SSTable) Get(key string) (*LSMEntry, bool) {
    // –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ Bloom filter
    if !sst.bloomFilter[key] {
        return nil, false // –¢–æ—á–Ω–æ –Ω–µ—Ç
    }
    
    // –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
    left, right := 0, len(sst.entries)-1
    
    for left <= right {
        mid := (left + right) / 2
        midKey := sst.entries[mid].Key
        
        if midKey == key {
            return sst.entries[mid], true
        } else if midKey < key {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return nil, false
}

// üèóÔ∏è LSM-TREE –°–¢–†–£–ö–¢–£–†–ê
type LSMTree struct {
    memTable    *MemTable
    level0      []*SSTable
    otherLevels [][]*SSTable
    mutex       sync.RWMutex
    nextSSTableID int
}

func NewLSMTree(memTableSize int) *LSMTree {
    return &LSMTree{
        memTable:      NewMemTable(memTableSize),
        level0:        make([]*SSTable, 0),
        otherLevels:   make([][]*SSTable, 3), // 3 —É—Ä–æ–≤–Ω—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        nextSSTableID: 0,
    }
}

// ‚úçÔ∏è –ó–ê–ü–ò–°–¨
func (lsm *LSMTree) Set(key, value string) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ flush MemTable
    if lsm.memTable.IsFull() {
        lsm.flushMemTable()
    }
    
    lsm.memTable.Set(key, value)
}

// üîç –ß–¢–ï–ù–ò–ï
func (lsm *LSMTree) Get(key string) (string, bool) {
    // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º MemTable
    if entry, found := lsm.memTable.Get(key); found {
        if entry.Deleted {
            return "", false // Tombstone
        }
        return entry.Value, true
    }
    
    lsm.mutex.RLock()
    defer lsm.mutex.RUnlock()
    
    // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º Level 0 (–æ—Ç –Ω–æ–≤—ã—Ö –∫ —Å—Ç–∞—Ä—ã–º)
    for i := len(lsm.level0) - 1; i >= 0; i-- {
        if entry, found := lsm.level0[i].Get(key); found {
            if entry.Deleted {
                return "", false
            }
            return entry.Value, true
        }
    }
    
    // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–≥–∏–µ —É—Ä–æ–≤–Ω–∏
    for level := 0; level < len(lsm.otherLevels); level++ {
        for _, sstable := range lsm.otherLevels[level] {
            if entry, found := sstable.Get(key); found {
                if entry.Deleted {
                    return "", false
                }
                return entry.Value, true
            }
        }
    }
    
    return "", false
}

// üóëÔ∏è –£–î–ê–õ–ï–ù–ò–ï
func (lsm *LSMTree) Delete(key string) {
    if lsm.memTable.IsFull() {
        lsm.flushMemTable()
    }
    
    lsm.memTable.Delete(key)
}

// üíæ FLUSH MEMTABLE –ù–ê –î–ò–°–ö
func (lsm *LSMTree) flushMemTable() {
    entries := lsm.memTable.GetSortedEntries()
    if len(entries) == 0 {
        return
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π SSTable
    sstableID := fmt.Sprintf("sst_%d", lsm.nextSSTableID)
    lsm.nextSSTableID++
    
    sstable := NewSSTable(entries, 0, sstableID)
    
    lsm.mutex.Lock()
    lsm.level0 = append(lsm.level0, sstable)
    lsm.mutex.Unlock()
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π MemTable
    lsm.memTable = NewMemTable(lsm.memTable.maxSize)
    
    fmt.Printf("üìÅ Flushed MemTable ‚Üí SSTable %s (%d entries)\n", sstableID, len(entries))
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–∞ –ª–∏ –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    if len(lsm.level0) > 4 { // –ü–æ—Ä–æ–≥ –¥–ª—è –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        go lsm.compactLevel0() // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    }
}

// üîÑ COMPACTION (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
func (lsm *LSMTree) compactLevel0() {
    lsm.mutex.Lock()
    defer lsm.mutex.Unlock()
    
    if len(lsm.level0) < 2 {
        return
    }
    
    fmt.Printf("üîÑ –ó–∞–ø—É—Å–∫ –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ Level 0 (%d SSTables)\n", len(lsm.level0))
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ SSTables Level 0
    allEntries := make([]*LSMEntry, 0)
    
    for _, sstable := range lsm.level0 {
        allEntries = append(allEntries, sstable.entries...)
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–ª—é—á—É, –∑–∞—Ç–µ–º –ø–æ timestamp (–Ω–æ–≤—ã–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—é—Ç —Å—Ç–∞—Ä—ã–µ)
    sort.Slice(allEntries, func(i, j int) bool {
        if allEntries[i].Key == allEntries[j].Key {
            return allEntries[i].Timestamp > allEntries[j].Timestamp
        }
        return allEntries[i].Key < allEntries[j].Key
    })
    
    // –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω—é—é –≤–µ—Ä—Å–∏—é)
    uniqueEntries := make([]*LSMEntry, 0)
    seen := make(map[string]bool)
    
    for _, entry := range allEntries {
        if !seen[entry.Key] {
            uniqueEntries = append(uniqueEntries, entry)
            seen[entry.Key] = true
        }
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π SSTable –¥–ª—è Level 1
    compactedSSTable := NewSSTable(uniqueEntries, 1, fmt.Sprintf("compacted_%d", lsm.nextSSTableID))
    lsm.nextSSTableID++
    
    if len(lsm.otherLevels[0]) == 0 {
        lsm.otherLevels[0] = make([]*SSTable, 0)
    }
    lsm.otherLevels[0] = append(lsm.otherLevels[0], compactedSSTable)
    
    // –û—á–∏—â–∞–µ–º Level 0
    lsm.level0 = make([]*SSTable, 0)
    
    fmt.Printf("‚úÖ –ö–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: %d ‚Üí 1 SSTable (%d —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π)\n", 
        len(allEntries), len(uniqueEntries))
}

// üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ò
func (lsm *LSMTree) Stats() {
    lsm.mutex.RLock()
    defer lsm.mutex.RUnlock()
    
    fmt.Println("=== LSM-Tree –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ ===")
    fmt.Printf("MemTable —Ä–∞–∑–º–µ—Ä: %d\n", lsm.memTable.size)
    fmt.Printf("Level 0 SSTables: %d\n", len(lsm.level0))
    
    for level, sstables := range lsm.otherLevels {
        if len(sstables) > 0 {
            fmt.Printf("Level %d SSTables: %d\n", level+1, len(sstables))
        }
    }
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø LSM-TREE
func lsmTreeDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è LSM-Tree ===")
    
    lsm := NewLSMTree(5) // MemTable –Ω–∞ 5 –∑–∞–ø–∏—Å–µ–π
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    fmt.Println("\nüìù –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ:")
    testData := [][]string{
        {"user:1", "Alice"}, {"user:2", "Bob"}, {"user:3", "Charlie"},
        {"user:4", "Diana"}, {"user:5", "Eve"}, {"user:6", "Frank"},
        {"user:7", "Grace"}, {"user:8", "Henry"}, {"user:1", "Alice Updated"},
    }
    
    for _, data := range testData {
        key, value := data[0], data[1]
        fmt.Printf("  SET %s = %s\n", key, value)
        lsm.Set(key, value)
        
        if lsm.memTable.size == lsm.memTable.maxSize {
            fmt.Println("  MemTable –∑–∞–ø–æ–ª–Ω–µ–Ω, –±—É–¥–µ—Ç flush –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–ø–∏—Å–∏")
        }
    }
    
    lsm.Stats()
    
    // –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    fmt.Println("\nüîç –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ:")
    readKeys := []string{"user:1", "user:5", "user:8", "user:99"}
    
    for _, key := range readKeys {
        if value, found := lsm.Get(key); found {
            fmt.Printf("  GET %s = %s ‚úÖ\n", key, value)
        } else {
            fmt.Printf("  GET %s = NOT FOUND ‚ùå\n", key)
        }
    }
    
    // –£–¥–∞–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
    fmt.Println("\nüóëÔ∏è –£–¥–∞–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ:")
    lsm.Delete("user:2")
    fmt.Println("  DELETE user:2")
    
    if value, found := lsm.Get("user:2"); found {
        fmt.Printf("  GET user:2 = %s (–Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–∞–π–¥–µ–Ω–æ!)\n", value)
    } else {
        fmt.Printf("  GET user:2 = NOT FOUND ‚úÖ\n")
    }
    
    lsm.Stats()
}

// üéØ –°–†–ê–í–ù–ï–ù–ò–ï –° B+ TREE
func indexComparisonDemo() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä ===")
    
    fmt.Println("üìä B+ Tree vs LSM-Tree:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞  ‚îÇ B+ Tree     ‚îÇ LSM-Tree    ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –ó–∞–ø–∏—Å—å          ‚îÇ O(log n)    ‚îÇ O(1)*       ‚îÇ")
    fmt.Println("‚îÇ –ß—Ç–µ–Ω–∏–µ          ‚îÇ O(log n)    ‚îÇ O(log n)**  ‚îÇ")
    fmt.Println("‚îÇ Range scan      ‚îÇ –û—Ç–ª–∏—á–Ω–æ     ‚îÇ –•–æ—Ä–æ—à–æ      ‚îÇ")
    fmt.Println("‚îÇ Space amplif.   ‚îÇ –ù–∏–∑–∫–∞—è      ‚îÇ –°—Ä–µ–¥–Ω—è—è     ‚îÇ")
    fmt.Println("‚îÇ Write amplif.   ‚îÇ –í—ã—Å–æ–∫–∞—è     ‚îÇ –°—Ä–µ–¥–Ω—è—è     ‚îÇ")
    fmt.Println("‚îÇ –§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è    ‚îÇ –°—Ä–µ–¥–Ω—è—è     ‚îÇ –ù–∏–∑–∫–∞—è      ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ (—Å —É—á–µ—Ç–æ–º flush/compaction)")
    fmt.Println("** –ú–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —É—Ä–æ–≤–Ω–µ–π")
    
    fmt.Println("\nüéØ –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:")
    fmt.Println("B+ Tree:")
    fmt.Println("  ‚úÖ Read-heavy workloads")
    fmt.Println("  ‚úÖ –ú–Ω–æ–≥–æ range queries")
    fmt.Println("  ‚úÖ OLTP —Å–∏—Å—Ç–µ–º—ã")
    fmt.Println("  ‚úÖ –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–µ RDBMS")
    
    fmt.Println("\nLSM-Tree:")
    fmt.Println("  ‚úÖ Write-heavy workloads")
    fmt.Println("  ‚úÖ –ë–æ–ª—å—à–∏–µ –æ–±—ä–µ–º—ã –¥–∞–Ω–Ω—ã—Ö")
    fmt.Println("  ‚úÖ NoSQL —Å–∏—Å—Ç–µ–º—ã")
    fmt.Println("  ‚úÖ Time-series –¥–∞–Ω–Ω—ã–µ")
}

---

## –ú–æ–¥—É–ª—å 12: –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ - –£—Å–∫–æ—Ä–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º

### üíæ LRU Cache - Least Recently Used

```
LRU CACHE - –í–´–¢–ï–°–ù–Ø–ï–ú –î–ê–í–ù–û –ù–ï –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ù–´–ï –î–ê–ù–ù–´–ï:

–°–¢–†–£–ö–¢–£–†–ê:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   HashMap   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ         Doubly Linked List          ‚îÇ
‚îÇ             ‚îÇ     ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ key ‚Üí node  ‚îÇ     ‚îÇ  ‚îÇ A ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∂‚îÇ B ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∂‚îÇ C ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∂‚îÇ D ‚îÇ  ‚îÇ
‚îÇ             ‚îÇ     ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ   ‚Üë head                tail ‚Üë    ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          (most recent)   (least recent)

–û–ü–ï–†–ê–¶–ò–ò:

GET(key):
1. –ï—Å–ª–∏ –∫–ª—é—á –Ω–∞–π–¥–µ–Ω –≤ HashMap ‚Üí –ø–µ—Ä–µ–º–µ—â–∞–µ–º —É–∑–µ–ª –≤ head
2. –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Üí cache miss

PUT(key, value):
1. –ï—Å–ª–∏ –∫–ª—é—á —Å—É—â–µ—Å—Ç–≤—É–µ—Ç ‚Üí –æ–±–Ω–æ–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ, –ø–µ—Ä–µ–º–µ—â–∞–µ–º –≤ head
2. –ï—Å–ª–∏ –Ω–æ–≤—ã–π –∫–ª—é—á:
   - –ï—Å–ª–∏ cache –ø–æ–ª–æ–Ω ‚Üí —É–¥–∞–ª—è–µ–º tail —É–∑–µ–ª –∏–∑ HashMap –∏ —Å–ø–∏—Å–∫–∞
   - –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª –≤ head, –¥–æ–±–∞–≤–ª—è–µ–º –≤ HashMap

–ü–†–ò–ú–ï–† –†–ê–ë–û–¢–´ (capacity = 3):

–ù–∞—á–∞–ª—å–Ω–æ–µ: [] (–ø—É—Å—Ç–æ)

PUT(1, "A"): [1] head‚Üí1‚Üêtail
PUT(2, "B"): [2, 1] head‚Üí2‚Üí1‚Üêtail  
PUT(3, "C"): [3, 2, 1] head‚Üí3‚Üí2‚Üí1‚Üêtail

GET(1): [1, 3, 2] head‚Üí1‚Üí3‚Üí2‚Üêtail (1 –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –≤ head)

PUT(4, "D"): [4, 1, 3] head‚Üí4‚Üí1‚Üí3‚Üêtail (2 –≤—ã—Ç–µ—Å–Ω—è–µ—Ç—Å—è)

–í–†–ï–ú–ï–ù–ù–ê–Ø –°–õ–û–ñ–ù–û–°–¢–¨:
‚Ä¢ GET: O(1)
‚Ä¢ PUT: O(1)  
‚Ä¢ –û–±–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω—ã –±–ª–∞–≥–æ–¥–∞—Ä—è HashMap + Linked List
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è LRU Cache –≤ Go

```go
package main

import (
    "fmt"
)

// üîó –£–ó–ï–õ –î–í–£–°–í–Ø–ó–ù–û–ì–û –°–ü–ò–°–ö–ê
type LRUNode struct {
    key   string
    value interface{}
    prev  *LRUNode
    next  *LRUNode
}

// üíæ LRU CACHE –°–¢–†–£–ö–¢–£–†–ê
type LRUCache struct {
    capacity int
    cache    map[string]*LRUNode // HashMap –¥–ª—è O(1) –¥–æ—Å—Ç—É–ø–∞
    head     *LRUNode            // Dummy head (most recent)
    tail     *LRUNode            // Dummy tail (least recent)
    size     int
}

func NewLRUCache(capacity int) *LRUCache {
    // –°–æ–∑–¥–∞–µ–º dummy —É–∑–ª—ã –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π
    head := &LRUNode{}
    tail := &LRUNode{}
    head.next = tail
    tail.prev = head
    
    return &LRUCache{
        capacity: capacity,
        cache:    make(map[string]*LRUNode),
        head:     head,
        tail:     tail,
        size:     0,
    }
}

// ‚ûï –î–û–ë–ê–í–õ–ï–ù–ò–ï –£–ó–õ–ê –í HEAD
func (lru *LRUCache) addToHead(node *LRUNode) {
    node.prev = lru.head
    node.next = lru.head.next
    
    lru.head.next.prev = node
    lru.head.next = node
}

// ‚ûñ –£–î–ê–õ–ï–ù–ò–ï –£–ó–õ–ê –ò–ó –°–ü–ò–°–ö–ê
func (lru *LRUCache) removeNode(node *LRUNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

// üîÑ –ü–ï–†–ï–ú–ï–©–ï–ù–ò–ï –£–ó–õ–ê –í HEAD
func (lru *LRUCache) moveToHead(node *LRUNode) {
    lru.removeNode(node)
    lru.addToHead(node)
}

// üóëÔ∏è –£–î–ê–õ–ï–ù–ò–ï –ü–û–°–õ–ï–î–ù–ï–ì–û –£–ó–õ–ê
func (lru *LRUCache) removeTail() *LRUNode {
    lastNode := lru.tail.prev
    lru.removeNode(lastNode)
    return lastNode
}

// üîç GET –û–ü–ï–†–ê–¶–ò–Ø
func (lru *LRUCache) Get(key string) (interface{}, bool) {
    if node, exists := lru.cache[key]; exists {
        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤ head (–æ—Ç–º–µ—á–∞–µ–º –∫–∞–∫ recently used)
        lru.moveToHead(node)
        return node.value, true
    }
    
    return nil, false
}

// ‚úçÔ∏è PUT –û–ü–ï–†–ê–¶–ò–Ø
func (lru *LRUCache) Put(key string, value interface{}) {
    if node, exists := lru.cache[key]; exists {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–ª—é—á
        node.value = value
        lru.moveToHead(node)
        return
    }
    
    // –ù–æ–≤—ã–π –∫–ª—é—á
    newNode := &LRUNode{key: key, value: value}
    
    if lru.size >= lru.capacity {
        // Cache –ø–æ–ª–æ–Ω, –≤—ã—Ç–µ—Å–Ω—è–µ–º LRU —ç–ª–µ–º–µ–Ω—Ç
        tail := lru.removeTail()
        delete(lru.cache, tail.key)
        lru.size--
    }
    
    lru.addToHead(newNode)
    lru.cache[key] = newNode
    lru.size++
}

// üóëÔ∏è DELETE –û–ü–ï–†–ê–¶–ò–Ø
func (lru *LRUCache) Delete(key string) bool {
    if node, exists := lru.cache[key]; exists {
        lru.removeNode(node)
        delete(lru.cache, key)
        lru.size--
        return true
    }
    return false
}

// üìä –ò–ù–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ï –ú–ï–¢–û–î–´
func (lru *LRUCache) Size() int {
    return lru.size
}

func (lru *LRUCache) Capacity() int {
    return lru.capacity
}

// üñ®Ô∏è –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –°–û–°–¢–û–Ø–ù–ò–Ø
func (lru *LRUCache) Print() {
    fmt.Printf("LRU Cache (size: %d, capacity: %d):\n", lru.size, lru.capacity)
    
    if lru.size == 0 {
        fmt.Println("  [empty]")
        return
    }
    
    fmt.Print("  [")
    current := lru.head.next
    for current != lru.tail {
        fmt.Printf("%s:%v", current.key, current.value)
        current = current.next
        if current != lru.tail {
            fmt.Print(" ‚Üí ")
        }
    }
    fmt.Println("] (head ‚Üí tail)")
}

// üìã –ü–û–õ–£–ß–ò–¢–¨ –í–°–ï –ö–õ–Æ–ß–ò –í –ü–û–†–Ø–î–ö–ï –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø
func (lru *LRUCache) GetKeys() []string {
    keys := make([]string, 0, lru.size)
    current := lru.head.next
    
    for current != lru.tail {
        keys = append(keys, current.key)
        current = current.next
    }
    
    return keys
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø LRU CACHE
func lruCacheDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è LRU Cache ===")
    
    cache := NewLRUCache(3) // Capacity = 3
    
    fmt.Println("\nüìù –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã:")
    
    operations := []struct {
        op    string
        key   string
        value interface{}
    }{
        {"PUT", "A", "Alice"},
        {"PUT", "B", "Bob"},
        {"PUT", "C", "Charlie"},
        {"GET", "A", nil},
        {"PUT", "D", "Diana"},  // –í—ã—Ç–µ—Å–Ω–∏—Ç B
        {"GET", "B", nil},      // Cache miss
        {"GET", "C", nil},
        {"PUT", "E", "Eve"},    // –í—ã—Ç–µ—Å–Ω–∏—Ç D
    }
    
    for _, op := range operations {
        fmt.Printf("\n%s(%s", op.op, op.key)
        if op.value != nil {
            fmt.Printf(", %v", op.value)
        }
        fmt.Printf("):\n")
        
        if op.op == "PUT" {
            cache.Put(op.key, op.value)
        } else {
            if value, found := cache.Get(op.key); found {
                fmt.Printf("  –†–µ–∑—É–ª—å—Ç–∞—Ç: %v ‚úÖ\n", value)
            } else {
                fmt.Printf("  –†–µ–∑—É–ª—å—Ç–∞—Ç: CACHE MISS ‚ùå\n")
            }
        }
        
        cache.Print()
    }
}

// üåê –ú–ù–û–ì–û–£–†–û–í–ù–ï–í–û–ï –ö–ï–®–ò–†–û–í–ê–ù–ò–ï
type MultiLevelCache struct {
    l1Cache *LRUCache // –ë—ã—Å—Ç—Ä—ã–π, –º–∞–ª–µ–Ω—å–∫–∏–π
    l2Cache *LRUCache // –ú–µ–¥–ª–µ–Ω–Ω–µ–µ, –±–æ–ª—å—à–µ
    l3Cache *LRUCache // –°–∞–º—ã–π –º–µ–¥–ª–µ–Ω–Ω—ã–π, —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π
    stats   *CacheStats
}

type CacheStats struct {
    L1Hits, L1Misses int
    L2Hits, L2Misses int
    L3Hits, L3Misses int
    TotalRequests    int
}

func NewMultiLevelCache(l1Size, l2Size, l3Size int) *MultiLevelCache {
    return &MultiLevelCache{
        l1Cache: NewLRUCache(l1Size),
        l2Cache: NewLRUCache(l2Size),
        l3Cache: NewLRUCache(l3Size),
        stats:   &CacheStats{},
    }
}

func (mlc *MultiLevelCache) Get(key string) (interface{}, bool) {
    mlc.stats.TotalRequests++
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º L1 cache
    if value, found := mlc.l1Cache.Get(key); found {
        mlc.stats.L1Hits++
        return value, true
    }
    mlc.stats.L1Misses++
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º L2 cache
    if value, found := mlc.l2Cache.Get(key); found {
        mlc.stats.L2Hits++
        // –ü–æ–¥–Ω–∏–º–∞–µ–º –≤ L1
        mlc.l1Cache.Put(key, value)
        return value, true
    }
    mlc.stats.L2Misses++
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º L3 cache
    if value, found := mlc.l3Cache.Get(key); found {
        mlc.stats.L3Hits++
        // –ü–æ–¥–Ω–∏–º–∞–µ–º –≤ L2 –∏ L1
        mlc.l2Cache.Put(key, value)
        mlc.l1Cache.Put(key, value)
        return value, true
    }
    mlc.stats.L3Misses++
    
    return nil, false
}

func (mlc *MultiLevelCache) Put(key string, value interface{}) {
    // –î–æ–±–∞–≤–ª—è–µ–º –≤–æ –≤—Å–µ —É—Ä–æ–≤–Ω–∏
    mlc.l1Cache.Put(key, value)
    mlc.l2Cache.Put(key, value)
    mlc.l3Cache.Put(key, value)
}

func (mlc *MultiLevelCache) PrintStats() {
    fmt.Println("=== Multi-Level Cache Statistics ===")
    fmt.Printf("Total requests: %d\n", mlc.stats.TotalRequests)
    
    if mlc.stats.TotalRequests > 0 {
        l1HitRate := float64(mlc.stats.L1Hits) / float64(mlc.stats.TotalRequests) * 100
        l2HitRate := float64(mlc.stats.L2Hits) / float64(mlc.stats.TotalRequests) * 100
        l3HitRate := float64(mlc.stats.L3Hits) / float64(mlc.stats.TotalRequests) * 100
        
        fmt.Printf("L1 Cache: %d hits, %d misses (%.1f%% hit rate)\n", 
            mlc.stats.L1Hits, mlc.stats.L1Misses, l1HitRate)
        fmt.Printf("L2 Cache: %d hits, %d misses (%.1f%% hit rate)\n", 
            mlc.stats.L2Hits, mlc.stats.L2Misses, l2HitRate)
        fmt.Printf("L3 Cache: %d hits, %d misses (%.1f%% hit rate)\n", 
            mlc.stats.L3Hits, mlc.stats.L3Misses, l3HitRate)
        
        overallHitRate := float64(mlc.stats.L1Hits+mlc.stats.L2Hits+mlc.stats.L3Hits) / float64(mlc.stats.TotalRequests) * 100
        fmt.Printf("Overall hit rate: %.1f%%\n", overallHitRate)
    }
}

func multiLevelCacheDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–≥–æ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è ===")
    
    // L1: 2, L2: 4, L3: 8
    mlCache := NewMultiLevelCache(2, 4, 8)
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º cache
    fmt.Println("\n–ó–∞–ø–æ–ª–Ω—è–µ–º cache –¥–∞–Ω–Ω—ã–º–∏:")
    for i := 1; i <= 10; i++ {
        key := fmt.Sprintf("key%d", i)
        value := fmt.Sprintf("value%d", i)
        mlCache.Put(key, value)
        fmt.Printf("  PUT %s = %s\n", key, value)
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø
    fmt.Println("\n–¢–µ—Å—Ç–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º:")
    testKeys := []string{"key1", "key5", "key8", "key1", "key3", "key12", "key5", "key8"}
    
    for _, key := range testKeys {
        if value, found := mlCache.Get(key); found {
            fmt.Printf("  GET %s = %s ‚úÖ\n", key, value)
        } else {
            fmt.Printf("  GET %s = MISS ‚ùå\n", key)
        }
    }
    
    mlCache.PrintStats()
}

// üîÑ CONSISTENT HASHING –î–õ–Ø –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ù–û–ì–û –ö–ï–®–ê
type ConsistentHash struct {
    ring        map[uint32]string   // hash ‚Üí node
    sortedHashes []uint32           // sorted hash values
    nodes       map[string]bool     // active nodes
    replicas    int                 // virtual nodes per physical node
}

func NewConsistentHash(replicas int) *ConsistentHash {
    return &ConsistentHash{
        ring:        make(map[uint32]string),
        sortedHashes: make([]uint32, 0),
        nodes:       make(map[string]bool),
        replicas:    replicas,
    }
}

// –ü—Ä–æ—Å—Ç–∞—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
func (ch *ConsistentHash) hash(data string) uint32 {
    hash := uint32(0)
    for _, c := range data {
        hash = hash*31 + uint32(c)
    }
    return hash
}

// ‚ûï –î–û–ë–ê–í–õ–ï–ù–ò–ï –£–ó–õ–ê
func (ch *ConsistentHash) AddNode(node string) {
    if ch.nodes[node] {
        return // –£–∑–µ–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }
    
    ch.nodes[node] = true
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —É–∑–ª—ã
    for i := 0; i < ch.replicas; i++ {
        virtualNode := fmt.Sprintf("%s:%d", node, i)
        hash := ch.hash(virtualNode)
        ch.ring[hash] = node
        ch.sortedHashes = append(ch.sortedHashes, hash)
    }
    
    // –ü–µ—Ä–µ—Å–æ—Ä—Ç–∏—Ä–æ–≤—ã–≤–∞–µ–º —Ö–µ—à–∏
    sort.Slice(ch.sortedHashes, func(i, j int) bool {
        return ch.sortedHashes[i] < ch.sortedHashes[j]
    })
    
    fmt.Printf("‚ûï –î–æ–±–∞–≤–ª–µ–Ω —É–∑–µ–ª %s (%d –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —É–∑–ª–æ–≤)\n", node, ch.replicas)
}

// ‚ûñ –£–î–ê–õ–ï–ù–ò–ï –£–ó–õ–ê
func (ch *ConsistentHash) RemoveNode(node string) {
    if !ch.nodes[node] {
        return // –£–∑–µ–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }
    
    delete(ch.nodes, node)
    
    // –£–¥–∞–ª—è–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —É–∑–ª—ã
    newSortedHashes := make([]uint32, 0)
    for _, hash := range ch.sortedHashes {
        if ch.ring[hash] != node {
            newSortedHashes = append(newSortedHashes, hash)
        } else {
            delete(ch.ring, hash)
        }
    }
    ch.sortedHashes = newSortedHashes
    
    fmt.Printf("‚ûñ –£–¥–∞–ª–µ–Ω —É–∑–µ–ª %s\n", node)
}

// üéØ –ü–û–ò–°–ö –£–ó–õ–ê –î–õ–Ø –ö–õ–Æ–ß–ê
func (ch *ConsistentHash) GetNode(key string) string {
    if len(ch.sortedHashes) == 0 {
        return ""
    }
    
    hash := ch.hash(key)
    
    // –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –ø–µ—Ä–≤–æ–≥–æ —É–∑–ª–∞ >= hash
    idx := sort.Search(len(ch.sortedHashes), func(i int) bool {
        return ch.sortedHashes[i] >= hash
    })
    
    // –ö–æ–ª—å—Ü–µ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞: –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π
    if idx == len(ch.sortedHashes) {
        idx = 0
    }
    
    return ch.ring[ch.sortedHashes[idx]]
}

// üìä –ê–ù–ê–õ–ò–ó –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–Ø
func (ch *ConsistentHash) AnalyzeDistribution(keys []string) {
    distribution := make(map[string]int)
    
    for _, key := range keys {
        node := ch.GetNode(key)
        distribution[node]++
    }
    
    fmt.Println("\nüìä –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–π –ø–æ —É–∑–ª–∞–º:")
    for node, count := range distribution {
        percentage := float64(count) / float64(len(keys)) * 100
        fmt.Printf("  %s: %d –∫–ª—é—á–µ–π (%.1f%%)\n", node, count, percentage)
    }
}

func consistentHashDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Consistent Hashing ===")
    
    ch := NewConsistentHash(3) // 3 –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —É–∑–ª–∞ –Ω–∞ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π
    
    // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–ª—ã
    nodes := []string{"server-1", "server-2", "server-3"}
    for _, node := range nodes {
        ch.AddNode(node)
    }
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –∫–ª—é—á–∏
    keys := make([]string, 1000)
    for i := 0; i < 1000; i++ {
        keys[i] = fmt.Sprintf("key_%d", i)
    }
    
    fmt.Printf("\n–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ %d –∫–ª—é—á–µ–π:\n", len(keys))
    ch.AnalyzeDistribution(keys)
    
    // –ú–æ–¥–µ–ª–∏—Ä—É–µ–º –æ—Ç–∫–∞–∑ —É–∑–ª–∞
    fmt.Println("\nüî• –ú–æ–¥–µ–ª–∏—Ä—É–µ–º –æ—Ç–∫–∞–∑ server-2:")
    ch.RemoveNode("server-2")
    ch.AnalyzeDistribution(keys)
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª
    fmt.Println("\n‚ûï –î–æ–±–∞–≤–ª—è–µ–º server-4:")
    ch.AddNode("server-4")
    ch.AnalyzeDistribution(keys)
    
    fmt.Println("\nüí° Consistent Hashing –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π,")
    fmt.Println("   –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–∑–ª–æ–≤.")
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò CACHE –°–¢–†–ê–¢–ï–ì–ò–ô
func cachePerformanceDemo() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ cache —Å—Ç—Ä–∞—Ç–µ–≥–∏–π ===")
    
    const operations = 100000
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    keys := make([]string, operations)
    for i := 0; i < operations; i++ {
        keys[i] = fmt.Sprintf("key_%d", i%1000) // –ü–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –∫–ª—é—á–∏ –¥–ª—è locality
    }
    
    // 1. LRU Cache
    lruCache := NewLRUCache(100)
    start := time.Now()
    lruHits := 0
    
    for _, key := range keys {
        if _, found := lruCache.Get(key); found {
            lruHits++
        } else {
            lruCache.Put(key, fmt.Sprintf("value_%s", key))
        }
    }
    lruTime := time.Since(start)
    
    // 2. Go built-in map (–±–µ–∑ eviction)
    goMap := make(map[string]# –ü–æ–ª–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Backend —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞

## üìö –í–≤–µ–¥–µ–Ω–∏–µ: –ó–∞—á–µ–º –∏–∑—É—á–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö?

–ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ, —á—Ç–æ –≤—ã —Å—Ç—Ä–æ–∏—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–º–∞–≥–∞–∑–∏–Ω. –£ –≤–∞—Å –µ—Å—Ç—å:
- üõçÔ∏è **10 –º–∏–ª–ª–∏–æ–Ω–æ–≤ —Ç–æ–≤–∞—Ä–æ–≤** - –∫–∞–∫ –±—ã—Å—Ç—Ä–æ –Ω–∞–π—Ç–∏ –Ω—É–∂–Ω—ã–π?
- üë• **100 —Ç—ã—Å—è—á –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –æ–Ω–ª–∞–π–Ω** - –∫–∞–∫ —É–ø—Ä–∞–≤–ª—è—Ç—å –∏—Ö —Å–µ—Å—Å–∏—è–º–∏?
- üì¶ **–ú–∏–ª–ª–∏–æ–Ω –∑–∞–∫–∞–∑–æ–≤ –≤ –¥–µ–Ω—å** - –∫–∞–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å?
- üíæ **–¢–µ—Ä–∞–±–∞–π—Ç—ã –¥–∞–Ω–Ω—ã—Ö** - –∫–∞–∫ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –ø–∞–º—è—Ç–∏?

**–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤—ã–±–æ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö = —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É —Å–∞–π—Ç–æ–º, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –∑–∞ 100–º—Å –∏ —Ç–µ–º, –∫–æ—Ç–æ—Ä—ã–π —Ç–æ—Ä–º–æ–∑–∏—Ç 10 —Å–µ–∫—É–Ω–¥.**

---

# üèóÔ∏è –§–∞–∑–∞ 1: –û—Å–Ω–æ–≤—ã —Ä–∞–±–æ—Ç—ã —Å –ø–∞–º—è—Ç—å—é

## –ú–æ–¥—É–ª—å 1: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–∞–º—è—Ç–∏ - –§—É–Ω–¥–∞–º–µ–Ω—Ç –≤—Å–µ–≥–æ

### üîç –ö–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω–∞ –ø–∞–º—è—Ç—å –∫–æ–º–ø—å—é—Ç–µ—Ä–∞

```
–ö–û–ú–ü–¨–Æ–¢–ï–†–ù–ê–Ø –ü–ê–ú–Ø–¢–¨ - –≠–¢–û –ö–ê–ö –ú–ù–û–ì–û–≠–¢–ê–ñ–ù–û–ï –ó–î–ê–ù–ò–ï:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –†–ï–ì–ò–°–¢–†–´ CPU (—Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π, 1-2 –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥—ã)
‚îÇ –†–µ–≥–∏—Å—Ç—Ä—ã       ‚îÇ   –†–∞–∑–º–µ—Ä: ~100 –±–∞–π—Ç, –≥–¥–µ CPU —Ö—Ä–∞–Ω–∏—Ç —Ç–µ–∫—É—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
‚îÇ rax, rbx, etc  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê L1 CACHE (–æ—á–µ–Ω—å –±—ã—Å—Ç—Ä—ã–π, ~1 –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥–∞) 
‚îÇ L1 Cache       ‚îÇ   –†–∞–∑–º–µ—Ä: ~32KB, –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–∫—É—â–µ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã
‚îÇ 32KB           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê L2 CACHE (–±—ã—Å—Ç—Ä—ã–π, ~3 –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥—ã)
‚îÇ L2 Cache       ‚îÇ   –†–∞–∑–º–µ—Ä: ~256KB, –Ω–µ–¥–∞–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ  
‚îÇ 256KB          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê L3 CACHE (—É–º–µ—Ä–µ–Ω–Ω–æ –±—ã—Å—Ç—Ä—ã–π, ~12 –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥)
‚îÇ L3 Cache       ‚îÇ   –†–∞–∑–º–µ—Ä: ~8MB, –æ–±—â–∏–π –¥–ª—è –≤—Å–µ—Ö —è–¥–µ—Ä –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞
‚îÇ 8MB            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –û–ü–ï–†–ê–¢–ò–í–ù–ê–Ø –ü–ê–ú–Ø–¢–¨ (–º–µ–¥–ª–µ–Ω–Ω–æ, ~100 –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥)
‚îÇ RAM            ‚îÇ   –†–∞–∑–º–µ—Ä: 8-64GB, –æ—Å–Ω–æ–≤–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –ø—Ä–æ–≥—Ä–∞–º–º
‚îÇ 16GB           ‚îÇ
‚îÇ                ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –°–¢–ï–ö (—Ä–∞—Å—Ç–µ—Ç –≤–Ω–∏–∑)
‚îÇ                ‚îÇ   ‚îÇ   –°–¢–ï–ö      ‚îÇ   –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–π
‚îÇ                ‚îÇ   ‚îÇ             ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ func main() ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ func test() ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ var x = 5   ‚îÇ   
‚îÇ                ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   
‚îÇ                ‚îÇ   
‚îÇ                ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –ö–£–ß–ê (—Ä–∞—Å—Ç–µ—Ç –≤–≤–µ—Ä—Ö)  
‚îÇ                ‚îÇ   ‚îÇ    –ö–£–ß–ê     ‚îÇ   –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
‚îÇ                ‚îÇ   ‚îÇ             ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ User struct ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ []int slice ‚îÇ   
‚îÇ                ‚îÇ   ‚îÇ map data    ‚îÇ   
‚îÇ                ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –î–ò–°–ö (–æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ, ~10 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥!)
‚îÇ SSD/HDD        ‚îÇ   –†–∞–∑–º–µ—Ä: 1TB+, –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
‚îÇ 1TB            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üöÄ –°–ö–û–†–û–°–¢–¨ –î–û–°–¢–£–ü–ê (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ):
–†–µ–≥–∏—Å—Ç—Ä—ã:    1x      (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)
L1 Cache:    1x      (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ) 
L2 Cache:    3x      (—á—É—Ç—å –º–µ–¥–ª–µ–Ω–Ω–µ–µ)
L3 Cache:    12x     (–∑–∞–º–µ—Ç–Ω–æ –º–µ–¥–ª–µ–Ω–Ω–µ–µ)
RAM:         100x    (–º–µ–¥–ª–µ–Ω–Ω–æ)
–î–∏—Å–∫:        100,000x (–û–ß–ï–ù–¨ –º–µ–¥–ª–µ–Ω–Ω–æ!)
```

### üß† –°—Ç–µ–∫ vs –ö—É—á–∞: –î–µ—Ç–∞–ª—å–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ

```
üìö –°–¢–ï–ö - –∫–∞–∫ —Å—Ç–æ–ø–∫–∞ –∫–Ω–∏–≥:

–ü–†–ò–ú–ï–† –í–´–ü–û–õ–ù–ï–ù–ò–Ø –ü–†–û–ì–†–ê–ú–ú–´:
main() –≤—ã–∑—ã–≤–∞–µ—Ç getUserData() –≤—ã–∑—ã–≤–∞–µ—Ç validateEmail()

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚Üê –¢–µ–∫—É—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è (Top of Stack)
‚îÇ validateEmail() ‚îÇ    var valid bool = true
‚îÇ valid: true     ‚îÇ    var at_pos int = 5  
‚îÇ at_pos: 5       ‚îÇ    return valid
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚Üë –ö–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è–µ—Ç—Å—è

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  
‚îÇ getUserData()   ‚îÇ    var email string = "user@example.com"
‚îÇ email: "user@.."‚îÇ    var user User
‚îÇ user: {..}      ‚îÇ    // –í—ã–∑—ã–≤–∞–µ—Ç validateEmail()
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚Üê –ù–∞—á–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ main()          ‚îÇ    var count int = 0
‚îÇ count: 0        ‚îÇ    // –í—ã–∑—ã–≤–∞–µ—Ç getUserData()
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò –°–¢–ï–ö–ê:
‚úÖ –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ/–æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ (–ø—Ä–æ—Å—Ç–æ —Å–¥–≤–∏–≥ —É–∫–∞–∑–∞—Ç–µ–ª—è)
‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é (no memory leaks)
‚úÖ –û—Ç–ª–∏—á–Ω–∞—è cache locality (–¥–∞–Ω–Ω—ã–µ —Ä—è–¥–æ–º –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º)
‚ùå –û–≥—Ä–∞–Ω–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä–æ–º (~8MB –Ω–∞ –ø–æ—Ç–æ–∫ –≤ Linux)
‚ùå –î–∞–Ω–Ω—ã–µ —É–º–∏—Ä–∞—é—Ç –≤–º–µ—Å—Ç–µ —Å —Ñ—É–Ω–∫—Ü–∏–µ–π
‚ùå –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é

üèóÔ∏è –ö–£–ß–ê - –∫–∞–∫ —Å–∫–ª–∞–¥ —Å –∞–¥—Ä–µ—Å–∞–º–∏:

–ü–†–ò–ú–ï–† –í–´–î–ï–õ–ï–ù–ò–Ø –í –ö–£–ß–ï:
users := make([]User, 1000)  // –ü—Ä–æ—Å–∏–º –º–µ—Å—Ç–æ –ø–æ–¥ 1000 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

–ê–¥—Ä–µ—Å: 0x1000              –ê–¥—Ä–µ—Å: 0x2500              –ê–¥—Ä–µ—Å: 0x4200
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ []User (1000)   ‚îÇ       ‚îÇ map[string]int  ‚îÇ       ‚îÇ *DatabaseConn   ‚îÇ
‚îÇ users[0]: {...} ‚îÇ       ‚îÇ "john": 25      ‚îÇ       ‚îÇ connection data ‚îÇ
‚îÇ users[1]: {...} ‚îÇ ‚Üê     ‚îÇ "mary": 30      ‚îÇ ‚Üê     ‚îÇ socket info     ‚îÇ
‚îÇ ...             ‚îÇ  \    ‚îÇ "bob": 22       ‚îÇ  \    ‚îÇ ...             ‚îÇ
‚îÇ users[999]:{..} ‚îÇ   \   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   \   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    \                        \
                        \                        \
–°–¢–ï–ö (—Å—Å—ã–ª–∫–∏):           \                        \
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       \                        \
‚îÇ main()          ‚îÇ        \                        \
‚îÇ users ‚Üí 0x1000 ‚îÄ‚îò         \                        \
‚îÇ scores ‚Üí 0x2500 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        \
‚îÇ db ‚Üí 0x4200 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò –ö–£–ß–ò:
‚úÖ –ì–∏–±–∫–∏–π —Ä–∞–∑–º–µ—Ä (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω–æ–π –ø–∞–º—è—Ç—å—é)
‚úÖ –î–∞–Ω–Ω—ã–µ –∂–∏–≤—É—Ç –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ñ—É–Ω–∫—Ü–∏–π
‚úÖ –ú–æ–∂–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª–∏
‚ùå –ú–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ/–æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ (–ø–æ–∏—Å–∫ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞)
‚ùå –§—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è –ø–∞–º—è—Ç–∏ (–¥—ã—Ä–∫–∏ –º–µ–∂–¥—É –æ–±—ä–µ–∫—Ç–∞–º–∏)
‚ùå –ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é (GC –∏–ª–∏ manual)
‚ùå –ü–ª–æ—Ö–∞—è cache locality (–¥–∞–Ω–Ω—ã–µ —Ä–∞–∑–±—Ä–æ—Å–∞–Ω—ã)
```

### üíª Go –ø—Ä–∏–º–µ—Ä—ã: –°—Ç–µ–∫ vs –ö—É—á–∞

```go
package main

import (
    "fmt"
    "runtime"
)

// ‚úÖ STACK ALLOCATION - –±—ã—Å—Ç—Ä–æ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
func stackExample() {
    // –í—Å–µ —ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–∞ —Å—Ç–µ–∫–µ
    var name string = "John"           // 16 –±–∞–π—Ç (string header)
    var age int = 25                   // 8 –±–∞–π—Ç
    var scores [5]int = [5]int{1,2,3,4,5} // 40 –±–∞–π—Ç (5 * 8)
    var valid bool = true              // 1 –±–∞–π—Ç
    
    fmt.Printf("Stack variables: %s, %d, %v, %t\n", name, age, scores, valid)
    // –ö–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è - –í–°–ï –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è—é—Ç—Å—è
}

// ‚ö†Ô∏è HEAP ALLOCATION - –º–µ–¥–ª–µ–Ω–Ω–µ–µ, –Ω–æ –≥–∏–±—á–µ
func heapExample() *[]User {
    // –≠—Ç–∏ –æ–±—ä–µ–∫—Ç—ã —Å–æ–∑–¥–∞—é—Ç—Å—è –≤ –∫—É—á–µ
    users := make([]User, 1000)        // –ë–æ–ª—å—à–æ–π slice ‚Üí –∫—É—á–∞
    userMap := make(map[string]int)    // Map –≤—Å–µ–≥–¥–∞ –≤ –∫—É—á–µ
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –¥–∞–Ω–Ω—ã–º–∏
    for i := 0; i < 1000; i++ {
        users[i] = User{
            ID:   i,
            Name: fmt.Sprintf("User_%d", i),
            Email: fmt.Sprintf("user%d@example.com", i),
        }
        userMap[users[i].Name] = i
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å - –¥–∞–Ω–Ω—ã–µ –æ—Å—Ç–∞—é—Ç—Å—è –≤ –∫—É—á–µ
    return &users // –≠–¢–û –ë–ï–ó–û–ü–ê–°–ù–û! –î–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ –∂–∏–≤—É—Ç –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏
}

type User struct {
    ID    int
    Name  string
    Email string
}

// üîç –ê–ù–ê–õ–ò–ó –ü–ê–ú–Ø–¢–ò
func memoryAnalysis() {
    var m1, m2 runtime.MemStats
    
    // –ò–∑–º–µ—Ä—è–µ–º –ø–∞–º—è—Ç—å –î–û —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
    runtime.ReadMemStats(&m1)
    
    // –°–æ–∑–¥–∞–µ–º –º–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –∫—É—á–µ
    var slices [][]int
    for i := 0; i < 1000; i++ {
        slice := make([]int, 1000) // –ö–∞–∂–¥—ã–π slice = 8KB
        slices = append(slices, slice)
    }
    
    // –ò–∑–º–µ—Ä—è–µ–º –ø–∞–º—è—Ç—å –ü–û–°–õ–ï
    runtime.ReadMemStats(&m2)
    
    fmt.Printf("–ü–∞–º—è—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: %d KB\n", (m2.Alloc-m1.Alloc)/1024)
    fmt.Printf("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ GC –∑–∞–ø—É—Å–∫–æ–≤: %d\n", m2.NumGC-m1.NumGC)
    
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Å—Å—ã–ª–∫–∏
    slices = nil
    runtime.GC() // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–±–æ—Ä—â–∏–∫–∞ –º—É—Å–æ—Ä–∞
    
    var m3 runtime.MemStats
    runtime.ReadMemStats(&m3)
    fmt.Printf("–ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ GC: %d KB\n", m3.Alloc/1024)
}
```

### üîÑ Memory Pools: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—ã—Å–æ–∫–æ–Ω–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ 100,000 HTTP –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É, –∫–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å —Å–æ–∑–¥–∞–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã (–±—É—Ñ–µ—Ä—ã, —Å—Ç—Ä—É–∫—Ç—É—Ä—ã). –≠—Ç–æ —Å–æ–∑–¥–∞–µ—Ç –æ–≥—Ä–æ–º–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É –Ω–∞ GC.

**–†–µ—à–µ–Ω–∏–µ**: –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —á–µ—Ä–µ–∑ –ø—É–ª—ã.

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
    "time"
)

// üèä‚Äç‚ôÇÔ∏è BUFFER POOL - –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–æ–≤
var bufferPool = sync.Pool{
    New: func() interface{} {
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –±—É—Ñ–µ—Ä —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –ø—É–ª –ø—É—Å—Ç
        return bytes.NewBuffer(make([]byte, 0, 4096)) // 4KB –±—É—Ñ–µ—Ä
    },
}

// ‚ùå –ë–ï–ó –ü–£–õ–ê - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –±—É—Ñ–µ—Ä –∫–∞–∂–¥—ã–π —Ä–∞–∑
func processRequestBad(data string) string {
    // –ö–∞–∂–¥—ã–π –≤—ã–∑–æ–≤ = –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –≤ –∫—É—á–µ
    buffer := bytes.NewBuffer(nil)
    buffer.WriteString("Processing: ")
    buffer.WriteString(data)
    buffer.WriteString(" - completed")
    return buffer.String()
}

// ‚úÖ –° –ü–£–õ–û–ú - –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –±—É—Ñ–µ—Ä—ã
func processRequestGood(data string) string {
    // –ü–æ–ª—É—á–∞–µ–º –±—É—Ñ–µ—Ä –∏–∑ –ø—É–ª–∞
    buffer := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buffer.Reset()        // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
        bufferPool.Put(buffer) // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –ø—É–ª
    }()
    
    buffer.WriteString("Processing: ")
    buffer.WriteString(data)
    buffer.WriteString(" - completed")
    return buffer.String()
}

// üìä –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func benchmarkPools() {
    const iterations = 100000
    
    // –¢–µ—Å—Ç –ë–ï–ó –ø—É–ª–∞
    start := time.Now()
    for i := 0; i < iterations; i++ {
        result := processRequestBad(fmt.Sprintf("request_%d", i))
        _ = result
    }
    withoutPool := time.Since(start)
    
    // –¢–µ—Å—Ç –° –ø—É–ª–æ–º
    start = time.Now()
    for i := 0; i < iterations; i++ {
        result := processRequestGood(fmt.Sprintf("request_%d", i))
        _ = result
    }
    withPool := time.Since(start)
    
    fmt.Printf("–ë–µ–∑ –ø—É–ª–∞: %v\n", withoutPool)
    fmt.Printf("–° –ø—É–ª–æ–º:  %v\n", withPool)
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: %.2fx\n", float64(withoutPool)/float64(withPool))
}

// üè≠ OBJECT POOL - –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
type ExpensiveObject struct {
    Data    []byte
    Connections []net.Conn
    Cache   map[string]interface{}
}

var objectPool = sync.Pool{
    New: func() interface{} {
        return &ExpensiveObject{
            Data:    make([]byte, 10240), // 10KB –±—É—Ñ–µ—Ä
            Cache:   make(map[string]interface{}),
        }
    },
}

func useExpensiveObject() {
    obj := objectPool.Get().(*ExpensiveObject)
    defer func() {
        // –û—á–∏—â–∞–µ–º –æ–±—ä–µ–∫—Ç –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º –≤ –ø—É–ª
        obj.Data = obj.Data[:0]
        for k := range obj.Cache {
            delete(obj.Cache, k)
        }
        objectPool.Put(obj)
    }()
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ä–µ–∫—Ç...
    obj.Data = append(obj.Data, []byte("some data")...)
    obj.Cache["key"] = "value"
}
```

### üß© Memory Fragmentation: –ü—Ä–æ–±–ª–µ–º–∞ –∏ —Ä–µ—à–µ–Ω–∏—è

```
–§–†–ê–ì–ú–ï–ù–¢–ê–¶–ò–Ø –ü–ê–ú–Ø–¢–ò - –∫–∞–∫ –±–µ—Å–ø–æ—Ä—è–¥–æ–∫ –≤ –≥–∞—Ä–∞–∂–µ:

–ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï - –≤—Å–µ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ A  ‚îÇ B  ‚îÇ C  ‚îÇ D  ‚îÇ E  ‚îÇ F  ‚îÇ G  ‚îÇ H  ‚îÇ  ‚Üê –û–±—ä–µ–∫—Ç—ã —Ä–∞–∑–º–µ—Ä–æ–º 1KB –∫–∞–∂–¥—ã–π
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 1KB  2KB  3KB  4KB  5KB  6KB  7KB  8KB

–ü–û–°–õ–ï –£–î–ê–õ–ï–ù–ò–Ø –ù–ï–ö–û–¢–û–†–´–• –û–ë–™–ï–ö–¢–û–í:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ A  ‚îÇFREE‚îÇ C  ‚îÇFREE‚îÇ E  ‚îÇFREE‚îÇ G  ‚îÇ H  ‚îÇ  ‚Üê –î—ã—Ä—ã –≤ –ø–∞–º—è—Ç–∏!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ü–†–û–ë–õ–ï–ú–ê: –•–æ—Ç–∏–º –≤—ã–¥–µ–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç 3KB
‚ùå –°—É–º–º–∞—Ä–Ω–æ —Å–≤–æ–±–æ–¥–Ω–æ: 3KB (1KB + 1KB + 1KB)
‚ùå –ù–æ –Ω–µ—Ç –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞ 3KB!
‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç: "Out of memory" –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ —Å–≤–æ–±–æ–¥–Ω–æ–π –ø–∞–º—è—Ç–∏

–í–ù–£–¢–†–ï–ù–ù–Ø–Ø –§–†–ê–ì–ú–ï–ù–¢–ê–¶–ò–Ø:
–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º: 10 –±–∞–π—Ç
–ü–æ–ª—É—á–∞–µ–º: 16 –±–∞–π—Ç (–∏–∑-–∑–∞ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è)
–ü–æ—Ç–µ—Ä–∏: 6 –±–∞–π—Ç –Ω–∞ –∫–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç

–í–ù–ï–®–ù–Ø–Ø –§–†–ê–ì–ú–ï–ù–¢–ê–¶–ò–Ø:  
–ú–Ω–æ–≥–æ –º–∞–ª–µ–Ω—å–∫–∏—Ö —Å–≤–æ–±–æ–¥–Ω—ã—Ö –±–ª–æ–∫–æ–≤
–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã–¥–µ–ª–∏—Ç—å –±–æ–ª—å—à–æ–π –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –±–ª–æ–∫
```

**–†–µ—à–µ–Ω–∏—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤ Go:**

```go
// üéØ SLAB ALLOCATOR - –æ–±—ä–µ–∫—Ç—ã —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
type SlabAllocator struct {
    blockSize int
    freeList  [][]byte
    mutex     sync.Mutex
}

func NewSlabAllocator(blockSize int, initialBlocks int) *SlabAllocator {
    slab := &SlabAllocator{
        blockSize: blockSize,
        freeList:  make([][]byte, 0, initialBlocks),
    }
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
func (s *Stack) String() string {
    if len(s.items) == 0 {
        return "Stack: []"
    }
    
    result := "Stack: ["
    for i := len(s.items) - 1; i >= 0; i-- { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
        result += fmt.Sprintf("%d", s.items[i])
        if i > 0 {
            result += ", "
        }
    }
    result += "] (top ‚Üí bottom)"
    return result
}

// üßÆ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ô –ü–†–ò–ú–ï–†: –ö–ê–õ–¨–ö–£–õ–Ø–¢–û–† –° –ü–û–õ–¨–°–ö–û–ô –ó–ê–ü–ò–°–¨–Æ
func rpnCalculator(expression []string) (int, error) {
    stack := NewStack()
    
    for _, token := range expression {
        switch token {
        case "+":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–ø–µ—Ä–∞–Ω–¥–æ–≤")
            }
            stack.Push(a + b)
            
        case "-":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–ø–µ—Ä–∞–Ω–¥–æ–≤")
            }
            stack.Push(a - b)
            
        case "*":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–ø–µ—Ä–∞–Ω–¥–æ–≤")
            }
            stack.Push(a * b)
            
        default:
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ
            var num int
            _, err := fmt.Sscanf(token, "%d", &num)
            if err != nil {
                return 0, fmt.Errorf("–Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–∫–µ–Ω: %s", token)
            }
            stack.Push(num)
        }
    }
    
    if stack.Size() != 1 {
        return 0, errors.New("–Ω–µ–≤–µ—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ")
    }
    
    return stack.Pop()
}

// üîç –ü–†–û–í–ï–†–ö–ê –°–ë–ê–õ–ê–ù–°–ò–†–û–í–ê–ù–ù–û–°–¢–ò –°–ö–û–ë–û–ö
func isBalanced(s string) bool {
    stack := NewStack()
    
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    
    for _, char := range s {
        switch char {
        case '(', '[', '{':
            stack.Push(int(char))
        case ')', ']', '}':
            if stack.IsEmpty() {
                return false
            }
            
            top, _ := stack.Pop()
            expected := pairs[char]
            if rune(top) != expected {
                return false
            }
        }
    }
    
    return stack.IsEmpty()
}

// üíª –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –û–ß–ï–†–ï–î–ò –í GO
type Queue struct {
    items []int
    front int
    rear  int
    size  int
}

func NewQueue(capacity int) *Queue {
    return &Queue{
        items: make([]int, capacity),
        front: 0,
        rear:  0,
        size:  0,
    }
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ (Enqueue)
func (q *Queue) Enqueue(item int) error {
    if q.size >= len(q.items) {
        return errors.New("queue is full")
    }
    
    q.items[q.rear] = item
    q.rear = (q.rear + 1) % len(q.items) // –ö–æ–ª—å—Ü–µ–≤–æ–π –±—É—Ñ–µ—Ä
    q.size++
    return nil
}

// –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ (Dequeue)
func (q *Queue) Dequeue() (int, error) {
    if q.size == 0 {
        return 0, errors.New("queue is empty")
    }
    
    item := q.items[q.front]
    q.front = (q.front + 1) % len(q.items) // –ö–æ–ª—å—Ü–µ–≤–æ–π –±—É—Ñ–µ—Ä
    q.size--
    return item, nil
}

// –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–µ—Ä–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
func (q *Queue) Peek() (int, error) {
    if q.size == 0 {
        return 0, errors.New("queue is empty")
    }
    
    return q.items[q.front], nil
}

func (q *Queue) IsEmpty() bool {
    return q.size == 0
}

func (q *Queue) IsFull() bool {
    return q.size >= len(q.items)
}

func (q *Queue) Size() int {
    return q.size
}

// üîÑ –ö–û–õ–¨–¶–ï–í–û–ô –ë–£–§–ï–† - –≠–§–§–ï–ö–¢–ò–í–ù–ê–Ø –û–ß–ï–†–ï–î–¨
func circularBufferDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–ª—å—Ü–µ–≤–æ–≥–æ –±—É—Ñ–µ—Ä–∞ ===")
    
    queue := NewQueue(5) // –û—á–µ—Ä–µ–¥—å –Ω–∞ 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—á–µ—Ä–µ–¥—å
    for i := 1; i <= 5; i++ {
        queue.Enqueue(i * 10)
        fmt.Printf("Enqueue %d: %s\n", i*10, queueState(queue))
    }
    
    // –ü—ã—Ç–∞–µ–º—Å—è –¥–æ–±–∞–≤–∏—Ç—å –≤ –ø–æ–ª–Ω—É—é –æ—á–µ—Ä–µ–¥—å
    err := queue.Enqueue(60)
    fmt.Printf("–ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å 60: %v\n", err)
    
    // –£–¥–∞–ª—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    for i := 0; i < 3; i++ {
        item, _ := queue.Dequeue()
        fmt.Printf("Dequeue %d: %s\n", item, queueState(queue))
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã (–∫–æ–ª—å—Ü–µ–≤–æ–µ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ)
    queue.Enqueue(60)
    queue.Enqueue(70)
    fmt.Printf("–ü–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è 60, 70: %s\n", queueState(queue))
}

func queueState(q *Queue) string {
    return fmt.Sprintf("front=%d, rear=%d, size=%d", q.front, q.rear, q.size)
}

// üè≠ –ü–†–ò–û–†–ò–¢–ï–¢–ù–ê–Ø –û–ß–ï–†–ï–î–¨ (–ü–†–û–°–¢–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)
type PriorityItem struct {
    Value    string
    Priority int
}

type PriorityQueue struct {
    items []PriorityItem
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{items: make([]PriorityItem, 0)}
}

func (pq *PriorityQueue) Enqueue(value string, priority int) {
    item := PriorityItem{Value: value, Priority: priority}
    
    // –ò—â–µ–º –º–µ—Å—Ç–æ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ (–ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)
    inserted := false
    for i, existing := range pq.items {
        if priority > existing.Priority { // –ë–æ–ª—å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç = –≤–∞–∂–Ω–µ–µ
            // –í—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–∑–∏—Ü–∏—é i
            pq.items = append(pq.items[:i], append([]PriorityItem{item}, pq.items[i:]...)...)
            inserted = true
            break
        }
    }
    
    if !inserted {
        pq.items = append(pq.items, item)
    }
}

func (pq *PriorityQueue) Dequeue() (PriorityItem, error) {
    if len(pq.items) == 0 {
        return PriorityItem{}, errors.New("priority queue is empty")
    }
    
    item := pq.items[0]
    pq.items = pq.items[1:]
    return item, nil
}

// üì± –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø

// 1. TASK SCHEDULER —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
type Task struct {
    ID          int
    Name        string
    Priority    int
    ExecuteTime time.Duration
}

func taskSchedulerDemo() {
    fmt.Println("=== Task Scheduler —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–π –æ—á–µ—Ä–µ–¥—å—é ===")
    
    scheduler := NewPriorityQueue()
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏
    tasks := []Task{
        {1, "Backup Database", 1, 100 * time.Millisecond},
        {2, "Send Email", 5, 10 * time.Millisecond},
        {3, "Generate Report", 3, 50 * time.Millisecond},
        {4, "Critical Bug Fix", 10, 200 * time.Millisecond},
        {5, "Log Cleanup", 1, 20 * time.Millisecond},
    }
    
    for _, task := range tasks {
        scheduler.Enqueue(fmt.Sprintf("[%s] (ID:%d)", task.Name, task.ID), task.Priority)
        fmt.Printf("–î–æ–±–∞–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞: %s (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: %d)\n", task.Name, task.Priority)
    }
    
    fmt.Println("\n–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É:")
    for !scheduler.IsEmpty() {
        item, err := scheduler.Dequeue()
        if err != nil {
            break
        }
        fmt.Printf("–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è: %s\n", item.Value)
    }
}

func (pq *PriorityQueue) IsEmpty() bool {
    return len(pq.items) == 0
}

// 2. BREADTH-FIRST SEARCH (BFS) —Å –æ—á–µ—Ä–µ–¥—å—é
type Graph struct {
    vertices map[int][]int
}

func NewGraph() *Graph {
    return &Graph{vertices: make(map[int][]int)}
}

func (g *Graph) AddEdge(from, to int) {
    g.vertices[from] = append(g.vertices[from], to)
    g.vertices[to] = append(g.vertices[to], from) // –ù–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
}

func (g *Graph) BFS(start int) []int {
    visited := make(map[int]bool)
    queue := NewQueue(100) // –ë–æ–ª—å—à–∞—è –æ—á–µ—Ä–µ–¥—å –¥–ª—è BFS
    result := make([]int, 0)
    
    queue.Enqueue(start)
    visited[start] = true
    
    for !queue.IsEmpty() {
        current, _ := queue.Dequeue()
        result = append(result, current)
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ—Ö –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö —Å–æ—Å–µ–¥–µ–π
        for _, neighbor := range g.vertices[current] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue.Enqueue(neighbor)
            }
        }
    }
    
    return result
}

// 3. UNDO/REDO —Å–∏—Å—Ç–µ–º–∞ —Å –¥–≤—É–º—è —Å—Ç–µ–∫–∞–º–∏
type UndoRedoSystem struct {
    undoStack *Stack
    redoStack *Stack
    current   string
}

func NewUndoRedoSystem() *UndoRedoSystem {
    return &UndoRedoSystem{
        undoStack: NewStack(),
        redoStack: NewStack(),
        current:   "",
    }
}

func (ur *UndoRedoSystem) ExecuteCommand(newState string) {
    if ur.current != "" {
        ur.undoStack.Push(ur.current) // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    }
    ur.current = newState
    
    // –û—á–∏—â–∞–µ–º redo stack (–Ω–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Ç–º–µ–Ω—è–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å redo)
    ur.redoStack = NewStack()
}

func (ur *UndoRedoSystem) Undo() string {
    if ur.undoStack.IsEmpty() {
        return ur.current
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ redo stack
    ur.redoStack.Push(ur.current)
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    previous, _ := ur.undoStack.Pop()
    ur.current = previous
    return ur.current
}

func (ur *UndoRedoSystem) Redo() string {
    if ur.redoStack.IsEmpty() {
        return ur.current
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ undo stack
    ur.undoStack.Push(ur.current)
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    next, _ := ur.redoStack.Pop()
    ur.current = next
    return ur.current
}

// üìä –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–ò –ò –¢–ï–°–¢–´
func stackQueueDemos() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Å—Ç–µ–∫–æ–≤ –∏ –æ—á–µ—Ä–µ–¥–µ–π ===")
    
    // 1. –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø–æ–ª—å—Å–∫–æ–π –∑–∞–ø–∏—Å–∏
    fmt.Println("\nüßÆ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä (–ø–æ–ª—å—Å–∫–∞—è –∑–∞–ø–∏—Å—å):")
    expressions := [][]string{
        {"3", "4", "+", "2", "*"},      // (3 + 4) * 2 = 14
        {"15", "7", "1", "1", "+", "-", "/", "3", "*", "2", "1", "1", "+", "+", "-"}, // –°–ª–æ–∂–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    }
    
    for _, expr := range expressions {
        result, err := rpnCalculator(expr)
        if err != nil {
            fmt.Printf("–í—ã—Ä–∞–∂–µ–Ω–∏–µ %v: –û–®–ò–ë–ö–ê - %v\n", expr, err)
        } else {
            fmt.Printf("–í—ã—Ä–∞–∂–µ–Ω–∏–µ %v = %d\n", expr, result)
        }
    }
    
    // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ–±–æ–∫
    fmt.Println("\nüîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ —Å–∫–æ–±–æ–∫:")
    testStrings := []string{
        "(())",
        "((()))",
        "()())",
        "{[()]}",
        "{[()]})",
        "(((",
    }
    
    for _, test := range testStrings {
        balanced := isBalanced(test)
        fmt.Printf("'%s': %v\n", test, balanced)
    }
    
    // 3. –ö–æ–ª—å—Ü–µ–≤–æ–π –±—É—Ñ–µ—Ä
    circularBufferDemo()
    
    // 4. Task Scheduler
    taskSchedulerDemo()
    
    // 5. BFS –æ–±—Ö–æ–¥ –≥—Ä–∞—Ñ–∞
    fmt.Println("\nüï∏Ô∏è BFS –æ–±—Ö–æ–¥ –≥—Ä–∞—Ñ–∞:")
    graph := NewGraph()
    
    // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –≥—Ä–∞—Ñ
    //   1 --- 2
    //   |     |
    //   3 --- 4 --- 5
    graph.AddEdge(1, 2)
    graph.AddEdge(1, 3)
    graph.AddEdge(2, 4)
    graph.AddEdge(3, 4)
    graph.AddEdge(4, 5)
    
    bfsResult := graph.BFS(1)
    fmt.Printf("BFS –æ–±—Ö–æ–¥ –Ω–∞—á–∏–Ω–∞—è —Å —É–∑–ª–∞ 1: %v\n", bfsResult)
    
    // 6. Undo/Redo —Å–∏—Å—Ç–µ–º–∞
    fmt.Println("\n‚Ü©Ô∏è Undo/Redo —Å–∏—Å—Ç–µ–º–∞:")
    editor := NewUndoRedoSystem()
    
    editor.ExecuteCommand("–ü–µ—á–∞—Ç–∞—é 'Hello'")
    fmt.Printf("–ü–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã: %s\n", editor.current)
    
    editor.ExecuteCommand("–ü–µ—á–∞—Ç–∞—é ' World'")
    fmt.Printf("–ü–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã: %s\n", editor.current)
    
    editor.ExecuteCommand("–£–¥–∞–ª—è—é –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–ª–æ–≤–æ")
    fmt.Printf("–ü–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã: %s\n", editor.current)
    
    fmt.Printf("Undo: %s\n", editor.Undo())
    fmt.Printf("Undo: %s\n", editor.Undo())
    fmt.Printf("Redo: %s\n", editor.Redo())
}

// üéØ –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func stackQueuePerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ===")
    
    const operations = 1000000
    
    // –¢–µ—Å—Ç —Å—Ç–µ–∫–∞
    stack := NewStack()
    start := time.Now()
    for i := 0; i < operations; i++ {
        stack.Push(i)
    }
    for i := 0; i < operations; i++ {
        stack.Pop()
    }
    stackTime := time.Since(start)
    
    // –¢–µ—Å—Ç –æ—á–µ—Ä–µ–¥–∏
    queue := NewQueue(operations)
    start = time.Now()
    for i := 0; i < operations; i++ {
        queue.Enqueue(i)
    }
    for i := 0; i < operations; i++ {
        queue.Dequeue()
    }
    queueTime := time.Since(start)
    
    fmt.Printf("–°—Ç–µ–∫ (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations*2, stackTime)
    fmt.Printf("–û—á–µ—Ä–µ–¥—å (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations*2, queueTime)
    
    fmt.Println("\n‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –û–ø–µ—Ä–∞—Ü–∏—è        ‚îÇ –°—Ç–µ–∫    ‚îÇ –û—á–µ—Ä–µ–¥—å ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ Push/Enqueue    ‚îÇ O(1)    ‚îÇ O(1)    ‚îÇ")
    fmt.Println("‚îÇ Pop/Dequeue     ‚îÇ O(1)    ‚îÇ O(1)    ‚îÇ")
    fmt.Println("‚îÇ Peek/Front      ‚îÇ O(1)    ‚îÇ O(1)    ‚îÇ")
    fmt.Println("‚îÇ –ü–æ–∏—Å–∫           ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îÇ –ü–∞–º—è—Ç—å          ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
}

---

## –ú–æ–¥—É–ª—å 6: –î–µ—Ä–µ–≤—å—è - –ò–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

### üå≥ –ê–Ω–∞—Ç–æ–º–∏—è –¥–µ—Ä–µ–≤–∞

```
–¢–ï–†–ú–ò–ù–û–õ–û–ì–ò–Ø –î–ï–†–ï–í–¨–ï–í:

                    8 ‚Üê ROOT (–∫–æ—Ä–µ–Ω—å)
                   / \
                  3   10 ‚Üê INTERNAL NODES (–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —É–∑–ª—ã)  
                 / \    \
                1   6    14
               /   / \   /
              0   4   7 13 ‚Üê LEAF NODES (–ª–∏—Å—Ç—å—è)

–û–°–ù–û–í–ù–´–ï –ü–û–ù–Ø–¢–ò–Ø:
‚Ä¢ ROOT: —É–∑–µ–ª –±–µ–∑ —Ä–æ–¥–∏—Ç–µ–ª—è (8)
‚Ä¢ LEAF: —É–∑–µ–ª –±–µ–∑ –¥–µ—Ç–µ–π (0, 4, 7, 13)  
‚Ä¢ HEIGHT: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–æ—Ä–Ω—è –¥–æ –ª–∏—Å—Ç–∞ (3)
‚Ä¢ DEPTH: —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–æ—Ä–Ω—è –¥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —É–∑–ª–∞
‚Ä¢ SUBTREE: –ø–æ–¥–¥–µ—Ä–µ–≤–æ —Å –∫–æ—Ä–Ω–µ–º –≤ –ª—é–±–æ–º —É–∑–ª–µ

–ü–£–¢–¨ –û–¢ –ö–û–†–ù–Ø –î–û –õ–ò–°–¢–ê:
8 ‚Üí 3 ‚Üí 1 ‚Üí 0 (–≥–ª—É–±–∏–Ω–∞ —É–∑–ª–∞ 0 = 3)

–†–ê–ó–ú–ï–†–´ –ü–û–î–î–ï–†–ï–í–¨–ï–í:
‚Ä¢ –õ–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ –∫–æ—Ä–Ω—è: {3, 1, 6, 0, 4, 7}
‚Ä¢ –ü—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ –∫–æ—Ä–Ω—è: {10, 14, 13}
```

### üîç –ë–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞ (BST)

```
–ò–ù–í–ê–†–ò–ê–ù–¢ BST: –î–ª—è –ª—é–±–æ–≥–æ —É–∑–ª–∞ N
‚Ä¢ –í—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ª–µ–≤–æ–º –ø–æ–¥–¥–µ—Ä–µ–≤–µ ‚â§ N
‚Ä¢ –í—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø—Ä–∞–≤–æ–º –ø–æ–¥–¥–µ—Ä–µ–≤–µ ‚â• N

–ü–û–ò–°–ö –≠–õ–ï–ú–ï–ù–¢–ê 6:
        8
       / \
      3   10     –ò—â–µ–º 6:
     / \    \    1. 6 < 8, –∏–¥–µ–º –≤–ª–µ–≤–æ  
    1   6    14  2. 6 > 3, –∏–¥–µ–º –≤–ø—Ä–∞–≤–æ
       / \   /   3. 6 = 6, –ù–ê–ô–î–ï–ù!
      4   7 13   
      
–®–∞–≥–æ–≤: 3 (–≤–º–µ—Å—Ç–æ 8 –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞)
–°–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n) –¥–ª—è —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞

–í–°–¢–ê–í–ö–ê –≠–õ–ï–ú–ï–ù–¢–ê 5:
        8
       / \
      3   10     –í—Å—Ç–∞–≤–ª—è–µ–º 5:
     / \    \    1. 5 < 8, –∏–¥–µ–º –≤–ª–µ–≤–æ
    1   6    14  2. 5 > 3, –∏–¥–µ–º –≤–ø—Ä–∞–≤–æ  
       / \   /   3. 5 < 6, –∏–¥–µ–º –≤–ª–µ–≤–æ
      4   7 13   4. –°–ª–µ–≤–∞ –æ—Ç 4 –ø—É—Å—Ç–æ
     /           5. –î–æ–±–∞–≤–ª—è–µ–º 5 –∫–∞–∫ –ª–µ–≤–æ–≥–æ —Ä–µ–±–µ–Ω–∫–∞ 4
    5

–£–î–ê–õ–ï–ù–ò–ï - 3 –°–õ–£–ß–ê–Ø:

1) –£–î–ê–õ–ï–ù–ò–ï –õ–ò–°–¢–ê (—É–∑–µ–ª 5):
   –ü—Ä–æ—Å—Ç–æ —É–¥–∞–ª—è–µ–º —É–∑–µ–ª ‚úÖ

2) –£–î–ê–õ–ï–ù–ò–ï –£–ó–õ–ê –° –û–î–ù–ò–ú –†–ï–ë–ï–ù–ö–û–ú (—É–∑–µ–ª 1):
   –ó–∞–º–µ–Ω—è–µ–º —É–∑–µ–ª –µ–≥–æ —Ä–µ–±–µ–Ω–∫–æ–º ‚úÖ

3) –£–î–ê–õ–ï–ù–ò–ï –£–ó–õ–ê –° –î–í–£–ú–Ø –î–ï–¢–¨–ú–ò (—É–∑–µ–ª 3):
   –ù–∞—Ö–æ–¥–∏–º INORDER SUCCESSOR (—Å–ª–µ–¥—É—é—â–∏–π –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ)
   –ó–∞–º–µ–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ, —É–¥–∞–ª—è–µ–º successor ü§î
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è BST –≤ Go

```go
package main

import (
    "fmt"
    "math"
)

// üå≥ –£–ó–ï–õ –ë–ò–ù–ê–†–ù–û–ì–û –î–ï–†–ï–í–ê –ü–û–ò–°–ö–ê
type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// BST —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
type BST struct {
    Root *TreeNode
    Size int
}

func NewBST() *BST {
    return &BST{Root: nil, Size: 0}
}

// üîç –ü–û–ò–°–ö –≠–õ–ï–ú–ï–ù–¢–ê
func (bst *BST) Search(value int) bool {
    return searchNode(bst.Root, value)
}

func searchNode(node *TreeNode, value int) bool {
    if node == nil {
        return false // –ù–µ –Ω–∞–π–¥–µ–Ω
    }
    
    if value == node.Value {
        return true // –ù–∞–π–¥–µ–Ω!
    } else if value < node.Value {
        return searchNode(node.Left, value) // –ò—â–µ–º —Å–ª–µ–≤–∞
    } else {
        return searchNode(node.Right, value) // –ò—â–µ–º —Å–ø—Ä–∞–≤–∞
    }
}

// ‚ûï –í–°–¢–ê–í–ö–ê –≠–õ–ï–ú–ï–ù–¢–ê
func (bst *BST) Insert(value int) {
    bst.Root = insertNode(bst.Root, value)
    bst.Size++
}

func insertNode(node *TreeNode, value int) *TreeNode {
    if node == nil {
        return &TreeNode{Value: value} // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —É–∑–µ–ª
    }
    
    if value < node.Value {
        node.Left = insertNode(node.Left, value)
    } else if value > node.Value {
        node.Right = insertNode(node.Right, value)
    }
    // –ï—Å–ª–∏ value == node.Value, –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç
    
    return node
}

// ‚ûñ –£–î–ê–õ–ï–ù–ò–ï –≠–õ–ï–ú–ï–ù–¢–ê
func (bst *BST) Delete(value int) {
    bst.Root = deleteNode(bst.Root, value)
    bst.Size--
}

func deleteNode(node *TreeNode, value int) *TreeNode {
    if node == nil {
        return nil // –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
    }
    
    if value < node.Value {
        node.Left = deleteNode(node.Left, value)
    } else if value > node.Value {
        node.Right = deleteNode(node.Right, value)
    } else {
        // –ù–∞—à–ª–∏ —É–∑–µ–ª –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
        
        // –°–ª—É—á–∞–π 1: —É–∑–µ–ª –±–µ–∑ –¥–µ—Ç–µ–π (–ª–∏—Å—Ç)
        if node.Left == nil && node.Right == nil {
            return nil
        }
        
        // –°–ª—É—á–∞–π 2: —É–∑–µ–ª —Å –æ–¥–Ω–∏–º —Ä–µ–±–µ–Ω–∫–æ–º
        if node.Left == nil {
            return node.Right
        }
        if node.Right == nil {
            return node.Left
        }
        
        // –°–ª—É—á–∞–π 3: —É–∑–µ–ª —Å –¥–≤—É–º—è –¥–µ—Ç—å–º–∏
        // –ù–∞—Ö–æ–¥–∏–º inorder successor (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤ –ø—Ä–∞–≤–æ–º –ø–æ–¥–¥–µ—Ä–µ–≤–µ)
        successor := findMin(node.Right)
        node.Value = successor.Value
        node.Right = deleteNode(node.Right, successor.Value)
    }
    
    return node
}

func findMin(node *TreeNode) *TreeNode {
    for node.Left != nil {
        node = node.Left
    }
    return node
}

// üö∂‚Äç‚ôÇÔ∏è –û–ë–•–û–î–´ –î–ï–†–ï–í–ê
func (bst *BST) InorderTraversal() []int {
    result := make([]int, 0)
    inorderTraverse(bst.Root, &result)
    return result
}

func inorderTraverse(node *TreeNode, result *[]int) {
    if node != nil {
        inorderTraverse(node.Left, result)   // –õ–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
        *result = append(*result, node.Value) // –¢–µ–∫—É—â–∏–π —É–∑–µ–ª
        inorderTraverse(node.Right, result)  // –ü—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
    }
}

func (bst *BST) PreorderTraversal() []int {
    result := make([]int, 0)
    preorderTraverse(bst.Root, &result)
    return result
}

func preorderTraverse(node *TreeNode, result *[]int) {
    if node != nil {
        *result = append(*result, node.Value) // –¢–µ–∫—É—â–∏–π —É–∑–µ–ª
        preorderTraverse(node.Left, result)   // –õ–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
        preorderTraverse(node.Right, result)  // –ü—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
    }
}

func (bst *BST) PostorderTraversal() []int {
    result := make([]int, 0)
    postorderTraverse(bst.Root, &result)
    return result
}

func postorderTraverse(node *TreeNode, result *[]int) {
    if node != nil {
        postorderTraverse(node.Left, result)  // –õ–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
        postorderTraverse(node.Right, result) // –ü—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
        *result = append(*result, node.Value) // –¢–µ–∫—É—â–∏–π —É–∑–µ–ª
    }
}

// üìè –°–í–û–ô–°–¢–í–ê –î–ï–†–ï–í–ê
func (bst *BST) Height() int {
    return calculateHeight(bst.Root)
}

func calculateHeight(node *TreeNode) int {
    if node == nil {
        return -1 // –í—ã—Å–æ—Ç–∞ –ø—É—Å—Ç–æ–≥–æ –¥–µ—Ä–µ–≤–∞ = -1
    }
    
    leftHeight := calculateHeight(node.Left)
    rightHeight := calculateHeight(node.Right)
    
    return 1 + max(leftHeight, rightHeight)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// üéØ –ü–†–û–í–ï–†–ö–ê –ù–ê –°–ë–ê–õ–ê–ù–°–ò–†–û–í–ê–ù–ù–û–°–¢–¨
func (bst *BST) IsBalanced() bool {
    _, balanced := checkBalance(bst.Root)
    return balanced
}

func checkBalance(node *TreeNode) (int, bool) {
    if node == nil {
        return 0, true
    }
    
    leftHeight, leftBalanced := checkBalance(node.Left)
    if !leftBalanced {
        return 0, false
    }
    
    rightHeight, rightBalanced := checkBalance(node.Right)
    if !rightBalanced {
        return 0, false
    }
    
    // –î–µ—Ä–µ–≤–æ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ, –µ—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å –≤—ã—Å–æ—Ç ‚â§ 1
    if abs(leftHeight-rightHeight) > 1 {
        return 0, false
    }
    
    return 1 + max(leftHeight, rightHeight), true
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

// üîç –ü–û–ò–°–ö –ú–ò–ù–ò–ú–£–ú–ê –ò –ú–ê–ö–°–ò–ú–£–ú–ê
func (bst *BST) FindMin() (int, bool) {
    if bst.Root == nil {
        return 0, false
    }
    
    node := bst.Root
    for node.Left != nil {
        node = node.Left
    }
    return node.Value, true
}

func (bst *BST) FindMax() (int, bool) {
    if bst.Root == nil {
        return 0, false
    }
    
    node := bst.Root
    for node.Right != nil {
        node = node.Right
    }
    return node.Value, true
}

// üìä –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –î–ï–†–ï–í–ê (–ø—Ä–æ—Å—Ç–∞—è)
func (bst *BST) PrintTree() {
    fmt.Println("–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–µ—Ä–µ–≤–∞:")
    printTreeHelper(bst.Root, "", true)
}

func printTreeHelper(node *TreeNode, indent string, isLast bool) {
    if node == nil {
        return
    }
    
    fmt.Print(indent)
    if isLast {
        fmt.Print("‚îî‚îÄ‚îÄ ")
        indent += "    "
    } else {
        fmt.Print("‚îú‚îÄ‚îÄ ")
        indent += "‚îÇ   "
    }
    fmt.Println(node.Value)
    
    if node.Left != nil || node.Right != nil {
        if node.Right != nil {
            printTreeHelper(node.Right, indent, node.Left == nil)
        }
        if node.Left != nil {
            printTreeHelper(node.Left, indent, true)
        }
    }
}

// üé™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø BST
func bstDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Binary Search Tree ===")
    
    bst := NewBST()
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
    values := []int{50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45}
    fmt.Printf("–í—Å—Ç–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã: %v\n", values)
    
    for _, val := range values {
        bst.Insert(val)
    }
    
    fmt.Printf("–†–∞–∑–º–µ—Ä –¥–µ—Ä–µ–≤–∞: %d\n", bst.Size)
    fmt.Printf("–í—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞: %d\n", bst.Height())
    fmt.Printf("–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ: %t\n", bst.IsBalanced())
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
    bst.PrintTree()
    
    // –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ö–æ–¥—ã
    fmt.Printf("\nInorder –æ–±—Ö–æ–¥ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π): %v\n", bst.InorderTraversal())
    fmt.Printf("Preorder –æ–±—Ö–æ–¥: %v\n", bst.PreorderTraversal())
    fmt.Printf("Postorder –æ–±—Ö–æ–¥: %v\n", bst.PostorderTraversal())
    
    // –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    fmt.Println("\nüîç –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤:")
    testValues := []int{25, 55, 80, 100}
    for _, val := range testValues {
        found := bst.Search(val)
        fmt.Printf("–ò—â–µ–º %d: %t\n", val, found)
    }
    
    // –ú–∏–Ω–∏–º—É–º –∏ –º–∞–∫—Å–∏–º—É–º
    min, _ := bst.FindMin()
    max, _ := bst.FindMax()
    fmt.Printf("\n–ú–∏–Ω–∏–º—É–º: %d, –ú–∞–∫—Å–∏–º—É–º: %d\n", min, max)
    
    // –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    fmt.Println("\n‚ûñ –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤:")
    deleteValues := []int{10, 30, 50} // –õ–∏—Å—Ç, —É–∑–µ–ª —Å –æ–¥–Ω–∏–º —Ä–µ–±–µ–Ω–∫–æ–º, —É–∑–µ–ª —Å –¥–≤—É–º—è –¥–µ—Ç—å–º–∏
    
    for _, val := range deleteValues {
        fmt.Printf("–£–¥–∞–ª—è–µ–º %d\n", val)
        bst.Delete(val)
        fmt.Printf("Inorder –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è: %v\n", bst.InorderTraversal())
    }
}

// ‚öñÔ∏è –ü–†–û–ë–õ–ï–ú–ê –ù–ï–°–ë–ê–õ–ê–ù–°–ò–†–û–í–ê–ù–ù–û–ì–û –î–ï–†–ï–í–ê
func balanceDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ ===")
    
    // –°–æ–∑–¥–∞–µ–º —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ
    balancedBST := NewBST()
    balancedValues := []int{50, 25, 75, 12, 37, 62, 87}
    for _, val := range balancedValues {
        balancedBST.Insert(val)
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ (–ø–æ —Å—É—Ç–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫)
    unbalancedBST := NewBST()
    for i := 1; i <= 7; i++ {
        unbalancedBST.Insert(i)
    }
    
    fmt.Printf("–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ:\n")
    fmt.Printf("  –í—ã—Å–æ—Ç–∞: %d\n", balancedBST.Height())
    fmt.Printf("  –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ: %t\n", balancedBST.IsBalanced())
    
    fmt.Printf("\n–ù–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –¥–µ—Ä–µ–≤–æ:\n")
    fmt.Printf("  –í—ã—Å–æ—Ç–∞: %d\n", unbalancedBST.Height())
    fmt.Printf("  –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ: %t\n", unbalancedBST.IsBalanced())
    
    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–∏—Å–∫–∞
    const searches = 10000
    
    start := time.Now()
    for i := 0; i < searches; i++ {
        balancedBST.Search(i % 7 + 1)
    }
    balancedTime := time.Since(start)
    
    start = time.Now()
    for i := 0; i < searches; i++ {
        unbalancedBST.Search(i % 7 + 1)
    }
    unbalancedTime := time.Since(start)
    
    fmt.Printf("\nüìä –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞ (%d –æ–ø–µ—Ä–∞—Ü–∏–π):\n", searches)
    fmt.Printf("–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ: %v\n", balancedTime)
    fmt.Printf("–ù–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ: %v\n", unbalancedTime)
    fmt.Printf("–†–∞–∑–Ω–∏—Ü–∞: %.2fx –º–µ–¥–ª–µ–Ω–Ω–µ–µ\n", float64(unbalancedTime)/float64(balancedTime))
    
    fmt.Println("\nüí° –í—ã–≤–æ–¥: –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–∞!")
    fmt.Println("   –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ BST: O(log n) –æ–ø–µ—Ä–∞—Ü–∏–∏")
    fmt.Println("   –ù–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ BST: O(n) –æ–ø–µ—Ä–∞—Ü–∏–∏ (–∫–∞–∫ —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫)")
}

// üå≤ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø BST
func bstApplications() {
    fmt.Println("=== –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è BST ===")
    
    // 1. –°–ª–æ–≤–∞—Ä—å —Å –±—ã—Å—Ç—Ä—ã–º –ø–æ–∏—Å–∫–æ–º
    fmt.Println("\nüìö 1. –°–ª–æ–≤–∞—Ä—å:")
    dictionary := NewBST()
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–∞ (–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞–º–∏ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã)
    words := []int{500, 300, 700, 200, 400, 600, 800} // hash codes —Å–ª–æ–≤
    for _, word := range words {
        dictionary.Insert(word)
    }
    
    fmt.Printf("–ü–æ–∏—Å–∫ —Å–ª–æ–≤–∞ (hash=400): %t\n", dictionary.Search(400))
    fmt.Printf("–í—Å–µ —Å–ª–æ–≤–∞ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É: %v\n", dictionary.InorderTraversal())
    
    // 2. –°–∏—Å—Ç–µ–º–∞ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤
    fmt.Println("\nüèÜ 2. –°–∏—Å—Ç–µ–º–∞ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤ –∏–≥—Ä–æ–∫–æ–≤:")
    ratings := NewBST()
    
    playerRatings := []int{1500, 1200, 1800, 1100, 1300, 1700, 1900}
    for _, rating := range playerRatings {
        ratings.Insert(rating)
    }
    
    // –ù–∞–π—Ç–∏ –∏–≥—Ä–æ–∫–æ–≤ —Å —Ä–µ–π—Ç–∏–Ω–≥–æ–º –≤—ã—à–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è
    allRatings := ratings.InorderTraversal()
    threshold := 1400
    fmt.Printf("–ò–≥—Ä–æ–∫–∏ —Å —Ä–µ–π—Ç–∏–Ω–≥–æ–º ‚â• %d: ", threshold)
    for _, rating := range allRatings {
        if rating >= threshold {
            fmt.Printf("%d ", rating)
        }
    }
    fmt.Println()
    
    // 3. –í—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã (—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ)
    fmt.Println("\n‚è∞ 3. –°–∏—Å—Ç–µ–º–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏:")
    // –í—Ä–µ–º—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –≤ –º–∏–Ω—É—Ç–∞—Ö –æ—Ç –Ω–∞—á–∞–ª–∞ –¥–Ω—è
    schedule := NewBST()
    
    // –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ª–æ—Ç—ã: 9:00, 10:30, 14:00, 16:15
    bookedSlots := []int{540, 630, 840, 975} // 9*60, 10.5*60, 14*60, 16.25*60
    for _, slot := range bookedSlots {
        schedule.Insert(slot)
    }
    
    fmt.Printf("–ó–∞–Ω—è—Ç—ã–µ —Å–ª–æ—Ç—ã: %v\n", schedule.InorderTraversal())
    fmt.Printf("–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ 12:00 (720 –º–∏–Ω): %t\n", !schedule.Search(720))
}
```

### üèÜ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö

```go
// üìä –°–†–ê–í–ù–ò–¢–ï–õ–¨–ù–ê–Ø –¢–ê–ë–õ–ò–¶–ê –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func performanceComparison() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ BST —Å –¥—Ä—É–≥–∏–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ ===")
    
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –û–ø–µ—Ä–∞—Ü–∏—è        ‚îÇ –ú–∞—Å—Å–∏–≤  ‚îÇ –°–ø–∏—Å–æ–∫  ‚îÇ BST     ‚îÇ Hash    ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –ü–æ–∏—Å–∫           ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ O(log n)‚îÇ O(1)*   ‚îÇ")
    fmt.Println("‚îÇ –í—Å—Ç–∞–≤–∫–∞         ‚îÇ O(n)    ‚îÇ O(1)**  ‚îÇ O(log n)‚îÇ O(1)*   ‚îÇ")
    fmt.Println("‚îÇ –£–¥–∞–ª–µ–Ω–∏–µ        ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ O(log n)‚îÇ O(1)*   ‚îÇ")
    fmt.Println("‚îÇ –ú–∏–Ω/–ú–∞–∫—Å        ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ O(log n)‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îÇ –û–±—Ö–æ–¥ —Å–æ—Ä—Ç–∏—Ä.   ‚îÇ O(n log n)‚îÇ O(n log n)‚îÇ O(n)  ‚îÇ O(n log n)‚îÇ")
    fmt.Println("‚îÇ Range –∑–∞–ø—Ä–æ—Å—ã   ‚îÇ O(n)    ‚îÇ O(n)    ‚îÇ O(log n)‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è")
    fmt.Println("** –ü—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –≤ –Ω–∞—á–∞–ª–æ")
    
    fmt.Println("\nüéØ –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å BST:")
    fmt.Println("‚úÖ –ù—É–∂–µ–Ω —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –æ–±—Ö–æ–¥ –¥–∞–Ω–Ω—ã—Ö")
    fmt.Println("‚úÖ –ß–∞—Å—Ç—ã–µ range –∑–∞–ø—Ä–æ—Å—ã (–Ω–∞–π—Ç–∏ –≤—Å–µ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ)")
    fmt.Println("‚úÖ –ü–æ–∏—Å–∫ –º–∏–Ω/–º–∞–∫—Å —ç–ª–µ–º–µ–Ω—Ç–æ–≤")
    fmt.Println("‚úÖ –ù—É–∂–Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è O(log n) –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å")
    
    fmt.Println("\n‚ùå –ö–æ–≥–¥–∞ –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å BST:")
    fmt.Println("‚ùå –ù—É–∂–µ–Ω –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Hash)")
    fmt.Println("‚ùå –î–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç—É–ø–∞—é—Ç —É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ (–¥–µ—Ä–µ–≤–æ —Å—Ç–∞–Ω–µ—Ç —Å–ø–∏—Å–∫–æ–º)")
    fmt.Println("‚ùå –ß–∞—Å—Ç—ã–µ –≤—Å—Ç–∞–≤–∫–∏/—É–¥–∞–ª–µ–Ω–∏—è –±–µ–∑ –ø–æ–∏—Å–∫–∞ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–∞—Å—Å–∏–≤)")
    fmt.Println("‚ùå –ú–∞–ª—ã–π –æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö (overhead –Ω–µ –æ–ø—Ä–∞–≤–¥–∞–Ω)")
}

---

## –ú–æ–¥—É–ª—å 7: –•–µ—à-—Ç–∞–±–ª–∏—Ü—ã - –ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º

### üîê –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è

```
–•–ï–®–ò–†–û–í–ê–ù–ò–ï - –ü–†–ï–í–†–ê–©–ï–ù–ò–ï –ö–õ–Æ–ß–ê –í –ê–î–†–ï–°:

INPUT: "apple"                OUTPUT: –º–∞—Å—Å–∏–≤ index
   ‚Üì                             ‚Üì
HASH FUNCTION                  hash("apple") = 3
   ‚Üì                             ‚Üì
h(key) = (sum of ASCII) % table_size

–ü–†–ò–ú–ï–†:
"apple" ‚Üí 'a'=97 + 'p'=112 + 'p'=112 + 'l'=108 + 'e'=101 = 530
530 % 7 = 5

–•–ï–®-–¢–ê–ë–õ–ò–¶–ê:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  0  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5  ‚îÇ "apple":üçé   ‚îÇ ‚Üê hash("apple") = 5
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6  ‚îÇ     nil      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ü–û–ò–°–ö: hash("apple") = 5 ‚Üí –ø—Ä–æ–≤–µ—Ä—è–µ–º index 5 ‚Üí –ù–ê–ô–î–ï–ù! ‚ö° O(1)

–ö–û–õ–õ–ò–ó–ò–ò - –∫–æ–≥–¥–∞ —Ä–∞–∑–Ω—ã–µ –∫–ª—é—á–∏ –¥–∞—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π hash:
hash("apple") = 5
hash("grape") = 5  ‚Üê –ö–û–õ–õ–ò–ó–ò–Ø!

–ö–ê–ö –†–ï–®–ò–¢–¨ –ö–û–õ–õ–ò–ó–ò–ò?
```

### üîß –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π

```
–ú–ï–¢–û–î 1: CHAINING (—Ü–µ–ø–æ—á–∫–∏)
===============================

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  0  ‚îÇ          nil                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1  ‚îÇ          nil                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2  ‚îÇ          nil                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3  ‚îÇ "cat":üê± ‚Üí "dog":üê∂ ‚Üí nil  ‚îÇ ‚Üê –¶–µ–ø–æ—á–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4  ‚îÇ          nil                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5  ‚îÇ "apple":üçé ‚Üí "grape":üçá     ‚îÇ ‚Üê –ï—â–µ –æ–¥–Ω–∞ —Ü–µ–ø–æ—á–∫–∞
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6  ‚îÇ "banana":üçå                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ü–û–ò–°–ö "grape":
1. hash("grape") = 5
2. –ò–¥–µ–º –ø–æ —Ü–µ–ø–æ—á–∫–µ –≤ –ø–æ–∑–∏—Ü–∏–∏ 5: "apple" ‚â† "grape", –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π
3. "grape" = "grape" ‚Üí –ù–ê–ô–î–ï–ù!

–ú–ï–¢–û–î 2: OPEN ADDRESSING (–æ—Ç–∫—Ä—ã—Ç–∞—è –∞–¥—Ä–µ—Å–∞—Ü–∏—è)
===============================================

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  0  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  2  ‚îÇ     nil      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  3  ‚îÇ "cat":üê±    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  4  ‚îÇ "dog":üê∂    ‚îÇ ‚Üê "dog" —Ç–æ–∂–µ —Ö–æ—Ç–µ–ª –≤ –ø–æ–∑–∏—Ü–∏—é 3, –Ω–æ –∑–∞–Ω—è—Ç–æ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  5  ‚îÇ "apple":üçé  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  6  ‚îÇ "grape":üçá  ‚îÇ ‚Üê "grape" —Ç–æ–∂–µ —Ö–æ—Ç–µ–ª –≤ –ø–æ–∑–∏—Ü–∏—é 5, –Ω–æ –∑–∞–Ω—è—Ç–æ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

LINEAR PROBING: –µ—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è –∑–∞–Ω—è—Ç–∞, –∏—â–µ–º —Å–ª–µ–¥—É—é—â—É—é —Å–≤–æ–±–æ–¥–Ω—É—é
hash("dog") = 3, –Ω–æ –ø–æ–∑–∏—Ü–∏—è 3 –∑–∞–Ω—è—Ç–∞ ‚Üí –ø—Ä–æ–±—É–µ–º 4 ‚Üí —Å–≤–æ–±–æ–¥–Ω–∞!

–ü–û–ò–°–ö "dog":
1. hash("dog") = 3
2. –ü–æ–∑–∏—Ü–∏—è 3: "cat" ‚â† "dog"
3. –ü—Ä–æ–±—É–µ–º –ø–æ–∑–∏—Ü–∏—é 4: "dog" = "dog" ‚Üí –ù–ê–ô–î–ï–ù!
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã –≤ Go

```go
package main

import (
    "fmt"
    "hash/fnv"
)

// üìù –≠–õ–ï–ú–ï–ù–¢ –•–ï–®-–¢–ê–ë–õ–ò–¶–´
type HashItem struct {
    Key   string
    Value interface{}
    Next  *HashItem // –î–ª—è chaining
}

// üóÇÔ∏è –•–ï–®-–¢–ê–ë–õ–ò–¶–ê –° CHAINING
type HashTable struct {
    buckets []*HashItem
    size    int
    count   int
}

func NewHashTable(size int) *HashTable {
    return &HashTable{
        buckets: make([]*HashItem, size),
        size:    size,
        count:   0,
    }
}

// üîê –•–ï–®–ò–†–û–í–ê–ù–ò–ï –°–¢–†–û–ö–ò
func (ht *HashTable) hash(key string) int {
    h := fnv.New32a()
    h.Write([]byte(key))
    return int(h.Sum32()) % ht.size
}

// ‚ûï –í–°–¢–ê–í–ö–ê –ò–õ–ò –û–ë–ù–û–í–õ–ï–ù–ò–ï
func (ht *HashTable) Set(key string, value interface{}) {
    index := ht.hash(key)
    
    // –ï—Å–ª–∏ bucket –ø—É—Å—Ç
    if ht.buckets[index] == nil {
        ht.buckets[index] = &HashItem{Key: key, Value: value}
        ht.count++
        return
    }
    
    // –ò—â–µ–º –∫–ª—é—á –≤ —Ü–µ–ø–æ—á–∫–µ
    current := ht.buckets[index]
    for current != nil {
        if current.Key == key {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–ª—é—á
            current.Value = value
            return
        }
        if current.Next == nil {
            break
        }
        current = current.Next
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ–Ω–µ—Ü —Ü–µ–ø–æ—á–∫–∏
    current.Next = &HashItem{Key: key, Value: value}
    ht.count++
}

// üîç –ü–û–ò–°–ö –≠–õ–ï–ú–ï–ù–¢–ê
func (ht *HashTable) Get(key string) (interface{}, bool) {
    index := ht.hash(key)
    
    current := ht.buckets[index]
    for current != nil {
        if current.Key == key {
            return current.Value, true
        }
        current = current.Next
    }
    
    return nil, false
}

// ‚ûñ –£–î–ê–õ–ï–ù–ò–ï –≠–õ–ï–ú–ï–ù–¢–ê
func (ht *HashTable) Delete(key string) bool {
    index := ht.hash(key)
    
    if ht.buckets[index] == nil {
        return false
    }
    
    // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Ü–µ–ø–æ—á–∫–µ
    if ht.buckets[index].Key == key {
        ht.buckets[index] = ht.buckets[index].Next
        ht.count--
        return true
    }
    
    // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ —Ü–µ–ø–æ—á–∫–µ
    current := ht.buckets[index]
    for current.Next != nil {
        if current.Next.Key == key {
            current.Next = current.Next.Next
            ht.count--
            return true
        }
        current = current.Next
    }
    
    return false
}

// üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ò
func (ht *HashTable) LoadFactor() float64 {
    return float64(ht.count) / float64(ht.size)
}

func (ht *HashTable) Stats() {
    fmt.Printf("=== –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã ===\n")
    fmt.Printf("–†–∞–∑–º–µ—Ä: %d\n", ht.size)
    fmt.Printf("–≠–ª–µ–º–µ–Ω—Ç–æ–≤: %d\n", ht.count)
    fmt.Printf("Load Factor: %.2f\n", ht.LoadFactor())
    
    // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
    emptyBuckets := 0
    maxChainLength := 0
    totalChainLength := 0
    
    for i, bucket := range ht.buckets {
        if bucket == nil {
            emptyBuckets++
        } else {
            chainLength := 0
            current := bucket
            for current != nil {
                chainLength++
                current = current.Next
            }
            if chainLength > maxChainLength {
                maxChainLength = chainLength
            }
            totalChainLength += chainLength
            
            if chainLength > 3 { // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Ü–µ–ø–æ—á–∫–∏
                fmt.Printf("Bucket %d: —Ü–µ–ø–æ—á–∫–∞ –¥–ª–∏–Ω–æ–π %d\n", i, chainLength)
            }
        }
    }
    
    fmt.Printf("–ü—É—Å—Ç—ã—Ö buckets: %d (%.1f%%)\n", emptyBuckets, float64(emptyBuckets)*100/float64(ht.size))
    fmt.Printf("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Ü–µ–ø–æ—á–∫–∏: %d\n", maxChainLength)
    fmt.Printf("–°—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ —Ü–µ–ø–æ—á–∫–∏: %.2f\n", float64(totalChainLength)/float64(ht.size-emptyBuckets))
}

// üóÇÔ∏è –•–ï–®-–¢–ê–ë–õ–ò–¶–ê –° OPEN ADDRESSING
type OpenHashTable struct {
    keys   []string
    values []interface{}
    size   int
    count  int
}

func NewOpenHashTable(size int) *OpenHashTable {
    return &OpenHashTable{
        keys:   make([]string, size),
        values: make([]interface{}, size),
        size:   size,
        count:  0,
    }
}

func (oht *OpenHashTable) hash(key string) int {
    h := fnv.New32a()
    h.Write([]byte(key))
    return int(h.Sum32()) % oht.size
}

// ‚ûï –í–°–¢–ê–í–ö–ê –° LINEAR PROBING
func (oht *OpenHashTable) Set(key string, value interface{}) bool {
    if oht.count >= oht.size {
        return false // –¢–∞–±–ª–∏—Ü–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞
    }
    
    index := oht.hash(key)
    
    // Linear probing: –∏—â–µ–º —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ
    for oht.keys[index] != "" {
        if oht.keys[index] == key {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–ª—é—á
            oht.values[index] = value
            return true
        }
        index = (index + 1) % oht.size // –ö–æ–ª—å—Ü–µ–≤–æ–π –ø–æ–∏—Å–∫
    }
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
    oht.keys[index] = key
    oht.values[index] = value
    oht.count++
    return true
}

// üîç –ü–û–ò–°–ö –° LINEAR PROBING
func (oht *OpenHashTable) Get(key string) (interface{}, bool) {
    index := oht.hash(key)
    
    // Linear probing: –∏—â–µ–º –∫–ª—é—á
    startIndex := index
    for oht.keys[index] != "" {
        if oht.keys[index] == key {
            return oht.values[index], true
        }
        index = (index + 1) % oht.size
        if index == startIndex {
            break // –ü—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π –∫—Ä—É–≥
        }
    }
    
    return nil, false
}

// üìã –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ö–û–õ–õ–ò–ó–ò–ô
func collisionDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–ª–ª–∏–∑–∏–π ===")
    
    // –°–æ–∑–¥–∞–µ–º –º–∞–ª–µ–Ω—å–∫—É—é —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–ª–ª–∏–∑–∏–π
    ht := NewHashTable(7)
    
    // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤—ã–∑–≤–∞—Ç—å –∫–æ–ª–ª–∏–∑–∏–∏
    testData := map[string]int{
        "apple":  1,
        "banana": 2,
        "cherry": 3,
        "date":   4,
        "elderberry": 5,
        "fig":    6,
        "grape":  7,
        "honeydew": 8,
    }
    
    fmt.Println("–î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã:")
    for key, value := range testData {
        index := ht.hash(key)
        fmt.Printf("'%s' ‚Üí hash=%d, value=%d\n", key, index, value)
        ht.Set(key, value)
    }
    
    ht.Stats()
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–∏—Å–∫
    fmt.Println("\n–¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–∏—Å–∫:")
    for key := range testData {
        value, found := ht.Get(key)
        fmt.Printf("'%s': %v (–Ω–∞–π–¥–µ–Ω: %t)\n", key, value, found)
    }
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï CHAINING VS OPEN ADDRESSING
func chainingVsOpenDemo() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ Chaining vs Open Addressing ===")
    
    const size = 1000
    const elements = 750 // Load factor = 0.75
    
    chainTable := NewHashTable(size)
    openTable := NewOpenHashTable(size)
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    testKeys := make([]string, elements)
    for i := 0; i < elements; i++ {
        testKeys[i] = fmt.Sprintf("key_%d", i)
    }
    
    // –¢–µ—Å—Ç –≤—Å—Ç–∞–≤–∫–∏ - Chaining
    start := time.Now()
    for i, key := range testKeys {
        chainTable.Set(key, i)
    }
    chainInsertTime := time.Since(start)
    
    // –¢–µ—Å—Ç –≤—Å—Ç–∞–≤–∫–∏ - Open Addressing
    start = time.Now()
    for i, key := range testKeys {
        openTable.Set(key, i)
    }
    openInsertTime := time.Since(start)
    
    // –¢–µ—Å—Ç –ø–æ–∏—Å–∫–∞ - Chaining
    start = time.Now()
    for _, key := range testKeys {
        chainTable.Get(key)
    }
    chainSearchTime := time.Since(start)
    
    // –¢–µ—Å—Ç –ø–æ–∏—Å–∫–∞ - Open Addressing
    start = time.Now()
    for _, key := range testKeys {
        openTable.Get(key)
    }
    openSearchTime := time.Since(start)
    
    fmt.Printf("–í—Å—Ç–∞–≤–∫–∞ %d —ç–ª–µ–º–µ–Ω—Ç–æ–≤:\n", elements)
    fmt.Printf("  Chaining: %v\n", chainInsertTime)
    fmt.Printf("  Open Addressing: %v\n", openInsertTime)
    
    fmt.Printf("\n–ü–æ–∏—Å–∫ %d —ç–ª–µ–º–µ–Ω—Ç–æ–≤:\n", elements)
    fmt.Printf("  Chaining: %v\n", chainSearchTime)
    fmt.Printf("  Open Addressing: %v\n", openSearchTime)
    
    fmt.Println("\nChaining —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:")
    chainTable.Stats()
}

// üîÑ REHASHING - –£–í–ï–õ–ò–ß–ï–ù–ò–ï –†–ê–ó–ú–ï–†–ê –¢–ê–ë–õ–ò–¶–´
func (ht *HashTable) Resize(newSize int) {
    fmt.Printf("Resizing —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã: %d ‚Üí %d\n", ht.size, newSize)
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    oldBuckets := ht.buckets
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É
    ht.buckets = make([]*HashItem, newSize)
    ht.size = newSize
    ht.count = 0
    
    // –ü–µ—Ä–µ—Ö–µ—à–∏—Ä—É–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    for _, bucket := range oldBuckets {
        current := bucket
        for current != nil {
            ht.Set(current.Key, current.Value)
            current = current.Next
        }
    }
}

func rehashingDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è rehashing ===")
    
    ht := NewHashTable(7) // –ù–∞—á–∏–Ω–∞–µ–º —Å –º–∞–ª–µ–Ω—å–∫–æ–π —Ç–∞–±–ª–∏—Ü—ã
    
    // –î–æ–±–∞–≤–ª—è–µ–º –º–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    for i := 0; i < 20; i++ {
        key := fmt.Sprintf("item_%d", i)
        ht.Set(key, i)
        
        loadFactor := ht.LoadFactor()
        if loadFactor > 0.75 && ht.size < 50 { // –ü–æ—Ä–æ–≥ –¥–ª—è resize
            fmt.Printf("Load factor %.2f –ø—Ä–µ–≤—ã—Å–∏–ª –ø–æ—Ä–æ–≥, resizing...\n", loadFactor)
            ht.Resize(ht.size * 2)
        }
    }
    
    fmt.Println("\n–§–∏–Ω–∞–ª—å–Ω—ã–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:")
    ht.Stats()
}

// üéØ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø
func hashTableApplications() {
    fmt.Println("=== –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ö–µ—à-—Ç–∞–±–ª–∏—Ü ===")
    
    // 1. –ö–µ—à –¥–∞–Ω–Ω—ã—Ö
    fmt.Println("\nüíæ 1. LRU Cache —Å —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–µ–π:")
    cache := NewHashTable(100)
    
    // –°–∏–º—É–ª–∏—Ä—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π
    expensiveFunction := func(x int) int {
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –¥–æ—Ä–æ–≥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
        time.Sleep(1 * time.Millisecond)
        return x * x
    }
    
    getCachedResult := func(x int) int {
        key := fmt.Sprintf("result_%d", x)
        if value, found := cache.Get(key); found {
            fmt.Printf("Cache HIT –¥–ª—è %d\n", x)
            return value.(int)
        }
        
        fmt.Printf("Cache MISS –¥–ª—è %d, –≤—ã—á–∏—Å–ª—è–µ–º...\n", x)
        result := expensiveFunction(x)
        cache.Set(key, result)
        return result
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–µ—à
    for _, x := range []int{5, 10, 5, 15, 10} {
        result := getCachedResult(x)
        fmt.Printf("f(%d) = %d\n", x, result)
    }
    
    // 2. –ü–æ–¥—Å—á–µ—Ç —á–∞—Å—Ç–æ—Ç—ã —Å–ª–æ–≤
    fmt.Println("\nüìä 2. –ü–æ–¥—Å—á–µ—Ç —á–∞—Å—Ç–æ—Ç—ã —Å–ª–æ–≤:")
    wordCount := NewHashTable(50)
    
    text := "the quick brown fox jumps over the lazy dog the fox is quick"
    words := strings.Fields(text)
    
    for _, word := range words {
        if count, found := wordCount.Get(word); found {
            wordCount.Set(word, count.(int)+1)
        } else {
            wordCount.Set(word, 1)
        }
    }
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    fmt.Printf("–¢–µ–∫—Å—Ç: %s\n", text)
    fmt.Println("–ß–∞—Å—Ç–æ—Ç–∞ —Å–ª–æ–≤:")
    
    // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å
    fmt.Println("\nüîç 3. –ü–æ–∏—Å–∫ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤:")
    numbers := []int{1, 2, 3, 2, 4, 5, 1, 6, 7, 3}
    seen := NewHashTable(20)
    duplicates := make([]int, 0)
    
    for _, num := range numbers {
        key := fmt.Sprintf("%d", num)
        if _, found := seen.Get(key); found {
            duplicates = append(duplicates, num)
        } else {
            seen.Set(key, true)
        }
    }
    
    fmt.Printf("–ú–∞—Å—Å–∏–≤: %v\n", numbers)
    fmt.Printf("–î—É–±–ª–∏–∫–∞—Ç—ã: %v\n", duplicates)
    
    // 4. –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    fmt.Println("\nüë• 4. –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É:")
    users := []struct {
        Name string
        Age  int
    }{
        {"Alice", 25}, {"Bob", 30}, {"Charlie", 25},
        {"Diana", 30}, {"Eve", 35}, {"Frank", 25},
    }
    
    ageGroups := NewHashTable(10)
    
    for _, user := range users {
        ageKey := fmt.Sprintf("age_%d", user.Age)
        if group, found := ageGroups.Get(ageKey); found {
            existingUsers := group.([]string)
            ageGroups.Set(ageKey, append(existingUsers, user.Name))
        } else {
            ageGroups.Set(ageKey, []string{user.Name})
        }
    }
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥—Ä—É–ø–ø—ã (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
    for _, user := range users {
        ageKey := fmt.Sprintf("age_%d", user.Age)
        if group, found := ageGroups.Get(ageKey); found {
            fmt.Printf("–í–æ–∑—Ä–∞—Å—Ç %d: %v\n", user.Age, group)
            break
        }
    }
}

// üèÜ –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func hashTablePerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–∏—Å–∫–∞ ===")
    
    const dataSize = 100000
    const searches = 10000
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    testData := make([]string, dataSize)
    for i := 0; i < dataSize; i++ {
        testData[i] = fmt.Sprintf("key_%d", i)
    }
    
    // 1. –ú–∞—Å—Å–∏–≤ (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫)
    array := make([]string, dataSize)
    copy(array, testData)
    
    start := time.Now()
    for i := 0; i < searches; i++ {
        searchKey := testData[i%dataSize]
        for _, key := range array {
            if key == searchKey {
                break
            }
        }
    }
    arrayTime := time.Since(start)
    
    // 2. –•–µ—à-—Ç–∞–±–ª–∏—Ü–∞
    hashTable := NewHashTable(dataSize / 4) // Load factor ~4
    for i, key := range testData {
        hashTable.Set(key, i)
    }
    
    start = time.Now()
    for i := 0; i < searches; i++ {
        searchKey := testData[i%dataSize]
        hashTable.Get(searchKey)
    }
    hashTime := time.Since(start)
    
    // 3. Go –≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è map
    goMap := make(map[string]int)
    for i, key := range testData {
        goMap[key] = i
    }
    
    start = time.Now()
    for i := 0; i < searches; i++ {
        searchKey := testData[i%dataSize]
        _ = goMap[searchKey]
    }
    mapTime := time.Since(start)
    
    fmt.Printf("–ü–æ–∏—Å–∫ –≤ %d —ç–ª–µ–º–µ–Ω—Ç–∞—Ö (%d –æ–ø–µ—Ä–∞—Ü–∏–π):\n", dataSize, searches)
    fmt.Printf("  –ú–∞—Å—Å–∏–≤ (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫): %v\n", arrayTime)
    fmt.Printf("  –ù–∞—à–∞ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞:        %v\n", hashTime)
    fmt.Printf("  Go map (–≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è):     %v\n", mapTime)
    
    fmt.Printf("\n–£—Å–∫–æ—Ä–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–∞—Å—Å–∏–≤–∞:\n")
    fmt.Printf("  –•–µ—à-—Ç–∞–±–ª–∏—Ü–∞: %.0fx –±—ã—Å—Ç—Ä–µ–µ\n", float64(arrayTime)/float64(hashTime))
    fmt.Printf("  Go map:      %.0fx –±—ã—Å—Ç—Ä–µ–µ\n", float64(arrayTime)/float64(mapTime))
    
    fmt.Println("\nüìä –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –°—Ç—Ä—É–∫—Ç—É—Ä–∞       ‚îÇ –ü–æ–∏—Å–∫   ‚îÇ –í—Å—Ç–∞–≤–∫–∞     ‚îÇ –£–¥–∞–ª–µ–Ω–∏–µ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –ú–∞—Å—Å–∏–≤          ‚îÇ O(n)    ‚îÇ O(n)        ‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îÇ –°–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫‚îÇ O(n)    ‚îÇ O(1)        ‚îÇ O(n)    ‚îÇ")
    fmt.Println("‚îÇ BST             ‚îÇ O(log n)‚îÇ O(log n)    ‚îÇ O(log n)‚îÇ")
    fmt.Println("‚îÇ –•–µ—à-—Ç–∞–±–ª–∏—Ü–∞     ‚îÇ O(1)*   ‚îÇ O(1)*       ‚îÇ O(1)*   ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è")
}

---

# üèóÔ∏è –§–∞–∑–∞ 3: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

## –ú–æ–¥—É–ª—å 8: –ö—É—á–∏ (Heaps) - –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –æ—á–µ—Ä–µ–¥–∏

### üèîÔ∏è –ß—Ç–æ —Ç–∞–∫–æ–µ –∫—É—á–∞?

```
–ö–£–ß–ê (HEAP) - –î–ï–†–ï–í–û –° –û–°–û–ë–´–ú –°–í–û–ô–°–¢–í–û–ú:

MIN-HEAP: —Ä–æ–¥–∏—Ç–µ–ª—å ‚â§ –≤—Å–µ—Ö –¥–µ—Ç–µ–π          MAX-HEAP: —Ä–æ–¥–∏—Ç–µ–ª—å ‚â• –≤—Å–µ—Ö –¥–µ—Ç–µ–π
        1                                       90
       / \                                     / \
      3   6                                   50  80
     / \ / \                                 / \ / \
    5  9 8  9                              30 20 70 40

–°–í–û–ô–°–¢–í–û –ö–£–ß–ò:
‚Ä¢ MIN-HEAP: –∫–æ—Ä–µ–Ω—å = –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
‚Ä¢ MAX-HEAP: –∫–æ—Ä–µ–Ω—å = –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
‚Ä¢ –ù–û —ç—Ç–æ –ù–ï BST! –ù–µ—Ç —É–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–Ω–∏—è –ª–µ–≤–æ/–ø—Ä–∞–≤–æ

–ü–†–ï–î–°–¢–ê–í–õ–ï–ù–ò–ï –í –ú–ê–°–°–ò–í–ï:
Min-heap: [1, 3, 6, 5, 9, 8, 9]
          0  1  2  3  4  5  6

–§–û–†–ú–£–õ–´ –î–õ–Ø –ù–ê–í–ò–ì–ê–¶–ò–ò:
‚Ä¢ –†–æ–¥–∏—Ç–µ–ª—å —ç–ª–µ–º–µ–Ω—Ç–∞ i: (i-1)/2
‚Ä¢ –õ–µ–≤—ã–π —Ä–µ–±–µ–Ω–æ–∫ i: 2*i + 1
‚Ä¢ –ü—Ä–∞–≤—ã–π —Ä–µ–±–µ–Ω–æ–∫ i: 2*i + 2

–ü–†–ò–ú–ï–†:
–≠–ª–µ–º–µ–Ω—Ç —Å –∏–Ω–¥–µ–∫—Å–æ–º 2 (–∑–Ω–∞—á–µ–Ω–∏–µ 6):
‚Ä¢ –†–æ–¥–∏—Ç–µ–ª—å: (2-1)/2 = 0 (–∑–Ω–∞—á–µ–Ω–∏–µ 1) ‚úì
‚Ä¢ –õ–µ–≤—ã–π —Ä–µ–±–µ–Ω–æ–∫: 2*2+1 = 5 (–∑–Ω–∞—á–µ–Ω–∏–µ 8) ‚úì
‚Ä¢ –ü—Ä–∞–≤—ã–π —Ä–µ–±–µ–Ω–æ–∫: 2*2+2 = 6 (–∑–Ω–∞—á–µ–Ω–∏–µ 9) ‚úì
```

### üîß –û–ø–µ—Ä–∞—Ü–∏–∏ —Å –∫—É—á–µ–π

```
–í–°–¢–ê–í–ö–ê –≠–õ–ï–ú–ï–ù–¢–ê (HEAPIFY UP):

–í—Å—Ç–∞–≤–ª—è–µ–º 2 –≤ min-heap:

–®–∞–≥ 1: –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü –º–∞—Å—Å–∏–≤–∞
[1, 3, 6, 5, 9, 8, 9, 2]
          0  1  2  3  4  5  6  7

        1
       / \
      3   6
     / \ / \ \
    5  9 8  9 2 ‚Üê –ù–∞—Ä—É—à–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏!

–®–∞–≥ 2: –ü–æ–¥–Ω–∏–º–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤–≤–µ—Ä—Ö (heapify up)
–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å —Ä–æ–¥–∏—Ç–µ–ª–µ–º (–∏–Ω–¥–µ–∫—Å 3, –∑–Ω–∞—á–µ–Ω–∏–µ 5):
2 < 5, –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏

[1, 3, 6, 2, 9, 8, 9, 5]
          0  1  2  3  4  5  6  7

        1
       / \
      3   6
     / \ / \ \
    2  9 8  9 5

–®–∞–≥ 3: –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º heapify up
–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –Ω–æ–≤—ã–º —Ä–æ–¥–∏—Ç–µ–ª–µ–º (–∏–Ω–¥–µ–∫—Å 1, –∑–Ω–∞—á–µ–Ω–∏–µ 3):
2 < 3, –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏

[1, 2, 6, 3, 9, 8, 9, 5]
          0  1  2  3  4  5  6  7

        1
       / \
      2   6
     / \ / \ \
    3  9 8  9 5

–®–∞–≥ 4: –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –∫–æ—Ä–Ω–µ–º (–∏–Ω–¥–µ–∫—Å 0, –∑–Ω–∞—á–µ–Ω–∏–µ 1):
2 > 1, —Å—Ç–æ–ø - —Å–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!

–ò–ó–í–õ–ï–ß–ï–ù–ò–ï –ú–ò–ù–ò–ú–£–ú–ê (HEAPIFY DOWN):

–ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ—Ä–µ–Ω—å (1) –∏–∑ min-heap:

–®–∞–≥ 1: –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ—Ä–µ–Ω—å, –ø–µ—Ä–µ–º–µ—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ—Ä–µ–Ω—å
[5, 2, 6, 3, 9, 8, 9] ‚Üê —É–±—Ä–∞–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π
 ‚Üë –∑–∞–º–µ–Ω–∏–ª–∏ –∫–æ—Ä–µ–Ω—å –Ω–∞ 5

        5 ‚Üê –ù–∞—Ä—É—à–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏!
       / \
      2   6
     / \ / \
    3  9 8  9

–®–∞–≥ 2: –û–ø—É—Å–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤–Ω–∏–∑ (heapify down)
–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –¥–µ—Ç—å–º–∏ (2 –∏ 6):
min(2, 6) = 2, –∏ 5 > 2, –º–µ–Ω—è–µ–º —Å –º–µ–Ω—å—à–∏–º —Ä–µ–±–µ–Ω–∫–æ–º

[2, 5, 6, 3, 9, 8, 9]

        2
       / \
      5   6
     / \ / \
    3  9 8  9

–®–∞–≥ 3: –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º heapify down
–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º 5 —Å –¥–µ—Ç—å–º–∏ (3 –∏ 9):
min(3, 9) = 3, –∏ 5 > 3, –º–µ–Ω—è–µ–º

[2, 3, 6, 5, 9, 8, 9]

        2
       / \
      3   6
     / \ / \
    5  9 8  9

–°–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫—É—á–∏ –≤ Go

```go
package main

import (
    "errors"
    "fmt"
)

// üèîÔ∏è MIN-HEAP –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø
type MinHeap struct {
    items []int
}

func NewMinHeap() *MinHeap {
    return &MinHeap{items: make([]int, 0)}
}

// üìç –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´
func (h *MinHeap) parent(index int) int {
    return (index - 1) / 2
}

func (h *MinHeap) leftChild(index int) int {
    return 2*index + 1
}

func (h *MinHeap) rightChild(index int) int {
    return 2*index + 2
}

func (h *MinHeap) hasParent(index int) bool {
    return h.parent(index) >= 0
}

func (h *MinHeap) hasLeftChild(index int) bool {
    return h.leftChild(index) < len(h.items)
}

func (h *MinHeap) hasRightChild(index int) bool {
    return h.rightChild(index) < len(h.items)
}

func (h *MinHeap) swap(i, j int) {
    h.items[i], h.items[j] = h.items[j], h.items[i]
}

// ‚¨ÜÔ∏è HEAPIFY UP (–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞ –∫—É—á–∏ –≤–≤–µ—Ä—Ö)
func (h *MinHeap) heapifyUp(index int) {
    // –ü–æ–∫–∞ –µ—Å—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å –∏ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –º–µ–Ω—å—à–µ —Ä–æ–¥–∏—Ç–µ–ª—è
    for h.hasParent(index) && h.items[h.parent(index)] > h.items[index] {
        parentIndex := h.parent(index)
        h.swap(index, parentIndex)
        index = parentIndex
    }
}

// ‚¨áÔ∏è HEAPIFY DOWN (–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞ –∫—É—á–∏ –≤–Ω–∏–∑)
func (h *MinHeap) heapifyDown(index int) {
    for h.hasLeftChild(index) {
        smallerChildIndex := h.leftChild(index)
        
        // –ù–∞—Ö–æ–¥–∏–º –º–µ–Ω—å—à–µ–≥–æ –∏–∑ –¥–µ—Ç–µ–π
        if h.hasRightChild(index) && h.items[h.rightChild(index)] < h.items[h.leftChild(index)] {
            smallerChildIndex = h.rightChild(index)
        }
        
        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –º–µ–Ω—å—à–µ –º–µ–Ω—å—à–µ–≥–æ —Ä–µ–±–µ–Ω–∫–∞ - –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
        if h.items[index] < h.items[smallerChildIndex] {
            break
        }
        
        h.swap(index, smallerChildIndex)
        index = smallerChildIndex
    }
}

// ‚ûï –í–°–¢–ê–í–ö–ê –≠–õ–ï–ú–ï–ù–¢–ê
func (h *MinHeap) Insert(value int) {
    h.items = append(h.items, value) // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü
    h.heapifyUp(len(h.items) - 1)    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏
}

// üîç –ü–†–û–°–ú–û–¢–† –ú–ò–ù–ò–ú–£–ú–ê (–ë–ï–ó –£–î–ê–õ–ï–ù–ò–Ø)
func (h *MinHeap) Peek() (int, error) {
    if len(h.items) == 0 {
        return 0, errors.New("heap is empty")
    }
    return h.items[0], nil
}

// ‚ûñ –ò–ó–í–õ–ï–ß–ï–ù–ò–ï –ú–ò–ù–ò–ú–£–ú–ê
func (h *MinHeap) ExtractMin() (int, error) {
    if len(h.items) == 0 {
        return 0, errors.New("heap is empty")
    }
    
    min := h.items[0]
    lastIndex := len(h.items) - 1
    
    // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ—Ä–µ–Ω—å
    h.items[0] = h.items[lastIndex]
    h.items = h.items[:lastIndex] // –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–æ –∫—É—á–∏
    if len(h.items) > 0 {
        h.heapifyDown(0)
    }
    
    return min, nil
}

// üìä –ò–ù–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ï –ú–ï–¢–û–î–´
func (h *MinHeap) Size() int {
    return len(h.items)
}

func (h *MinHeap) IsEmpty() bool {
    return len(h.items) == 0
}

// üñ®Ô∏è –ö–†–ê–°–ò–í–´–ô –í–´–í–û–î –ö–£–ß–ò
func (h *MinHeap) Print() {
    if len(h.items) == 0 {
        fmt.Println("–ö—É—á–∞ –ø—É—Å—Ç–∞")
        return
    }
    
    fmt.Printf("–ö—É—á–∞ (–º–∞—Å—Å–∏–≤): %v\n", h.items)
    fmt.Println("–î—Ä–µ–≤–æ–≤–∏–¥–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ:")
    h.printTree(0, "", true)
}

func (h *MinHeap) printTree(index int, prefix string, isLast bool) {
    if index >= len(h.items) {
        return
    }
    
    fmt.Print(prefix)
    if isLast {
        fmt.Print("‚îî‚îÄ‚îÄ ")
        prefix += "    "
    } else {
        fmt.Print("‚îú‚îÄ‚îÄ ")
        prefix += "‚îÇ   "
    }
    fmt.Println(h.items[index])
    
    // –ü–µ—á–∞—Ç–∞–µ–º –¥–µ—Ç–µ–π
    if h.hasLeftChild(index) || h.hasRightChild(index) {
        if h.hasRightChild(index) {
            h.printTree(h.rightChild(index), prefix, !h.hasLeftChild(index))
        }
        if h.hasLeftChild(index) {
            h.printTree(h.leftChild(index), prefix, true)
        }
    }
}

// üèîÔ∏è MAX-HEAP (–¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è)
type MaxHeap struct {
    items []int
}

func NewMaxHeap() *MaxHeap {
    return &MaxHeap{items: make([]int, 0)}
}

func (h *MaxHeap) Insert(value int) {
    h.items = append(h.items, value)
    h.heapifyUp(len(h.items) - 1)
}

func (h *MaxHeap) heapifyUp(index int) {
    for index > 0 {
        parentIndex := (index - 1) / 2
        if h.items[parentIndex] >= h.items[index] {
            break
        }
        h.items[index], h.items[parentIndex] = h.items[parentIndex], h.items[index]
        index = parentIndex
    }
}

func (h *MaxHeap) ExtractMax() (int, error) {
    if len(h.items) == 0 {
        return 0, errors.New("heap is empty")
    }
    
    max := h.items[0]
    lastIndex := len(h.items) - 1
    h.items[0] = h.items[lastIndex]
    h.items = h.items[:lastIndex]
    
    if len(h.items) > 0 {
        h.heapifyDown(0)
    }
    
    return max, nil
}

func (h *MaxHeap) heapifyDown(index int) {
    for {
        largest := index
        leftChild := 2*index + 1
        rightChild := 2*index + 2
        
        if leftChild < len(h.items) && h.items[leftChild] > h.items[largest] {
            largest = leftChild
        }
        
        if rightChild < len(h.items) && h.items[rightChild] > h.items[largest] {
            largest = rightChild
        }
        
        if largest == index {
            break
        }
        
        h.items[index], h.items[largest] = h.items[largest], h.items[index]
        index = largest
    }
}

// üéØ –ü–†–ò–û–†–ò–¢–ï–¢–ù–ê–Ø –û–ß–ï–†–ï–î–¨ –ù–ê –û–°–ù–û–í–ï –ö–£–ß–ò
type PriorityQueue struct {
    heap *MinHeap
}

type Task struct {
    Name     string
    Priority int
    Data     interface{}
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{heap: NewMinHeap()}
}

// –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏
func (pq *PriorityQueue) Enqueue(priority int) {
    pq.heap.Insert(priority)
}

func (pq *PriorityQueue) Dequeue() (int, error) {
    return pq.heap.ExtractMin()
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–ò
func heapDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Min-Heap ===")
    
    heap := NewMinHeap()
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
    values := []int{50, 30, 70, 20, 40, 60, 80, 10}
    fmt.Printf("–í—Å—Ç–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã: %v\n", values)
    
    for _, val := range values {
        fmt.Printf("\n–í—Å—Ç–∞–≤–ª—è–µ–º %d:\n", val)
        heap.Insert(val)
        heap.Print()
    }
    
    fmt.Printf("\n–§–∏–Ω–∞–ª—å–Ω–∞—è –∫—É—á–∞:\n")
    heap.Print()
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
    fmt.Println("\n=== –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ===")
    for !heap.IsEmpty() {
        min, _ := heap.ExtractMin()
        fmt.Printf("–ò–∑–≤–ª–µ–∫–ª–∏ –º–∏–Ω–∏–º—É–º: %d\n", min)
        if !heap.IsEmpty() {
            heap.Print()
        }
    }
}

// üìä HEAP SORT –ê–õ–ì–û–†–ò–¢–ú
func heapSort(arr []int) []int {
    // –°–æ–∑–¥–∞–µ–º max-heap
    maxHeap := NewMaxHeap()
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –∫—É—á—É
    for _, val := range arr {
        maxHeap.Insert(val)
    }
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è, –∑–∞—Ç–µ–º –ø–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
    result := make([]int, len(arr))
    for i := len(arr) - 1; i >= 0; i-- {
        max, _ := maxHeap.ExtractMax()
        result[i] = max
    }
    
    return result
}

func heapSortDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Heap Sort ===")
    
    unsorted := []int{64, 34, 25, 12, 22, 11, 90, 5}
    fmt.Printf("–ò—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤: %v\n", unsorted)
    
    sorted := heapSort(unsorted)
    fmt.Printf("–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π: %v\n", sorted)
    
    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
    fmt.Println("\nüìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –ê–ª–≥–æ—Ä–∏—Ç–º        ‚îÇ –õ—É—á—à–∏–π      ‚îÇ –°—Ä–µ–¥–Ω–∏–π     ‚îÇ –•—É–¥—à–∏–π      ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ Bubble Sort     ‚îÇ O(n)        ‚îÇ O(n¬≤)       ‚îÇ O(n¬≤)       ‚îÇ")
    fmt.Println("‚îÇ Quick Sort      ‚îÇ O(n log n)  ‚îÇ O(n log n)  ‚îÇ O(n¬≤)       ‚îÇ")
    fmt.Println("‚îÇ Merge Sort      ‚îÇ O(n log n)  ‚îÇ O(n log n)  ‚îÇ O(n log n)  ‚îÇ")
    fmt.Println("‚îÇ Heap Sort       ‚îÇ O(n log n)  ‚îÇ O(n log n)  ‚îÇ O(n log n)  ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("\n‚úÖ Heap Sort –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç O(n log n) –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ!")
}

// üè• –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –°–ò–°–¢–ï–ú–ê –ë–û–õ–¨–ù–ò–ß–ù–û–ô –û–ß–ï–†–ï–î–ò
func hospitalQueueDemo() {
    fmt.Println("=== –°–∏—Å—Ç–µ–º–∞ –±–æ–ª—å–Ω–∏—á–Ω–æ–π –æ—á–µ—Ä–µ–¥–∏ ===")
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º min-heap –≥–¥–µ –º–µ–Ω—å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç = –±–æ–ª–µ–µ —Å—Ä–æ—á–Ω—ã–π
    urgentQueue := NewMinHeap()
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ü–∏–µ–Ω—Ç–æ–≤ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: 1=–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π, 5=–æ–±—ã—á–Ω—ã–π)
    patients := []struct {
        name     string
        priority int
    }{
        {"–ê–Ω–Ω–∞ (–ø–µ—Ä–µ–ª–æ–º)", 2},
        {"–ë–æ—Ä–∏—Å (–ø—Ä–æ—Å—Ç—É–¥–∞)", 5},
        {"–í–µ—Ä–∞ (—Å–µ—Ä–¥–µ—á–Ω—ã–π –ø—Ä–∏—Å—Ç—É–ø)", 1},
        {"–ì–µ–æ—Ä–≥–∏–π (–≥–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å)", 4},
        {"–î–∞—Ä—å—è (–∞–ª–ª–µ—Ä–≥–∏—è)", 3},
        {"–ï–≤–≥–µ–Ω–∏–π (—Ç—Ä–∞–≤–º–∞)", 2},
    }
    
    fmt.Println("–ü–∞—Ü–∏–µ–Ω—Ç—ã –ø—Ä–∏–±—ã–≤–∞—é—Ç:")
    for _, patient := range patients {
        fmt.Printf("  %s (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç %d)\n", patient.name, patient.priority)
        urgentQueue.Insert(patient.priority)
    }
    
    fmt.Println("\n–ü–æ—Ä—è–¥–æ–∫ –ø—Ä–∏–µ–º–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É:")
    patientIndex := 0
    patientMap := make(map[int][]string)
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–∞—Ü–∏–µ–Ω—Ç–æ–≤ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
    for _, patient := range patients {
        patientMap[patient.priority] = append(patientMap[patient.priority], patient.name)
    }
    
    position := 1
    for !urgentQueue.IsEmpty() {
        priority, _ := urgentQueue.ExtractMin()
        if len(patientMap[priority]) > 0 {
            patient := patientMap[priority][0]
            patientMap[priority] = patientMap[priority][1:]
            fmt.Printf("  %d. %s\n", position, patient)
            position++
        }
    }
}

// üéÆ –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: A* PATHFINDING
type AStarNode struct {
    x, y     int
    gCost    int // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Å—Ç–∞—Ä—Ç–∞
    hCost    int // –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–∏  
    fCost    int // gCost + hCost
    parent   *AStarNode
}

func (n *AStarNode) calculateFCost() {
    n.fCost = n.gCost + n.hCost
}

// –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏
func pathfindingDemo() {
    fmt.Println("=== A* Pathfinding —Å Priority Queue ===")
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º min-heap –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞ —É–∑–ª–æ–≤
    openSet := NewMinHeap()
    
    fmt.Println("üéÆ –í –∏–≥—Ä–∞—Ö A* –∏—Å–ø–æ–ª—å–∑—É–µ—Ç priority queue –¥–ª—è:")
    fmt.Println("  ‚Ä¢ –í—ã–±–æ—Ä–∞ –Ω–∞–∏–±–æ–ª–µ–µ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —É–∑–ª–∞ –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è")
    fmt.Println("  ‚Ä¢ –ì–∞—Ä–∞–Ω—Ç–∏–∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏")
    fmt.Println("  ‚Ä¢ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –º–∏—Ä–∞")
    
    // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É–∑–ª–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
    nodes := []struct {
        name  string
        fCost int
    }{
        {"–°—Ç–∞—Ä—Ç", 10},
        {"–£–∑–µ–ª A", 8},
        {"–£–∑–µ–ª B", 12},
        {"–£–∑–µ–ª C", 6},
        {"–¶–µ–ª—å", 0},
    }
    
    fmt.Println("\n–î–æ–±–∞–≤–ª—è–µ–º —É–∑–ª—ã –≤ priority queue:")
    for _, node := range nodes {
        fmt.Printf("  %s (f-cost: %d)\n", node.name, node.fCost)
        openSet.Insert(node.fCost)
    }
    
    fmt.Println("\n–ü–æ—Ä—è–¥–æ–∫ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è —É–∑–ª–æ–≤ (–ª—É—á—à–∏–π f-cost –ø–µ—Ä–≤—ã–º):")
    nodeMap := make(map[int][]string)
    for _, node := range nodes {
        nodeMap[node.fCost] = append(nodeMap[node.fCost], node.name)
    }
    
    step := 1
    for !openSet.IsEmpty() {
        fCost, _ := openSet.ExtractMin()
        if len(nodeMap[fCost]) > 0 {
            nodeName := nodeMap[fCost][0]
            nodeMap[fCost] = nodeMap[fCost][1:]
            fmt.Printf("  –®–∞–≥ %d: –∏—Å—Å–ª–µ–¥—É–µ–º %s (f-cost: %d)\n", step, nodeName, fCost)
            step++
        }
    }
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func heapPerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ Priority Queue ===")
    
    const operations = 100000
    
    // 1. –ù–∞–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (–º–∞—Å—Å–∏–≤)
    type NaivePQ struct {
        items []int
    }
    
    naiveInsert := func(pq *NaivePQ, value int) {
        pq.items = append(pq.items, value)
    }
    
    naiveExtractMin := func(pq *NaivePQ) int {
        if len(pq.items) == 0 {
            return -1
        }
        
        minIdx := 0
        for i, val := range pq.items {
            if val < pq.items[minIdx] {
                minIdx = i
            }
        }
        
        min := pq.items[minIdx]
        pq.items = append(pq.items[:minIdx], pq.items[minIdx+1:]...)
        return min
    }
    
    // –¢–µ—Å—Ç –Ω–∞–∏–≤–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
    naivePQ := &NaivePQ{}
    start := time.Now()
    for i := 0; i < operations/10; i++ { // –ú–µ–Ω—å—à–µ –æ–ø–µ—Ä–∞—Ü–∏–π –∏–∑-–∑–∞ O(n¬≤)
        naiveInsert(naivePQ, i)
        if i%2 == 0 {
            naiveExtractMin(naivePQ)
        }
    }
    naiveTime := time.Since(start)
    
    // –¢–µ—Å—Ç heap —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
    heapPQ := NewMinHeap()
    start = time.Now()
    for i := 0; i < operations; i++ {
        heapPQ.Insert(i)
        if i%2 == 0 {
            heapPQ.ExtractMin()
        }
    }
    heapTime := time.Since(start)
    
    fmt.Printf("–ù–∞–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations/10, naiveTime)
    fmt.Printf("Heap —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è (%d –æ–ø–µ—Ä–∞—Ü–∏–π): %v\n", operations, heapTime)
    
    // –≠–∫—Å—Ç—Ä–∞–ø–æ–ª–∏—Ä—É–µ–º –≤—Ä–µ–º—è –Ω–∞–∏–≤–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
    estimatedNaiveTime := time.Duration(float64(naiveTime) * 10 * 10) // O(n¬≤) scaling
    fmt.Printf("–†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞–∏–≤–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–ª—è %d –æ–ø–µ—Ä–∞—Ü–∏–π: %v\n", operations, estimatedNaiveTime)
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: ~%.0fx\n", float64(estimatedNaiveTime)/float64(heapTime))
    
    fmt.Println("\nüìä –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π Priority Queue:")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è      ‚îÇ Insert      ‚îÇ Extract-Min ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –ù–µ–æ—Ç—Å–æ—Ä—Ç. –º–∞—Å—Å–∏–≤‚îÇ O(1)        ‚îÇ O(n)        ‚îÇ")
    fmt.Println("‚îÇ –û—Ç—Å–æ—Ä—Ç. –º–∞—Å—Å–∏–≤  ‚îÇ O(n)        ‚îÇ O(1)        ‚îÇ")
    fmt.Println("‚îÇ –°–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫‚îÇ O(n)        ‚îÇ O(1)        ‚îÇ")
    fmt.Println("‚îÇ Binary Heap     ‚îÇ O(log n)    ‚îÇ O(log n)    ‚îÇ")
    fmt.Println("‚îÇ Fibonacci Heap  ‚îÇ O(1)*       ‚îÇ O(log n)    ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è")
}

---

## –ú–æ–¥—É–ª—å 9: Trie (Prefix Tree) - –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ —Å—Ç—Ä–æ–∫

### üå≥ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ Trie

```
TRIE - –î–ï–†–ï–í–û –î–õ–Ø –•–†–ê–ù–ï–ù–ò–Ø –°–¢–†–û–ö:

–î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–∞: "cat", "car", "card", "care", "careful", "can"

                     ROOT
                      |
                      c
                      |
                      a
                    / | \
                   t  r  n*
                   |  |
                   *  d---e*
                      |   |
                      *   f*
                          |
                          u
                          |
                          l
                          |
                          *

* = –∫–æ–Ω–µ—Ü —Å–ª–æ–≤–∞ (isEndOfWord = true)

–°–¢–†–£–ö–¢–£–†–ê –£–ó–õ–ê:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ TrieNode        ‚îÇ
‚îÇ ‚îú children: map ‚îÇ ‚Üê map[rune]*TrieNode
‚îÇ ‚îú isEndOfWord   ‚îÇ ‚Üê bool (true –µ—Å–ª–∏ –∑–¥–µ—Å—å –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è —Å–ª–æ–≤–æ)
‚îÇ ‚îî value: rune   ‚îÇ ‚Üê —Å–∏–º–≤–æ–ª (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê TRIE:
‚úÖ –ü–æ–∏—Å–∫ —Å–ª–æ–≤–∞: O(m) –≥–¥–µ m = –¥–ª–∏–Ω–∞ —Å–ª–æ–≤–∞
‚úÖ –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ: –ª–µ–≥–∫–æ –Ω–∞–π—Ç–∏ –≤—Å–µ —Å–ª–æ–≤–∞ —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º
‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ—Ñ–∏–∫—Å–∞: O(m) 
‚úÖ –í—Å—Ç–∞–≤–∫–∞: O(m)
‚úÖ Memory sharing: –æ–±—â–∏–µ –ø—Ä–µ—Ñ–∏–∫—Å—ã –∑–∞–Ω–∏–º–∞—é—Ç –º–µ—Å—Ç–æ –æ–¥–∏–Ω —Ä–∞–∑

–ù–ï–î–û–°–¢–ê–¢–ö–ò:
‚ùå –ë–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏ –Ω–∞ –æ–¥–Ω–æ —Å–ª–æ–≤–æ (–∫–∞–∂–¥—ã–π —É–∑–µ–ª = —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –¥–µ—Ç–µ–π)
‚ùå Cache locality —Ö—É–∂–µ —á–µ–º —É –º–∞—Å—Å–∏–≤–æ–≤
‚ùå –°–ª–æ–∂–Ω–µ–µ –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è Trie –≤ Go

```go
package main

import (
    "fmt"
    "sort"
    "strings"
)

// üå≥ –£–ó–ï–õ TRIE
type TrieNode struct {
    children    map[rune]*TrieNode
    isEndOfWord bool
    value       rune // –°–∏–º–≤–æ–ª –≤ —ç—Ç–æ–º —É–∑–ª–µ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
}

func NewTrieNode(char rune) *TrieNode {
    return &TrieNode{
        children:    make(map[rune]*TrieNode),
        isEndOfWord: false,
        value:       char,
    }
}

// üèóÔ∏è TRIE –°–¢–†–£–ö–¢–£–†–ê
type Trie struct {
    root *TrieNode
    size int // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤
}

func NewTrie() *Trie {
    return &Trie{
        root: NewTrieNode(0), // –ö–æ—Ä–µ–Ω—å –±–µ–∑ —Å–∏–º–≤–æ–ª–∞
        size: 0,
    }
}

// ‚ûï –í–°–¢–ê–í–ö–ê –°–õ–û–í–ê
func (t *Trie) Insert(word string) {
    if word == "" {
        return
    }
    
    current := t.root
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É —Å–ª–æ–≤–∞
    for _, char := range word {
        // –ï—Å–ª–∏ —Ä–µ–±–µ–Ω–∫–∞ —Å —Ç–∞–∫–∏–º —Å–∏–º–≤–æ–ª–æ–º –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º
        if current.children[char] == nil {
            current.children[char] = NewTrieNode(char)
        }
        current = current.children[char]
    }
    
    // –û—Ç–º–µ—á–∞–µ–º –∫–æ–Ω–µ—Ü —Å–ª–æ–≤–∞
    if !current.isEndOfWord {
        current.isEndOfWord = true
        t.size++
    }
}

// üîç –ü–û–ò–°–ö –°–õ–û–í–ê
func (t *Trie) Search(word string) bool {
    if word == "" {
        return false
    }
    
    current := t.root
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É
    for _, char := range word {
        if current.children[char] == nil {
            return false // –°–∏–º–≤–æ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω
        }
        current = current.children[char]
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –ª–∏ –∑–¥–µ—Å—å —Å–ª–æ–≤–æ
    return current.isEndOfWord
}

// üîç –ü–û–ò–°–ö –ü–†–ï–§–ò–ö–°–ê
func (t *Trie) StartsWith(prefix string) bool {
    if prefix == "" {
        return true
    }
    
    current := t.root
    
    for _, char := range prefix {
        if current.children[char] == nil {
            return false
        }
        current = current.children[char]
    }
    
    return true // –ü—Ä–µ—Ñ–∏–∫—Å –Ω–∞–π–¥–µ–Ω
}

// üìù –ê–í–¢–û–î–û–ü–û–õ–ù–ï–ù–ò–ï
func (t *Trie) AutoComplete(prefix string) []string {
    var results []string
    
    // –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ø—Ä–µ—Ñ–∏–∫—Å—É
    current := t.root
    for _, char := range prefix {
        if current.children[char] == nil {
            return results // –ü—Ä–µ—Ñ–∏–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω
        }
        current = current.children[char]
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–ª–æ–≤–∞, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å —ç—Ç–æ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞
    t.collectWords(current, prefix, &results)
    sort.Strings(results) // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    
    return results
}

// üîÑ –†–ï–ö–£–†–°–ò–í–ù–´–ô –°–ë–û–† –°–õ–û–í
func (t *Trie) collectWords(node *TrieNode, currentWord string, results *[]string) {
    if node.isEndOfWord {
        *results = append(*results, currentWord)
    }
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π
    for char, child := range node.children {
        t.collectWords(child, currentWord+string(char), results)
    }
}

// ‚ûñ –£–î–ê–õ–ï–ù–ò–ï –°–õ–û–í–ê
func (t *Trie) Delete(word string) bool {
    if word == "" || !t.Search(word) {
        return false
    }
    
    deleted := t.deleteHelper(t.root, word, 0)
    if deleted {
        t.size--
    }
    return deleted
}

func (t *Trie) deleteHelper(node *TrieNode, word string, index int) bool {
    if index == len(word) {
        // –î–æ—à–ª–∏ –¥–æ –∫–æ–Ω—Ü–∞ —Å–ª–æ–≤–∞
        if !node.isEndOfWord {
            return false // –°–ª–æ–≤–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        }
        
        node.isEndOfWord = false
        
        // –ï—Å–ª–∏ —É —É–∑–ª–∞ –µ—Å—Ç—å –¥–µ—Ç–∏, –Ω–µ —É–¥–∞–ª—è–µ–º –µ–≥–æ (–æ–Ω –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º –¥—Ä—É–≥–∏—Ö —Å–ª–æ–≤)
        return len(node.children) == 0
    }
    
    char := rune(word[index])
    childNode := node.children[char]
    if childNode == nil {
        return false // –°–ª–æ–≤–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }
    
    shouldDeleteChild := t.deleteHelper(childNode, word, index+1)
    
    if shouldDeleteChild {
        delete(node.children, char)
        
        // –£–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª, –µ—Å–ª–∏:
        // 1. –û–Ω –Ω–µ –∫–æ–Ω–µ—Ü –¥—Ä—É–≥–æ–≥–æ —Å–ª–æ–≤–∞
        // 2. –£ –Ω–µ–≥–æ –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –¥–µ—Ç–µ–π
        return !node.isEndOfWord && len(node.children) == 0
    }
    
    return false
}

// üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ò
func (t *Trie) Size() int {
    return t.size
}

func (t *Trie) IsEmpty() bool {
    return t.size == 0
}

// üìù –ü–û–õ–£–ß–ï–ù–ò–ï –í–°–ï–• –°–õ–û–í
func (t *Trie) GetAllWords() []string {
    var words []string
    t.collectWords(t.root, "", &words)
    sort.Strings(words)
    return words
}

// üîç –ü–û–ò–°–ö –°–ê–ú–û–ì–û –î–õ–ò–ù–ù–û–ì–û –û–ë–©–ï–ì–û –ü–†–ï–§–ò–ö–°–ê
func (t *Trie) LongestCommonPrefix() string {
    if t.size == 0 {
        return ""
    }
    
    var prefix strings.Builder
    current := t.root
    
    // –ò–¥–µ–º –≤–Ω–∏–∑ –ø–æ–∫–∞ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–µ–±–µ–Ω–æ–∫ –∏ –Ω–µ –≤—Å—Ç—Ä–µ—á–∞–µ–º –∫–æ–Ω–µ—Ü —Å–ª–æ–≤–∞
    for len(current.children) == 1 && !current.isEndOfWord {
        for char, child := range current.children {
            prefix.WriteRune(char)
            current = child
            break
        }
    }
    
    return prefix.String()
}

// üñ®Ô∏è –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø TRIE
func (t *Trie) Print() {
    fmt.Println("–°—Ç—Ä—É–∫—Ç—É—Ä–∞ Trie:")
    t.printNode(t.root, "", true, "")
}

func (t *Trie) printNode(node *TrieNode, prefix string, isLast bool, currentPath string) {
    if node == t.root {
        fmt.Println("ROOT")
    } else {
        connector := "‚îú‚îÄ‚îÄ "
        if isLast {
            connector = "‚îî‚îÄ‚îÄ "
        }
        
        endMarker := ""
        if node.isEndOfWord {
            endMarker = " *"
        }
        
        fmt.Printf("%s%s'%c'%s\n", prefix, connector, node.value, endMarker)
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º –¥–µ—Ç–µ–π –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö
    var children []rune
    for char := range node.children {
        children = append(children, char)
    }
    sort.Slice(children, func(i, j int) bool {
        return children[i] < children[j]
    })
    
    // –í—ã–≤–æ–¥–∏–º –¥–µ—Ç–µ–π
    for i, char := range children {
        isLastChild := i == len(children)-1
        childPrefix := prefix
        if node != t.root {
            if isLast {
                childPrefix += "    "
            } else {
                childPrefix += "‚îÇ   "
            }
        }
        
        t.printNode(node.children[char], childPrefix, isLastChild, currentPath+string(char))
    }
}

// üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø TRIE
func trieDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Trie ===")
    
    trie := NewTrie()
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–∞
    words := []string{"cat", "car", "card", "care", "careful", "can", "dog", "dodge"}
    
    fmt.Printf("–î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–∞: %v\n", words)
    for _, word := range words {
        trie.Insert(word)
    }
    
    fmt.Printf("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ–≤ –≤ Trie: %d\n\n", trie.Size())
    
    // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
    trie.Print()
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–∏—Å–∫
    fmt.Println("\n=== –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ ===")
    testWords := []string{"car", "card", "cart", "care", "careful", "cat", "dog", "elephant"}
    
    for _, word := range testWords {
        found := trie.Search(word)
        status := "‚ùå"
        if found {
            status = "‚úÖ"
        }
        fmt.Printf("%s '%s'\n", status, word)
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å—ã
    fmt.Println("\n=== –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ—Ñ–∏–∫—Å–æ–≤ ===")
    prefixes := []string{"car", "ca", "d", "x", ""}
    
    for _, prefix := range prefixes {
        hasPrefix := trie.StartsWith(prefix)
        status := "‚ùå"
        if hasPrefix {
            status = "‚úÖ"
        }
        fmt.Printf("%s –ø—Ä–µ—Ñ–∏–∫—Å '%s'\n", status, prefix)
    }
    
    // –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
    fmt.Println("\n=== –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ ===")
    autocompleteTests := []string{"car", "ca", "d", "care"}
    
    for _, prefix := range autocompleteTests {
        suggestions := trie.AutoComplete(prefix)
        fmt.Printf("'%s' ‚Üí %v\n", prefix, suggestions)
    }
    
    fmt.Printf("\n–°–∞–º—ã–π –¥–ª–∏–Ω–Ω—ã–π –æ–±—â–∏–π –ø—Ä–µ—Ñ–∏–∫—Å: '%s'\n", trie.LongestCommonPrefix())
}

// üîç –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –ü–û–ò–°–ö–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê
type SearchEngine struct {
    trie     *Trie
    documents map[string][]string // word -> list of document IDs
}

func NewSearchEngine() *SearchEngine {
    return &SearchEngine{
        trie:      NewTrie(),
        documents: make(map[string][]string),
    }
}

func (se *SearchEngine) IndexDocument(docID string, content string) {
    // –ü—Ä–æ—Å—Ç–∞—è —Ç–æ–∫–µ–Ω–∏–∑–∞—Ü–∏—è (—Ä–∞–∑–±–∏–µ–Ω–∏–µ –Ω–∞ —Å–ª–æ–≤–∞)
    words := strings.Fields(strings.ToLower(content))
    
    for _, word := range words {
        // –û—á–∏—â–∞–µ–º —Å–ª–æ–≤–æ –æ—Ç –∑–Ω–∞–∫–æ–≤ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è
        cleanWord := strings.Trim(word, ".,!?;:")
        if cleanWord == "" {
            continue
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ Trie
        se.trie.Insert(cleanWord)
        
        // –ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –¥–æ–∫—É–º–µ–Ω—Ç
        if se.documents[cleanWord] == nil {
            se.documents[cleanWord] = make([]string, 0)
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞
        found := false
        for _, existingDocID := range se.documents[cleanWord] {
            if existingDocID == docID {
                found = true
                break
            }
        }
        
        if !found {
            se.documents[cleanWord] = append(se.documents[cleanWord], docID)
        }
    }
}

func (se *SearchEngine) Search(query string) []string {
    cleanQuery := strings.ToLower(strings.TrimSpace(query))
    if cleanQuery == "" {
        return nil
    }
    
    if se.trie.Search(cleanQuery) {
        return se.documents[cleanQuery]
    }
    
    return nil
}

func (se *SearchEngine) AutoComplete(prefix string) []string {
    return se.trie.AutoComplete(strings.ToLower(prefix))
}

func searchEngineDemo() {
    fmt.Println("=== –ü–æ–∏—Å–∫–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å Trie ===")
    
    search := NewSearchEngine()
    
    // –ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –¥–æ–∫—É–º–µ–Ω—Ç—ã
    documents := map[string]string{
        "doc1": "The quick brown fox jumps over the lazy dog",
        "doc2": "A quick brown dog runs fast",
        "doc3": "The lazy cat sleeps all day",
        "doc4": "Quick fixes for common problems",
        "doc5": "Brown bears live in the forest",
    }
    
    fmt.Println("–ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –¥–æ–∫—É–º–µ–Ω—Ç—ã:")
    for docID, content := range documents {
        fmt.Printf("  %s: %s\n", docID, content)
        search.IndexDocument(docID, content)
    }
    
    fmt.Printf("\n–í—Å–µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å–ª–æ–≤: %d\n", search.trie.Size())
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–∏—Å–∫
    fmt.Println("\n=== –ü–æ–∏—Å–∫ ===")
    queries := []string{"quick", "brown", "lazy", "forest", "nonexistent"}
    
    for _, query := range queries {
        results := search.Search(query)
        fmt.Printf("'%s' ‚Üí %v\n", query, results)
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
    fmt.Println("\n=== –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ ===")
    prefixes := []string{"qu", "br", "l", "f"}
    
    for _, prefix := range prefixes {
        suggestions := search.AutoComplete(prefix)
        fmt.Printf("'%s' ‚Üí %v\n", prefix, suggestions)
    }
}

// üì± –ü–†–ò–ú–ï–ù–ï–ù–ò–ï: –¢–ï–õ–ï–§–û–ù–ù–ê–Ø –ö–ù–ò–ì–ê
type Contact struct {
    Name  string
    Phone string
    Email string
}

type PhoneBook struct {
    nameTrie  *Trie
    phoneTrie *Trie
    contacts  map[string]*Contact // name -> contact
}

func NewPhoneBook() *PhoneBook {
    return &PhoneBook{
        nameTrie:  NewTrie(),
        phoneTrie: NewTrie(),
        contacts:  make(map[string]*Contact),
    }
}

func (pb *PhoneBook) AddContact(contact *Contact) {
    name := strings.ToLower(contact.Name)
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –≤ Trie –¥–ª—è –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è
    pb.nameTrie.Insert(name)
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–ª–µ—Ñ–æ–Ω –≤ Trie (–¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –Ω–æ–º–µ—Ä—É)
    pb.phoneTrie.Insert(contact.Phone)
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç
    pb.contacts[name] = contact
}

func (pb *PhoneBook) SearchByName(name string) *Contact {
    key := strings.ToLower(name)
    return pb.contacts[key]
}

func (pb *PhoneBook) AutoCompleteNames(prefix string) []string {
    return pb.nameTrie.AutoComplete(strings.ToLower(prefix))
}

func (pb *PhoneBook) FindContactsByPrefix(prefix string) []*Contact {
    names := pb.AutoCompleteNames(prefix)
    contacts := make([]*Contact, 0, len(names))
    
    for _, name := range names {
        if contact := pb.contacts[name]; contact != nil {
            contacts = append(contacts, contact)
        }
    }
    
    return contacts
}

func phoneBookDemo() {
    fmt.Println("=== –¢–µ–ª–µ—Ñ–æ–Ω–Ω–∞—è –∫–Ω–∏–≥–∞ —Å Trie ===")
    
    phoneBook := NewPhoneBook()
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã
    contacts := []*Contact{
        {"Alice Johnson", "+1-555-1234", "alice@example.com"},
        {"Bob Smith", "+1-555-5678", "bob@example.com"},
        {"Alice Brown", "+1-555-9012", "alice.brown@example.com"},
        {"Charlie Wilson", "+1-555-3456", "charlie@example.com"},
        {"Alice Cooper", "+1-555-7890", "alice.cooper@example.com"},
        {"David Anderson", "+1-555-2468", "david@example.com"},
    }
    
    fmt.Println("–î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã:")
    for _, contact := range contacts {
        fmt.Printf("  %s: %s\n", contact.Name, contact.Phone)
        phoneBook.AddContact(contact)
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
    fmt.Println("\n=== –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–º–µ–Ω ===")
    prefixes := []string{"a", "al", "alice", "b", "ch", "d"}
    
    for _, prefix := range prefixes {
        suggestions := phoneBook.AutoCompleteNames(prefix)
        fmt.Printf("'%s' ‚Üí %v\n", prefix, suggestions)
    }
    
    // –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
    fmt.Println("\n=== –ü–æ–∏—Å–∫ –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ ===")
    searchPrefixes := []string{"alice", "bo", "char"}
    
    for _, prefix := range searchPrefixes {
        foundContacts := phoneBook.FindContactsByPrefix(prefix)
        fmt.Printf("'%s':\n", prefix)
        for _, contact := range foundContacts {
            fmt.Printf("  %s (%s)\n", contact.Name, contact.Phone)
        }
    }
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func triePerformance() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–∏—Å–∫–∞ —Å—Ç—Ä–æ–∫ ===")
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    const wordsCount = 100000
    const searchCount = 10000
    
    words := make([]string, wordsCount)
    for i := 0; i < wordsCount; i++ {
        words[i] = fmt.Sprintf("word_%d_%d", i, i*i%1000)
    }
    
    // 1. Trie
    trie := NewTrie()
    start := time.Now()
    for _, word := range words {
        trie.Insert(word)
    }
    trieBuildTime := time.Since(start)
    
    start = time.Now()
    for i := 0; i < searchCount; i++ {
        searchWord := words[i%wordsCount]
        trie.Search(searchWord)
    }
    trieSearchTime := time.Since(start)
    
    // 2. –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫ (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫)
    start = time.Now()
    for i := 0; i < searchCount; i++ {
        searchWord := words[i%wordsCount]
        for _, word := range words {
            if word == searchWord {
                break
            }
        }
    }
    arraySearchTime := time.Since(start)
    
    // 3. Go map
    stringMap := make(map[string]bool)
    start = time.Now()
    for _, word := range words {
        stringMap[word] = true
    }
    mapBuildTime := time.Since(start)
    
    start = time.Now()
    for i := 0; i < searchCount; i++ {
        searchWord := words[i%wordsCount]
        _ = stringMap[searchWord]
    }
    mapSearchTime := time.Since(start)
    
    fmt.Printf("–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (%d —Å–ª–æ–≤):\n", wordsCount)
    fmt.Printf("  Trie:      %v\n", trieBuildTime)
    fmt.Printf("  Map:       %v\n", mapBuildTime)
    
    fmt.Printf("\n–ü–æ–∏—Å–∫ (%d –æ–ø–µ—Ä–∞—Ü–∏–π):\n", searchCount)
    fmt.Printf("  –ú–∞—Å—Å–∏–≤:    %v\n", arraySearchTime)
    fmt.Printf("  Trie:      %v\n", trieSearchTime)
    fmt.Printf("  Map:       %v\n", mapSearchTime)
    
    fmt.Printf("\n–£—Å–∫–æ—Ä–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –º–∞—Å—Å–∏–≤–∞:\n")
    fmt.Printf("  Trie:      %.0fx\n", float64(arraySearchTime)/float64(trieSearchTime))
    fmt.Printf("  Map:       %.0fx\n", float64(arraySearchTime)/float64(mapSearchTime))
    
    fmt.Println("\nüéØ –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Trie:")
    fmt.Println("‚úÖ –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –ø–æ–∏—Å–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É")
    fmt.Println("‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å—Ç—Ä–æ–∫")
    fmt.Println("‚úÖ –ü–æ–∏—Å–∫ —Å–∞–º–æ–≥–æ –¥–ª–∏–Ω–Ω–æ–≥–æ –æ–±—â–µ–≥–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞")
    fmt.Println("‚úÖ –°–ª–æ–≤–∞—Ä–∏ –∏ spell-checkers")
    
    fmt.Println("\n‚ùå –ö–æ–≥–¥–∞ –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Trie:")
    fmt.Println("‚ùå –ü—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ map)")
    fmt.Println("‚ùå –ú–∞–ª–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫")
    fmt.Println("‚ùå –°—Ç—Ä–æ–∫–∏ –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã–µ –∏ —Ä–∞–∑–Ω—ã–µ")
}
    –¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏
    for i := 0; i < initialBlocks; i++ {
        block := make([]byte, blockSize)
        slab.freeList = append(slab.freeList, block)
    }
    
    return slab
}

func (s *SlabAllocator) Allocate() []byte {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    if len(s.freeList) == 0 {
        // –ü—É–ª –ø—É—Å—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –±–ª–æ–∫
        return make([]byte, s.blockSize)
    }
    
    // –ë–µ—Ä–µ–º –±–ª–æ–∫ –∏–∑ –ø—É–ª–∞
    block := s.freeList[len(s.freeList)-1]
    s.freeList = s.freeList[:len(s.freeList)-1]
    return block
}

func (s *SlabAllocator) Free(block []byte) {
    if len(block) != s.blockSize {
        return // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±–ª–æ–∫–∞
    }
    
    s.mutex.Lock()
    defer s.mutex.Unlock()
    
    // –û—á–∏—â–∞–µ–º –±–ª–æ–∫ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –ø—É–ª
    for i := range block {
        block[i] = 0
    }
    s.freeList = append(s.freeList, block)
}

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –±—É—Ñ–µ—Ä–æ–≤ HTTP –æ—Ç–≤–µ—Ç–æ–≤
var responseBufferSlab = NewSlabAllocator(4096, 100) // 4KB –±—É—Ñ–µ—Ä—ã

func handleHTTPRequest(w http.ResponseWriter, r *http.Request) {
    buffer := responseBufferSlab.Allocate()
    defer responseBufferSlab.Free(buffer)
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±—É—Ñ–µ—Ä –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞...
}
```

---

## –ú–æ–¥—É–ª—å 2: Garbage Collection - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é

### üóëÔ∏è –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç GC –≤ Go: –ü–æ—à–∞–≥–æ–≤—ã–π —Ä–∞–∑–±–æ—Ä

```
GARBAGE COLLECTION - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –¥–≤–æ—Ä–Ω–∏–∫ –ø–∞–º—è—Ç–∏:

–§–ê–ó–ê 1: MARK (–ü–æ–º–µ—Ç–∫–∞ –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤)
========================================

–ù–∞—á–∏–Ω–∞–µ–º —Å –ö–û–†–ù–ï–í–´–• –æ–±—ä–µ–∫—Ç–æ–≤ (stack, global variables):

STACK:               HEAP:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     
‚îÇ main()      ‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ user ‚Üí A ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ User A  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Profile ‚îÇ ‚Üê –î–æ—Å—Ç–∏–∂–∏–º —á–µ—Ä–µ–∑ A
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  
                    ‚îÇ User B  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Orders  ‚îÇ ‚Üê –ù–ï –¥–æ—Å—Ç–∏–∂–∏–º!
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ê–õ–ì–û–†–ò–¢–ú –ü–û–ú–ï–¢–ö–ò:
1. –ù–∞—á–∏–Ω–∞–µ–º —Å –∫–æ—Ä–Ω–µ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (Stack + Global)
2. –ü–æ–º–µ—á–∞–µ–º –∏—Ö –∫–∞–∫ "–∂–∏–≤—ã–µ" (MARK = true)
3. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Å—Å—ã–ª–∫–∞–º
4. –ü–æ–º–µ—á–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç–∏–∂–∏–º—ã–µ –æ–±—ä–µ–∫—Ç—ã

–†–µ–∑—É–ª—å—Ç–∞—Ç:
‚úÖ User A: MARKED (–¥–æ—Å—Ç–∏–∂–∏–º)
‚úÖ Profile: MARKED (–¥–æ—Å—Ç–∏–∂–∏–º —á–µ—Ä–µ–∑ A)
‚ùå User B: UNMARKED (–Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º)
‚ùå Orders: UNMARKED (–Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º)

–§–ê–ó–ê 2: SWEEP (–û—á–∏—Å—Ç–∫–∞ –Ω–µ–ø–æ–º–µ—á–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤)
===========================================

–ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–π –∫—É—á–µ –∏ —É–¥–∞–ª—è–µ–º –Ω–µ–ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã:

–î–û SWEEP:                    –ü–û–°–õ–ï SWEEP:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚úÖ MARKED       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –û—Å—Ç–∞–µ—Ç—Å—è  
‚îÇ User A  ‚îÇ Keep            ‚îÇ User A  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ùå UNMARKED     [DELETED] ‚Üê –£–¥–∞–ª–µ–Ω
‚îÇ User B  ‚îÇ Delete          
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚úÖ MARKED       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üê –û—Å—Ç–∞–µ—Ç—Å—è
‚îÇ Profile ‚îÇ Keep            ‚îÇ Profile ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ùå UNMARKED     [DELETED] ‚Üê –£–¥–∞–ª–µ–Ω  
‚îÇ Orders  ‚îÇ Delete
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üöÄ Tri-color Mark and Sweep –≤ Go

Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å –ø—Ä–æ–≥—Ä–∞–º–º–æ–π:

```go
// –ü—Ä–∏–º–µ—Ä –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã GC
package main

import (
    "fmt"
    "runtime"
    "runtime/debug"
    "time"
)

type Node struct {
    Value int
    Next  *Node
    Data  []byte // –ß—Ç–æ–±—ã –æ–±—ä–µ–∫—Ç –∑–∞–Ω–∏–º–∞–ª –±–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏
}

func createGarbage() {
    // –°–æ–∑–¥–∞–µ–º —Ü–µ–ø–æ—á–∫—É –æ–±—ä–µ–∫—Ç–æ–≤
    var head *Node
    for i := 0; i < 10000; i++ {
        node := &Node{
            Value: i,
            Next:  head,
            Data:  make([]byte, 1024), // 1KB –Ω–∞ –æ–±—ä–µ–∫—Ç
        }
        head = node
    }
    
    // head –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏
    // –í—Å–µ –æ–±—ä–µ–∫—Ç—ã —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º—ã–º–∏
}

func monitorGC() {
    var stats runtime.MemStats
    
    fmt.Println("=== –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ Garbage Collection ===")
    
    // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π GC –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    debug.SetGCPercent(-1)
    
    // –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    runtime.ReadMemStats(&stats)
    fmt.Printf("–ü–∞–º—è—Ç—å –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤: %d KB\n", stats.Alloc/1024)
    
    // –°–æ–∑–¥–∞–µ–º –º—É—Å–æ—Ä
    createGarbage()
    
    runtime.ReadMemStats(&stats)
    fmt.Printf("–ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤: %d KB\n", stats.Alloc/1024)
    fmt.Printf("–û–±—ä–µ–∫—Ç—ã —Å—Ç–∞–ª–∏ –º—É—Å–æ—Ä–æ–º (–Ω–æ –µ—â–µ –Ω–µ —É–¥–∞–ª–µ–Ω—ã)\n")
    
    // –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ GC
    fmt.Println("–ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä—â–∏–∫ –º—É—Å–æ—Ä–∞...")
    start := time.Now()
    runtime.GC()
    gcTime := time.Since(start)
    
    runtime.ReadMemStats(&stats)
    fmt.Printf("–ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ GC: %d KB\n", stats.Alloc/1024)
    fmt.Printf("–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã GC: %v\n", gcTime)
    fmt.Printf("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ GC —Ü–∏–∫–ª–æ–≤: %d\n", stats.NumGC)
    
    // –í–∫–ª—é—á–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π GC
    debug.SetGCPercent(100)
}

// üéØ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –î–õ–Ø GC
func gcOptimizationExample() {
    
    // ‚ùå –ü–õ–û–•–û: –º–Ω–æ–≥–æ –º–µ–ª–∫–∏—Ö –∞–ª–ª–æ–∫–∞—Ü–∏–π
    func badCode() {
        var results []string
        for i := 0; i < 100000; i++ {
            // –ö–∞–∂–¥—ã–π fmt.Sprintf —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É –≤ –∫—É—á–µ
            result := fmt.Sprintf("Result number %d", i)
            results = append(results, result)
        }
    }
    
    // ‚úÖ –•–û–†–û–®–û: –º–∏–Ω–∏–º—É–º –∞–ª–ª–æ–∫–∞—Ü–∏–π
    func goodCode() {
        results := make([]string, 0, 100000) // –ü—Ä–µ–¥–∞–ª–ª–æ–∫–∞—Ü–∏—è
        
        for i := 0; i < 100000; i++ {
            // –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –±—É—Ñ–µ—Ä
            result := "Result number " + strconv.Itoa(i)
            results = append(results, result)
        }
    }
    
    // üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ GC-–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ ===")
    
    // –¢–µ—Å—Ç –ø–ª–æ—Ö–æ–≥–æ –∫–æ–¥–∞
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)
    start := time.Now()
    badCode()
    badTime := time.Since(start)
    runtime.ReadMemStats(&m2)
    badAllocs := m2.TotalAlloc - m1.TotalAlloc
    
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π GC –¥–ª—è –æ—á–∏—Å—Ç–∫–∏
    runtime.GC()
    
    // –¢–µ—Å—Ç —Ö–æ—Ä–æ—à–µ–≥–æ –∫–æ–¥–∞  
    runtime.ReadMemStats(&m1)
    start = time.Now()
    goodCode()
    goodTime := time.Since(start)
    runtime.ReadMemStats(&m2)
    goodAllocs := m2.TotalAlloc - m1.TotalAlloc
    
    fmt.Printf("–ü–ª–æ—Ö–æ–π –∫–æ–¥: %v, –∞–ª–ª–æ–∫–∞—Ü–∏–π: %d KB\n", badTime, badAllocs/1024)
    fmt.Printf("–•–æ—Ä–æ—à–∏–π –∫–æ–¥: %v, –∞–ª–ª–æ–∫–∞—Ü–∏–π: %d KB\n", goodTime, goodAllocs/1024)
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: %.2fx\n", float64(badTime)/float64(goodTime))
    fmt.Printf("–≠–∫–æ–Ω–æ–º–∏—è –ø–∞–º—è—Ç–∏: %.2fx\n", float64(badAllocs)/float64(goodAllocs))
}
```

### üéõÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ GC –¥–ª—è production

```go
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è GC –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π

// üéÆ LOW LATENCY –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–∏–≥—Ä—ã, real-time —Å–∏—Å—Ç–µ–º—ã)
func configureLowLatencyGC() {
    // –ë–æ–ª–µ–µ —á–∞—Å—Ç—ã–π, –Ω–æ –±—ã—Å—Ç—Ä—ã–π GC
    debug.SetGCPercent(20) // GC –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏ —Ä–æ—Å—Ç–µ –∫—É—á–∏ –Ω–∞ 20%
    
    // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–∞—É–∑ GC
    go func() {
        var lastGC uint64
        for {
            var stats runtime.MemStats
            runtime.ReadMemStats(&stats)
            
            if stats.NumGC != lastGC {
                // GC –ø—Ä–æ–∏–∑–æ—à–µ–ª
                pause := stats.PauseNs[(stats.NumGC+255)%256]
                fmt.Printf("GC pause: %v\n", time.Duration(pause))
                lastGC = stats.NumGC
            }
            
            time.Sleep(100 * time.Millisecond)
        }
    }()
}

// üè≠ HIGH THROUGHPUT –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (batch processing)  
func configureHighThroughputGC() {
    // –†–µ–∂–µ –∑–∞–ø—É—Å–∫–∞–µ–º GC, –ø–æ–∑–≤–æ–ª—è–µ–º –∫—É—á–µ —Ä–∞—Å—Ç–∏
    debug.SetGCPercent(200) // GC –ø—Ä–∏ —Ä–æ—Å—Ç–µ –Ω–∞ 200%
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –ø–∞–º—è—Ç–∏
    debug.SetMemoryLimit(8 << 30) // 8GB –ª–∏–º–∏—Ç
}

// üìä BALANCED –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–≤–µ–±-—Å–µ—Ä–≤–µ—Ä—ã)
func configureBalancedGC() {
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –Ω–æ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º
    debug.SetGCPercent(100) // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
    // –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ GC
    ticker := time.NewTicker(30 * time.Second)
    go func() {
        for range ticker.C {
            var stats runtime.MemStats
            runtime.ReadMemStats(&stats)
            
            fmt.Printf("GC Stats: Cycles=%d, Pause=%v, HeapSize=%dMB\n",
                stats.NumGC,
                time.Duration(stats.PauseNs[(stats.NumGC+255)%256]),
                stats.HeapSys/1024/1024)
        }
    }()
}
```

---

# üèóÔ∏è –§–∞–∑–∞ 2: –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

## –ú–æ–¥—É–ª—å 3: –ú–∞—Å—Å–∏–≤—ã –∏ —Å–ª–∞–π—Å—ã - –û—Å–Ω–æ–≤–∞ –≤—Å–µ—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π

### üìã –ê–Ω–∞—Ç–æ–º–∏—è –º–∞—Å—Å–∏–≤–∞ –≤ –ø–∞–º—è—Ç–∏

```
–ú–ê–°–°–ò–í - –ù–ï–ü–†–ï–†–´–í–ù–´–ô –ë–õ–û–ö –ü–ê–ú–Ø–¢–ò:

var numbers [5]int = [5]int{10, 20, 30, 40, 50}

–ü–ê–ú–Ø–¢–¨:
–ê–¥—Ä–µ—Å:   0x1000  0x1008  0x1010  0x1018  0x1020
–ó–Ω–∞—á–µ–Ω–∏–µ:  10      20      30      40      50
–ò–Ω–¥–µ–∫—Å:    [0]     [1]     [2]     [3]     [4]
           ‚Üë                               ‚Üë
        –Ω–∞—á–∞–ª–æ                          –∫–æ–Ω–µ—Ü

–†–ê–ó–ú–ï–†: 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ √ó 8 –±–∞–π—Ç (int64) = 40 –±–∞–π—Ç

–î–û–°–¢–£–ü –ü–û –ò–ù–î–ï–ö–°–£:
numbers[2] = –∞–¥—Ä–µ—Å_–Ω–∞—á–∞–ª–∞ + (–∏–Ω–¥–µ–∫—Å √ó —Ä–∞–∑–º–µ—Ä_—ç–ª–µ–º–µ–Ω—Ç–∞)
           = 0x1000 + (2 √ó 8) = 0x1010
           
‚ö° –í–†–ï–ú–Ø: O(1) - –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø!

CACHE LOCALITY - –ø–æ—á–µ–º—É –º–∞—Å—Å–∏–≤—ã –±—ã—Å—Ç—Ä—ã–µ:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CPU CACHE LINE (64 –±–∞–π—Ç–∞)               ‚îÇ
‚îÇ [10][20][30][40][50][??][??][??]        ‚îÇ ‚Üê –û–¥–Ω–∞ –∑–∞–≥—Ä—É–∑–∫–∞ = 8 —ç–ª–µ–º–µ–Ω—Ç–æ–≤!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–ü—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ numbers[0] –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ä–∞–∑—É –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
–ü–æ—Å–ª–µ–¥—É—é—â–∏–µ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ numbers[1], numbers[2] —Ä–∞–±–æ—Ç–∞—é—Ç –∏–∑ –∫–µ—à–∞ = –û–ß–ï–ù–¨ –ë–´–°–¢–†–û!
```

### üîÑ –°–ª–∞–π—Å—ã: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –º–∞—Å—Å–∏–≤—ã

```
SLICE HEADER - —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–∑ 3 –ø–æ–ª–µ–π:

type SliceHeader struct {
    Data uintptr // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Å—Å–∏–≤
    Len  int     // –¢–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞  
    Cap  int     // –í–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
}

–ü–†–ò–ú–ï–†:
slice := make([]int, 3, 5) // –¥–ª–∏–Ω–∞=3, –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å=5

–ü–ê–ú–Ø–¢–¨:
SLICE HEADER:              –ë–ê–ó–û–í–´–ô –ú–ê–°–°–ò–í:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
‚îÇData: 0x2000 ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ 0 ‚îÇ 0 ‚îÇ 0 ‚îÇ ? ‚îÇ ? ‚îÇ
‚îÇLen:  3      ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
‚îÇCap:  5      ‚îÇ             ‚Üë       ‚Üë       ‚Üë
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             0       2       4
                          ‚îú‚îÄlen‚îÄ‚î§
                          ‚îú‚îÄ‚îÄ‚îÄ‚îÄcap‚îÄ‚îÄ‚îÄ‚îÄ‚î§

–û–ü–ï–†–ê–¶–ò–ò –°–û –°–õ–ê–ô–°–ê–ú–ò:

1) APPEND –í –ü–†–ï–î–ï–õ–ê–• CAPACITY:
   slice = append(slice, 42)
   
   –î–û:  [0, 0, 0] len=3, cap=5
   –ü–û–°–õ–ï: [0, 0, 0, 42] len=4, cap=5
   
   ‚ö° –ë—ã—Å—Ç—Ä–æ: O(1) - –ø—Ä–æ—Å—Ç–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º len

2) APPEND –° –ü–†–ï–í–´–®–ï–ù–ò–ï–ú CAPACITY:
   slice = append(slice, 100, 200) // –î–æ–±–∞–≤–ª—è–µ–º 2 —ç–ª–µ–º–µ–Ω—Ç–∞
   
   –î–û:    [0, 0, 0, 42] len=4, cap=5
   –ü–û–°–õ–ï: [0, 0, 0, 42, 100, 200] len=6, cap=10
   
   üêå –ú–µ–¥–ª–µ–Ω–Ω–æ: O(n) - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤, –∫–æ–ø–∏—Ä—É–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã
   
   –°–¢–†–ê–¢–ï–ì–ò–Ø –†–û–°–¢–ê:
   –ù–æ–≤–∞—è –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å = —Å—Ç–∞—Ä–∞—è_–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å √ó 2 (–ø—Ä–∏ —Ä–∞–∑–º–µ—Ä–µ < 1024)
   –ù–æ–≤–∞—è –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å = —Å—Ç–∞—Ä–∞—è_–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å √ó 1.25 (–ø—Ä–∏ —Ä–∞–∑–º–µ—Ä–µ ‚â• 1024)
```

### üíª –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã —Å–æ —Å–ª–∞–π—Å–∞–º–∏

```go
package main

import (
    "fmt"
    "time"
)

// üìä –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–û–°–¢–ê –°–õ–ê–ô–°–ê
func sliceGrowthDemo() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–æ—Å—Ç–∞ —Å–ª–∞–π—Å–∞ ===")
    
    slice := make([]int, 0, 1) // –ù–∞—á–∏–Ω–∞–µ–º —Å capacity = 1
    
    for i := 0; i < 20; i++ {
        oldCap := cap(slice)
        slice = append(slice, i)
        newCap := cap(slice)
        
        if newCap != oldCap {
            fmt.Printf("–†–æ—Å—Ç: len=%d, —Å—Ç–∞—Ä–∞—è cap=%d ‚Üí –Ω–æ–≤–∞—è cap=%d (√ó%.1f)\n", 
                len(slice), oldCap, newCap, float64(newCap)/float64(oldCap))
        }
    }
}

// ‚ö° –°–†–ê–í–ù–ï–ù–ò–ï: append —Å preallocation vs –±–µ–∑
func appendPerformanceDemo() {
    const size = 1000000
    
    // ‚ùå –ú–ï–î–õ–ï–ù–ù–û: –∫–∞–∂–¥—ã–π append –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å reallocation
    func slowAppend() []int {
        var slice []int // capacity = 0
        for i := 0; i < size; i++ {
            slice = append(slice, i)
        }
        return slice
    }
    
    // ‚úÖ –ë–´–°–¢–†–û: –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
    func fastAppend() []int {
        slice := make([]int, 0, size) // –∑–∞—Ä–∞–Ω–µ–µ –≤—ã–¥–µ–ª—è–µ–º capacity
        for i := 0; i < size; i++ {
            slice = append(slice, i)
        }
        return slice
    }
    
    // –ë–µ–Ω—á–º–∞—Ä–∫ –º–µ–¥–ª–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏
    start := time.Now()
    slowResult := slowAppend()
    slowTime := time.Since(start)
    
    // –ë–µ–Ω—á–º–∞—Ä–∫ –±—ã—Å—Ç—Ä–æ–π –≤–µ—Ä—Å–∏–∏
    start = time.Now()
    fastResult := fastAppend()
    fastTime := time.Since(start)
    
    fmt.Printf("–ú–µ–¥–ª–µ–Ω–Ω—ã–π append: %v (%d —ç–ª–µ–º–µ–Ω—Ç–æ–≤)\n", slowTime, len(slowResult))
    fmt.Printf("–ë—ã—Å—Ç—Ä—ã–π append: %v (%d —ç–ª–µ–º–µ–Ω—Ç–æ–≤)\n", fastTime, len(fastResult))
    fmt.Printf("–£—Å–∫–æ—Ä–µ–Ω–∏–µ: %.2fx\n", float64(slowTime)/float64(fastTime))
}

// üîç –°–õ–ê–ô–°–´ –ò MEMORY SHARING
func sliceSharingDemo() {
    fmt.Println("=== –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –º–µ–∂–¥—É —Å–ª–∞–π—Å–∞–º–∏ ===")
    
    // –°–æ–∑–¥–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Å–ª–∞–π—Å
    original := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    fmt.Printf("–ò—Å—Ö–æ–¥–Ω—ã–π: %v\n", original)
    
    // –°–æ–∑–¥–∞–µ–º –ø–æ–¥—Å–ª–∞–π—Å - –æ–Ω —Ä–∞–∑–¥–µ–ª—è–µ—Ç –ø–∞–º—è—Ç—å —Å original!
    subSlice := original[2:7] // —ç–ª–µ–º–µ–Ω—Ç—ã —Å –∏–Ω–¥–µ–∫—Å–∞–º–∏ 2-6
    fmt.Printf("–ü–æ–¥—Å–ª–∞–π—Å: %v (len=%d, cap=%d)\n", subSlice, len(subSlice), cap(subSlice))
    
    // –ò–∑–º–µ–Ω—è–µ–º –ø–æ–¥—Å–ª–∞–π—Å
    subSlice[0] = 999
    
    fmt.Printf("–ü–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–¥—Å–ª–∞–π—Å–∞:\n")
    fmt.Printf("–ò—Å—Ö–æ–¥–Ω—ã–π: %v\n", original)   // –ò–∑–º–µ–Ω–∏–ª—Å—è!
    fmt.Printf("–ü–æ–¥—Å–ª–∞–π—Å: %v\n", subSlice)
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
    safeCopy := make([]int, len(subSlice))
    copy(safeCopy, subSlice)
    safeCopy[1] = 777
    
    fmt.Printf("–ü–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–ø–∏–∏:\n")
    fmt.Printf("–ò—Å—Ö–æ–¥–Ω—ã–π: %v\n", original)   // –ù–ï –∏–∑–º–µ–Ω–∏–ª—Å—è
    fmt.Printf("–ü–æ–¥—Å–ª–∞–π—Å: %v\n", subSlice)   // –ù–ï –∏–∑–º–µ–Ω–∏–ª—Å—è  
    fmt.Printf("–ö–æ–ø–∏—è:    %v\n", safeCopy)   // –ò–∑–º–µ–Ω–∏–ª—Å—è —Ç–æ–ª—å–∫–æ –æ–Ω
}

// üéØ –≠–§–§–ï–ö–¢–ò–í–ù–ê–Ø –†–ê–ë–û–¢–ê –°–û –°–õ–ê–ô–°–ê–ú–ò
type IntSlice []int

// –ú–µ—Ç–æ–¥ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞
func (s *IntSlice) RemoveAt(index int) {
    if index < 0 || index >= len(*s) {
        return
    }
    
    // –°–¥–≤–∏–≥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤–ª–µ–≤–æ
    copy((*s)[index:], (*s)[index+1:])
    *s = (*s)[:len(*s)-1] // –£–º–µ–Ω—å—à–∞–µ–º –¥–ª–∏–Ω—É
}

// –ú–µ—Ç–æ–¥ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ —ç–ª–µ–º–µ–Ω—Ç–∞
func (s *IntSlice) InsertAt(index int, value int) {
    if index < 0 || index > len(*s) {
        return
    }
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–ª–∞–π—Å
    *s = append(*s, 0)
    
    // –°–¥–≤–∏–≥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤–ø—Ä–∞–≤–æ
    copy((*s)[index+1:], (*s)[index:])
    
    // –í—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
    (*s)[index] = value
}

func sliceOperationsDemo() {
    fmt.Println("=== –û–ø–µ—Ä–∞—Ü–∏–∏ —Å–æ —Å–ª–∞–π—Å–∞–º–∏ ===")
    
    slice := IntSlice{10, 20, 30, 40, 50}
    fmt.Printf("–ò—Å—Ö–æ–¥–Ω—ã–π: %v\n", slice)
    
    // –í—Å—Ç–∞–≤–∫–∞
    slice.InsertAt(2, 999)
    fmt.Printf("–ü–æ—Å–ª–µ –≤—Å—Ç–∞–≤–∫–∏ 999 –≤ –ø–æ–∑–∏—Ü–∏—é 2: %v\n", slice)
    
    // –£–¥–∞–ª–µ–Ω–∏–µ
    slice.RemoveAt(3)
    fmt.Printf("–ü–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –ø–æ–∑–∏—Ü–∏–∏ 3: %v\n", slice)
}

// üèÜ –°–õ–û–ñ–ù–û–°–¢–¨ –û–ü–ï–†–ê–¶–ò–ô
func complexityDemo() {
    fmt.Println("=== –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π —Å –º–∞—Å—Å–∏–≤–∞–º–∏/—Å–ª–∞–π—Å–∞–º–∏ ===")
    fmt.Println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    fmt.Println("‚îÇ –û–ø–µ—Ä–∞—Ü–∏—è        ‚îÇ –í—Ä–µ–º—è   ‚îÇ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ       ‚îÇ")
    fmt.Println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    fmt.Println("‚îÇ –î–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É‚îÇ O(1)   ‚îÇ –ü—Ä—è–º–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ ‚îÇ")
    fmt.Println("‚îÇ –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞  ‚îÇ O(n)    ‚îÇ –ü—Ä–æ—Ö–æ–¥ –ø–æ –≤—Å–µ–º   ‚îÇ")
    fmt.Println("‚îÇ –í—Å—Ç–∞–≤–∫–∞ –≤ –∫–æ–Ω–µ—Ü ‚îÇ O(1)*   ‚îÇ –ï—Å–ª–∏ –µ—Å—Ç—å –º–µ—Å—Ç–æ  ‚îÇ")
    fmt.Println("‚îÇ –í—Å—Ç–∞–≤–∫–∞ –≤ –Ω–∞—á–∞–ª–æ‚îÇ O(n)    ‚îÇ –°–¥–≤–∏–≥ –≤—Å–µ—Ö       ‚îÇ")
    fmt.Println("‚îÇ –£–¥–∞–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ü–µ‚îÇ O(1)    ‚îÇ –ü—Ä–æ—Å—Ç–æ len--     ‚îÇ")
    fmt.Println("‚îÇ –£–¥–∞–ª–µ–Ω–∏–µ –≤ —Å–µ—Ä. ‚îÇ O(n)    ‚îÇ –°–¥–≤–∏–≥ —ç–ª–µ–º–µ–Ω—Ç–æ–≤  ‚îÇ")
    fmt.Println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    fmt.Println("* –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è")
}
```

---

## –ú–æ–¥—É–ª—å 4: –°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ - –ì–∏–±–∫–æ—Å—Ç—å –ø—Ä–æ—Ç–∏–≤ —Å–∫–æ—Ä–æ—Å—Ç–∏

### üîó –ê–Ω–∞—Ç–æ–º–∏—è —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞

```
–°–í–Ø–ó–ê–ù–ù–´–ô –°–ü–ò–°–û–ö - –¶–ï–ü–û–ß–ö–ê –£–ó–õ–û–í:

–û–î–ù–û–°–í–Ø–ó–ù–´–ô –°–ü–ò–°–û–ö:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Node 1      ‚îÇ    ‚îÇ Node 2      ‚îÇ    ‚îÇ Node 3      ‚îÇ    ‚îÇ Node 4      ‚îÇ
‚îÇ Value: 10   ‚îÇ    ‚îÇ Value: 20   ‚îÇ    ‚îÇ Value: 30   ‚îÇ    ‚îÇ Value: 40   ‚îÇ
‚îÇ Next: ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Next: ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Next: ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Next: nil   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚Üë
   head pointer

–ü–û–ò–°–ö –≠–õ–ï–ú–ï–ù–¢–ê 30:
1. –ù–∞—á–∏–Ω–∞–µ–º —Å head (Node 1)
2. –ü—Ä–æ–≤–µ—Ä—è–µ–º value: 10 ‚â† 30, –∏–¥–µ–º –∫ next
3. Node 2: value: 20 ‚â† 30, –∏–¥–µ–º –∫ next  
4. Node 3: value: 30 = 30, –ù–ê–ô–î–ï–ù!

–®–∞–≥–æ–≤: 3 (–≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ N —à–∞–≥–æ–≤) ‚Üí O(n)

–î–í–£–°–í–Ø–ó–ù–´–ô –°–ü–ò–°–û–ö - –ú–û–ñ–ù–û –ò–î–¢–ò –í –û–ë–ï –°–¢–û–†–û–ù–´:
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   nil ‚óÑ‚î§ Prev: nil   ‚îÇ‚óÑ‚îÄ‚îÄ‚î§ Prev: ‚óè     ‚îÇ‚óÑ‚îÄ‚îÄ‚î§ Prev: ‚óè     ‚îÇ
        ‚îÇ Value: 10   ‚îÇ    ‚îÇ Value: 20   ‚îÇ    ‚îÇ Value: 30   ‚îÇ
        ‚îÇ Next: ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Next: ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Next: nil   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚Üë                                      ‚Üë
          head                                   tail

–ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –î–í–£–°–í–Ø–ó–ù–û–ì–û:
‚úÖ –£–¥–∞–ª–µ–Ω–∏–µ —É–∑–ª–∞ –∑–∞ O(1) –µ—Å–ª–∏ –µ—Å—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω–µ–≥–æ
‚úÖ –û–±—Ö–æ–¥ –≤ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã
‚úÖ –í—Å—Ç–∞–≤–∫–∞ –ø–µ—Ä–µ–¥ —É–∑–ª–æ–º –∑–∞ O(1)

–ù–ï–î–û–°–¢–ê–¢–ö–ò:
‚ùå –ë–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏ (extra pointer)
‚ùå –ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –≤ Go

```go
package main

import "fmt"

// üîó –û–î–ù–û–°–í–Ø–ó–ù–´–ô –°–ü–ò–°–û–ö
type ListNode struct {
    Value int
    Next  *ListNode
}

type LinkedList struct {
    Head *ListNode
    Size int
}

// –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Å–ø–∏—Å–∫–∞
func NewLinkedList() *LinkedList {
    return &LinkedList{Head: nil, Size: 0}
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –Ω–∞—á–∞–ª–æ (—Å–∞–º–∞—è –±—ã—Å—Ç—Ä–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è)
func (ll *LinkedList) Prepend(value int) {
    newNode := &ListNode{Value: value, Next: ll.Head}
    ll.Head = newNode
    ll.Size++
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü (–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è)
func (ll *LinkedList) Append(value int) {
    newNode := &ListNode{Value: value, Next: nil}
    
    if ll.Head == nil {
        ll.Head = newNode
    } else {
        // –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —É–∑–µ–ª
        current := ll.Head
        for current.Next != nil {
            current = current.Next
        }
        current.Next = newNode
    }
    ll.Size++
}

// –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞
func (ll *LinkedList) Find(value int) *ListNode {
    current := ll.Head
    for current != nil {
        if current.Value == value {
            return current
        }
        current = current.Next
    }
    return nil
}

// –£–¥–∞–ª–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–∂–¥–µ–Ω–∏—è
func (ll *LinkedList) Remove(value int) bool {
    if ll.Head == nil {
        return false
    }
    
    // –£–¥–∞–ª—è–µ–º –≥–æ–ª–æ–≤–Ω–æ–π —ç–ª–µ–º–µ–Ω—Ç
    if ll.Head.Value == value {
        ll.Head = ll.Head.Next
        ll.Size--
        return true
    }
    
    // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    current := ll.Head
    for current.Next != nil {
        if current.Next.Value == value {
            current.Next = current.Next.Next // "–ø–µ—Ä–µ–ø—Ä—ã–≥–∏–≤–∞–µ–º" —É–∑–µ–ª
            ll.Size--
            return true
        }
        current = current.Next
    }
    
    return false
}

// –í—Å—Ç–∞–≤–∫–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É
func (ll *LinkedList) InsertAt(index int, value int) bool {
    if index < 0 || index > ll.Size {
        return false
    }
    
    if index == 0 {
        ll.Prepend(value)
        return true
    }
    
    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
    current := ll.Head
    for i := 0; i < index-1; i++ {
        current = current.Next
    }
    
    newNode := &ListNode{Value: value, Next: current.Next}
    current.Next = newNode
    ll.Size++
    return true
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
func (ll *LinkedList) String() string {
    if ll.Head == nil {
        return "[]"
    }
    
    result := "["
    current := ll.Head
    for current != nil {
        result += fmt.Sprintf("%d", current.Value)
        if current.Next != nil {
            result += " -> "
        }
        current = current.Next
    }
    result += "]"
    return result
}

// üîó –î–í–£–°–í–Ø–ó–ù–´–ô –°–ü–ò–°–û–ö (–±–æ–ª–µ–µ —ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π)
type DoublyNode struct {
    Value int
    Next  *DoublyNode
    Prev  *DoublyNode
}

type DoublyLinkedList struct {
    Head *DoublyNode
    Tail *DoublyNode
    Size int
}

func NewDoublyLinkedList() *DoublyLinkedList {
    return &DoublyLinkedList{Head: nil, Tail: nil, Size: 0}
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü (–±—ã—Å—Ç—Ä–æ –±–ª–∞–≥–æ–¥–∞—Ä—è tail pointer)
func (dll *DoublyLinkedList) Append(value int) {
    newNode := &DoublyNode{Value: value, Next: nil, Prev: dll.Tail}
    
    if dll.Head == nil {
        // –°–ø–∏—Å–æ–∫ –ø—É—Å—Ç
        dll.Head = newNode
        dll.Tail = newNode
    } else {
        dll.Tail.Next = newNode
        dll.Tail = newNode
    }
    dll.Size++
}

// –£–¥–∞–ª–µ–Ω–∏–µ —É–∑–ª–∞ (–±—ã—Å—Ç—Ä–æ –µ—Å–ª–∏ –µ—Å—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —É–∑–µ–ª)
func (dll *DoublyLinkedList) RemoveNode(node *DoublyNode) {
    if node == nil {
        return
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É–∑–ª–∞
    if node.Prev != nil {
        node.Prev.Next = node.Next
    } else {
        // –£–¥–∞–ª—è–µ–º –≥–æ–ª–æ–≤–Ω–æ–π —É–∑–µ–ª
        dll.Head = node.Next
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞
    if node.Next != nil {
        node.Next.Prev = node.Prev
    } else {
        // –£–¥–∞–ª—è–µ–º —Ö–≤–æ—Å—Ç–æ–≤–æ–π —É–∑–µ–ª
        dll.Tail = node.Prev
    }
    
    dll.Size--
}

// üìä –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func linkedListPerformanceDemo() {
    fmt.Println("=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ===")
    
    const size = 100000
    
    // –¢–µ—Å—Ç –æ–¥–Ω–æ—Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
    ll := NewLinkedList()
    
    start := time.Now()
    for i := 0; i < size; i++ {
        ll.Prepend(i) // O(1) –æ–ø–µ—Ä–∞—Ü–∏—è
    }
    prependTime := time.Since(start)
    
    start = time.Now()
    for i := 0; i < size; i++ {
        ll.Append(i) // O(n) –æ–ø–µ—Ä–∞—Ü–∏—è!
    }
    appendTime := time.Since(start)
    
    fmt.Printf("Prepend %d —ç–ª–µ–º–µ–Ω—Ç–æ–≤: %v\n", size, prependTime)
    fmt.Printf("Append %d —ç–ª–µ–º–µ–Ω—Ç–æ–≤: %v\n", size, appendTime)
    fmt.Printf("Append –º–µ–¥–ª–µ–Ω–Ω–µ–µ –≤ %.0f —Ä–∞–∑\n", float64(appendTime)/float64(prependTime))
    
    // –¢–µ—Å—Ç –ø–æ–∏—Å–∫–∞
    start = time.Now()
    found := ll.Find(size / 2) // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ
    searchTime := time.Since(start)
    
    fmt.Printf("–ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞: %v (–Ω–∞–π–¥–µ–Ω: %t)\n", searchTime, found != nil)
}

// üéØ –ö–û–ì–î–ê –ò–°–ü–û–õ–¨–ó–û–í–ê–¢–¨ –°–í–Ø–ó–ê–ù–ù–´–ï –°–ü–ò–°–ö–ò
func useCasesDemo() {
    fmt.Println("=== –°–ª—É—á–∞–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤ ===")
    
    fmt.Println("‚úÖ –•–û–†–û–®–û –¥–ª—è:")
    fmt.Println("  ‚Ä¢ –ß–∞—Å—Ç—ã–µ –≤—Å—Ç–∞–≤–∫–∏/—É–¥–∞–ª–µ–Ω–∏—è –≤ –Ω–∞—á–∞–ª–µ")
    fmt.Println("  ‚Ä¢ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö")  
    fmt.Println("  ‚Ä¢ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–µ–∫–æ–≤/–æ—á–µ—Ä–µ–¥–µ–π")
    fmt.Println("  ‚Ä¢ –ö–æ–≥–¥–∞ –Ω—É–∂–Ω–∞ —ç–∫–æ–Ω–æ–º–∏—è –ø–∞–º—è—Ç–∏ –ø—Ä–∏ sparse data")
    
    fmt.Println("\n‚ùå –ü–õ–û–•–û –¥–ª—è:")
    fmt.Println("  ‚Ä¢ –ß–∞—Å—Ç—ã–π –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É")
    fmt.Println("  ‚Ä¢ –ü–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤")
    fmt.Println("  ‚Ä¢ –°–ª—É—á–∞–π–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º")
    fmt.Println("  ‚Ä¢ –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–∞ cache locality")
    
    // –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: –∏—Å—Ç–æ—Ä–∏—è –±—Ä–∞—É–∑–µ—Ä–∞
    fmt.Println("\nüì± –ü–†–ò–ú–ï–†: –ò—Å—Ç–æ—Ä–∏—è –±—Ä–∞—É–∑–µ—Ä–∞")
    
    type BrowserHistory struct {
        pages    *DoublyLinkedList
        current  *DoublyNode
    }
    
    func (bh *BrowserHistory) visitPage(url string) {
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–π
        // –£–¥–∞–ª—è–µ–º –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –ø–æ—Å–ª–µ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ (–∫–∞–∫ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ)
    }
    
    func (bh *BrowserHistory) goBack() string {
        if bh.current != nil && bh.current.Prev != nil {
            bh.current = bh.current.Prev
            // return page URL
        }
        return ""
    }
    
    func (bh *BrowserHistory) goForward() string {
        if bh.current != nil && bh.current.Next != nil {
            bh.current = bh.current.Next
            // return page URL  
        }
        return ""
    }
    
    fmt.Println("–î–≤—É—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–¥–µ–∞–ª–µ–Ω –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ –±—Ä–∞—É–∑–µ—Ä–∞:")
    fmt.Println("- O(1) –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞–∑–∞–¥/–≤–ø–µ—Ä–µ–¥")
    fmt.Println("- O(1) –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã")
    fmt.Println("- –ü—Ä–æ—Å—Ç–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ forward history")
}
```

### ‚öñÔ∏è –ú–∞—Å—Å–∏–≤—ã vs –°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏: –î–µ—Ç–∞–ª—å–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ

```go
// üìä –ü–û–î–†–û–ë–ù–û–ï –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
func detailedComparison() {
    fmt.Println("=== –î–µ—Ç–∞–ª—å–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –ú–∞—Å—Å–∏–≤—ã vs –°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ ===")
    
    const size = 100000
    
    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    slice := make([]int, 0, size)
    linkedList := NewLinkedList()
    
    fmt.Println("\nüèóÔ∏è –ü–û–°–¢–†–û–ï–ù–ò–ï –ö–û–õ–õ–ï–ö–¶–ò–ò:")
    
    // –¢–µ—Å—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è slice
    start := time.Now()
    for i := 0; i < size; i++ {
        slice = append(slice, i)
    }
    sliceBuildTime := time.Since(start)
    
    // –¢–µ—Å—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è linked list  
    start = time.Now()
    for i := 0; i < size; i++ {
        linkedList.Prepend(i)
    }
    listBuildTime := time.Since(start)
    
    fmt.Printf("Slice (append):      %v\n", sliceBuildTime)
    fmt.Printf("LinkedList (prepend): %v\n", listBuildTime)
    
    fmt.Println("\nüîç –ü–û–ò–°–ö –≠–õ–ï–ú–ï–ù–¢–û–í:")
    
    searchValue := size / 2
    
    // –ü–æ–∏—Å–∫ –≤ slice (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫)
    start = time.Now()
    var found bool
    for _, v := range slice {
        if v == searchValue {
            found = true
            break
        }
    }
    sliceSearchTime := time.Since(start)
    
    // –ü–æ–∏—Å–∫ –≤ linked list
    start = time.Now()
    foundNode := linkedList.Find(searchValue)
    listSearchTime := time.Since(start)
    
    fmt.Printf("Slice (linear search): %v (–Ω–∞–π–¥–µ–Ω: %t)\n", sliceSearchTime, found)
    fmt.Printf("LinkedList (traverse): %v (–Ω–∞–π–¥–µ–Ω: %t)\n", listSearchTime, foundNode != nil)
    
    fmt.Println("\nüíæ –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï –ü–ê–ú–Ø–¢–ò:")
    
    // –ü–∞–º—è—Ç—å –¥–ª—è slice
    sliceMemory := len(slice) * 8 // 8 –±–∞–π—Ç –Ω–∞ int64
    
    // –ü–∞–º—è—Ç—å –¥–ª—è linked list (–±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ)
    // –ö–∞–∂–¥—ã–π —É–∑–µ–ª: 8 –±–∞–π—Ç (value) + 8 –±–∞–π—Ç (pointer) = 16 –±–∞–π—Ç
    listMemory := linkedList.Size * 16
    
    fmt.Printf("Slice memory:      %d –±–∞–π—Ç (%d –±–∞–π—Ç –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç)\n", sliceMemory, 8)
    fmt.Printf("LinkedList memory: %d –±–∞–π—Ç (%d –±–∞–π—Ç –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç)\n", listMemory, 16)
    fmt.Printf("Overhead —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞: %.1fx\n", float64(listMemory)/float64(sliceMemory))
    
    fmt.Println("\nüéØ –í–´–í–û–î:")
    fmt.Println("–ú–∞—Å—Å–∏–≤—ã/—Å–ª–∞–π—Å—ã –ø–æ–±–µ–∂–¥–∞—é—Ç –≤:")
    fmt.Println("  ‚úÖ –°–∫–æ—Ä–æ—Å—Ç–∏ –¥–æ—Å—Ç—É–ø–∞ (O(1) vs O(n))")
    fmt.Println("  ‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞–º—è—Ç–∏ (–º–µ–Ω—å—à–µ overhead)")
    fmt.Println("  ‚úÖ Cache locality (–ª—É—á—à–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)")
    
    fmt.Println("\n–°–≤—è–∑–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –ø–æ–±–µ–∂–¥–∞—é—Ç –≤:")
    fmt.Println("  ‚úÖ –í—Å—Ç–∞–≤–∫–µ –≤ –Ω–∞—á–∞–ª–æ (O(1) vs O(n))")
    fmt.Println("  ‚úÖ –£–¥–∞–ª–µ–Ω–∏–∏ –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º –º–µ—Å—Ç–µ (O(1) vs O(n) –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è)")
    fmt.Println("  ‚úÖ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–º —Ä–∞–∑–º–µ—Ä–µ –±–µ–∑ –ø–µ—Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏")
}
```

---

## –ú–æ–¥—É–ª—å 5: –°—Ç–µ–∫–∏ –∏ –æ—á–µ—Ä–µ–¥–∏ - LIFO –∏ FIFO –≤ –¥–µ–π—Å—Ç–≤–∏–∏

### üìö –°—Ç–µ–∫ (Stack) - Last In, First Out

```
–°–¢–ï–ö - –ö–ê–ö –°–¢–û–ü–ö–ê –¢–ê–†–ï–õ–û–ö:

–û–ü–ï–†–ê–¶–ò–ò PUSH (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ):
    
–®–∞–≥ 1: push(10)        –®–∞–≥ 2: push(20)        –®–∞–≥ 3: push(30)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ        ‚îÇ     30      ‚îÇ ‚Üê top
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ             ‚îÇ        ‚îÇ     20      ‚îÇ ‚Üê top   ‚îÇ     20      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ             ‚îÇ        ‚îÇ     10      ‚îÇ        ‚îÇ     10      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     10      ‚îÇ ‚Üê top   ‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–û–ü–ï–†–ê–¶–ò–ò POP (—É–¥–∞–ª–µ–Ω–∏–µ):

pop() ‚Üí 30             pop() ‚Üí 20             pop() ‚Üí 10
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     20      ‚îÇ ‚Üê top   ‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     10      ‚îÇ        ‚îÇ     10      ‚îÇ ‚Üê top   ‚îÇ             ‚îÇ ‚Üê top (empty)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ        ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üî• –ì–õ–ê–í–ù–´–ô –ü–†–ò–ù–¶–ò–ü: –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π = –ø–µ—Ä–≤—ã–π —É–¥–∞–ª—è–µ–º—ã–π
```

### üö∂‚Äç‚ôÇÔ∏è –û—á–µ—Ä–µ–¥—å (Queue) - First In, First Out

```
–û–ß–ï–†–ï–î–¨ - –ö–ê–ö –û–ß–ï–†–ï–î–¨ –í –ú–ê–ì–ê–ó–ò–ù–ï:

–û–ü–ï–†–ê–¶–ò–ò ENQUEUE (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü):

–®–∞–≥ 1: enqueue(A)      –®–∞–≥ 2: enqueue(B)      –®–∞–≥ 3: enqueue(C)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      A      ‚îÇ        ‚îÇ   A ‚îÇ B     ‚îÇ        ‚îÇ A ‚îÇ B ‚îÇ C   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 ‚Üë           ‚Üë         ‚Üë           ‚Üë         ‚Üë           ‚Üë
front       rear      front       rear      front       rear

–û–ü–ï–†–ê–¶–ò–ò DEQUEUE (—É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –Ω–∞—á–∞–ª–∞):

dequeue() ‚Üí A          dequeue() ‚Üí B          dequeue() ‚Üí C
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     B ‚îÇ C   ‚îÇ        ‚îÇ       C     ‚îÇ        ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 ‚Üë           ‚Üë         ‚Üë           ‚Üë         ‚Üë           ‚Üë
front       rear      front       rear      front       rear

üéØ –ì–õ–ê–í–ù–´–ô –ü–†–ò–ù–¶–ò–ü: –ø–µ—Ä–≤—ã–π –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π = –ø–µ—Ä–≤—ã–π —É–¥–∞–ª—è–µ–º—ã–π
```

### üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–µ–∫–∞ –≤ Go

```go
package main

import (
    "errors"
    "fmt"
)

// üìö –°–¢–ï–ö –ù–ê –û–°–ù–û–í–ï –°–õ–ê–ô–°–ê
type Stack struct {
    items []int
}

func NewStack() *Stack {
    return &Stack{items: make([]int, 0)}
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ (Push)
func (s *Stack) Push(item int) {
    s.items = append(s.items, item)
}

// –£–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ (Pop)
func (s *Stack) Pop() (int, error) {
    if len(s.items) == 0 {
        return 0, errors.New("stack is empty")
    }
    
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index] // –£–∫–æ—Ä–∞—á–∏–≤–∞–µ–º —Å–ª–∞–π—Å
    return item, nil
}

// –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–µ—Ä—Ö–Ω–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ (Peek)
func (s *Stack) Peek() (int, error) {
    if len(s.items) == 0 {
        return 0, errors.New("stack is empty")
    }
    
    return s.items[len(s.items)-1], nil
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É
func (s *Stack) IsEmpty() bool {
    return len(s.items) == 0
}

// –†–∞–∑–º–µ—Ä —Å—Ç–µ–∫–∞
func (s *Stack) Size() int {
    return len(s.items)
}

// –ü—Ä–µ