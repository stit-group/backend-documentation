# Компактное техническое собеседование Backend разработчика
## Глубокое понимание структур данных и управления памятью

### Инструкции для интервьюера
- **Время**: 45-60 минут
- **Формат**: 2-3 основных блока + практическое задание
- **Фокус**: Понимание принципов + умение применять на практике
- **Оценка**: Глубина объяснений + качество решений

---

## Блок 1: Массивы и управление памятью (15-20 мин)

### Основной вопрос: Объясните разницу между статическими и динамическими массивами. Реализуйте динамический массив с оптимальной стратегией роста.

**Код для анализа:**
```python
# Что не так с этим кодом с точки зрения памяти?
def process_data(items):
    result = []
    for item in items:
        if is_valid(item):
            result.append(transform(item))
        result = result + [item]  # Проблема здесь
    return result
```

**Углубляющие вопросы:**
1. **Memory Layout**: Как массивы хранятся в памяти? Что такое cache locality?
2. **Growth Strategy**: Почему коэффициент роста 1.5-2? Что такое amortized analysis?
3. **Optimization**: Как memory alignment и padding влияют на производительность?
4. **Real-world**: Когда использовать ArrayList vs LinkedList vs деque?

**Ожидаемый ответ должен включать:**
- Понимание memory layout и cache effects
- Знание amortized O(1) для append операций
- Объяснение trade-offs между memory и временем
- Практические соображения (prefetching, NUMA)

---

## Блок 2: Сложные структуры данных (15-20 мин)

### Основной вопрос: Дизайн LRU Cache с O(1) операциями. Объясните choice структур данных и memory overhead.

**Практическое задание:**
```python
class LRUCache:
    def __init__(self, capacity):
        # Реализуйте с объяснением memory usage
        pass
    
    def get(self, key):
        # O(1) с минимальным memory overhead
        pass
    
    def put(self, key, value):
        # Обработайте eviction policy
        pass
```

**Углубляющие вопросы:**
1. **Data Structures**: Почему HashMap + DoublyLinkedList? Альтернативы?
2. **Memory Efficiency**: Как минимизировать pointer overhead?
3. **Concurrency**: Как реализовать thread-safe версию?
4. **Variants**: Clock algorithm, 2Q, ARC - когда что использовать?
5. **Scale**: Как адаптировать для distributed cache?

**Оценка глубины:**
- **Junior**: Может объяснить basic approach
- **Middle**: Понимает trade-offs, может оптимизировать
- **Senior**: Знает advanced variants, concurrent solutions

---

## Блок 3: Системное мышление (10-15 мин)

### Комплексный вопрос: Дизайн системы для real-time analytics с ограниченной памятью

**Сценарий:**
```
Входящий поток: 1M events/sec
Память: 8GB RAM
Требования: 
- Top-K queries за последние 5 минут
- Memory-efficient storage
- Low latency responses (<10ms)
```

**Ключевые аспекты для обсуждения:**
1. **Data Structures**: Какие использовать и почему?
2. **Memory Management**: Sliding window, eviction policies
3. **Approximation**: Когда точность можно пожертвовать для памяти?
4. **Trade-offs**: CPU vs Memory vs Accuracy

**Углубляющие вопросы:**
- Bloom filters для membership queries
- Count-Min Sketch для frequency estimation  
- HyperLogLog для cardinality estimation
- Reservoir sampling для representative samples

---

## Практическое задание (10-15 мин)

### Задача: Реализуйте memory-efficient алгоритм для finding duplicate elements

```python
def find_duplicates_memory_efficient(stream):
    """
    Найти дубликаты в потоке данных с ограниченной памятью
    
    Constraints:
    - Stream может быть очень большим (не помещается в память)
    - Доступная память: O(√n) 
    - Нужно минимизировать false positives
    """
    pass
```

**Критерии оценки:**
1. **Алгоритмическое мышление**: Выбор подходящего алгоритма
2. **Memory analysis**: Понимание space complexity
3. **Trade-offs**: Обоснование решений
4. **Edge cases**: Обработка граничных случаев

**Возможные решения для обсуждения:**
- Bloom filter + secondary verification
- External sorting approach
- Probabilistic counting
- Hybrid approaches

---

## Дополнительные темы для Senior+ (по времени)

### Quick-fire вопросы (5 мин):

1. **Garbage Collection**: Generational GC vs Mark-and-Sweep - когда что лучше?

2. **Lock-free Programming**: ABA problem и способы решения

3. **Memory Models**: Что такое memory barriers и зачем нужны?

4. **Database Internals**: B+ tree vs LSM tree - memory implications

5. **Distributed Systems**: CAP theorem и memory consistency

---

## Система оценки

### Memory Fundamentals (30%)
- [ ] Понимание memory layout и cache effects
- [ ] Знание основных структур данных
- [ ] Умение анализировать space complexity

### Algorithm Design (40%)
- [ ] Выбор оптимальных структур данных
- [ ] Понимание trade-offs
- [ ] Способность к оптимизации

### Systems Thinking (30%)
- [ ] Масштабируемость решений
- [ ] Real-world constraints
- [ ] Performance considerations

### Уровни:
- **Junior (50-65%)**: Знает основы, может реализовать basic solutions
- **Middle (65-80%)**: Понимает trade-offs, оптимизирует решения
- **Senior (80-90%)**: Системное мышление, advanced optimizations
- **Principal (90%+)**: Инновационные подходы, глубокая экспертиза

---

## Красные флаги

❌ **Избегайте кандидатов, которые:**
- Не могут объяснить time/space complexity
- Не понимают разницу между stack и heap
- Не знают основные структуры данных
- Не могут обосновать выбор решения
- Фокусируются только на "работающем" коде без оптимизации

✅ **Сильные кандидаты:**
- Объясняют принципы простыми словами
- Приводят real-world examples
- Понимают системные ограничения
- Могут адаптировать решения под constraints
- Задают уточняющие вопросы

---

## Подготовка интервьюера

### Перед интервью:
1. Изучите резюме кандидата
2. Подготовьте 2-3 follow-up вопроса на основе опыта
3. Настройте coding environment (если нужно)

### Во время интервью:
- Больше слушайте, чем говорите
- Задавайте "почему" вместо "что"
- Подстраивайте сложность под уровень кандидата
- Фокусируйтесь на процессе мышления, не только результате

### После интервью:
- Записывайте конкретные примеры ответов
- Оценивайте по критериям, не по "общему впечатлению"
- Обсуждайте с другими интервьюерами