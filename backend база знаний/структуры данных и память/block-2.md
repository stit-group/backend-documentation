# Блок 2: Линейные структуры данных

**⏱️ Длительность:** 3-4 недели  
**🎯 Цель:** Освоить базовые структуры для последовательного хранения данных

---

## 2.1 Массивы и их вариации

### Статические массивы

Статический массив - это непрерывная область памяти, где элементы расположены последовательно.

```
Статический массив int arr[5] = {10, 20, 30, 40, 50}

Память:
┌────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │
└────┴────┴────┴────┴────┘
  0    1    2    3    4    (индексы)

Адреса в памяти (например):
0x1000 0x1004 0x1008 0x100C 0x1010
```

**Характеристики:**
- ✅ **Доступ по индексу:** O(1)
- ✅ **Кэш-дружественность:** отличная
- ❌ **Изменение размера:** невозможно
- ❌ **Вставка/удаление:** O(n)

### Динамические массивы (Vector/ArrayList)

Динамический массив автоматически увеличивает размер при необходимости.

```
Рост динамического массива:

Начальное состояние (capacity = 4):
┌────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ ?? │
└────┴────┴────┴────┘
size = 3, capacity = 4

После добавления элементов 40, 50:
┌────┬────┬────┬────┐  Переполнение!
│ 10 │ 20 │ 30 │ 40 │
└────┴────┴────┴────┘

Перевыделение памяти (capacity = 8):
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │ ?? │ ?? │ ?? │
└────┴────┴────┴────┴────┴────┴────┴────┘
size = 5, capacity = 8
```

**Стратегии роста:**
- **Геометрическое:** новый размер = старый × 2 (или × 1.5)
- **Арифметическое:** новый размер = старый + константа

### Многомерные массивы

```
2D массив в памяти (row-major order):

Логическое представление:
┌────┬────┬────┐
│ 1  │ 2  │ 3  │
├────┼────┼────┤
│ 4  │ 5  │ 6  │
└────┴────┴────┘

Физическое расположение в памяти:
┌───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
└───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

Формула доступа: arr[i][j] = *(arr + i * cols + j)
```

### Кольцевые буферы

```
Кольцевой буфер (Ring Buffer):

Состояние 1:
     head=0, tail=0
┌────┬────┬────┬────┬────┐
│ ?? │ ?? │ ?? │ ?? │ ?? │
└────┴────┴────┴────┴────┘
  0    1    2    3    4

После добавления A, B, C:
     head=0, tail=3
┌────┬────┬────┬────┬────┐
│ A  │ B  │ C  │ ?? │ ?? │
└────┴────┴────┴────┴────┘
  0    1    2    3    4

После удаления A, B и добавления D, E, F:
     head=2, tail=1
┌────┬────┬────┬────┬────┐
│ F  │ ?? │ C  │ D  │ E  │
└────┴────┴────┴────┴────┘
  0    1    2    3    4
```

---

## 2.2 Связные списки

### Односвязный список

```
Односвязный список:

┌──────┬────┐    ┌──────┬────┐    ┌──────┬────┐
│ data │next│───▶│ data │next│───▶│ data │NULL│
│  10  │  ──│    │  20  │  ──│    │  30  │ ── │
└──────┴────┘    └──────┴────┘    └──────┴────┘
   Node 1           Node 2           Node 3

HEAD ───▶ Node 1
```

**Операции:**

```
Вставка в начало:
Before:  HEAD ───▶ [10|─] ───▶ [20|─] ───▶ NULL
After:   HEAD ───▶ [5|─] ───▶ [10|─] ───▶ [20|─] ───▶ NULL

Удаление из середины:
Before:  HEAD ───▶ [10|─] ───▶ [20|─] ───▶ [30|─] ───▶ NULL
After:   HEAD ───▶ [10|─] ────────────▶ [30|─] ───▶ NULL
                              [20|X] (освобождаем память)
```

### Двусвязный список

```
Двусвязный список:

     ┌──────┬────┬────┐    ┌──────┬────┬────┐    ┌──────┬────┬────┐
NULL◀│prev  │data│next│◀──▶│prev  │data│next│◀──▶│prev  │data│next│───▶NULL
     │ ──   │ 10 │ ── │    │ ──   │ 20 │ ── │    │ ──   │ 30 │ ── │
     └──────┴────┴────┘    └──────┴────┴────┘    └──────┴────┴────┘
        Node 1                 Node 2                 Node 3

HEAD ───▶ Node 1                                              ◀─── TAIL
```

### XOR-список (экономия памяти)

```
XOR-список (каждый узел хранит XOR адресов предыдущего и следующего):

┌──────┬─────────┐    ┌──────┬─────────┐    ┌──────┬─────────┐
│ data │   XOR   │    │ data │   XOR   │    │ data │   XOR   │
│  10  │ 0⊕addr2 │    │  20  │addr1⊕addr3  │  30  │addr2⊕0 │
└──────┴─────────┘    └──────┴─────────┘    └──────┴─────────┘
   addr1                addr2                addr3

Навигация: next = prev ⊕ node.xor
          prev = next ⊕ node.xor
```

---

## 2.3 Стеки и очереди

### Стек (LIFO - Last In, First Out)

```
Стек на массиве:

Операция PUSH:
┌───┬───┬───┬───┬───┐     ┌───┬───┬───┬───┬───┐
│ A │ B │ C │   │   │ ──▶ │ A │ B │ C │ D │   │
└───┴───┴───┴───┴───┘     └───┴───┴───┴───┴───┘
          ↑                           ↑
        top=2                       top=3

Операция POP:
┌───┬───┬───┬───┬───┐     ┌───┬───┬───┬───┬───┐
│ A │ B │ C │ D │   │ ──▶ │ A │ B │ C │   │   │
└───┴───┴───┴───┴───┘     └───┴───┴───┴───┴───┘
          ↑                       ↑
        top=3                   top=2
```

### Применение стека: Проверка скобок

```
Строка: "({[]})"

Шаг 1: '(' ──▶ PUSH    Stack: [  (  ]
Шаг 2: '{' ──▶ PUSH    Stack: [  (  {  ]
Шаг 3: '[' ──▶ PUSH    Stack: [  (  {  [  ]
Шаг 4: ']' ──▶ POP     Stack: [  (  {  ]    (совпадает с '[')
Шаг 5: '}' ──▶ POP     Stack: [  (  ]       (совпадает с '{')
Шаг 6: ')' ──▶ POP     Stack: [  ]          (совпадает с '(')

Результат: Stack пуст ✅ Строка корректна
```

### Очередь (FIFO - First In, First Out)

```
Очередь на массиве:

Начальное состояние:
┌───┬───┬───┬───┬───┐
│   │   │   │   │   │
└───┴───┴───┴───┴───┘
  0   1   2   3   4
front=0, rear=0

После ENQUEUE(A,B,C):
┌───┬───┬───┬───┬───┐
│ A │ B │ C │   │   │
└───┴───┴───┴───┴───┘
  0   1   2   3   4
front=0, rear=3

После DEQUEUE():
┌───┬───┬───┬───┬───┐
│   │ B │ C │   │   │
└───┴───┴───┴───┴───┘
  0   1   2   3   4
front=1, rear=3
```

### Deque (двусторонняя очередь)

```
Deque - вставка и удаление с обеих сторон:

┌─────────────────────────────────────┐
│ ◀─── FRONT         REAR ───▶        │
│                                     │
│  [10] [20] [30] [40] [50]          │
│   ↑                   ↑             │
│ front               rear            │
└─────────────────────────────────────┘

Операции:
- push_front(x)  / pop_front()
- push_back(x)   / pop_back()
```

---

## 2.4 Строки и их оптимизация

### Представление строк в памяти

```
C-строка (null-terminated):
┌───┬───┬───┬───┬───┬───┬───┐
│ H │ e │ l │ l │ o │ \0│   │
└───┴───┴───┴───┴───┴───┴───┘
  0   1   2   3   4   5

Pascal-строка (с длиной):
┌───┬───┬───┬───┬───┬───┐
│ 5 │ H │ e │ l │ l │ o │
└───┴───┴───┴───┴───┴───┘
```

### String Interning

```
Без interning:
┌─────────┐   ┌─────────┐   ┌─────────┐
│"Hello"  │   │"Hello"  │   │"Hello"  │
│(копия 1)│   │(копия 2)│   │(копия 3)│
└─────────┘   └─────────┘   └─────────┘

С interning:
┌─────────┐   ┌─────────┐   ┌─────────┐
│указатель│──▶│"Hello"  │◀──│указатель│
│         │   │(единая  │   │         │
│         │   │ копия)  │   │         │
└─────────┘   └─────────┘   └─────────┘
```

### Rope структуры для больших текстов

```
Rope - дерево для эффективной работы с большими строками:

                    Root
                   /    \
              "Hello"   Concat
                        /    \
                   " wo"     "rld!"

Concatenation = O(log n) вместо O(n)
```

### Алгоритм KMP (поиск подстроки)

```
Строка: "ABABCABABA"
Паттерн: "ABABA"

Таблица failure function для "ABABA":
┌───┬───┬───┬───┬───┐
│ A │ B │ A │ B │ A │
├───┼───┼───┼───┼───┤
│ 0 │ 0 │ 1 │ 2 │ 3 │
└───┴───┴───┴───┴───┘

При несовпадении сдвигаем паттерн используя таблицу
вместо начала с следующей позиции.
```

---

## 📋 Практические задания

### Задание 1: Калькулятор с использованием стека

```
Входное выражение: "3 + 4 * 2"
Постфиксная запись: "3 4 2 * +"

Алгоритм:
1. Сканируем выражение слева направо
2. Операнды помещаем в стек
3. При встрече операции берем операнды из стека
4. Результат помещаем обратно в стек

Выполнение:
Стек: [3]          (прочитали 3)
Стек: [3, 4]       (прочитали 4)
Стек: [3, 4, 2]    (прочитали 2)
Стек: [3, 8]       (выполнили 4*2)
Стек: [11]         (выполнили 3+8)
```

### Задание 2: Текстовый редактор с Undo/Redo

```
Структура команд:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Insert(5,"H")│───▶│Delete(5,1)  │───▶│Insert(6,"i")│
└─────────────┘    └─────────────┘    └─────────────┘
      ↑                    ↑                    ↑
   current              undo 1              undo 2

Undo Stack: храним обратные операции
Redo Stack: восстанавливаем отмененные операции
```

### Задание 3: Система буферизации потокового ввода

```
Circular Buffer для сетевого ввода:

┌─────────────────────────────────────┐
│ [   ][   ][XXX][XXX][XXX][   ][   ] │
│  5    6    0    1    2    3    4    │
└─────────────────────────────────────┘
       ↑                      ↑
   write_pos              read_pos

Данные поступают циклически, читаются по мере обработки
```

---

## ✅ Контрольные вопросы

1. **Анализ сложности:** Почему вставка в середину массива имеет сложность O(n)?

2. **Выбор структуры:** Когда использовать связный список вместо массива?

3. **Оптимизация памяти:** Как XOR-список экономит память по сравнению с обычным двусвязным списком?

4. **Практическое применение:** Приведите примеры использования стека в системном программировании.

5. **Строковые алгоритмы:** Объясните преимущество алгоритма KMP над наивным поиском.

---

## 🎯 Результаты обучения

После завершения этого блока вы должны:

✅ **Понимать** принципы работы всех линейных структур данных  
✅ **Уметь** выбирать оптимальную структуру для конкретной задачи  
✅ **Реализовывать** эффективные алгоритмы работы со структурами  
✅ **Анализировать** временную и пространственную сложность операций  
✅ **Оптимизировать** использование памяти в реальных приложениях  

---

## 📚 Дополнительные материалы

- **Книги:**
  - "Data Structures and Algorithm Analysis in C++" - Mark Weiss
  - "Algorithms in C++" - Robert Sedgewick

- **Практика:**
  - LeetCode: Arrays, Linked Lists, Stacks & Queues
  - HackerRank: Data Structures Track

- **Визуализация:**
  - VisuAlgo.net - интерактивные демонстрации
  - Algorithm Visualizer - GitHub проект