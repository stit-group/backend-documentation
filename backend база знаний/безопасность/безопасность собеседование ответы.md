# –ü–æ–ª–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ: –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

## üîê 1. –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è

### ‚≠ê Q1: –ü—Ä–æ—Ç–æ–∫–æ–ª—ã –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –º–µ–∂—Å–µ—Ä–≤–∏—Å–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è

**–û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã:**

**mTLS (Mutual TLS)**
- –î–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–º —É—Ä–æ–≤–Ω–µ
- –í—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
- –ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–π

```go
// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ mTLS –∫–ª–∏–µ–Ω—Ç–∞
tlsConfig := &tls.Config{
    Certificates: []tls.Certificate{clientCert},
    RootCAs:      caCertPool,
    ServerName:   "service-name",
}
client := &http.Client{
    Transport: &http.Transport{TLSClientConfig: tlsConfig},
}
```

**OAuth 2.0 Client Credentials**
- –¢–æ–∫–µ–Ω-–±–∞–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
- –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏
- –õ—É—á—à–µ –¥–ª—è heterogeneous environments

```javascript
// OAuth 2.0 Client Credentials Flow
const getAccessToken = async () => {
    const response = await fetch('/oauth/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: 'grant_type=client_credentials&client_id=service1&client_secret=secret'
    });
    return response.json().access_token;
};
```

**Token Rotation –±–µ–∑ downtime:**
```yaml
# Kubernetes Secret —Å –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º
apiVersion: v1
kind: Secret
metadata:
  name: service-creds
  annotations:
    cert-manager.io/next-private-key: "true"
data:
  current-cert: <base64-cert>
  next-cert: <base64-next-cert>
```

### ‚≠ê Q2: JWT –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö –∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏

**–ü—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã JWT:**
JWT —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ Header.Payload.Signature. –í –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö JWT –ø–µ—Ä–µ–¥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏ –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –±–∞–∑–µ.

```javascript
// –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è JWT
const jwt = require('jsonwebtoken');

const verifyToken = (token, secret) => {
    try {
        // –í—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–π—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º!
        return jwt.verify(token, secret, { algorithms: ['RS256'] });
    } catch (error) {
        throw new Error('Invalid token');
    }
};
```

**–û—Å–Ω–æ–≤–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏:**

1. **Algorithm Confusion Attack:**
```javascript
// –£–Ø–ó–í–ò–ú–û - –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º
jwt.verify(token, publicKey); // –º–æ–∂–µ—Ç –ø—Ä–∏–Ω—è—Ç—å HS256 —Å –ø—É–±–ª–∏—á–Ω—ã–º –∫–ª—é—á–æ–º

// –ë–ï–ó–û–ü–ê–°–ù–û
jwt.verify(token, publicKey, { algorithms: ['RS256'] });
```

2. **JWT Blacklist –¥–ª—è –æ—Ç–æ–∑–≤–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤:**
```redis
# Redis –¥–ª—è blacklist
SETEX jwt_blacklist:${jti} ${exp-now} "revoked"
```

### ‚≠ê‚≠ê Q3: –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ RBAC/ABAC

**RBAC (Role-Based Access Control):**
```yaml
# Policy Engine Configuration
roles:
  - name: "order-manager"
    permissions:
      - "orders:read"
      - "orders:create"
      - "orders:update"
  - name: "financial-viewer"
    permissions:
      - "payments:read"
      - "orders:read"
```

**ABAC (Attribute-Based Access Control):**
```javascript
// Policy Decision Point
const evaluatePolicy = (subject, resource, action, environment) => {
    const policy = {
        effect: "Allow",
        condition: {
            and: [
                { equals: [subject.department, resource.owner] },
                { in: [environment.time, "business-hours"] },
                { not: { equals: [resource.classification, "confidential"] } }
            ]
        }
    };
    return evaluateCondition(policy.condition, { subject, resource, action, environment });
};
```

**Token Relay vs Token Exchange:**
```javascript
// Token Relay - –ø—Ä–æ—Å—Ç–∞—è –ø–µ—Ä–µ–¥–∞—á–∞
app.use('/api/orders', (req, res, next) => {
    const token = req.headers.authorization;
    // –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞–µ–º —Ç–æ–∫–µ–Ω –¥–∞–ª—å—à–µ
    makeServiceCall('/payments-service/validate', { 
        headers: { authorization: token } 
    });
});

// Token Exchange - –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ
const exchangeToken = async (originalToken, targetService) => {
    const response = await fetch('/oauth/token', {
        method: 'POST',
        body: new URLSearchParams({
            grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',
            subject_token: originalToken,
            audience: targetService
        })
    });
    return response.json().access_token;
};
```

### ‚≠ê‚≠ê Q4: Zero Trust Architecture

**–ü—Ä–∏–Ω—Ü–∏–ø—ã Zero Trust:**
1. Never trust, always verify
2. Least privilege access
3. Assume breach mentality

```yaml
# Istio Authorization Policy - Zero Trust
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: payment-service-policy
spec:
  selector:
    matchLabels:
      app: payment-service
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/order-service"]
  - to:
    - operation:
        methods: ["POST"]
        paths: ["/api/v1/payments"]
  - when:
    - key: custom.request_id
      values: ["*"]
```

**Policy Decision Point –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:**
```javascript
// Centralized PDP
class PolicyDecisionPoint {
    async authorize(request) {
        const context = {
            subject: await this.extractSubject(request),
            resource: this.extractResource(request),
            action: this.extractAction(request),
            environment: this.getEnvironment()
        };
        
        return await this.policyEngine.evaluate(context);
    }
}
```

### ‚≠ê‚≠ê‚≠ê Q5: Service Mesh –≤ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

**Sidecar vs Ambient Mesh:**

**Sidecar (Istio):**
```yaml
# Automatic sidecar injection
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    istio-injection: enabled
```

**Ambient Mesh –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ú–µ–Ω—å—à–µ —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ sidecar –Ω–∞ –∫–∞–∂–¥—ã–π pod)
- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- –õ—É—á—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

```yaml
# Istio Ambient Mode
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: ambient
spec:
  values:
    pilot:
      env:
        PILOT_ENABLE_AMBIENT: true
```

**End-to-end encryption:**
```yaml
# PeerAuthentication –¥–ª—è mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT  # –¢—Ä–µ–±—É–µ—Ç mTLS –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
```

### ‚≠ê Q6: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—è–º–∏ –≤ Kubernetes

**Service Account vs SPIFFE/SPIRE:**

```yaml
# Kubernetes Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: payment-service-sa
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789:role/PaymentServiceRole"
```

**SPIFFE/SPIRE –¥–ª—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç–∏:**
```yaml
# SPIRE Entry –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞
apiVersion: spiffeid.spiffe.io/v1beta1
kind: SpiffeID
metadata:
  name: payment-service
spec:
  spiffeId: "spiffe://trust-domain/ns/production/sa/payment-service"
  parentId: "spiffe://trust-domain/spire/agent"
  selector:
    k8s:
      namespace: "production"
      serviceAccount: "payment-service"
```

### ‚≠ê‚≠ê Q7: OAuth 2.0 PKCE –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö

**PKCE –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π:**
```javascript
// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è code verifier –∏ challenge
const generatePKCE = () => {
    const codeVerifier = base64URLEncode(crypto.randomBytes(32));
    const codeChallenge = base64URLEncode(
        crypto.createHash('sha256').update(codeVerifier).digest()
    );
    return { codeVerifier, codeChallenge };
};

// Authorization request
const { codeVerifier, codeChallenge } = generatePKCE();
const authUrl = `${authServer}/authorize?` +
    `client_id=${clientId}&` +
    `code_challenge=${codeChallenge}&` +
    `code_challenge_method=S256&` +
    `response_type=code`;
```

**Device Flow –¥–ª—è IoT:**
```javascript
// Device Authorization Grant
const deviceAuth = await fetch('/oauth/device_authorization', {
    method: 'POST',
    body: 'client_id=iot-device&scope=read-sensors'
});
const { device_code, user_code, verification_uri } = await deviceAuth.json();

// Polling –¥–ª—è —Ç–æ–∫–µ–Ω–∞
const pollForToken = async () => {
    const response = await fetch('/oauth/token', {
        method: 'POST',
        body: `grant_type=device_code&device_code=${device_code}&client_id=iot-device`
    });
    return response.json();
};
```

### ‚≠ê‚≠ê Q8: API Gateway –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏

**–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è:**
```yaml
# Kong Gateway Authentication
apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: jwt-auth
plugin: jwt
config:
  key_claim_name: iss
  secret_is_base64: false
  run_on_preflight: true
```

```javascript
// Rate limiting per user
const rateLimitMiddleware = async (req, res, next) => {
    const userId = req.user?.sub;
    const key = `rate_limit:${userId}`;
    
    const current = await redis.incr(key);
    if (current === 1) {
        await redis.expire(key, 3600); // 1 —á–∞—Å
    }
    
    if (current > 1000) { // 1000 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —á–∞—Å
        return res.status(429).json({ error: 'Rate limit exceeded' });
    }
    
    next();
};
```

### ‚≠ê‚≠ê‚≠ê Q9: Single Sign-On –¥–ª—è –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤

**OpenID Connect vs SAML:**
```javascript
// OpenID Connect Discovery
const discoverOIDC = async (issuer) => {
    const response = await fetch(`${issuer}/.well-known/openid_configuration`);
    return response.json();
};

// OIDC Authorization Flow
const handleOIDCCallback = async (code, state) => {
    const tokenResponse = await fetch(config.token_endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            grant_type: 'authorization_code',
            code,
            redirect_uri: process.env.REDIRECT_URI,
            client_id: process.env.CLIENT_ID,
            client_secret: process.env.CLIENT_SECRET
        })
    });
    
    const { access_token, id_token } = await tokenResponse.json();
    return { access_token, id_token };
};
```

**Step-up Authentication:**
```javascript
// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
const requireStepUp = (requiredAuthLevel) => {
    return (req, res, next) => {
        const currentAuthLevel = req.user?.auth_level || 1;
        const authTime = req.user?.auth_time;
        const maxAge = 300; // 5 –º–∏–Ω—É—Ç –¥–ª—è –≤—ã—Å–æ–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è
        
        if (currentAuthLevel < requiredAuthLevel || 
            (Date.now() - authTime * 1000) > maxAge * 1000) {
            return res.status(401).json({
                error: 'step_up_required',
                auth_url: `/auth/step-up?level=${requiredAuthLevel}`
            });
        }
        
        next();
    };
};
```

### ‚≠ê‚≠ê‚≠ê Q10: –ü–µ—Ä–µ–¥–∞—á–∞ user context –º–µ–∂–¥—É —Å–µ—Ä–≤–∏—Å–∞–º–∏

**–ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è PII –≤ —Ç–æ–∫–µ–Ω–∞—Ö:**
```javascript
// Reference Token –≤–º–µ—Å—Ç–æ Self-contained
const createReferenceToken = async (userId, permissions) => {
    const tokenId = crypto.randomUUID();
    const tokenData = {
        sub: userId,
        permissions,
        exp: Date.now() + 3600000 // 1 —á–∞—Å
    };
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫–µ—à–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ —Å—Å—ã–ª–∫—É
    await redis.setex(`token:${tokenId}`, 3600, JSON.stringify(tokenData));
    return tokenId;
};

// Introspection endpoint
app.post('/oauth/introspect', async (req, res) => {
    const token = req.body.token;
    const tokenData = await redis.get(`token:${token}`);
    
    if (!tokenData) {
        return res.json({ active: false });
    }
    
    const data = JSON.parse(tokenData);
    res.json({
        active: true,
        sub: data.sub,
        permissions: data.permissions,
        exp: data.exp
    });
});
```

**GDPR compliance:**
```javascript
// –ü—Å–µ–≤–¥–æ–Ω–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
const pseudonymizeUser = (userId) => {
    const hmac = crypto.createHmac('sha256', process.env.PSEUDONYM_SECRET);
    hmac.update(userId);
    return hmac.digest('hex').substring(0, 16);
};

// Right to erasure
const deleteUserData = async (userId) => {
    const pseudonym = pseudonymizeUser(userId);
    
    // –£–¥–∞–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    await Promise.all([
        orderService.deleteUserData(pseudonym),
        paymentService.deleteUserData(pseudonym),
        profileService.deleteUserData(userId) // –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ñ–∏–ª—å
    ]);
};
```

## üõ°Ô∏è 2. API Security

### ‚≠ê Q11: –ó–∞—â–∏—Ç–∞ –æ—Ç OWASP API Top 10

**API1: Broken Object Level Authorization**
```javascript
// –£–Ø–ó–í–ò–ú–û
app.get('/api/orders/:orderId', (req, res) => {
    const order = db.getOrder(req.params.orderId);
    res.json(order); // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª—é–±–æ–π –∑–∞–∫–∞–∑
});

// –ë–ï–ó–û–ü–ê–°–ù–û
app.get('/api/orders/:orderId', authenticateUser, (req, res) => {
    const order = db.getOrder(req.params.orderId);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if (order.userId !== req.user.id && !req.user.roles.includes('admin')) {
        return res.status(403).json({ error: 'Access denied' });
    }
    
    res.json(order);
});
```

**API3: Excessive Data Exposure**
```javascript
// –£–Ø–ó–í–ò–ú–û - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Å–µ –ø–æ–ª—è
const getUserProfile = (userId) => {
    return db.users.findById(userId); // –≤–∫–ª—é—á–∞–µ—Ç password, ssn, etc.
};

// –ë–ï–ó–û–ü–ê–°–ù–û - –≤—ã–±–æ—Ä–æ—á–Ω—ã–µ –ø–æ–ª—è
const getUserProfile = (userId, requestingUser) => {
    const baseFields = ['id', 'name', 'email'];
    const sensitiveFields = ['phone', 'address'];
    
    let allowedFields = baseFields;
    if (requestingUser.id === userId || requestingUser.roles.includes('admin')) {
        allowedFields = [...baseFields, ...sensitiveFields];
    }
    
    return db.users.findById(userId, { select: allowedFields });
};
```

### ‚≠ê‚≠ê Q12: Secure design –¥–ª—è REST API

**–ü—Ä–∏–Ω—Ü–∏–ø—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω–∞:**

1. **Least Privilege –¥–ª—è endpoints:**
```javascript
// –†–æ–ª—å-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ endpoints
app.get('/api/admin/users', requireRole('admin'), getAllUsers);
app.get('/api/manager/reports', requireRole('manager'), getReports);
app.get('/api/user/profile', requireAuth, getUserProfile);
```

2. **Critical HTTP Headers:**
```javascript
const securityHeaders = (req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    next();
};
```

**GraphQL Security:**
```javascript
// Depth limiting
const depthLimit = require('graphql-depth-limit');

const server = new ApolloServer({
    typeDefs,
    resolvers,
    validationRules: [depthLimit(7)], // –ú–∞–∫—Å–∏–º—É–º 7 —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏
    introspection: process.env.NODE_ENV !== 'production',
    playground: process.env.NODE_ENV !== 'production'
});

// Query complexity analysis
const costAnalysis = require('graphql-query-complexity');
const server = new ApolloServer({
    validationRules: [costAnalysis({
        maximumComplexity: 1000,
        onComplete: (complexity) => {
            console.log('Query complexity:', complexity);
        }
    })]
});
```

### ‚≠ê Q13: –ó–∞—â–∏—Ç–∞ –æ—Ç injection attacks

**Parameterized Queries:**
```javascript
// –£–Ø–ó–í–ò–ú–û –∫ SQL injection
const getUserOrders = (userId, status) => {
    return db.query(`SELECT * FROM orders WHERE user_id = ${userId} AND status = '${status}'`);
};

// –ë–ï–ó–û–ü–ê–°–ù–û - –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
const getUserOrders = (userId, status) => {
    return db.query(
        'SELECT * FROM orders WHERE user_id = ? AND status = ?',
        [userId, status]
    );
};

// ORM —Å –±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏ –º–µ—Ç–æ–¥–∞–º–∏
const getUserOrders = (userId, status) => {
    return Orders.findAll({
        where: {
            user_id: userId,
            status: status
        }
    });
};
```

**NoSQL Injection –∑–∞—â–∏—Ç–∞:**
```javascript
// –£–Ø–ó–í–ò–ú–û –∫ NoSQL injection
const findUser = (username, password) => {
    return db.users.findOne({ 
        username: username, 
        password: password 
    });
};

// –ë–ï–ó–û–ü–ê–°–ù–û - –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ç–∏–ø–æ–≤
const findUser = (username, password) => {
    if (typeof username !== 'string' || typeof password !== 'string') {
        throw new Error('Invalid input types');
    }
    
    return db.users.findOne({ 
        username: { $eq: username }, 
        password: { $eq: password }
    });
};
```

### ‚≠ê‚≠ê Q14: Circuit Breaker —Å security considerations

```javascript
class SecurityAwareCircuitBreaker {
    constructor(options) {
        this.failureThreshold = options.failureThreshold || 5;
        this.resetTimeout = options.resetTimeout || 30000;
        this.securityThreshold = options.securityThreshold || 3;
        this.state = 'CLOSED';
        this.failureCount = 0;
        this.securityFailures = 0;
        this.nextAttempt = null;
    }

    async call(fn, context) {
        if (this.state === 'OPEN') {
            if (Date.now() < this.nextAttempt) {
                throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
        }

        try {
            const result = await fn();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure(error, context);
            throw error;
        }
    }

    onFailure(error, context) {
        this.failureCount++;
        
        // –û—Ç–¥–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ security-related –æ—à–∏–±–æ–∫
        if (this.isSecurityError(error)) {
            this.securityFailures++;
            this.logSecurityIncident(error, context);
            
            // –ë–æ–ª–µ–µ –±—ã—Å—Ç—Ä–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ –¥–ª—è security –∏–Ω—Ü–∏–¥–µ–Ω—Ç–æ–≤
            if (this.securityFailures >= this.securityThreshold) {
                this.openCircuit();
                this.alertSecurityTeam(context);
            }
        }
        
        if (this.failureCount >= this.failureThreshold) {
            this.openCircuit();
        }
    }

    isSecurityError(error) {
        return error.code === 'UNAUTHORIZED' || 
               error.code === 'FORBIDDEN' ||
               error.message.includes('injection');
    }
}
```

### ‚≠ê‚≠ê‚≠ê Q15: API Security Testing

**DAST –≤ CI/CD:**
```yaml
# GitLab CI –¥–ª—è security testing
security_scan:
  stage: test
  image: owasp/zap2docker-stable
  script:
    - zap-baseline.py -t $API_URL -J zap-report.json
    - zap-api-scan.py -t $API_SPEC_URL -f openapi
  artifacts:
    reports:
      junit: zap-report.json
    expire_in: 1 week
  only:
    - merge_requests
```

**Contract Testing —Å security:**
```javascript
// Pact contract —Å security constraints
const { Pact } = require('@pact-foundation/pact');

const provider = new Pact({
    consumer: 'PaymentService',
    provider: 'UserService'
});

describe('Payment Service', () => {
    it('should authenticate user before payment', async () => {
        await provider
            .given('user is authenticated')
            .uponReceiving('a payment request')
            .withRequest({
                method: 'POST',
                path: '/api/payments',
                headers: {
                    'Authorization': Matchers.like('Bearer token123'),
                    'Content-Type': 'application/json'
                },
                body: {
                    amount: 100,
                    currency: 'USD'
                }
            })
            .willRespondWith({
                status: 200,
                headers: { 'Content-Type': 'application/json' },
                body: {
                    paymentId: Matchers.like('pay_123'),
                    status: 'created'
                }
            });

        // –¢–µ—Å—Ç –±–µ–∑ —Ç–æ–∫–µ–Ω–∞ –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å 401
        await provider
            .given('user is not authenticated')
            .uponReceiving('a payment request without auth')
            .withRequest({
                method: 'POST',
                path: '/api/payments',
                body: { amount: 100, currency: 'USD' }
            })
            .willRespondWith({
                status: 401,
                body: { error: 'Unauthorized' }
            });
    });
});
```

### ‚≠ê‚≠ê Q16: Rate Limiting –∏ Quota Management

**Distributed Rate Limiting:**
```javascript
// Redis-based distributed rate limiting
class DistributedRateLimiter {
    constructor(redis, options) {
        this.redis = redis;
        this.windowSize = options.windowSize || 3600; // 1 —á–∞—Å
        this.maxRequests = options.maxRequests || 1000;
    }

    async checkLimit(identifier, cost = 1) {
        const key = `rate_limit:${identifier}`;
        const pipeline = this.redis.pipeline();
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º sliding window log
        const now = Date.now();
        const windowStart = now - (this.windowSize * 1000);
        
        pipeline.zremrangebyscore(key, 0, windowStart);
        pipeline.zcard(key);
        pipeline.zadd(key, now, `${now}:${Math.random()}`);
        pipeline.expire(key, this.windowSize);
        
        const results = await pipeline.exec();
        const currentCount = results[1][1] + cost;
        
        return {
            allowed: currentCount <= this.maxRequests,
            count: currentCount,
            remaining: Math.max(0, this.maxRequests - currentCount),
            resetTime: now + (this.windowSize * 1000)
        };
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å —Ä–∞–∑–Ω—ã–º–∏ –ª–∏–º–∏—Ç–∞–º–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
const getRateLimitForUser = (user) => {
    if (user.plan === 'premium') return { maxRequests: 10000, windowSize: 3600 };
    if (user.plan === 'basic') return { maxRequests: 1000, windowSize: 3600 };
    return { maxRequests: 100, windowSize: 3600 }; // free tier
};
```

### ‚≠ê‚≠ê‚≠ê Q17: Secure API Composition

**Authorization –ø—Ä–∏ composite operations:**
```javascript
class SecureCompositeService {
    async createOrderWithPayment(userId, orderData, paymentData) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞
        if (!await this.authService.hasPermission(userId, 'orders:create')) {
            throw new ForbiddenError('Cannot create orders');
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
        if (!await this.authService.hasPermission(userId, 'payments:create')) {
            throw new ForbiddenError('Cannot create payments');
        }

        const transaction = await this.db.beginTransaction();
        try {
            // –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
            const order = await this.orderService.create(orderData, { 
                userId, 
                transaction,
                auditContext: { operation: 'composite_order_payment' }
            });

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ –∑–∞–∫–∞–∑–∞
            if (order.amount > 10000 && !await this.authService.hasPermission(userId, 'high_value_orders')) {
                throw new ForbiddenError('High value orders require special permission');
            }

            // –°–æ–∑–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂
            const payment = await this.paymentService.create({
                ...paymentData,
                orderId: order.id
            }, { userId, transaction });

            await transaction.commit();
            
            // –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
            await this.auditService.log({
                userId,
                action: 'composite_order_payment_created',
                resources: [order.id, payment.id],
                metadata: { orderAmount: order.amount }
            });

            return { order, payment };
        } catch (error) {
            await transaction.rollback();
            
            // –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω—É—é –ø–æ–ø—ã—Ç–∫—É
            await this.auditService.log({
                userId,
                action: 'composite_order_payment_failed',
                error: error.message,
                metadata: { attemptedAmount: orderData.amount }
            });
            
            throw error;
        }
    }

    // –ß–∞—Å—Ç–∏—á–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    async getOrderSummary(userId, orderId) {
        const order = await this.orderService.getById(orderId);
        
        if (!order) {
            throw new NotFoundError('Order not found');
        }

        const result = { id: order.id, status: order.status };

        // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏ –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–∞–≤–∞
        if (await this.authService.hasPermission(userId, 'orders:read_details')) {
            result.items = order.items;
            result.amount = order.amount;
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∞—Ç–µ–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–∞–≤–∞
        if (await this.authService.hasPermission(userId, 'payments:read')) {
            try {
                result.payment = await this.paymentService.getByOrderId(orderId, userId);
            } catch (error) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–ª–∞—Ç–µ–∂–∞–º
                console.warn(`Payment access denied for user ${userId}, order ${orderId}`);
            }
        }

        return result;
    }
}
```

### ‚≠ê‚≠ê Q18: gRPC Security

**Authentication –≤ gRPC:**
```go
// Server-side interceptor –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
func authInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Errorf(codes.Unauthenticated, "missing metadata")
    }
    
    tokens := md["authorization"]
    if len(tokens) == 0 {
        return nil, status.Errorf(codes.Unauthenticated, "missing token")
    }
    
    token := strings.TrimPrefix(tokens[0], "Bearer ")
    claims, err := validateJWT(token)
    if err != nil {
        return nil, status.Errorf(codes.Unauthenticated, "invalid token")
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
    ctx = context.WithValue(ctx, "user", claims)
    return handler(ctx, req)
}

// Streaming operations security
func streamAuthInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
    ctx := ss.Context()
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return status.Errorf(codes.Unauthenticated, "missing metadata")
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    token := extractToken(md)
    user, err := validateJWT(token)
    if err != nil {
        return status.Errorf(codes.Unauthenticated, "invalid token")
    }
    
    // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º stream —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    wrappedStream := &authenticatedStream{
        ServerStream: ss,
        ctx: context.WithValue(ctx, "user", user),
    }
    
    return handler(srv, wrappedStream)
}
```

**Client-side security:**
```go
// –°–æ–∑–¥–∞–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ gRPC –∫–ª–∏–µ–Ω—Ç–∞
func createSecureClient(serverAddr string, token string) (*grpc.ClientConn, error) {
    // TLS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    tlsConfig := &tls.Config{
        InsecureSkipVerify: false,
        ServerName:         "payment-service",
    }
    
    // Credential –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
    creds := credentials.NewTLS(tlsConfig)
    
    // Per-RPC credentials –¥–ª—è —Ç–æ–∫–µ–Ω–∞
    tokenAuth := &tokenAuth{token: token}
    
    conn, err := grpc.Dial(serverAddr,
        grpc.WithTransportCredentials(creds),
        grpc.WithPerRPCCredentials(tokenAuth),
        grpc.WithUnaryInterceptor(clientLoggingInterceptor),
    )
    
    return conn, err
}

type tokenAuth struct {
    token string
}

func (t *tokenAuth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
    return map[string]string{
        "authorization": "Bearer " + t.token,
    }, nil
}

func (t *tokenAuth) RequireTransportSecurity() bool {
    return true
}
```

## üîí 3. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–∞–º–∏

### ‚≠ê‚≠ê Q19: –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–∞–º–∏

**HashiCorp Vault –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è:**
```go
// Vault client —Å automatic token renewal
type VaultSecretManager struct {
    client *vault.Client
    config *VaultConfig
}

func NewVaultSecretManager(config *VaultConfig) (*VaultSecretManager, error) {
    vaultConfig := vault.DefaultConfig()
    vaultConfig.Address = config.Address
    
    client, err := vault.NewClient(vaultConfig)
    if err != nil {
        return nil, err
    }
    
    // Kubernetes auth
    data := map[string]interface{}{
        "role": config.Role,
        "jwt":  readServiceAccountToken(),
    }
    
    resp, err := client.Logical().Write("auth/kubernetes/login", data)
    if err != nil {
        return nil, err
    }
    
    client.SetToken(resp.Auth.ClientToken)
    
    manager := &VaultSecretManager{client: client, config: config}
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞
    go manager.renewToken(resp.Auth)
    
    return manager, nil
}

func (v *VaultSecretManager) GetSecret(path string) (map[string]interface{}, error) {
    secret, err := v.client.Logical().Read(path)
    if err != nil {
        return nil, err
    }
    return secret.Data, nil
}

// Secret rotation –±–µ–∑ downtime
func (v *VaultSecretManager) RotateSecret(path string) error {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Å–µ–∫—Ä–µ—Ç
    newSecret, err := v.generateSecret()
    if err != nil {
        return err
    }
    
    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–∞–∫ next-secret
    err = v.writeSecret(path+"/next", newSecret)
    if err != nil {
        return err
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —Å–µ—Ä–≤–∏—Å—ã –æ –Ω–æ–≤–æ–º —Å–µ–∫—Ä–µ—Ç–µ
    err = v.notifyServices(path, "rotation_started")
    if err != nil {
        return err
    }
    
    // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    err = v.waitForAcknowledgment(path)
    if err != nil {
        return err
    }
    
    // –ü–µ—Ä–µ–º–µ—â–∞–µ–º next –≤ current
    err = v.promoteSecret(path)
    if err != nil {
        return err
    }
    
    return v.notifyServices(path, "rotation_completed")
}
```

### ‚≠ê Q20: Encryption at rest, in transit, in use

**Envelope Encryption:**
```go
type EnvelopeEncryption struct {
    kmsClient KMSClient
    dataKey   []byte
}

func (e *EnvelopeEncryption) Encrypt(plaintext []byte) (*EncryptedData, error) {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
    dataKey := generateRandomKey(32)
    
    // –®–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –ª–æ–∫–∞–ª—å–Ω—ã–º –∫–ª—é—á–æ–º
    encryptedData, err := aesEncrypt(plaintext, dataKey)
    if err != nil {
        return nil, err
    }
    
    // –®–∏—Ñ—Ä—É–µ–º –∫–ª—é—á –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ KMS
    encryptedKey, err := e.kmsClient.Encrypt(dataKey)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedData{
        Data:         encryptedData,
        EncryptedKey: encryptedKey,
        Algorithm:    "AES-256-GCM",
        KeyID:        e.kmsClient.GetKeyID(),
    }, nil
}

func (e *EnvelopeEncryption) Decrypt(encrypted *EncryptedData) ([]byte, error) {
    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º –∫–ª—é—á –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ KMS
    dataKey, err := e.kmsClient.Decrypt(encrypted.EncryptedKey)
    if err != nil {
        return nil, err
    }
    defer clearMemory(dataKey) // –û—á–∏—â–∞–µ–º –∫–ª—é—á –∏–∑ –ø–∞–º—è—Ç–∏
    
    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    return aesDecrypt(encrypted.Data, dataKey)
}
```

**Perfect Forward Secrecy:**
```go
// ECDHE –¥–ª—è perfect forward secrecy
func setupTLSWithPFS() *tls.Config {
    return &tls.Config{
        MinVersion: tls.VersionTLS12,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
        },
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{
            tls.CurveP521,
            tls.CurveP384,
            tls.CurveP256,
        },
    }
}
```

### ‚≠ê‚≠ê Q21: –†–æ—Ç–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –∫–ª—é—á–µ–π

**Automatic Key Rotation:**
```yaml
# Cert-manager –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–æ—Ç–∞—Ü–∏–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: service-tls
spec:
  secretName: service-tls-secret
  duration: 2160h # 90 –¥–Ω–µ–π
  renewBefore: 360h # –æ–±–Ω–æ–≤–ª—è–µ–º –∑–∞ 15 –¥–Ω–µ–π –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è
  subject:
    organizations:
      - company-name
  commonName: service.internal
  isCA: false
  privateKey:
    algorithm: RSA
    encoding: PKCS1
    size: 2048
  usages:
    - server auth
    - client auth
  dnsNames:
    - service.internal
    - service.namespace.svc.cluster.local
  issuerRef:
    name: ca-issuer
    kind: ClusterIssuer
```

**Blue-Green Key Deployment:**
```go
type KeyManager struct {
    currentKeys map[string]*CryptoKey
    nextKeys    map[string]*CryptoKey
    mu          sync.RWMutex
}

func (km *KeyManager) RotateKey(keyID string) error {
    km.mu.Lock()
    defer km.mu.Unlock()
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –∫–ª—é—á
    newKey, err := generateKey()
    if err != nil {
        return err
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ next key
    km.nextKeys[keyID] = newKey
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ –∏–Ω—Å—Ç–∞–Ω—Å—ã –æ –Ω–æ–≤–æ–º –∫–ª—é—á–µ
    err = km.distributeKey(keyID, newKey)
    if err != nil {
        delete(km.nextKeys, keyID)
        return err
    }
    
    // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç –≤—Å–µ—Ö –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤
    err = km.waitForDistribution(keyID)
    if err != nil {
        return err
    }
    
    // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –Ω–æ–≤—ã–π –∫–ª—é—á
    oldKey := km.currentKeys[keyID]
    km.currentKeys[keyID] = newKey
    delete(km.nextKeys, keyID)
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ –∫–ª—é—á–∞
    go km.scheduleKeyDeletion(keyID, oldKey, 24*time.Hour)
    
    return nil
}
```

## üì¶ 4. Container Security

### ‚≠ê Q25: –û—Å–Ω–æ–≤–Ω—ã–µ —É–≥—Ä–æ–∑—ã –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π

**Container Escape Prevention:**
```yaml
# Security Context –¥–ª—è Pod
apiVersion: v1
kind: Pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE # –¢–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ capabilities
    volumeMounts:
    - name: tmp-volume
      mountPath: /tmp
    - name: var-volume
      mountPath: /var/run
  volumes:
  - name: tmp-volume
    emptyDir: {}
  - name: var-volume
    emptyDir: {}
```

**Privileged Containers Alternatives:**
```yaml
# –í–º–µ—Å—Ç–æ privileged: true –∏—Å–ø–æ–ª—å–∑—É–µ–º specific capabilities
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: network-tool
    securityContext:
      capabilities:
        add:
        - NET_ADMIN  # –¢–æ–ª—å–∫–æ –¥–ª—è —Å–µ—Ç–µ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        - NET_RAW    # –î–ª—è raw sockets
        drop:
        - ALL
```

### ‚≠ê‚≠ê Q26: Secure Container Image Building

**Multi-stage Build —Å —Å–µ–∫—Ä–µ—Ç–∞–º–∏:**
```dockerfile
# Multi-stage build –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
FROM golang:1.19-alpine AS builder

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ ca-certificates –≤ builder
RUN apk --no-cache add ca-certificates git

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# –§–∏–Ω–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–∑ –±–µ–∑ dev tools
FROM scratch

# –ö–æ–ø–∏—Ä—É–µ–º ca-certificates –∏–∑ builder
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
COPY --from=builder /etc/passwd /etc/passwd

# –ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–∏–Ω–∞—Ä–Ω–∏–∫
COPY --from=builder /app/main /main

USER 1000:1000

EXPOSE 8080
ENTRYPOINT ["/main"]
```

**Secrets –≤ Build Process:**
```yaml
# BuildKit secrets
# syntax=docker/dockerfile:1
FROM alpine
RUN --mount=type=secret,id=api_key \
    API_KEY=$(cat /run/secrets/api_key) && \
    wget --header="Authorization: Bearer $API_KEY" https://api.example.com/package
```

**Vulnerability Scanning –≤ CI/CD:**
```yaml
# GitLab CI —Å Trivy scanning
container_scanning:
  stage: test
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    reports:
      container_scanning: trivy-report.json
```

### ‚≠ê‚≠ê Q27: Runtime Security –≤ Kubernetes

**Pod Security Standards:**
```yaml
# Namespace —Å restricted policy
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
```

**Network Policies:**
```yaml
# Deny-all –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress

---
# –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: payment-service-policy
spec:
  podSelector:
    matchLabels:
      app: payment-service
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: order-service
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
    ports:
    - protocol: TCP
      port: 5432
  - to: []  # DNS
    ports:
    - protocol: UDP
      port: 53
```

**Runtime Monitoring:**
```yaml
# Falco –ø—Ä–∞–≤–∏–ª–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
- rule: Unexpected outbound connection
  desc: Detect unexpected outbound connection
  condition: >
    spawned_process and container and
    outbound and fd.typechar = 4 and fd.ip != "0.0.0.0" and
    not proc.name in (allowed_processes) and
    not fd.ip in (allowed_ips)
  output: >
    Unexpected outbound connection (user=%user.name command=%proc.cmdline 
    connection=%fd.name container_id=%container.id image=%container.image.repository)
  priority: WARNING
```

## üìä 5. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —É–≥—Ä–æ–∑

### ‚≠ê‚≠ê Q31: –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

**Centralized Logging Architecture:**
```yaml
# Fluent Bit –¥–ª—è —Å–±–æ—Ä–∞ –ª–æ–≥–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf

    [INPUT]
        Name              tail
        Path              /var/log/containers/*payment*.log
        Parser            docker
        Tag               payment.*
        Refresh_Interval  5

    [FILTER]
        Name             grep
        Match            payment.*
        Regex            log (ERROR|WARN|authentication|authorization|security)

    [OUTPUT]
        Name  es
        Match payment.*
        Host  elasticsearch.logging.svc.cluster.local
        Port  9200
        Index security-logs
```

**Security Metrics Collection:**
```go
// Prometheus –º–µ—Ç—Ä–∏–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
var (
    authFailures = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "auth_failures_total",
            Help: "Total number of authentication failures",
        },
        []string{"service", "reason", "user_type"},
    )
    
    suspiciousRequests = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "suspicious_requests_total",
            Help: "Total number of suspicious requests",
        },
        []string{"service", "attack_type", "source_ip"},
    )
    
    privilegeEscalations = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "privilege_escalations_total",
            Help: "Total number of privilege escalation attempts",
        },
    )
)

// Middleware –¥–ª—è —Å–±–æ—Ä–∞ security –º–µ—Ç—Ä–∏–∫
func securityMetricsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        if isSuspiciousRequest(r) {
            suspiciousRequests.WithLabelValues(
                "payment-service", 
                detectAttackType(r), 
                getClientIP(r),
            ).Inc()
        }
        
        recorder := &responseRecorder{ResponseWriter: w, statusCode: 200}
        next.ServeHTTP(recorder, r)
        
        // –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω—ã–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        if recorder.statusCode == 401 || recorder.statusCode == 403 {
            authFailures.WithLabelValues(
                "payment-service",
                getFailureReason(recorder.statusCode),
                getUserType(r),
            ).Inc()
        }
        
        duration := time.Since(start)
        
        // –ê–ª–µ—Ä—Ç–∏–º –Ω–∞ –º–µ–¥–ª–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã (–≤–æ–∑–º–æ–∂–Ω–∞—è DoS –∞—Ç–∞–∫–∞)
        if duration > 5*time.Second {
            alertManager.SendAlert("slow_request", map[string]string{
                "service":     "payment-service",
                "duration":    duration.String(),
                "endpoint":    r.URL.Path,
                "source_ip":   getClientIP(r),
            })
        }
    })
}
```

### ‚≠ê‚≠ê Q32: Distributed Tracing –¥–ª—è security monitoring

**Security Context –≤ Traces:**
```go
// OpenTelemetry —Å security context
func securityTracingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        span := trace.SpanFromContext(ctx)
        
        // –î–æ–±–∞–≤–ª—è–µ–º security –∞—Ç—Ä–∏–±—É—Ç—ã –≤ span
        user := getUserFromRequest(r)
        if user != nil {
            span.SetAttributes(
                attribute.String("user.id", user.ID),
                attribute.String("user.role", user.Role),
                attribute.String("user.permissions", strings.Join(user.Permissions, ",")),
            )
        }
        
        span.SetAttributes(
            attribute.String("http.client_ip", getClientIP(r)),
            attribute.String("http.user_agent", r.UserAgent()),
            attribute.String("security.auth_method", getAuthMethod(r)),
        )
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ security headers
        securityHeaders := map[string]string{
            "X-Forwarded-For":    r.Header.Get("X-Forwarded-For"),
            "X-Real-IP":          r.Header.Get("X-Real-IP"),
            "Authorization":      maskToken(r.Header.Get("Authorization")),
        }
        
        for key, value := range securityHeaders {
            if value != "" {
                span.SetAttributes(attribute.String("http.header."+strings.ToLower(key), value))
            }
        }
        
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// –ê–Ω–∞–ª–∏–∑ security patterns –≤ traces
func analyzeSecurityTraces() {
    jaegerClient := jaeger.NewClient()
    
    // –ü–æ–∏—Å–∫ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    traces, err := jaegerClient.FindTraces(&jaeger.TraceQueryParameters{
        ServiceName: "payment-service",
        Tags: map[string]string{
            "http.status_code": "401",
            "user.role":        "anonymous",
        },
        StartTime: time.Now().Add(-1 * time.Hour),
        EndTime:   time.Now(),
    })
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ IP –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è brute force
    ipAttempts := make(map[string]int)
    for _, trace := range traces {
        for _, span := range trace.Spans {
            if ip, ok := span.Tags["http.client_ip"]; ok {
                ipAttempts[ip]++
            }
        }
    }
    
    // –ê–ª–µ—Ä—Ç–∏–º –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ø–æ—Ä–æ–≥–∞
    for ip, attempts := range ipAttempts {
        if attempts > 10 {
            alertManager.SendAlert("brute_force_detected", map[string]string{
                "source_ip": ip,
                "attempts":  strconv.Itoa(attempts),
                "service":   "payment-service",
            })
        }
    }
}
```

### ‚≠ê‚≠ê‚≠ê Q33: Behavioral Analysis –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∞–Ω–æ–º–∞–ª–∏–π

**Machine Learning –¥–ª—è Anomaly Detection:**
```python
# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è Isolation Forest –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∞–Ω–æ–º–∞–ª–∏–π
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
import numpy as np

class SecurityAnomalyDetector:
    def __init__(self):
        self.model = IsolationForest(contamination=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.baseline_established = False
        
    def extract_features(self, request_logs):
        """–ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
        features = []
        for log in request_logs:
            feature_vector = [
                log['request_size'],
                log['response_time'],
                log['hour_of_day'],
                log['requests_per_minute'],
                len(log['user_agent']),
                log['unique_endpoints_accessed'],
                log['failed_auth_attempts'],
                log['privilege_level'],  # 0-3 scale
            ]
            features.append(feature_vector)
        return np.array(features)
    
    def establish_baseline(self, historical_data):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º baseline –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        features = self.extract_features(historical_data)
        features_scaled = self.scaler.fit_transform(features)
        self.model.fit(features_scaled)
        self.baseline_established = True
        
    def detect_anomalies(self, current_requests):
        """–û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º –∞–Ω–æ–º–∞–ª–∏–∏ –≤ —Ç–µ–∫—É—â–∏—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö"""
        if not self.baseline_established:
            raise ValueError("Baseline not established")
            
        features = self.extract_features(current_requests)
        features_scaled = self.scaler.transform(features)
        
        # -1 –¥–ª—è –∞–Ω–æ–º–∞–ª–∏–π, 1 –¥–ª—è –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö
        predictions = self.model.predict(features_scaled)
        anomaly_scores = self.model.decision_function(features_scaled)
        
        anomalies = []
        for i, (prediction, score) in enumerate(zip(predictions, anomaly_scores)):
            if prediction == -1:
                anomalies.append({
                    'request_id': current_requests[i]['id'],
                    'anomaly_score': score,
                    'features': features[i].tolist(),
                    'severity': self.calculate_severity(score)
                })
                
        return anomalies
    
    def calculate_severity(self, score):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å –∞–Ω–æ–º–∞–ª–∏–∏"""
        if score < -0.5:
            return "HIGH"
        elif score < -0.3:
            return "MEDIUM"
        else:
            return "LOW"
```

**Real-time Behavioral Monitoring:**
```go
// Go implementation –¥–ª—è real-time –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
type BehaviorProfile struct {
    UserID              string            `json:"user_id"`
    TypicalHours        []int             `json:"typical_hours"`
    AverageRequestRate  float64           `json:"avg_request_rate"`
    CommonEndpoints     map[string]float64 `json:"common_endpoints"`
    TypicalLocations    []string          `json:"typical_locations"`
    DeviceFingerprints  []string          `json:"device_fingerprints"`
    LastUpdated         time.Time         `json:"last_updated"`
}

type BehaviorAnalyzer struct {
    profiles map[string]*BehaviorProfile
    redis    *redis.Client
    mu       sync.RWMutex
}

func (ba *BehaviorAnalyzer) AnalyzeRequest(req *http.Request, user *User) (*AnomalyAlert, error) {
    ba.mu.RLock()
    profile, exists := ba.profiles[user.ID]
    ba.mu.RUnlock()
    
    if !exists {
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å
        profile = ba.createInitialProfile(user.ID)
        ba.mu.Lock()
        ba.profiles[user.ID] = profile
        ba.mu.Unlock()
        return nil, nil // –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    }
    
    anomalies := make([]string, 0)
    severity := "LOW"
    
    // –ê–Ω–∞–ª–∏–∑ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ—Å—Ç—É–ø–∞
    currentHour := time.Now().Hour()
    if !contains(profile.TypicalHours, currentHour) {
        anomalies = append(anomalies, "unusual_access_time")
        severity = "MEDIUM"
    }
    
    // –ê–Ω–∞–ª–∏–∑ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
    clientIP := getClientIP(req)
    location := getLocationFromIP(clientIP)
    if !contains(profile.TypicalLocations, location) {
        anomalies = append(anomalies, "unusual_location")
        severity = "HIGH"
    }
    
    // –ê–Ω–∞–ª–∏–∑ device fingerprint
    deviceFingerprint := generateDeviceFingerprint(req)
    if !contains(profile.DeviceFingerprints, deviceFingerprint) {
        anomalies = append(anomalies, "unknown_device")
        severity = "HIGH"
    }
    
    // –ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
    requestRate := ba.calculateCurrentRequestRate(user.ID)
    if requestRate > profile.AverageRequestRate*3 {
        anomalies = append(anomalies, "unusual_request_rate")
        severity = "HIGH"
    }
    
    if len(anomalies) > 0 {
        alert := &AnomalyAlert{
            UserID:     user.ID,
            Timestamp:  time.Now(),
            Anomalies:  anomalies,
            Severity:   severity,
            RequestID:  getRequestID(req),
            ClientIP:   clientIP,
            UserAgent:  req.UserAgent(),
        }
        
        // –õ–æ–≥–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–ª–µ—Ä—Ç
        ba.logAnomaly(alert)
        
        // –î–ª—è HIGH severity —Å—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        if severity == "HIGH" {
            ba.sendRealTimeAlert(alert)
        }
        
        return alert, nil
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    go ba.updateProfile(user.ID, req)
    
    return nil, nil
}
```

### ‚≠ê‚≠ê‚≠ê Q34: Incident Response –¥–ª—è –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

**Automated Containment:**
```yaml
# Runbook –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏—è
apiVersion: v1
kind: ConfigMap
metadata:
  name: incident-response-runbook
data:
  security-incident.yaml: |
    triggers:
      - type: "authentication_failure_spike"
        threshold: 100
        window: "5m"
        actions:
          - "block_source_ip"
          - "scale_auth_service"
          - "notify_security_team"
      
      - type: "privilege_escalation"
        threshold: 1
        actions:
          - "isolate_container"
          - "collect_forensics"
          - "emergency_alert"
    
    actions:
      block_source_ip:
        type: "network_policy"
        config:
          deny_ingress_from_ip: "{{ .source_ip }}"
          duration: "1h"
      
      isolate_container:
        type: "kubernetes"
        config:
          action: "delete_pod"
          selector: "{{ .pod_selector }}"
          backup_logs: true
      
      collect_forensics:
        type: "script"
        config:
          script: "/scripts/collect-forensics.sh"
          args: ["{{ .pod_name }}", "{{ .namespace }}"]
```

**Multi-team Coordination:**
```go
// Incident coordination system
type IncidentCoordinator struct {
    teams    map[string]Team
    channels map[string]CommunicationChannel
    runbooks map[string]Runbook
}

type IncidentResponse struct {
    ID           string               `json:"id"`
    Type         string               `json:"type"`
    Severity     string               `json:"severity"`
    Status       string               `json:"status"`
    AffectedServices []string        `json:"affected_services"`
    Timeline     []IncidentEvent      `json:"timeline"`
    AssignedTeams    []string        `json:"assigned_teams"`
    Evidence     []Evidence           `json:"evidence"`
}

func (ic *IncidentCoordinator) HandleSecurityIncident(incident *SecurityIncident) error {
    response := &IncidentResponse{
        ID:       generateIncidentID(),
        Type:     incident.Type,
        Severity: incident.Severity,
        Status:   "INVESTIGATING",
        AffectedServices: incident.AffectedServices,
        Timeline: []IncidentEvent{{
            Timestamp: time.Now(),
            Event:     "INCIDENT_DETECTED",
            Details:   incident.Description,
        }},
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    teams := ic.determineResponsibleTeams(incident)
    response.AssignedTeams = teams
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    for _, teamName := range teams {
        team := ic.teams[teamName]
        go ic.notifyTeam(team, response)
    }
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
    runbook := ic.runbooks[incident.Type]
    if runbook != nil {
        for _, action := range runbook.AutomatedActions {
            err := ic.executeAction(action, incident)
            if err != nil {
                log.Printf("Failed to execute action %s: %v", action.Name, err)
            }
            
            response.Timeline = append(response.Timeline, IncidentEvent{
                Timestamp: time.Now(),
                Event:     "ACTION_EXECUTED",
                Details:   action.Name,
            })
        }
    }
    
    // –°–æ–∑–¥–∞–µ–º war room –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏
    warRoom := ic.createWarRoom(response)
    ic.channels[response.ID] = warRoom
    
    return ic.persistIncident(response)
}

// Forensic Data Collection –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞—Ö
func (ic *IncidentCoordinator) collectForensics(podName, namespace string) error {
    // –°–æ–∑–¥–∞–µ–º snapshot —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
    err := ic.createFilesystemSnapshot(podName, namespace)
    if err != nil {
        return err
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º –ª–æ–≥–∏
    logs, err := ic.collectPodLogs(podName, namespace)
    if err != nil {
        return err
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º —Å–µ—Ç–µ–≤—É—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    networkData, err := ic.collectNetworkData(podName, namespace)
    if err != nil {
        return err
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    metrics, err := ic.collectMetrics(podName, namespace)
    if err != nil {
        return err
    }
    
    // –£–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –≤—Å–µ –≤ secure archive
    forensicsPackage := &ForensicsPackage{
        IncidentID:       ic.currentIncidentID,
        PodName:          podName,
        Namespace:        namespace,
        CollectionTime:   time.Now(),
        FilesystemSnapshot: ic.encryptData(filesystemSnapshot),
        Logs:             ic.encryptData(logs),
        NetworkData:      ic.encryptData(networkData),
        Metrics:          ic.encryptData(metrics),
        Hash:             ic.calculateHash(logs, networkData, metrics),
    }
    
    return ic.storeForensicsPackage(forensicsPackage)
}
```

### ‚≠ê‚≠ê Q35: User and Entity Behavior Analytics (UEBA)

**User Behavior Profiling:**
```go
type UserBehaviorAnalytics struct {
    profileStore ProfileStore
    mlEngine     MLEngine
    alertManager AlertManager
}

type BehaviorMetrics struct {
    LoginTimes          []time.Time   `json:"login_times"`
    AccessPatterns      []AccessEvent `json:"access_patterns"`
    DataVolume          []DataTransfer `json:"data_volume"`
    GeographicLocations []Location    `json:"locations"`
    DeviceFingerprints  []Device      `json:"devices"`
    PrivilegeUsage      []PrivilegeEvent `json:"privilege_usage"`
}

func (uba *UserBehaviorAnalytics) AnalyzeUserBehavior(userID string, event *SecurityEvent) (*ThreatAssessment, error) {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    profile, err := uba.profileStore.GetProfile(userID)
    if err != nil {
        return nil, err
    }
    
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ–±—ã—Ç–∏–µ –ø—Ä–æ—Ç–∏–≤ –ø—Ä–æ—Ñ–∏–ª—è
    anomalies := uba.detectAnomalies(profile, event)
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º risk score
    riskScore := uba.calculateRiskScore(anomalies, event)
    
    assessment := &ThreatAssessment{
        UserID:     userID,
        EventID:    event.ID,
        RiskScore:  riskScore,
        Anomalies:  anomalies,
        Timestamp:  time.Now(),
    }
    
    // –ï—Å–ª–∏ –≤—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫ - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    if riskScore > 0.8 {
        assessment.RequiredActions = []string{
            "step_up_authentication",
            "additional_monitoring",
            "security_review",
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∏–Ω—Å–∞–π–¥–µ—Ä—Å–∫–∏–µ —É–≥—Ä–æ–∑—ã
        insiderThreatIndicators := uba.checkInsiderThreatIndicators(userID, event)
        if len(insiderThreatIndicators) > 0 {
            assessment.ThreatType = "INSIDER_THREAT"
            assessment.Indicators = insiderThreatIndicators
            
            // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ security team
            uba.alertManager.SendHighPriorityAlert("insider_threat_detected", map[string]interface{}{
                "user_id":    userID,
                "risk_score": riskScore,
                "indicators": insiderThreatIndicators,
                "event":      event,
            })
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    go uba.updateProfile(userID, event)
    
    return assessment, nil
}

func (uba *UserBehaviorAnalytics) checkInsiderThreatIndicators(userID string, event *SecurityEvent) []string {
    indicators := make([]string, 0)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º access patterns
    if uba.isAccessingUnusualResources(userID, event) {
        indicators = append(indicators, "unusual_resource_access")
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞
    if uba.isAccessingOffHours(userID, event) {
        indicators = append(indicators, "off_hours_access")
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö
    if uba.isUnusualDataTransfer(userID, event) {
        indicators = append(indicators, "unusual_data_transfer")
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ privilege abuse
    if uba.isPrivilegeAbuse(userID, event) {
        indicators = append(indicators, "privilege_abuse")
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ lateral movement
    if uba.isLateralMovement(userID, event) {
        indicators = append(indicators, "lateral_movement")
    }
    
    return indicators
}
```

**Entity Behavior Modeling:**
```python
# Machine Learning –º–æ–¥–µ–ª—å –¥–ª—è entity behavior
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.cluster import DBSCAN
import pandas as pd

class EntityBehaviorModel:
    def __init__(self):
        self.isolation_forest = IsolationForest(contamination=0.1)
        self.clustering_model = DBSCAN(eps=0.5, min_samples=5)
        self.feature_columns = [
            'requests_per_hour', 'avg_response_time', 'error_rate',
            'unique_endpoints', 'data_volume_mb', 'auth_failures',
            'privilege_escalations', 'off_hours_activity'
        ]
        
    def train_baseline(self, historical_data):
        """–û–±—É—á–∞–µ–º –º–æ–¥–µ–ª—å –Ω–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        features = self.extract_features(historical_data)
        
        # –û–±—É—á–∞–µ–º isolation forest –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∞–Ω–æ–º–∞–ª–∏–π
        self.isolation_forest.fit(features)
        
        # –ö–ª–∞—Å—Ç–µ—Ä–∏–∑—É–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
        clusters = self.clustering_model.fit_predict(features)
        self.normal_clusters = set(clusters[clusters != -1])
        
        return self
    
    def detect_anomalies(self, current_data):
        """–û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ–º –∞–Ω–æ–º–∞–ª–∏–∏ –≤ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        features = self.extract_features(current_data)
        
        # Isolation Forest predictions
        anomaly_scores = self.isolation_forest.decision_function(features)
        anomaly_predictions = self.isolation_forest.predict(features)
        
        # Clustering analysis
        clusters = self.clustering_model.fit_predict(features)
        
        results = []
        for i, (score, prediction, cluster) in enumerate(zip(anomaly_scores, anomaly_predictions, clusters)):
            entity_id = current_data.iloc[i]['entity_id']
            
            is_anomaly = prediction == -1 or cluster not in self.normal_clusters
            
            if is_anomaly:
                threat_level = self.calculate_threat_level(score, cluster)
                results.append({
                    'entity_id': entity_id,
                    'anomaly_score': score,
                    'threat_level': threat_level,
                    'cluster': cluster,
                    'features': features[i].tolist()
                })
        
        return results
    
    def calculate_threat_level(self, score, cluster):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å —É–≥—Ä–æ–∑—ã"""
        if score < -0.6 or cluster == -1:
            return "HIGH"
        elif score < -0.4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def extract_features(self, data):
        """–ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
        return data[self.feature_columns].values
```

## üåê 6. –°–µ—Ç–µ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### ‚≠ê‚≠ê Q36: Network Segmentation –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö

**Zero-Trust Networking:**
```yaml
# Istio Authorization Policies –¥–ª—è zero-trust
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: payment-service-authz
  namespace: financial
spec:
  selector:
    matchLabels:
      app: payment-service
  rules:
  # –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ order-service –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ payment
  - from:
    - source:
        principals: ["cluster.local/ns/commerce/sa/order-service"]
  - to:
    - operation:
        methods: ["POST"]
        paths: ["/api/v1/payments", "/api/v1/refunds"]
  - when:
    - key: request.headers[x-request-id]
      values: ["*"]  # –¢—Ä–µ–±—É–µ–º tracing header

---
# Deny-all policy –∫–∞–∫ baseline
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: default-deny
  namespace: financial
spec:
  {} # –ü—É—Å—Ç–∞—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è = deny all
```

**Kubernetes Network Policies —Å Calico:**
```yaml
# Fine-grained network policy
apiVersion: projectcalico.org/v3
kind: NetworkPolicy
metadata:
  name: payment-service-policy
  namespace: financial
spec:
  selector: app == "payment-service"
  types:
  - Ingress
  - Egress
  
  ingress:
  # –†–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—Ç order-service
  - action: Allow
    source:
      selector: app == "order-service"
      namespaceSelector: name == "commerce"
    destination:
      ports:
      - 8080
  
  # –†–∞–∑—Ä–µ—à–∞–µ–º health checks –æ—Ç Kubernetes
  - action: Allow
    source:
      selector: app == "kube-probe"
    destination:
      ports:
      - 8080
      
  egress:
  # –†–∞–∑—Ä–µ—à–∞–µ–º –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
  - action: Allow
    destination:
      selector: app == "postgres"
      ports:
      - 5432
  
  # –†–∞–∑—Ä–µ—à–∞–µ–º DNS
  - action: Allow
    destination:
      ports:
      - 53
    protocol: UDP
  
  # –†–∞–∑—Ä–µ—à–∞–µ–º –∫ external payment gateway
  - action: Allow
    destination:
      nets:
      - "203.0.113.0/24"  # Payment gateway subnet
      ports:
      - 443
```

### ‚≠ê‚≠ê‚≠ê Q37: East-West Traffic Security

**Service Mesh Traffic Encryption:**
```yaml
# Automatic mTLS –¥–ª—è –≤—Å–µ–≥–æ mesh
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT

---
# Destination Rule –¥–ª—è TLS
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: payment-service-tls
spec:
  host: payment-service.financial.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL  # –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã Istio
```

**Traffic Inspection –±–µ–∑ performance impact:**
```go
// eBPF-based traffic monitoring
type TrafficMonitor struct {
    ebpfProgram *ebpf.Program
    eventChan   chan TrafficEvent
}

func (tm *TrafficMonitor) StartMonitoring() error {
    // –ó–∞–≥—Ä—É–∂–∞–µ–º eBPF –ø—Ä–æ–≥—Ä–∞–º–º—É –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ç–µ–≤–æ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
    prog, err := ebpf.LoadProgram("traffic_monitor.o", ebpf.XDP)
    if err != nil {
        return err
    }
    tm.ebpfProgram = prog
    
    // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∫ —Å–µ—Ç–µ–≤–æ–º—É –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
    err = tm.attachToInterface("eth0")
    if err != nil {
        return err
    }
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π
    go tm.processEvents()
    
    return nil
}

func (tm *TrafficMonitor) processEvents() {
    for event := range tm.eventChan {
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç—Ä–∞—Ñ–∏–∫ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        if tm.isSuspiciousTraffic(event) {
            tm.handleSuspiciousTraffic(event)
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
        tm.updateMetrics(event)
    }
}

func (tm *TrafficMonitor) isSuspiciousTraffic(event TrafficEvent) bool {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–æ–≤
    if event.PacketSize > 65535 {
        return true
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–∞—Å—Ç–æ—Ç—É –∑–∞–ø—Ä–æ—Å–æ–≤
    if event.RequestRate > 1000 {
        return true
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—ã—á–Ω—ã–µ –ø–æ—Ä—Ç—ã
    if !tm.isAllowedPort(event.DestPort) {
        return true
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ DDoS –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    if tm.isDDoSPattern(event) {
        return true
    }
    
    return false
}
```

**Lateral Movement Prevention:**
```yaml
# Micro-segmentation —Å Cilium
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: payment-microsegmentation
spec:
  endpointSelector:
    matchLabels:
      app: payment-service
  
  ingress:
  # L7 policy - —Ç–æ–ª—å–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ HTTP methods
  - fromEndpoints:
    - matchLabels:
        app: order-service
    toPorts:
    - ports:
      - port: "8080"
        protocol: TCP
      rules:
        http:
        - method: "POST"
          path: "/api/v1/payments"
        - method: "GET"
          path: "/health"
  
  egress:
  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥—è—â–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  - toEndpoints:
    - matchLabels:
        app: database
    toPorts:
    - ports:
      - port: "5432"
        protocol: TCP
  
  # –ó–∞–ø—Ä–µ—â–∞–µ–º –ª—é–±—ã–µ –¥—Ä—É–≥–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
  - {} # Empty rule = deny all other traffic
```

### ‚≠ê‚≠ê Q38: Network Policy Enforcement

**eBPF-based Enforcement —Å Cilium:**
```yaml
# Application-aware network policy
apiVersion: cilium.io/v2
kind: CiliumNetworkPolicy
metadata:
  name: api-security-policy
spec:
  endpointSelector:
    matchLabels:
      app: api-gateway
  
  ingress:
  - fromEntities:
    - "world"  # –í–Ω–µ—à–Ω–∏–π —Ç—Ä–∞—Ñ–∏–∫
    toPorts:
    - ports:
      - port: "443"
        protocol: TCP
      rules:
        http:
        - method: "GET"
          path: "/api/v1/public/.*"
        - method: "POST"
          path: "/api/v1/auth/login"
        - method: "POST"
          path: "/api/v1/users"
          headers:
          - "Content-Type: application/json"
        
        # Rate limiting –Ω–∞ L7 —É—Ä–æ–≤–Ω–µ
        l7proto: http
        http:
        - method: "POST"
          path: "/api/v1/.*"
          rateLimit:
            requests: 100
            period: "1m"
```

**CNI Plugin Security (Calico eBPF mode):**
```yaml
# Felix –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è eBPF dataplane
apiVersion: v1
kind: ConfigMap
metadata:
  name: calico-config
  namespace: kube-system
data:
  calico_backend: "bird"
  cluster_type: "k8s,bgp"
  
  # –í–∫–ª—é—á–∞–µ–º eBPF dataplane –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  felix_bpfenabled: "true"
  felix_bpfexternalservicemode: "tunnel"
  
  # Security features
  felix_bpfconnecttimebalancing: "true"
  felix_bpfhostconntrackbypass: "true"
  
  # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
  felix_bpflogfilters: |
    {
      "drop": "all",
      "accept": "none"
    }
```

## üõ°Ô∏è 7. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏ GDPR

### ‚≠ê‚≠ê Q39: Data Protection –∏ Privacy –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö

**Data Minimization –≤ API Design:**
```go
// API —Å data minimization –ø—Ä–∏–Ω—Ü–∏–ø–∞–º–∏
type UserService struct {
    repo UserRepository
}

// –ü—É–±–ª–∏—á–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å - –º–∏–Ω–∏–º—É–º –¥–∞–Ω–Ω—ã—Ö
func (s *UserService) GetPublicProfile(userID string) (*PublicProfile, error) {
    user, err := s.repo.GetByID(userID)
    if err != nil {
        return nil, err
    }
    
    return &PublicProfile{
        ID:          user.ID,
        DisplayName: user.DisplayName,
        Avatar:      user.Avatar,
        // –ù–µ –≤–∫–ª—é—á–∞–µ–º email, phone, address –∏ —Ç.–¥.
    }, nil
}

// –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å - –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
func (s *UserService) GetPrivateProfile(userID, requestingUserID string) (*PrivateProfile, error) {
    if userID != requestingUserID {
        return nil, errors.New("access denied")
    }
    
    user, err := s.repo.GetByID(userID)
    if err != nil {
        return nil, err
    }
    
    return &PrivateProfile{
        ID:          user.ID,
        Email:       user.Email,
        Phone:       user.Phone,
        DisplayName: user.DisplayName,
        Avatar:      user.Avatar,
        // –ê–¥—Ä–µ—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–∞–ª —Å–æ–≥–ª–∞—Å–∏–µ
        Address:     s.getAddressIfConsented(user),
    }, nil
}

// –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å - –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤
func (s *UserService) GetAdminProfile(userID string, admin *User) (*AdminProfile, error) {
    if !admin.HasRole("admin") {
        return nil, errors.New("admin access required")
    }
    
    user, err := s.repo.GetByID(userID)
    if err != nil {
        return nil, err
    }
    
    // –õ–æ–≥–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø –∞–¥–º–∏–Ω–∞ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º
    s.auditLog.LogAccess(admin.ID, "admin_profile_access", userID)
    
    return &AdminProfile{
        ID:              user.ID,
        Email:           user.Email,
        Phone:           user.Phone,
        DisplayName:     user.DisplayName,
        Address:         user.Address,
        LastLoginIP:     user.LastLoginIP,
        AccountStatus:   user.Status,
        CreatedAt:       user.CreatedAt,
        ConsentRecords:  s.getConsentHistory(userID),
    }, nil
}
```

**Consent Management:**
```go
type ConsentManager struct {
    storage ConsentStorage
    events  EventPublisher
}

type ConsentRecord struct {
    UserID      string    `json:"user_id"`
    Purpose     string    `json:"purpose"`
    Granted     bool      `json:"granted"`
    Timestamp   time.Time `json:"timestamp"`
    Version     string    `json:"version"`
    IPAddress   string    `json:"ip_address"`
    UserAgent   string    `json:"user_agent"`
    LegalBasis  string    `json:"legal_basis"`
    Expiry      *time.Time `json:"expiry,omitempty"`
}

func (cm *ConsentManager) RecordConsent(userID, purpose string, granted bool, context *ConsentContext) error {
    record := &ConsentRecord{
        UserID:     userID,
        Purpose:    purpose,
        Granted:    granted,
        Timestamp:  time.Now(),
        Version:    cm.getCurrentPolicyVersion(purpose),
        IPAddress:  context.IPAddress,
        UserAgent:  context.UserAgent,
        LegalBasis: cm.getLegalBasis(purpose),
    }
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Å–æ–≥–ª–∞—Å–∏—è
    if granted && cm.hasExpiry(purpose) {
        expiry := time.Now().Add(cm.getConsentDuration(purpose))
        record.Expiry = &expiry
    }
    
    err := cm.storage.SaveConsent(record)
    if err != nil {
        return err
    }
    
    // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    event := &ConsentEvent{
        UserID:    userID,
        Purpose:   purpose,
        Granted:   granted,
        Timestamp: record.Timestamp,
    }
    
    return cm.events.Publish("consent.updated", event)
}

func (cm *ConsentManager) CheckConsent(userID, purpose string) (bool, error) {
    consents, err := cm.storage.GetUserConsents(userID, purpose)
    if err != nil {
        return false, err
    }
    
    // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–≥–ª–∞—Å–∏–µ
    var latestConsent *ConsentRecord
    for _, consent := range consents {
        if latestConsent == nil || consent.Timestamp.After(latestConsent.Timestamp) {
            latestConsent = consent
        }
    }
    
    if latestConsent == nil {
        return false, nil // –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –æ —Å–æ–≥–ª–∞—Å–∏–∏
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –∏—Å—Ç–µ–∫–ª–æ –ª–∏ —Å–æ–≥–ª–∞—Å–∏–µ
    if latestConsent.Expiry != nil && time.Now().After(*latestConsent.Expiry) {
        return false, nil
    }
    
    return latestConsent.Granted, nil
}
```

### ‚≠ê‚≠ê‚≠ê Q40: Regulatory Compliance (GDPR, CCPA, HIPAA)

**GDPR Right to Erasure Implementation:**
```go
type DataErasureOrchestrator struct {
    services map[string]DataService
    audit    AuditLogger
    queue    MessageQueue
}

type ErasureRequest struct {
    UserID          string            `json:"user_id"`
    RequestID       string            `json:"request_id"`
    RequestedBy     string            `json:"requested_by"`
    Timestamp       time.Time         `json:"timestamp"`
    Scope          ErasureScope       `json:"scope"`
    LegalBasis     string            `json:"legal_basis"`
    Exceptions     []string          `json:"exceptions"`
}

type ErasureScope struct {
    IncludeBackups     bool     `json:"include_backups"`
    IncludeLogs        bool     `json:"include_logs"`
    IncludeAnalytics   bool     `json:"include_analytics"`
    Services           []string `json:"services"`
    RetentionOverride  bool     `json:"retention_override"`
}

func (deo *DataErasureOrchestrator) ProcessErasureRequest(request *ErasureRequest) error {
    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å
    if err := deo.validateErasureRequest(request); err != nil {
        return err
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è (legal hold, financial records, etc.)
    exceptions, err := deo.checkErasureExceptions(request.UserID)
    if err != nil {
        return err
    }
    
    if len(exceptions) > 0 {
        request.Exceptions = exceptions
        deo.audit.LogErasureBlocked(request, exceptions)
        return fmt.Errorf("erasure blocked due to: %v", exceptions)
    }
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
    return deo.orchestrateErasure(request)
}

func (deo *DataErasureOrchestrator) orchestrateErasure(request *ErasureRequest) error {
    orchestrationID := generateOrchestrationID()
    
    // –°–æ–∑–¥–∞–µ–º –ø–ª–∞–Ω —É–¥–∞–ª–µ–Ω–∏—è
    plan := deo.createErasurePlan(request)
    
    // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
    deo.audit.LogErasureStarted(request, orchestrationID, plan)
    
    results := make(map[string]ErasureResult)
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –≤ –∫–∞–∂–¥–æ–º —Å–µ—Ä–≤–∏—Å–µ
    for serviceName, service := range deo.services {
        if !deo.shouldProcessService(serviceName, request.Scope) {
            continue
        }
        
        result, err := deo.eraseFromService(service, request)
        results[serviceName] = result
        
        if err != nil {
            deo.audit.LogErasureServiceFailed(request, serviceName, err)
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –¥—Ä—É–≥–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏, –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è
        }
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±—ç–∫–∞–ø—ã –µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è
    if request.Scope.IncludeBackups {
        backupResult := deo.eraseFromBackups(request)
        results["backups"] = backupResult
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–æ–≥–∏
    if request.Scope.IncludeLogs {
        logResult := deo.eraseFromLogs(request)
        results["logs"] = logResult
    }
    
    // –°–æ–∑–¥–∞–µ–º –æ—Ç—á–µ—Ç –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö
    report := deo.createErasureReport(request, results)
    
    // –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
    deo.audit.LogErasureCompleted(request, orchestrationID, report)
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    return deo.notifyErasureCompletion(request, report)
}

func (deo *DataErasureOrchestrator) eraseFromService(service DataService, request *ErasureRequest) (ErasureResult, error) {
    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    dataInventory, err := service.GetUserDataInventory(request.UserID)
    if err != nil {
        return ErasureResult{}, err
    }
    
    // –ü—Å–µ–≤–¥–æ–Ω–∏–º–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å (—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏)
    pseudonymizedCount := 0
    for _, item := range dataInventory {
        if deo.requiresPseudonymization(item) {
            err := service.PseudonymizeData(item.ID)
            if err != nil {
                return ErasureResult{}, err
            }
            pseudonymizedCount++
        }
    }
    
    // –£–¥–∞–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    deletedCount, err := service.DeleteUserData(request.UserID)
    if err != nil {
        return ErasureResult{}, err
    }
    
    return ErasureResult{
        ServiceName:        service.GetName(),
        RecordsDeleted:     deletedCount,
        RecordsPseudonymized: pseudonymizedCount,
        CompletedAt:        time.Now(),
        Success:           true,
    }, nil
}
```

**HIPAA Compliance –¥–ª—è Healthcare Data:**
```go
type HIPAACompliantService struct {
    encryptionKey []byte
    auditLogger   AuditLogger
    accessControl AccessController
}

type PatientDataHandler struct {
    service *HIPAACompliantService
}

// –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å PHI –ª–æ–≥–∏—Ä—É—é—Ç—Å—è
func (pdh *PatientDataHandler) AccessPatientData(patientID, providerID string, purpose string) (*PatientData, error) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    if !pdh.service.accessControl.HasAccess(providerID, patientID, purpose) {
        pdh.service.auditLogger.LogUnauthorizedAccess(providerID, patientID, purpose)
        return nil, errors.New("access denied")
    }
    
    // –õ–æ–≥–∏—Ä—É–µ–º –ª–µ–≥–∞–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø
    pdh.service.auditLogger.LogPHIAccess(providerID, patientID, purpose)
    
    // –ü–æ–ª—É—á–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    encryptedData, err := pdh.service.getEncryptedPatientData(patientID)
    if err != nil {
        return nil, err
    }
    
    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º
    data, err := pdh.service.decryptPHI(encryptedData)
    if err != nil {
        return nil, err
    }
    
    return data, nil
}

// –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è purpose
func (pdh *PatientDataHandler) GetMinimalPHI(patientID, providerID, purpose string) (*MinimalPHI, error) {
    fullData, err := pdh.AccessPatientData(patientID, providerID, purpose)
    if err != nil {
        return nil, err
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è
    switch purpose {
    case "appointment_scheduling":
        return &MinimalPHI{
            PatientID: fullData.ID,
            Name:      fullData.Name,
            Phone:     fullData.Phone,
            // –ù–ï –≤–∫–ª—é—á–∞–µ–º –º–µ–¥–∏—Ü–∏–Ω—Å–∫—É—é –∏—Å—Ç–æ—Ä–∏—é
        }, nil
    case "treatment":
        return &MinimalPHI{
            PatientID:      fullData.ID,
            Name:          fullData.Name,
            MedicalHistory: fullData.MedicalHistory,
            Allergies:     fullData.Allergies,
            // –ù–ï –≤–∫–ª—é—á–∞–µ–º —Ñ–∏–Ω–∞–Ω—Å–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        }, nil
    default:
        return nil, errors.New("unknown purpose")
    }
}

// Audit trail –¥–ª—è HIPAA compliance
func (al *AuditLogger) LogPHIAccess(userID, patientID, purpose string) {
    entry := &AuditEntry{
        Timestamp:     time.Now(),
        UserID:        userID,
        Action:        "PHI_ACCESS",
        ResourceID:    patientID,
        Purpose:       purpose,
        IPAddress:     al.getCurrentIP(),
        Workstation:   al.getCurrentWorkstation(),
        Success:       true,
        SessionID:     al.getCurrentSessionID(),
    }
    
    // HIPAA —Ç—Ä–µ–±—É–µ—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    al.writeAuditEntry(entry)
    
    // –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ SIEM –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    al.sendToSIEM(entry)
}
```

**Data Subject Rights Automation:**
```go
type DataSubjectRightsManager struct {
    services []ComplianceService
    workflow WorkflowEngine
}

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å—É–±—ä–µ–∫—Ç–æ–≤ –¥–∞–Ω–Ω—ã—Ö
func (dsrm *DataSubjectRightsManager) ProcessDataSubjectRequest(request *DataSubjectRequest) error {
    switch request.Type {
    case "ACCESS":
        return dsrm.processAccessRequest(request)
    case "RECTIFICATION":
        return dsrm.processRectificationRequest(request)
    case "ERASURE":
        return dsrm.processErasureRequest(request)
    case "PORTABILITY":
        return dsrm.processPortabilityRequest(request)
    case "RESTRICTION":
        return dsrm.processRestrictionRequest(request)
    case "OBJECTION":
        return dsrm.processObjectionRequest(request)
    default:
        return errors.New("unsupported request type")
    }
}

func (dsrm *DataSubjectRightsManager) processAccessRequest(request *DataSubjectRequest) error {
    // –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    userData := make(map[string]interface{})
    
    for _, service := range dsrm.services {
        data, err := service.GetUserData(request.SubjectID)
        if err != nil {
            return err
        }
        userData[service.GetName()] = data
    }
    
    // –°–æ–∑–¥–∞–µ–º –º–∞—à–∏–Ω–æ—á–∏—Ç–∞–µ–º—ã–π —ç–∫—Å–ø–æ—Ä—Ç
    export := &DataExport{
        SubjectID:    request.SubjectID,
        RequestID:    request.ID,
        ExportDate:   time.Now(),
        Format:       "JSON",
        Data:         userData,
        Verification: dsrm.createVerificationHash(userData),
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—É–±—ä–µ–∫—Ç—É –¥–∞–Ω–Ω—ã—Ö
    return dsrm.deliverDataExport(request, export)
}
```

---

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏ - –†–µ—à–µ–Ω–∏—è

### üéØ –ó–∞–¥–∞—á–∞ 1: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –¥–∏–∑–∞–π–Ω - –†–µ—à–µ–Ω–∏–µ

**–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ Zero Trust –¥–ª—è —Ñ–∏–Ω—Ç–µ—Ö–∞:**

```yaml
# 1. Service Mesh –¥–ª—è mTLS
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
metadata:
  name: fintech-mesh
spec:
  values:
    global:
      meshID: fintech-cluster
      trustDomain: fintech.local
    pilot:
      env:
        ENABLE_WORKLOAD_ENTRY_AUTOREGISTRATION: true

---
# 2. Strict mTLS –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT

---
# 3. Authorization policies –¥–ª—è PCI DSS
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: payment-processor-policy
spec:
  selector:
    matchLabels:
      app: payment-processor
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/default/sa/order-service"]
  - to:
    - operation:
        methods: ["POST"]
        paths: ["/api/v1/charge"]
  - when:
    - key: request.headers[x-pci-compliant]
      values: ["true"]
```

**OAuth 2.0 + SPIFFE Implementation:**
```go
// Centralized Identity Provider
type FintechIdentityProvider struct {
    spiffeSource *workloadapi.Source
    jwtIssuer    *jwt.Issuer
    policies     *PolicyEngine
}

func (fip *FintechIdentityProvider) AuthenticateService(ctx context.Context, spiffeID string) (*ServiceCredentials, error) {
    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º SPIFFE ID
    svid, err := fip.spiffeSource.GetX509SVID()
    if err != nil {
        return nil, err
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤ whitelist —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    if !fip.isAuthorizedService(spiffeID) {
        return nil, errors.New("service not authorized")
    }
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º JWT —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º scope
    claims := &ServiceClaims{
        Subject:     spiffeID,
        Issuer:      "fintech-idp",
        IssuedAt:    time.Now(),
        ExpiresAt:   time.Now().Add(15 * time.Minute), // –ö–æ—Ä–æ—Ç–∫–∏–π TTL
        Audience:    fip.getAuthorizedAudiences(spiffeID),
        Scope:       fip.getServiceScope(spiffeID),
    }
    
    token, err := fip.jwtIssuer.IssueToken(claims)
    if err != nil {
        return nil, err
    }
    
    return &ServiceCredentials{
        AccessToken: token,
        TokenType:   "Bearer",
        ExpiresIn:   900, // 15 –º–∏–Ω—É—Ç
        SPIFFEID:    spiffeID,
    }, nil
}

// High Availability setup
func (fip *FintechIdentityProvider) setupHA() error {
    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–ª–∞—Å—Ç–µ—Ä identity providers
    cluster := &HACluster{
        Nodes: []Node{
            {ID: "idp-1", Address: "idp-1.internal:8443", Role: "primary"},
            {ID: "idp-2", Address: "idp-2.internal:8443", Role: "secondary"},
            {ID: "idp-3", Address: "idp-3.internal:8443", Role: "secondary"},
        },
        ConsensusAlgorithm: "raft",
        ElectionTimeout:    5 * time.Second,
        HeartbeatInterval:  1 * time.Second,
    }
    
    return fip.joinCluster(cluster)
}
```

### üéØ –ó–∞–¥–∞—á–∞ 2: –ò–Ω—Ü–∏–¥–µ–Ω—Ç-–æ—Ç–≤–µ—Ç - –†–µ—à–µ–Ω–∏–µ

**–ü–ª–∞–Ω —Ä–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:**

```go
type IncidentInvestigator struct {
    logAggregator    LogAggregator
    tracingClient    TracingClient
    metricsClient    MetricsClient
    networkAnalyzer  NetworkAnalyzer
    threatIntel      ThreatIntelligence
}

func (ii *IncidentInvestigator) InvestigateSuspiciousAPIActivity(incidentID string) (*Investigation, error) {
    investigation := &Investigation{
        ID:        incidentID,
        StartTime: time.Now(),
        Status:    "IN_PROGRESS",
    }
    
    // 1. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–≥–∏ API Gateway
    gatewayLogs, err := ii.logAggregator.Query(&LogQuery{
        TimeRange: TimeRange{
            Start: time.Now().Add(-2 * time.Hour),
            End:   time.Now(),
        },
        Services: []string{"api-gateway", "order-service", "payment-service"},
        Filters: map[string]interface{}{
            "status_code": []int{200, 201, 400, 401, 403, 500},
            "path":        []string{"/api/orders/*", "/api/payments/*"},
        },
    })
    
    // 2. –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å distributed traces
    suspiciousTraces, err := ii.analyzeSuspiciousTraces(gatewayLogs)
    if err != nil {
        return nil, err
    }
    
    // 3. –ê–Ω–∞–ª–∏–∑ –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    metrics := ii.analyzeMetrics(gatewayLogs.TimeRange)
    
    // 4. –°–µ—Ç–µ–≤–æ–π –∞–Ω–∞–ª–∏–∑
    networkAnalysis := ii.analyzeNetworkPatterns(gatewayLogs)
    
    // 5. Threat Intelligence lookup
    threatAnalysis := ii.analyzeThreatIntelligence(networkAnalysis.SourceIPs)
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º scope –∫–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏–∏
    scope := ii.determineScopeOfCompromise(gatewayLogs, suspiciousTraces, metrics)
    
    investigation.Findings = &InvestigationFindings{
        SuspiciousLogs:     gatewayLogs,
        SuspiciousTraces:   suspiciousTraces,
        AnomalousMetrics:   metrics,
        NetworkAnalysis:    networkAnalysis,
        ThreatIntelligence: threatAnalysis,
        CompromiseScope:    scope,
    }
    
    return investigation, nil
}

func (ii *IncidentInvestigator) analyzeSuspiciousTraces(logs *LogResult) ([]*SuspiciousTrace, error) {
    var suspiciousTraces []*SuspiciousTrace
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ trace ID
    traceGroups := make(map[string][]*LogEntry)
    for _, log := range logs.Entries {
        traceID := log.Metadata["trace_id"]
        if traceID != "" {
            traceGroups[traceID] = append(traceGroups[traceID], log)
        }
    }
    
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π trace
    for traceID, logEntries := range traceGroups {
        trace, err := ii.tracingClient.GetTrace(traceID)
        if err != nil {
            continue
        }
        
        // –ò—â–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        if ii.isAnomalousTrace(trace, logEntries) {
            suspiciousTrace := &SuspiciousTrace{
                TraceID:     traceID,
                Trace:       trace,
                LogEntries:  logEntries,
                Anomalies:   ii.identifyTraceAnomalies(trace),
                RiskScore:   ii.calculateTraceRiskScore(trace),
            }
            suspiciousTraces = append(suspiciousTraces, suspiciousTrace)
        }
    }
    
    return suspiciousTraces, nil
}

// Containment —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
func (ii *IncidentInvestigator) executeContainment(scope *CompromiseScope) error {
    var actions []ContainmentAction
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ IP
    for _, ip := range scope.CompromisedIPs {
        actions = append(actions, &BlockIPAction{
            IP:       ip,
            Duration: 24 * time.Hour,
            Reason:   "Suspicious API activity",
        })
    }
    
    // –ò–∑–æ–ª–∏—Ä—É–µ–º —Å–∫–æ–º–ø—Ä–æ–º–µ—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
    for _, service := range scope.CompromisedServices {
        actions = append(actions, &IsolateServiceAction{
            ServiceName: service,
            Method:      "network_policy",
            Duration:    1 * time.Hour,
        })
    }
    
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–æ–≤
    if scope.TokensCompromised {
        actions = append(actions, &ForceTokenRotationAction{
            Scope: "all_user_tokens",
            Reason: "Potential token compromise",
        })
    }
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –¥–µ–π—Å—Ç–≤–∏—è
    for _, action := range actions {
        err := ii.executeContainmentAction(action)
        if err != nil {
            log.Printf("Failed to execute containment action: %v", err)
        }
    }
    
    return nil
}
```

### üéØ –ó–∞–¥–∞—á–∞ 3: Code Review - –†–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∫–æ–¥–∞:**

```javascript
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const validator = require('validator');
const { body, validationResult } = require('express-validator');

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ security middleware
app.use(helmet());
app.use(rateLimit({
    windowMs: 15 * 60 * 1000, // 15 –º–∏–Ω—É—Ç
    max: 100, // –º–∞–∫—Å–∏–º—É–º 100 –∑–∞–ø—Ä–æ—Å–æ–≤ —Å IP
    message: 'Too many requests from this IP'
}));

// –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
const paymentValidation = [
    body('amount')
        .isNumeric()
        .isFloat({ min: 0.01, max: 100000 })
        .withMessage('Amount must be a positive number up to 100000'),
    body('currency')
        .isAlpha()
        .isLength({ min: 3, max: 3 })
        .toUpperCase()
        .withMessage('Currency must be a 3-letter code'),
];

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π endpoint
app.post('/api/payments', 
    authenticateToken,           // Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ JWT
    authorize(['create_payment']), // Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π
    paymentValidation,           // –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    async (req, res) => {
        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({ 
                    error: 'Validation failed', 
                    details: errors.array() 
                });
            }

            // –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
            const userId = req.user.sub;
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ä–µ—Å—É—Ä—Å–∞
            const canCreatePayment = await checkPaymentPermissions(userId, req.body.amount);
            if (!canCreatePayment) {
                return res.status(403).json({ error: 'Insufficient permissions for this amount' });
            }

            const payment = {
                userId: userId, // –ò—Å–ø–æ–ª—å–∑—É–µ–º ID –∏–∑ —Ç–æ–∫–µ–Ω–∞, –Ω–µ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
                amount: req.body.amount,
                currency: req.body.currency
            };

            // –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å
            const result = await db.query(
                'INSERT INTO payments (user_id, amount, currency, created_at) VALUES ($1, $2, $3, NOW()) RETURNING id',
                [payment.userId, payment.amount, payment.currency]
            );

            // –õ–æ–≥–∏—Ä—É–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é –¥–ª—è –∞—É–¥–∏—Ç–∞
            await auditLogger.log({
                action: 'payment_created',
                userId: payment.userId,
                amount: payment.amount,
                currency: payment.currency,
                paymentId: result.rows[0].id,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });

            res.status(201).json({ 
                success: true, 
                paymentId: result.rows[0].id 
            });

        } catch (error) {
            // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –Ω–æ –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏
            console.error('Payment creation error:', error);
            
            await auditLogger.log({
                action: 'payment_creation_failed',
                userId: req.user?.sub,
                error: error.message,
                ip: req.ip
            });

            res.status(500).json({ 
                error: 'Internal server error' 
            });
        }
    }
);

// Middleware –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
async function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω –∏ –∏–∑–≤–ª–µ–∫–∞–µ–º payload
        const decoded = jwt.verify(token, process.env.JWT_SECRET, {
            algorithms: ['HS256'], // –£–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
            issuer: process.env.JWT_ISSUER,
            audience: process.env.JWT_AUDIENCE
        });

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ–∫–µ–Ω –≤ blacklist
        const isBlacklisted = await redis.get(`blacklist:${token}`);
        if (isBlacklisted) {
            return res.status(401).json({ error: 'Token has been revoked' });
        }

        req.user = decoded;
        next();
    } catch (error) {
        console.error('Token verification failed:', error.message);
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
}

// Middleware –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
function authorize(permissions) {
    return async (req, res, next) => {
        try {
            const userPermissions = req.user.permissions || [];
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è
            const hasPermission = permissions.some(permission => 
                userPermissions.includes(permission)
            );
            
            if (!hasPermission) {
                await auditLogger.log({
                    action: 'authorization_failed',
                    userId: req.user.sub,
                    requiredPermissions: permissions,
                    userPermissions: userPermissions,
                    endpoint: req.path,
                    ip: req.ip
                });
                
                return res.status(403).json({ 
                    error: 'Insufficient permissions' 
                });
            }
            
            next();
        } catch (error) {
            console.error('Authorization error:', error);
            res.status(500).json({ error: 'Authorization failed' });
        }
    };
}
```

**–ù–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:**

1. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ JWT —Ç–æ–∫–µ–Ω–∞** - —Ç–æ–∫–µ–Ω –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª—Å—è
2. **SQL Injection** - –ø—Ä—è–º–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ SQL
3. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö** - amount –∏ currency –Ω–µ –≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–ª–∏—Å—å
4. **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∑–∞–ø—Ä–æ—Å–∞** - userId –±—Ä–∞–ª—Å—è –∏–∑ —Ç–æ–∫–µ–Ω–∞ –±–µ–∑ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
5. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ rate limiting** - –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å DDoS –∞—Ç–∞–∫
6. **–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã–µ –æ—à–∏–±–∫–∏** - —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
7. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∞—É–¥–∏—Ç–∞** - –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–µ –ª–æ–≥–∏—Ä–æ–≤–∞–ª–∏—Å—å
8. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ HTTPS enforcement** - security headers
9. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π** - —Ç–æ–ª—å–∫–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
10. **–ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - stack traces –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ

---

## üìö –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –∫–ª—é—á–µ–≤—ã–µ –∞—Å–ø–µ–∫—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã. –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã:

1. **Defense in Depth** - –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –∑–∞—â–∏—Ç–∞
2. **Zero Trust** - –Ω–µ –¥–æ–≤–µ—Ä—è–π, –ø—Ä–æ–≤–µ—Ä—è–π
3. **Least Privilege** - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø—Ä–∞–≤–∞
4. **Security by Design** - –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞
5. **Continuous Monitoring** - –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
6. **Incident Response** - –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞–º
7. **Compliance** - —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º

**–ü–æ–º–Ω–∏—Ç–µ:** –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å - —ç—Ç–æ –Ω–µ –ø—Ä–æ–¥—É–∫—Ç, –∞ –ø—Ä–æ—Ü–µ—Å—Å. –¢—Ä–µ–±—É–µ—Ç –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è, –æ–±—É—á–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã –∏ –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∫ –Ω–æ–≤—ã–º —É–≥—Ä–æ–∑–∞–º.