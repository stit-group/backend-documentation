# ðŸ”„ Ð‘Ð»Ð¾Ðº 5: Ð Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ðµ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

**â±ï¸ ÐŸÑ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ:** 3 Ð½ÐµÐ´ÐµÐ»Ð¸  
**ðŸŽ¯ Ð¦ÐµÐ»ÑŒ:** ÐŸÐ¾ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÐ¼Ñ‹Ðµ ÐºÑÑˆÐ¸Ñ€ÑƒÑŽÑ‰Ð¸Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ Ð´Ð»Ñ Ð²Ñ‹ÑÐ¾ÐºÐ¾Ð½Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ñ‹Ñ… Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹

---

## ðŸ“š Ð“Ð»Ð°Ð²Ð° 1: ÐšÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

### ðŸŽ¯ Ð’Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ

ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸ÑŽ: Ñƒ Ð²Ð°Ñ ÐµÑÑ‚ÑŒ 3 ÐºÑÑˆ-ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¸ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ñ€Ð°Ð²Ð½Ð¾Ð¼ÐµÑ€Ð½Ð¾ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¼ÐµÐ¶Ð´Ñƒ Ð½Ð¸Ð¼Ð¸ 1000 ÐºÐ»ÑŽÑ‡ÐµÐ¹. ÐŸÑ€Ð¾ÑÑ‚Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ â€” Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ:

```
server_id = hash(key) % number_of_servers
```

### âš ï¸ ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ð³Ð¾ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

```
Ð˜ÑÑ…Ð¾Ð´Ð½Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ (3 ÑÐµÑ€Ð²ÐµÑ€Ð°):
------------------------------------
Server 0: ÐºÐ»ÑŽÑ‡Ð¸ 0, 3, 6, 9, ...
Server 1: ÐºÐ»ÑŽÑ‡Ð¸ 1, 4, 7, 10, ...
Server 2: ÐºÐ»ÑŽÑ‡Ð¸ 2, 5, 8, 11, ...
------------------------------------

ÐŸÐ¾ÑÐ»Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ 4-Ð³Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°:
------------------------------------
Server 0: ÐºÐ»ÑŽÑ‡Ð¸ 0, 4, 8, 12, ...
Server 1: ÐºÐ»ÑŽÑ‡Ð¸ 1, 5, 9, 13, ...
Server 2: ÐºÐ»ÑŽÑ‡Ð¸ 2, 6, 10, 14, ...
Server 3: ÐºÐ»ÑŽÑ‡Ð¸ 3, 7, 11, 15, ...
------------------------------------
```

**Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚:** 75% ÐºÐ»ÑŽÑ‡ÐµÐ¹ Ð¿ÐµÑ€ÐµÐ¼ÐµÑÑ‚Ð¸Ð»Ð¸ÑÑŒ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹! Ð­Ñ‚Ð¾ Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ Ð¼Ð°ÑÑÐ¾Ð²Ñ‹Ðµ cache miss'Ñ‹.

### ðŸ”§ Ð ÐµÑˆÐµÐ½Ð¸Ðµ: ÐšÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

ÐšÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ñ€ÐµÑˆÐ°ÐµÑ‚ ÑÑ‚Ñƒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñƒ, Ð¼Ð¸Ð½Ð¸Ð¼Ð¸Ð·Ð¸Ñ€ÑƒÑ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ð¹ Ð¿Ñ€Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð².

#### ÐŸÑ€Ð¸Ð½Ñ†Ð¸Ð¿ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹:

```
        0Â°
        â†‘
   315Â°   45Â°
      \ /
270Â° â† â€¢ â†’ 90Â°
      / \
   225Â°   135Â°
        â†“
       180Â°

ÐšÐ¾Ð»ÑŒÑ†Ð¾ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ (0-360Â°)
```

**ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼:**
1. Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÐ¼ ÑÐµÑ€Ð²ÐµÑ€Ñ‹ Ð½Ð° ÐºÐ¾Ð»ÑŒÑ†Ðµ Ð¿Ð¾ Ñ…ÐµÑˆÑƒ Ð¸Ñ… Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²
2. Ð Ð°Ð·Ð¼ÐµÑ‰Ð°ÐµÐ¼ ÐºÐ»ÑŽÑ‡Ð¸ Ð½Ð° ÐºÐ¾Ð»ÑŒÑ†Ðµ Ð¿Ð¾ Ð¸Ñ… Ñ…ÐµÑˆÑƒ
3. ÐšÐ°Ð¶Ð´Ñ‹Ð¹ ÐºÐ»ÑŽÑ‡ Ð¾Ð±ÑÐ»ÑƒÐ¶Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐ¸Ð¼ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð¼ Ð¿Ð¾ Ñ‡Ð°ÑÐ¾Ð²Ð¾Ð¹ ÑÑ‚Ñ€ÐµÐ»ÐºÐµ

#### Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ñ:

```
        Server A (45Â°)
        â†‘
   Key3   Key1
      \ /
Server C â† â€¢ â†’ Key2
   (270Â°)    / \
   Key4   Key5
        â†“
    Server B (180Â°)
```

### ðŸŽ² Virtual Nodes (Ð’Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÑƒÐ·Ð»Ñ‹)

Ð”Ð»Ñ Ð±Ð¾Ð»ÐµÐµ Ñ€Ð°Ð²Ð½Ð¾Ð¼ÐµÑ€Ð½Ð¾Ð³Ð¾ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ÑÑ Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ðµ ÑƒÐ·Ð»Ñ‹:

```
Ð‘ÐµÐ· Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÑƒÐ·Ð»Ð¾Ð²:
----------------------
Server A: 45Â°
Server B: 180Â°
Server C: 270Â°

ÐÐ°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð½ÐµÑ€Ð°Ð²Ð½Ð¾Ð¼ÐµÑ€Ð½Ð°Ñ!

Ð¡ Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ ÑƒÐ·Ð»Ð°Ð¼Ð¸ (Ð¿Ð¾ 3 Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€):
---------------------------------------
Server A: 45Â°, 120Â°, 300Â°
Server B: 60Â°, 180Â°, 330Â°  
Server C: 90Â°, 210Â°, 270Â°

ÐÐ°Ð³Ñ€ÑƒÐ·ÐºÐ° Ñ€Ð°Ð²Ð½Ð¾Ð¼ÐµÑ€Ð½Ð°Ñ!
```

### ðŸ’» ÐŸÑ€Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ

```python
import hashlib
import bisect

class ConsistentHash:
    def __init__(self, replicas=3):
        self.replicas = replicas
        self.ring = {}
        self.sorted_keys = []
    
    def _hash(self, key):
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node):
        for i in range(self.replicas):
            virtual_key = f"{node}:{i}"
            key = self._hash(virtual_key)
            self.ring[key] = node
            bisect.insort(self.sorted_keys, key)
    
    def remove_node(self, node):
        for i in range(self.replicas):
            virtual_key = f"{node}:{i}"
            key = self._hash(virtual_key)
            del self.ring[key]
            self.sorted_keys.remove(key)
    
    def get_node(self, key):
        if not self.ring:
            return None
        
        hash_key = self._hash(key)
        idx = bisect.bisect_right(self.sorted_keys, hash_key)
        if idx == len(self.sorted_keys):
            idx = 0
        return self.ring[self.sorted_keys[idx]]
```

### ðŸ“Š Ð¡Ñ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸

```
Ð¡Ñ†ÐµÐ½Ð°Ñ€Ð¸Ð¹: ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ 1 Ð¸Ð· 4 ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð²

ÐžÐ±Ñ‹Ñ‡Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ:
--------------------
ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¾ ÐºÐ»ÑŽÑ‡ÐµÐ¹: 75%
Cache miss rate: 75%

ÐšÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ:
--------------------------
ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¾ ÐºÐ»ÑŽÑ‡ÐµÐ¹: 25%
Cache miss rate: 25%

Ð’Ñ‹Ð¸Ð³Ñ€Ñ‹Ñˆ Ð² 3 Ñ€Ð°Ð·Ð°!
```

---

## ðŸ“š Ð“Ð»Ð°Ð²Ð° 2: Ð ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð¸ ÑˆÐ°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

### ðŸ”„ Ð ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ…

Ð ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð¾Ð±ÐµÑÐ¿ÐµÑ‡Ð¸Ð²Ð°ÐµÑ‚ Ð²Ñ‹ÑÐ¾ÐºÑƒÑŽ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ Ð¸ Ð¾Ñ‚ÐºÐ°Ð·Ð¾ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ð¾ÑÑ‚ÑŒ ÐºÑÑˆÐ°.

#### Master-Slave Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ:

```
    Client
      â†“
   [Master]     â† Ð·Ð°Ð¿Ð¸ÑÑŒ
      â†“
   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
   â†“     â†“     â†“
[Slave1][Slave2][Slave3]  â† Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ
```

**Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸:**
- âœ… Ð’Ñ‹ÑÐ¾ÐºÐ°Ñ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ñ‡Ñ‚ÐµÐ½Ð¸Ñ
- âœ… ÐŸÑ€Ð¾ÑÑ‚Ð¾Ñ‚Ð° Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸  
- âŒ Ð•Ð´Ð¸Ð½Ð°Ñ Ñ‚Ð¾Ñ‡ÐºÐ° Ð¾Ñ‚ÐºÐ°Ð·Ð° (master)
- âŒ Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð° Ð¿Ð¾Ñ‚ÐµÑ€Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ñ€Ð¸ Ð¿Ð°Ð´ÐµÐ½Ð¸Ð¸ master

#### Master-Master Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ:

```
[Master A] â†” [Master B]
    â†‘           â†‘
    â””â”€ Client â”€â”€â”˜
```

**Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ¸:**
- âœ… ÐÐµÑ‚ ÐµÐ´Ð¸Ð½Ð¾Ð¹ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¾Ñ‚ÐºÐ°Ð·Ð°
- âœ… Ð‘Ð°Ð»Ð°Ð½ÑÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð·Ð°Ð¿Ð¸ÑÐ¸
- âŒ Ð¡Ð»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ñ ÐºÐ¾Ð½Ñ„Ð»Ð¸ÐºÑ‚Ð¾Ð²
- âŒ Ð¡Ð»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸

### ðŸ—‚ï¸ Ð¨Ð°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ (Partitioning)

Ð Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¼ÐµÐ¶Ð´Ñƒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ð¼Ð¸ ÑƒÐ·Ð»Ð°Ð¼Ð¸ Ð´Ð»Ñ Ð³Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ.

#### Ð“Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚Ð°Ð»ÑŒÐ½Ð¾Ðµ ÑˆÐ°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ:

```
Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹:
--------------------
User ID: 1-1000   â†’ Shard A
User ID: 1001-2000 â†’ Shard B  
User ID: 2001-3000 â†’ Shard C
User ID: 3001-4000 â†’ Shard D
```

#### Ð¨Ð°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾ hash'Ñƒ:

```
hash(key) % num_shards = shard_id

Example:
--------
hash("user:123") % 4 = 1 â†’ Shard B
hash("user:456") % 4 = 3 â†’ Shard D
```

### ðŸ”§ Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ Failover

#### ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Failover:

```
ÐÐ¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð°Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ð°:
-----------------
Client â†’ Master A (Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹)
         Master B (standby)

ÐŸÐ¾ÑÐ»Ðµ Ð¾Ñ‚ÐºÐ°Ð·Ð° Master A:
---------------------
Client â†’ Master B (Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹)
         Master A (Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½)

Ð’Ñ€ÐµÐ¼Ñ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ: 1-5 ÑÐµÐºÑƒÐ½Ð´
```

#### Graceful Degradation:

```
Ð’ÑÐµ 4 ÑˆÐ°Ñ€Ð´Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚:
--------------------
Performance: 100%
Capacity: 100%

1 ÑˆÐ°Ñ€Ð´ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½:
-----------------
Performance: 75%
Capacity: 75%
Strategy: Ð¿ÐµÑ€ÐµÐ½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¸Ðµ ÑˆÐ°Ñ€Ð´Ñ‹
```

### ðŸ’¾ Recovery ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸

#### Warm Standby:

```
[Primary] â†’ sync â†’ [Standby]
    â†“               â†“
  Hot cache      Warm cache
  (Ð²ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ)   (Ñ‡Ð°ÑÑ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ñ…)

Recovery time: ÑÐµÐºÑƒÐ½Ð´Ñ‹
```

#### Cold Standby:

```
[Primary] â†’ backup â†’ [Storage]
                        â†“
                   [New instance]
                        â†“
                   Ð’Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ

Recovery time: Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹/Ñ‡Ð°ÑÑ‹
```

---

## ðŸ“š Ð“Ð»Ð°Ð²Ð° 3: ÐŸÐ°Ñ‚Ñ‚ÐµÑ€Ð½Ñ‹ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð³Ð¾ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

### ðŸ”„ Cache-Aside Ð² Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ ÑÑ€ÐµÐ´Ðµ

```
Application Logic:
------------------

1. Ð§Ñ‚ÐµÐ½Ð¸Ðµ:
   â”Œâ”€ get(key) â†’ Cache Cluster
   â”‚              â†“
   â”‚         [Node A][Node B][Node C]
   â”‚              â†“
   â”‚         cache miss/hit
   â”‚              â†“
   â”‚         if miss: â†’ Database
   â”‚              â†“
   â”‚         put(key, value) â†’ Cache

2. Ð—Ð°Ð¿Ð¸ÑÑŒ:
   â”Œâ”€ save(data) â†’ Database
   â”‚              â†“
   â”‚         invalidate(key) â†’ Cache Cluster
```

#### ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ð² Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ ÑÑ€ÐµÐ´Ðµ:

```
Race Condition:
--------------
Thread 1: invalidate(key) â†’ [Node A]
Thread 2: get(key) â†’ miss â†’ DB â†’ put(key, old_value)

Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚: ÑƒÑÑ‚Ð°Ñ€ÐµÐ²ÑˆÐ¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² ÐºÑÑˆÐµ!

Ð ÐµÑˆÐµÐ½Ð¸Ðµ: Ð²ÐµÑ€ÑÐ¸Ð¾Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ
```

### ðŸ”„ Write-Through ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

```
Write-Through Pattern:
---------------------

Application
    â†“ write(key, value)
Cache Cluster
    â†“ (ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾)
Database

ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð°:
âœ… ÐšÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ñ…
âœ… Ð’ÑÐµÐ³Ð´Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ð¹ ÐºÑÑˆ

ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚ÐºÐ¸:
âŒ Ð’Ñ‹ÑÐ¾ÐºÐ°Ñ Ð»Ð°Ñ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚ÑŒ Ð·Ð°Ð¿Ð¸ÑÐ¸
âŒ ÐÐ°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð½Ð° ÐºÑÑˆ Ð¿Ñ€Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÐ¸
```

### ðŸ”„ Write-Behind ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

```
Write-Behind Pattern:
--------------------

Application
    â†“ write(key, value)
Cache Cluster
    â†“ (Ð°ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾, Ð±Ð°Ñ‚Ñ‡Ð°Ð¼Ð¸)
Database

ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð°Ñ Ð·Ð°Ð¿Ð¸ÑÑŒ:
------------------
Cache Buffer: [key1, key2, key3, ...]
               â†“ (ÐºÐ°Ð¶Ð´Ñ‹Ðµ 5 ÑÐµÐº)
Database: batch_write([key1, key2, key3])
```

#### Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Write-Behind:

```python
import asyncio
from collections import defaultdict

class WriteBehindCache:
    def __init__(self, flush_interval=5):
        self.cache = {}
        self.dirty_keys = set()
        self.flush_interval = flush_interval
        self.running = True
        
    async def put(self, key, value):
        self.cache[key] = value
        self.dirty_keys.add(key)
        
    async def flush_worker(self):
        while self.running:
            if self.dirty_keys:
                # Batch write to database
                await self.flush_to_db(list(self.dirty_keys))
                self.dirty_keys.clear()
            await asyncio.sleep(self.flush_interval)
```

### ðŸ”„ Read-Through ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

```
Read-Through Pattern:
--------------------

Application
    â†“ get(key)
Cache Cluster
    â†“ (ÐµÑÐ»Ð¸ miss)
Database Loader
    â†“
Cache (Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸)

Transparent Loading:
-------------------
def get(key):
    value = cache.get(key)
    if value is None:
        value = database.load(key)
        cache.put(key, value)
    return value
```

---

## ðŸ“š Ð“Ð»Ð°Ð²Ð° 4: ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ð¸

### âš–ï¸ CAP Ñ‚ÐµÐ¾Ñ€ÐµÐ¼Ð° Ð¸ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

```
CAP Triangle:
            Consistency
                â–²
               / \
              /   \
             /     \
            /       \
Availability â—„â”€â”€â”€â”€â”€â–º Partition
                   Tolerance

Ð’ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ñ… ÐºÑÑˆÐ°Ñ… Ð½ÑƒÐ¶Ð½Ð¾ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ 2 Ð¸Ð· 3!
```

#### ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ Ð²Ñ‹Ð±Ð¾Ñ€Ð°:

```
CP (Consistency + Partition Tolerance):
--------------------------------------
Redis Cluster Ð² ÑÑ‚Ñ€Ð¾Ð³Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ
- Ð¡Ð¸Ð»ÑŒÐ½Ð°Ñ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚ÑŒ
- Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ Ð¼Ð¾Ð¶ÐµÑ‚ ÑÑ‚Ñ€Ð°Ð´Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸ Ñ€Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð¸Ð¸

AP (Availability + Partition Tolerance):
---------------------------------------
Memcached ÐºÐ»Ð°ÑÑ‚ÐµÑ€
- Ð’Ñ‹ÑÐ¾ÐºÐ°Ñ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ
- Eventual consistency

CA (Consistency + Availability):
-------------------------------
ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð² Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ ÑÑ€ÐµÐ´Ðµ!
```

### ðŸ•°ï¸ Eventual Consistency

```
Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ð°Ñ ÑˆÐºÐ°Ð»Ð° Eventual Consistency:
------------------------------------

T0: Write(key=X, value=1) â†’ Node A
T1: Node A â†’ sync â†’ Node B âŒ (network issue)
T2: Read(key=X) from Node B â†’ returns old value
T3: Network recovered
T4: Node A â†’ sync â†’ Node B âœ…
T5: Read(key=X) from Node B â†’ returns new value

ÐŸÐµÑ€Ð¸Ð¾Ð´ Ð½ÐµÑÐ¾Ð³Ð»Ð°ÑÐ¾Ð²Ð°Ð½Ð½Ð¾ÑÑ‚Ð¸: T1-T4
```

#### Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ Ð¼Ð¸Ð½Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð½ÐµÑÐ¾Ð³Ð»Ð°ÑÐ¾Ð²Ð°Ð½Ð½Ð¾ÑÑ‚Ð¸:

```
1. Read Repair:
--------------
Client reads from multiple nodes
If values differ â†’ trigger repair

2. Anti-Entropy:
---------------
Background process ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ ÑƒÐ·Ð»Ñ‹

3. Hinted Handoff:
-----------------
Ð’Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ðµ Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹ Ð´Ð»Ñ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… ÑƒÐ·Ð»Ð¾Ð²
```

### âš”ï¸ Conflict Resolution

#### Last Write Wins (LWW):

```
Timeline:
--------
T1: Node A writes value=100, timestamp=T1
T2: Node B writes value=200, timestamp=T2
T3: Sync occurs

Result: value=200 (T2 > T1)

ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ð°: Ð¿Ð¾Ñ‚ÐµÑ€Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ñ€Ð¸ Ð½ÐµÑ‚Ð¾Ñ‡Ð½Ñ‹Ñ… Ñ‡Ð°ÑÐ°Ñ…!
```

#### Vector Clocks:

```
Vector Clock Example:
--------------------
Node A: [A:1, B:0, C:0] â†’ value=100
Node B: [A:1, B:1, C:0] â†’ value=200

ÐŸÑ€Ð¸ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸:
- Node B's clock Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ > Node A's clock
- Node B wins: value=200
```

#### CRDT (Conflict-free Replicated Data Types):

```
G-Counter (Grow-only Counter):
-----------------------------
Node A: {A: 5, B: 3, C: 2} = total: 10
Node B: {A: 4, B: 4, C: 2} = total: 10

Merge: {A: max(5,4), B: max(3,4), C: max(2,2)}
     = {A: 5, B: 4, C: 2} = total: 11
```

---

## ðŸ› ï¸ ÐŸÑ€Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ

### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 1: Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ð³Ð¾ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

```python
# Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑŽ ConsistentHash
# Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð¼ÐµÑ‚Ð¾Ð´Ñ‹:
# - get_load_distribution() - Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸
# - rebalance() - Ð¿ÐµÑ€ÐµÐ±Ð°Ð»Ð°Ð½ÑÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð¿Ñ€Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ð¸ ÑƒÐ·Ð»Ð¾Ð²

class AdvancedConsistentHash(ConsistentHash):
    def get_load_distribution(self):
        # TODO: Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒ Ð°Ð½Ð°Ð»Ð¸Ð· Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ
        pass
    
    def rebalance(self):
        # TODO: Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿ÐµÑ€ÐµÐ±Ð°Ð»Ð°Ð½ÑÐ¸Ñ€Ð¾Ð²ÐºÑƒ
        pass
```

### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 2: Distributed Cache Ñ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¼ ÑˆÐ°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼

```python
# Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ ÐºÐ»Ð°ÑÑ DistributedCache ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹:
# 1. ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ ÑˆÐ°Ñ€Ð´Ð¸Ñ€ÑƒÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¼ÐµÐ¶Ð´Ñƒ ÑƒÐ·Ð»Ð°Ð¼Ð¸
# 2. ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸ÑŽ
# 3. ÐžÐ±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÑ‚ Ð¾Ñ‚ÐºÐ°Ð·Ñ‹ ÑƒÐ·Ð»Ð¾Ð²

class DistributedCache:
    def __init__(self, nodes, replication_factor=2):
        # TODO: Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ
        pass
    
    async def get(self, key):
        # TODO: ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ñ ÑƒÑ‡ÐµÑ‚Ð¾Ð¼ ÑˆÐ°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
        pass
    
    async def put(self, key, value):
        # TODO: Ð—Ð°Ð¿Ð¸ÑÑŒ Ñ Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸ÐµÐ¹
        pass
    
    async def handle_node_failure(self, failed_node):
        # TODO: ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾Ñ‚ÐºÐ°Ð·Ð° ÑƒÐ·Ð»Ð°
        pass
```

### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 3: Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð°

```python
# Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñƒ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°ÐµÑ‚:
# - Hit/miss ratio Ð¿Ð¾ ÑƒÐ·Ð»Ð°Ð¼
# - Ð Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸
# - Ð—Ð°Ð´ÐµÑ€Ð¶ÐºÐ¸ Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸Ð¸
# - Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒ ÑƒÐ·Ð»Ð¾Ð²

class CacheMonitor:
    def __init__(self, cache_cluster):
        # TODO: Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð°
        pass
    
    def get_metrics(self):
        # TODO: Ð¡Ð±Ð¾Ñ€ Ð¼ÐµÑ‚Ñ€Ð¸Ðº
        pass
    
    def alert_on_issues(self):
        # TODO: Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð° Ð°Ð»ÐµÑ€Ñ‚Ð¾Ð²
        pass
```

### Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ 4: ÐÐ°Ð³Ñ€ÑƒÐ·Ð¾Ñ‡Ð½Ð¾Ðµ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ

```python
# Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ benchmark Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ:
# - ÐŸÑ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸ Ð¿Ñ€Ð¸ Ñ€Ð°Ð·Ð½Ð¾Ð¼ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ðµ ÑƒÐ·Ð»Ð¾Ð²
# - ÐŸÐ¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¸ Ð¾Ñ‚ÐºÐ°Ð·Ð°Ñ…
# - Ð­Ñ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ð³Ð¾ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ

async def benchmark_distributed_cache():
    # TODO: ÐšÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ñ‹Ð¹ Ð±ÐµÐ½Ñ‡Ð¼Ð°Ñ€Ðº
    pass
```

---

## ðŸ“Š ÐšÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸

### Performance Metrics:

```
Throughput:
----------
Requests per second (RPS)
Target: > 100,000 RPS

Latency:
-------
P50: < 1ms
P95: < 5ms  
P99: < 10ms

Consistency:
-----------
Max inconsistency window: < 100ms
Conflict resolution time: < 50ms
```

### Availability Metrics:

```
Uptime:
------
Target: 99.99% (52 minutes downtime/year)

MTTR (Mean Time To Recovery):
----------------------------
Target: < 30 seconds

Data Durability:
---------------
Target: 99.999999999% (11 9's)
```

---

## âœ… Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð±Ð»Ð¾ÐºÐ°

ÐŸÐ¾ÑÐ»Ðµ Ð¸Ð·ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑÑ‚Ð¾Ð³Ð¾ Ð±Ð»Ð¾ÐºÐ° Ð²Ñ‹ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ:

- ðŸŽ¯ ÐŸÑ€Ð¾ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ðµ ÐºÑÑˆÐ¸Ñ€ÑƒÑŽÑ‰Ð¸Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹
- âš–ï¸ Ð’Ñ‹Ð±Ð¸Ñ€Ð°Ñ‚ÑŒ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ðµ trade-off Ð¼ÐµÐ¶Ð´Ñƒ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ÑÑ‚ÑŒÑŽ  
- ðŸ”§ Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ñ‹Ð²Ð°Ñ‚ÑŒ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ñ…ÐµÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¸ ÑˆÐ°Ñ€Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ
- ðŸ›¡ï¸ ÐžÐ±ÐµÑÐ¿ÐµÑ‡Ð¸Ð²Ð°Ñ‚ÑŒ Ð¾Ñ‚ÐºÐ°Ð·Ð¾ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ð¾ÑÑ‚ÑŒ Ñ‡ÐµÑ€ÐµÐ· Ñ€ÐµÐ¿Ð»Ð¸ÐºÐ°Ñ†Ð¸ÑŽ
- ðŸ“Š ÐœÐ¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ñ‚ÑŒ Ð¸ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ
- ðŸ”„ Ð ÐµÑˆÐ°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ ÐºÐ¾Ð½ÑÐ¸ÑÑ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚Ð¸ Ð² Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ñ‹Ñ… ÑÐ¸ÑÑ‚ÐµÐ¼Ð°Ñ…

---

## ðŸ“š Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ€ÐµÑÑƒÑ€ÑÑ‹

### Ð¡Ñ‚Ð°Ñ‚ÑŒÐ¸:
- "Consistent Hashing and Random Trees" - Karger et al.
- "Dynamo: Amazon's Highly Available Key-value Store"
- "The CAP Theorem" - Eric Brewer

### Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹:
- Redis Cluster
- Apache Ignite  
- Hazelcast
- Memcached

### Open Source Ð¿Ñ€Ð¾ÐµÐºÑ‚Ñ‹:
- Consistent hashing implementations
- Distributed cache benchmarks
- Monitoring tools Ð´Ð»Ñ ÐºÑÑˆÐµÐ¹