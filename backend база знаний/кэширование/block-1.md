# Блок 1: Основы кэширования
**⏱️ Продолжительность:** 2 недели  
**🎯 Цель:** Понять фундаментальные принципы кэширования и заложить теоретическую базу

---

## 📖 Глава 1: Введение в кэширование

### Что такое кэш?

**Кэш** — это высокоскоростное хранилище данных, которое содержит копии часто используемых данных для быстрого доступа.

```
┌─────────────────────────────────────────┐
│           СИСТЕМА БЕЗ КЭША              │
├─────────────────────────────────────────┤
│                                         │
│  Приложение ────────► База данных       │
│      │                    │             │
│      │                    │             │
│   Запрос              Медленный         │
│   данных              ответ             │
│                      (100ms)            │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│            СИСТЕМА С КЭШЕМ              │
├─────────────────────────────────────────┤
│                                         │
│  Приложение ──► КЭШ ──► База данных     │
│      │          │           │           │
│      │       Быстрый    Медленный       │
│   Запрос    ответ       ответ           │
│   данных    (1ms)       (100ms)         │
│                                         │
└─────────────────────────────────────────┘
```

### Зачем нужен кэш?

**Основные преимущества:**
- 🚀 **Скорость** — доступ к данным в разы быстрее
- 💰 **Экономия ресурсов** — снижение нагрузки на основное хранилище
- 🌐 **Масштабируемость** — обработка большего количества запросов
- 💡 **Улучшение UX** — пользователи получают мгновенный отклик

### История развития кэширования

```
────────────────────────────────────────────────────────────────
1960s │ Первые буферные системы в мэйнфреймах
      │
1970s │ Появление кэшей процессоров
      │ ┌──────────────────┐
      │ │ CPU Cache L1     │
      │ └──────────────────┘
      │
1980s │ Многоуровневые кэши (L1, L2)
      │ ┌────┐ ┌────────┐
      │ │ L1 │─│   L2   │
      │ └────┘ └────────┘
      │
1990s │ Веб-кэширование, HTTP кэши
      │ ┌─────────┐ ┌─────────┐
      │ │Browser  │ │ Proxy   │
      │ │ Cache   │ │ Cache   │
      │ └─────────┘ └─────────┘
      │
2000s │ Распределенные кэши (Memcached, Redis)
      │ ┌─────┐ ┌─────┐ ┌─────┐
      │ │Node1│ │Node2│ │Node3│
      │ └─────┘ └─────┘ └─────┘
      │
2010s │ CDN, Edge кэширование
      │
2020s │ AI-powered кэширование
────────────────────────────────────────────────────────────────
```

### Типы кэшей в компьютерных системах

```
┌─────────────────── ИЕРАРХИЯ КЭШЕЙ ───────────────────┐
│                                                      │
│  ┌──────────────┐ ← Регистры процессора              │
│  │  Registers   │   (≤1 байт, ~0.5ns)                │
│  └──────────────┘                                    │
│         │                                            │
│  ┌──────────────┐ ← L1 кэш                           │
│  │   L1 Cache   │   (~32KB, ~1ns)                    │
│  └──────────────┘                                    │
│         │                                            │
│  ┌──────────────┐ ← L2 кэш                           │
│  │   L2 Cache   │   (~256KB, ~3ns)                   │
│  └──────────────┘                                    │
│         │                                            │
│  ┌──────────────┐ ← L3 кэш                           │
│  │   L3 Cache   │   (~8MB, ~12ns)                    │
│  └──────────────┘                                    │
│         │                                            │
│  ┌──────────────┐ ← Основная память                  │
│  │     RAM      │   (~16GB, ~100ns)                  │
│  └──────────────┘                                    │
│         │                                            │
│  ┌──────────────┐ ← Дисковое хранилище               │
│  │   Storage    │   (~1TB, ~10ms)                    │
│  └──────────────┘                                    │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

## 🎯 Глава 2: Принцип локальности данных

### Временная локальность (Temporal Locality)

**Определение:** Если к данным обратились недавно, то с высокой вероятностью к ним обратятся снова в ближайшее время.

```
Временная линия:
─────────────────────────────────────────────────────►
t1   t2   t3   t4   t5   t6   t7   t8   t9   t10

Доступ к переменной X:
 X         X              X    X         X

┌─────────────────────────────────────────┐
│ Вероятность повторного обращения:       │
│                                         │
│ Высокая  ████████                       │
│          ████████                       │
│          ████████                       │
│ Низкая   ████████                       │
│          ─────────────────────►          │
│          Время после обращения          │
└─────────────────────────────────────────┘
```

**Примеры временной локальности:**
- Переменные в циклах
- Недавно открытые файлы
- Активные веб-страницы

### Пространственная локальность (Spatial Locality)

**Определение:** Если обратились к данным в определенном месте, то вероятно скоро обратятся к соседним данным.

```
Память:
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │  F  │  G  │  H  │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
Адрес: 100  104  108  112  116  120  124  128

Обращение к элементу C (адрес 108):
┌─────┬─────┬█████┬─────┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │  F  │  G  │  H  │
└─────┴─────┴█████┴─────┴─────┴─────┴─────┴─────┘

Высокая вероятность обращения к соседним B и D:
┌─────┬█████┬█████┬█████┬─────┬─────┬─────┬─────┐
│  A  │  B  │  C  │  D  │  E  │  F  │  G  │  H  │
└─────┴█████┴█████┴█████┴─────┴─────┴─────┴─────┘
```

**Примеры пространственной локальности:**
- Обход массивов
- Чтение файлов последовательно
- Загрузка веб-страниц с ресурсами

### Практические примеры

**Пример 1: Цикл обработки массива**
```python
# Демонстрация обоих типов локальности
for i in range(1000):           # Временная локальность переменной i
    array[i] = array[i] * 2     # Пространственная локальность массива
```

**Пример 2: Веб-браузинг**
```
Пользователь открыл страницу example.com/products

Временная локальность:
- Переходы назад на главную страницу
- Повторное обновление страницы

Пространственная локальность:
- Загрузка CSS, JS, изображений с той же страницы
- Переходы на похожие страницы (/products/category1)
```

---

## ⚙️ Глава 3: Базовые алгоритмы вытеснения

### FIFO (First In, First Out)

**Принцип:** Удаляется элемент, который был добавлен в кэш первым.

```
Состояние кэша (размер = 3):
┌─────────────────────────────────────────────┐
│ Операция │   Кэш после операции            │
├─────────────────────────────────────────────┤
│ ADD(A)   │ [A]                             │
│ ADD(B)   │ [A, B]                          │
│ ADD(C)   │ [A, B, C]                       │
│ ADD(D)   │ [B, C, D] ← A удален (первый)   │
│ ADD(E)   │ [C, D, E] ← B удален (первый)   │
└─────────────────────────────────────────────┘

Структура данных:
┌────┐    ┌────┐    ┌────┐    ┌────┐
│ A  │───►│ B  │───►│ C  │───►│NULL│
└────┘    └────┘    └────┘    └────┘
  ↑                             ↑
Head                           Tail
(удаляем)                   (добавляем)
```

**Преимущества:**
- Простота реализации
- O(1) сложность операций
- Предсказуемое поведение

**Недостатки:**
- Не учитывает частоту использования
- Может удалить часто используемые данные

### LRU (Least Recently Used)

**Принцип:** Удаляется элемент, к которому дольше всего не обращались.

```
Пример работы LRU (размер = 3):
┌──────────────────────────────────────────────────┐
│ Операция    │ Кэш состояние │ Комментарий        │
├──────────────────────────────────────────────────┤
│ ACCESS(A)   │ [A]           │ Добавлен A         │
│ ACCESS(B)   │ [B, A]        │ B - самый свежий   │
│ ACCESS(C)   │ [C, B, A]     │ C - самый свежий   │
│ ACCESS(A)   │ [A, C, B]     │ A перемещен вперед │
│ ACCESS(D)   │ [D, A, C]     │ B удален (LRU)     │
│ ACCESS(B)   │ [B, D, A]     │ C удален (LRU)     │
└──────────────────────────────────────────────────┘

Реализация через двусвязный список + хеш-таблица:

Hash Table:        Doubly Linked List:
┌─────────────┐    ┌────┐ ↔ ┌────┐ ↔ ┌────┐
│ A → node_A  │    │ B  │   │ D  │   │ A  │
│ B → node_B  │    └────┘   └────┘   └────┘
│ D → node_D  │      ↑                 ↑
└─────────────┘     Head              Tail
                 (Most Recent)   (Least Recent)
```

**Преимущества:**
- Хорошо отражает принцип временной локальности
- Эффективен для большинства рабочих нагрузок

**Недостатки:**
- Сложнее в реализации
- Требует дополнительную память для поддержания порядка

### LFU (Least Frequently Used)

**Принцип:** Удаляется элемент с наименьшей частотой обращений.

```
Пример работы LFU (размер = 3):
┌────────────────────────────────────────────────────────┐
│ Операция │ Кэш состояние │ Счетчики      │ Удален      │
├────────────────────────────────────────────────────────┤
│ACCESS(A) │ [A]           │ A:1           │ -           │
│ACCESS(B) │ [A, B]        │ A:1, B:1      │ -           │
│ACCESS(C) │ [A, B, C]     │ A:1, B:1, C:1 │ -           │
│ACCESS(A) │ [A, B, C]     │ A:2, B:1, C:1 │ -           │
│ACCESS(B) │ [A, B, C]     │ A:2, B:2, C:1 │ -           │
│ACCESS(D) │ [A, B, D]     │ A:2, B:2, D:1 │ C (freq=1)  │
│ACCESS(A) │ [A, B, D]     │ A:3, B:2, D:1 │ -           │
│ACCESS(E) │ [A, B, E]     │ A:3, B:2, E:1 │ D (freq=1)  │
└────────────────────────────────────────────────────────┘

Структура данных:
┌─────────────────┐
│ Frequency = 1   │  [E, новые элементы]
├─────────────────┤
│ Frequency = 2   │  [B]
├─────────────────┤
│ Frequency = 3   │  [A]
└─────────────────┘
```

**Преимущества:**
- Учитывает долгосрочные паттерны использования
- Хорош для стабильных рабочих нагрузок

**Недостатки:**
- Медленно адаптируется к изменениям
- Требует хранения счетчиков

### Random Replacement

**Принцип:** Удаляется случайно выбранный элемент.

```
Пример работы Random (размер = 3):
┌─────────────────────────────────────────────┐
│ Операция │ Кэш состояние │ Удален (random) │
├─────────────────────────────────────────────┤
│ ADD(A)   │ [A]           │ -               │
│ ADD(B)   │ [A, B]        │ -               │
│ ADD(C)   │ [A, B, C]     │ -               │
│ ADD(D)   │ [A, D, C]     │ B (random)      │
│ ADD(E)   │ [E, D, C]     │ A (random)      │
│ ADD(F)   │ [E, F, C]     │ D (random)      │
└─────────────────────────────────────────────┘

Генератор случайных чисел:
┌─────────┐    ┌─────────────┐    ┌─────────┐
│ random()│───►│ index % size│───►│ victim  │
└─────────┘    └─────────────┘    └─────────┘
```

**Преимущества:**
- Простейшая реализация
- O(1) сложность
- Низкие накладные расходы

**Недостатки:**
- Непредсказуемая производительность
- Может удалить критически важные данные

### Сравнение алгоритмов

```
┌─────────────────────────────────────────────────────────┐
│                СРАВНЕНИЕ АЛГОРИТМОВ                     │
├──────────┬──────────┬──────────┬──────────┬─────────────┤
│Алгоритм  │Сложность│Память    │Адаптация │Эффективность│
│          │операций  │накладные │к паттернам│             │
├──────────┼──────────┼──────────┼──────────┼─────────────┤
│ FIFO     │ O(1)     │ Низкие   │ Никакая  │ Низкая      │
│ LRU      │ O(1)     │ Средние  │ Хорошая  │ Высокая     │
│ LFU      │ O(log n) │ Высокие  │ Медленная│ Средняя     │
│ Random   │ O(1)     │ Низкие   │ Никакая  │ Средняя     │
└──────────┴──────────┴──────────┴──────────┴─────────────┘

График эффективности (Hit Rate):
100% │
     │     ██████ LRU
 90% │   ████████
     │ ████████████
 80% │ ████████████ LFU
     │ ████████████████
 70% │ ████████████████ Random
     │ ████████████████████
 60% │ ████████████████████ FIFO
     │ ████████████████████████
 50% └─────────────────────────────►
     0    20   40   60   80   100
          Нагрузка (requests/sec)
```

---

## 📊 Глава 4: Метрики эффективности кэша

### Hit Rate и Miss Rate

**Hit Rate** — процент запросов, найденных в кэше
**Miss Rate** — процент запросов, НЕ найденных в кэше

```
Формулы:
┌─────────────────────────────────────────┐
│ Hit Rate = Cache Hits / Total Requests  │
│ Miss Rate = Cache Misses / Total        │
│ Hit Rate + Miss Rate = 100%             │
└─────────────────────────────────────────┘

Пример расчета:
┌────────────────────────────────────────────┐
│ За час:                                    │
│ • Всего запросов: 10,000                   │
│ • Cache hits: 8,500                        │
│ • Cache misses: 1,500                      │
│                                            │
│ Hit Rate = 8,500 / 10,000 = 85%           │
│ Miss Rate = 1,500 / 10,000 = 15%          │
└────────────────────────────────────────────┘

Визуализация:
     Total Requests (10,000)
    ┌─────────────────────────┐
    │████████████████████░░░░│ 85% Hits
    │████████████████████░░░░│ 15% Misses
    └─────────────────────────┘
```

### Latency (Задержка)

**Cache Hit Latency** — время получения данных из кэша
**Cache Miss Latency** — время получения данных при промахе

```
Среднее время ответа:
┌─────────────────────────────────────────────────────────┐
│ Average Latency = (Hit Rate × Hit Latency) +           │
│                   (Miss Rate × Miss Latency)           │
└─────────────────────────────────────────────────────────┘

Пример:
┌────────────────────────────────────────────┐
│ • Hit Rate: 85%                            │
│ • Miss Rate: 15%                           │
│ • Hit Latency: 1ms                         │
│ • Miss Latency: 100ms                      │
│                                            │
│ Average = (0.85 × 1ms) + (0.15 × 100ms)   │
│         = 0.85ms + 15ms = 15.85ms          │
└────────────────────────────────────────────┘

График распределения:
Latency
   ▲
100ms│     ████
     │     ████ Miss (15%)
  50ms│     ████
     │     ████
   1ms│████████
     │████████ Hit (85%)
     └─────────────────────► Requests
```

### Throughput (Пропускная способность)

**Определение:** Количество запросов, обработанных в единицу времени

```
Формула пропускной способности:
┌──────────────────────────────────────────────┐
│ Throughput = Processed Requests / Time Unit  │
│                                              │
│ С кэшем:                                     │
│ Cache Throughput = Cache Capacity / Latency  │
└──────────────────────────────────────────────┘

Пример сравнения:
┌─────────────────────────────────────────────────┐
│                БЕЗ КЭША    │    С КЭШЕМ         │
├─────────────────────────────────────────────────┤
│ Latency:     100ms         │ 15.85ms (среднее)  │
│ Throughput:  10 req/sec    │ 63 req/sec          │
│ Улучшение:   -             │ 6.3x                │
└─────────────────────────────────────────────────┘

Визуализация throughput:
req/sec
   ▲
   │
70 │     ████████ С кэшем
   │     ████████
60 │     ████████
   │     ████████
50 │     ████████
   │     ████████
40 │     ████████
   │     ████████
30 │     ████████
   │     ████████
20 │     ████████
   │     ████████
10 │████ ████████ Без кэша
   │████ ████████
 0 └─────────────────────► Time
```

### Cache Efficiency Ratio

**Определение:** Отношение производительности с кэшем к производительности без кэша

```
Формула:
┌─────────────────────────────────────────────────────┐
│ Efficiency Ratio = Performance_with_cache /         │
│                    Performance_without_cache        │
└─────────────────────────────────────────────────────┘

Примеры расчета:
┌─────────────────────────────────────────────────────┐
│ По времени отклика:                                 │
│ Ratio = Latency_without / Latency_with              │
│       = 100ms / 15.85ms = 6.3x                     │
│                                                     │
│ По пропускной способности:                          │
│ Ratio = Throughput_with / Throughput_without        │
│       = 63 req/sec / 10 req/sec = 6.3x              │
└─────────────────────────────────────────────────────┘

Матрица эффективности:
┌─────────────────────────────────────────────┐
│ Hit Rate │ Efficiency Ratio │ Категория     │
├─────────────────────────────────────────────┤
│ 95-99%   │ 20-100x         │ Отличная      │
│ 90-95%   │ 10-20x          │ Очень хорошая │
│ 80-90%   │ 5-10x           │ Хорошая       │
│ 70-80%   │ 3-5x            │ Приемлемая    │
│ <70%     │ <3x             │ Требует       │
│          │                 │ оптимизации   │
└─────────────────────────────────────────────┘
```

---

## 🛠️ Практические задания

### Задание 1: Реализация простого LRU кэша

**Цель:** Создать работающий LRU кэш и протестировать его

**Техническое задание:**
```python
class LRUCache:
    def __init__(self, capacity):
        # Инициализация кэша заданного размера
        pass
    
    def get(self, key):
        # Получить значение по ключу
        # Вернуть -1 если ключа нет
        pass
    
    def put(self, key, value):
        # Добавить/обновить значение
        # При превышении capacity удалить LRU элемент
        pass

# Тестирование:
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # Ожидается: 1
cache.put(3, 3)      # Удаляет ключ 2
print(cache.get(2))  # Ожидается: -1
print(cache.get(3))  # Ожидается: 3
```

**Критерии оценки:**
- ✅ Корректная работа операций get/put
- ✅ Соблюдение ограничения capacity
- ✅ Правильный порядок вытеснения (LRU)
- ✅ Временная сложность O(1) для всех операций

### Задание 2: Бенчмарк алгоритмов

**Цель:** Сравнить производительность FIFO, LRU, LFU и Random

**Структура бенчмарка:**
```
┌─────────────────────────────────────────────┐
│ ПЛАН БЕНЧМАРКА                              │
├─────────────────────────────────────────────┤
│                                             │
│ 1. Реализовать 4 алгоритма                  │
│ 2. Создать тестовые сценарии:               │
│    • Последовательный доступ                │
│    • Случайный доступ                       │
│    • Циклический доступ                     │
│    • Реальные данные (web logs)             │
│ 3. Измерить:                                │
│    • Hit Rate                               │
│    • Среднее время операции                 │
│    • Использование памяти                   │
│ 4. Построить графики сравнения              │
│                                             │
└─────────────────────────────────────────────┘
```

**Пример структуры отчета:**
```
РЕЗУЛЬТАТЫ БЕНЧМАРКА
─────────────────────

Тестовый сценарий: Последовательный доступ
┌──────────┬─────────┬──────────┬─────────────┐
│Алгоритм  │Hit Rate │Avg Time  │Memory Usage │
├──────────┼─────────┼──────────┼─────────────┤
│ FIFO     │ 45.2%   │ 2.1ms    │ 100KB       │
│ LRU      │ 67.8%   │ 2.3ms    │ 120KB       │
│ LFU      │ 43.1%   │ 3.5ms    │ 140KB       │
│ Random   │ 38.9%   │ 1.8ms    │ 95KB        │
└──────────┴─────────┴──────────┴─────────────┘

Вывод: LRU показывает лучший Hit Rate для
последовательного доступа благодаря учету
временной локальности.
```

### Задание 3: Анализ паттернов доступа

**Цель:** Исследовать влияние различных паттернов на hit rate

**Паттерны для тестирования:**

1. **Последовательный доступ:**
```
Паттерн: 1, 2, 3, 4, 5, 6, 7, 8...
┌────┬────┬────┬────┬────┬────┬────┬────┐
│ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │
└────┴────┴────┴────┴────┴────┴────┴────┘
  ↑                                    ↑
Начало                               Конец

Ожидаемые результаты:
• FIFO: Низкий hit rate (нет повторов)
• LRU: Низкий hit rate (нет повторов)
• LFU: Низкий hit rate (все элементы равны)
```

2. **Циклический доступ:**
```
Паттерн: 1, 2, 3, 1, 2, 3, 1, 2, 3...
┌────┬────┬────┐ ┌────┬────┬────┐
│ 1  │ 2  │ 3  │ │ 1  │ 2  │ 3  │ цикл
└────┴────┴────┘ └────┴────┴────┘

Ожидаемые результаты:
• LRU: Высокий hit rate (временная локальность)
• LFU: Высокий hit rate (частотная локальность)
```

3. **Zipf распределение (реальные данные):**
```
Частота обращений:
   ▲
   │██
   │██
   │██ ██
   │██ ██ ██
   │██ ██ ██ ██ ██ ██ ████████████
   └─────────────────────────────────► Элементы
   
80% обращений к 20% элементов (правило Парето)
```

**Задание по анализу:**
- Реализовать генераторы для каждого паттерна
- Протестировать все алгоритмы на каждом паттерне
- Построить графики hit rate vs размер кэша
- Объяснить полученные результаты

---

## ✅ Контрольные вопросы

### Теоретические вопросы:

1. **Объясните разницу между временной и пространственной локальностью. Приведите примеры.**

2. **Почему LRU часто работает лучше FIFO в реальных системах?**

3. **В каких случаях LFU может быть предпочтительнее LRU?**

4. **Как рассчитать среднее время отклика системы с кэшем?**

### Практические задачи:

1. **Расчет метрик:**
   ```
   Дано:
   - 1000 запросов в час
   - 750 cache hits
   - Hit latency: 5ms
   - Miss latency: 200ms
   
   Найти:
   - Hit rate
   - Miss rate  
   - Среднее время отклика
   - Улучшение по сравнению с системой без кэша
   ```

2. **Трассировка алгоритма:**
   ```
   LRU кэш размером 3, последовательность обращений:
   A, B, C, A, D, E, A, B, C
   
   Покажите состояние кэша после каждой операции
   и рассчитайте hit rate.
   ```

---

## 📚 Дополнительные материалы

### Рекомендуемое чтение:
- **"Computer Systems: A Programmer's Perspective"** - глава о иерархии памяти
- **"Algorithms"** by Robert Sedgewick - раздел о хеш-таблицах и кэшировании

### Полезные ссылки:
- [LRU Cache Implementation in Python](https://example.com)
- [Cache Performance Analysis Tools](https://example.com)
- [Real-world Caching Case Studies](https://example.com)

### Следующий блок:
**Блок 2: Аппаратное кэширование** - изучение кэшей процессора и оптимизация кода для эффективного использования аппаратных кэшей.

---

## 🎯 Чек-лист завершения блока

- [ ] Понимаю концепцию кэширования и его пользу
- [ ] Могу объяснить принципы временной и пространственной локальности  
- [ ] Знаю основные алгоритмы вытеснения и их особенности
- [ ] Умею рассчитывать метрики эффективности кэша
- [ ] Реализовал рабочий LRU кэш
- [ ] Провел сравнительный анализ алгоритмов
- [ ] Готов переходить к изучению аппаратного кэширования

**Поздравляем! Вы успешно освоили основы кэширования! 🎉**