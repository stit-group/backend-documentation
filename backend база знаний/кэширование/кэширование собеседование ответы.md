# Backend Developer: Cache Interview Answers Guide

## 1. üéØ Cache Fundamentals

### Q1: Explain caching and when NOT to use it

**Answer:**
–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî —ç—Ç–æ —Ç–µ—Ö–Ω–∏–∫–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–ø–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –±—ã—Å—Ç—Ä–æ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –æ–±—Ä–∞—â–µ–Ω–∏–π. –ü—Ä–∏–Ω—Ü–∏–ø: trade-off –º–µ–∂–¥—É –ø–∞–º—è—Ç—å—é –∏ —Å–∫–æ—Ä–æ—Å—Ç—å—é.

**–ö–æ–≥–¥–∞ –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—ç—à:**
- –î–∞–Ω–Ω—ã–µ –º–µ–Ω—è—é—Ç—Å—è —á–∞—â–µ, —á–µ–º —á–∏—Ç–∞—é—Ç—Å—è
- –¢—Ä–µ–±—É–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–∞—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
- –û–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö –ø—Ä–µ–≤—ã—à–∞–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—É—é –ø–∞–º—è—Ç—å
- –°—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–º–∞—Ö–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –≤—ã–≥–æ–¥—É –æ—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è

**–ü—Ä–∏–º–µ—Ä –≤—Ä–µ–¥–Ω–æ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è:**
```javascript
// –ü–õ–û–•–û: –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ rapidly changing data
const userLocationCache = new Map();

function getUserLocation(userId) {
    if (userLocationCache.has(userId)) {
        return userLocationCache.get(userId); // –ú–æ–∂–µ—Ç –±—ã—Ç—å —É—Å—Ç–∞—Ä–µ–≤—à–∏–º —á–µ—Ä–µ–∑ —Å–µ–∫—É–Ω–¥—ã
    }
    const location = gpsService.getCurrentLocation(userId);
    userLocationCache.set(userId, location);
    return location;
}
```

### Q2: What's the difference between cache and buffer?

**Answer:**
- **Cache** - —Ö—Ä–∞–Ω–∏—Ç –∫–æ–ø–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è —á—Ç–µ–Ω–∏—è
- **Buffer** - –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–µ–π –∑–∞–ø–∏—Å–∏/—á—Ç–µ–Ω–∏—è

**Redis –∫–∞–∫ cache –∏ buffer:**
```javascript
// Cache usage
await redis.set('user:123', JSON.stringify(userData), 'EX', 3600);

// Buffer usage –¥–ª—è batch –∑–∞–ø–∏—Å–∏
const writeBuffer = [];
writeBuffer.push(operation);
if (writeBuffer.length >= 100) {
    await redis.pipeline(writeBuffer).exec();
    writeBuffer.length = 0;
}
```

### Q3: Explain cache locality principles

**Answer:**
–ü—Ä–∏–Ω—Ü–∏–ø—ã –ª–æ–∫–∞–ª—å–Ω–æ—Å—Ç–∏:
- **Temporal** - –Ω–µ–¥–∞–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã —Å–Ω–æ–≤–∞
- **Spatial** - –¥–∞–Ω–Ω—ã–µ —Ä—è–¥–æ–º —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–º–∏ —Ç–∞–∫–∂–µ –≤–µ—Ä–æ—è—Ç–Ω–æ –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è

**–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ e-commerce:**
```javascript
class ProductCatalogCache {
    constructor() {
        this.productCache = new LRU(1000);
        this.categoryCache = new LRU(100);
    }
    
    async getProduct(productId) {
        // Temporal locality - –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
        let product = this.productCache.get(productId);
        if (!product) {
            product = await db.getProduct(productId);
            this.productCache.set(productId, product);
            
            // Spatial locality - –∫—ç—à–∏—Ä—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
            this.categoryCache.set(product.categoryId, await db.getCategory(product.categoryId));
        }
        return product;
    }
}
```

### Q4: What causes cache pollution and how do you prevent it?

**Answer:**
Cache pollution - –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫—ç—à–∞ —Ä–µ–¥–∫–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, –≤—ã—Ç–µ—Å–Ω—è—é—â–∏–º–∏ "–≥–æ—Ä—è—á–∏–µ" –¥–∞–Ω–Ω—ã–µ.

**–ü—Ä–∏—á–∏–Ω—ã:**
- Scan operations —á–µ—Ä–µ–∑ –±–æ–ª—å—à–∏–µ datasets
- One-time batch operations
- –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ TTL

**–ó–∞—â–∏—Ç–∞:**
```javascript
class ProtectedCache {
    constructor() {
        this.hotCache = new LRU(800);  // 80% –¥–ª—è hot data
        this.coldCache = new LRU(200); // 20% –¥–ª—è new/scan data
    }
    
    get(key) {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º hot cache
        let value = this.hotCache.get(key);
        if (value) return value;
        
        // –ó–∞—Ç–µ–º cold cache
        value = this.coldCache.get(key);
        if (value) {
            // Promote to hot –µ—Å–ª–∏ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
            if (this.isFrequentlyAccessed(key)) {
                this.hotCache.set(key, value);
                this.coldCache.delete(key);
            }
            return value;
        }
        return null;
    }
}
```

### Q5: Cache warming strategies

**Answer:**
–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫—ç—à–∞ –∫—Ä–∏—Ç–∏—á–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ä–∞–±–æ—Ç—ã.

**–°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–∏:**
1. Critical path data (–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è, –æ—Å–Ω–æ–≤–Ω—ã–µ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏)
2. High-frequency access patterns
3. Expensive computations

```javascript
class CacheWarmer {
    async warmup() {
        const priorities = [
            { data: 'userSessions', weight: 10 },
            { data: 'productCatalog', weight: 8 },
            { data: 'recommendations', weight: 5 }
        ];
        
        for (const item of priorities.sort((a, b) => b.weight - a.weight)) {
            await this.warmDataType(item.data);
        }
    }
    
    async warmDataType(dataType) {
        switch(dataType) {
            case 'userSessions':
                const activeSessions = await db.getActiveSessions();
                for (const session of activeSessions) {
                    await cache.set(`session:${session.id}`, session, 3600);
                }
                break;
        }
    }
}
```

## 2. üîÑ Cache Strategies & Patterns

### Q6: Compare Cache-Aside vs Read-Through patterns

**Answer:**

**Cache-Aside (Lazy Loading):**
```javascript
// Application —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫—ç—à–µ–º
async function getUser(userId) {
    let user = await cache.get(`user:${userId}`);
    if (!user) {
        user = await database.getUser(userId);
        await cache.set(`user:${userId}`, user, 3600);
    }
    return user;
}
```

**Read-Through:**
```javascript
// Cache —Å–∞–º –∑–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
class ReadThroughCache {
    constructor(loader) {
        this.cache = new Map();
        this.loader = loader;
    }
    
    async get(key) {
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        const value = await this.loader(key);
        this.cache.set(key, value);
        return value;
    }
}

const userCache = new ReadThroughCache(userId => database.getUser(userId));
```

**–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:**
- Cache-Aside: –∫–æ–≥–¥–∞ –Ω—É–∂–µ–Ω –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –ª–æ–≥–∏–∫–æ–π –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
- Read-Through: –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è application –∫–æ–¥–∞

### Q7: Write-Through vs Write-Behind

**Answer:**

**Write-Through (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π):**
```javascript
async function updateUser(userId, userData) {
    // –û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤ cache –ò database
    await Promise.all([
        cache.set(`user:${userId}`, userData),
        database.updateUser(userId, userData)
    ]);
    
    if (database.error) {
        await cache.delete(`user:${userId}`); // Rollback
        throw database.error;
    }
}
```

**Write-Behind (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π):**
```javascript
class WriteBehindCache {
    constructor() {
        this.writeQueue = [];
        this.processing = false;
    }
    
    async set(key, value) {
        // –°—Ä–∞–∑—É –≤ cache
        await this.cache.set(key, value);
        
        // –í –æ—á–µ—Ä–µ–¥—å –Ω–∞ –∑–∞–ø–∏—Å—å –≤ DB
        this.writeQueue.push({ key, value, timestamp: Date.now() });
        this.scheduleFlush();
    }
    
    async scheduleFlush() {
        if (this.processing) return;
        
        this.processing = true;
        setTimeout(async () => {
            await this.flushToDatabase();
            this.processing = false;
        }, 1000);
    }
}
```

**–î–ª—è –±–∞–Ω–∫–æ–≤—Å–∫–æ–π —Å–∏—Å—Ç–µ–º—ã:** Write-Through –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π, Write-Behind –¥–ª—è –ª–æ–≥–æ–≤ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏.

### Q8: Solve the Cache Stampede problem

**Answer:**
–ü—Ä–æ–±–ª–µ–º–∞: –º–Ω–æ–∂–µ—Å—Ç–≤–æ requests –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –ø—ã—Ç–∞—é—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–∏ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ cache miss.

**–†–µ—à–µ–Ω–∏–µ —Å –º—å—é—Ç–µ–∫—Å–æ–º:**
```javascript
class StampedeProtectedCache {
    constructor() {
        this.cache = new Map();
        this.loadingKeys = new Map(); // –ú—å—é—Ç–µ–∫—Å –¥–ª—è –∑–∞–≥—Ä—É–∂–∞—é—â–∏—Ö—Å—è –∫–ª—é—á–µ–π
    }
    
    async get(key, loader) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º cache
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –ª–∏ —É–∂–µ
        if (this.loadingKeys.has(key)) {
            return await this.loadingKeys.get(key);
        }
        
        // –°–æ–∑–¥–∞–µ–º promise –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
        const loadingPromise = this.loadData(key, loader);
        this.loadingKeys.set(key, loadingPromise);
        
        try {
            const result = await loadingPromise;
            this.cache.set(key, result);
            return result;
        } finally {
            this.loadingKeys.delete(key);
        }
    }
    
    async loadData(key, loader) {
        return await loader(key);
    }
}
```

### Q9: TTL vs Manual Invalidation strategies

**Answer:**

**TTL –ø–æ–¥—Ö–æ–¥:**
```javascript
// –ü—Ä–æ—Å—Ç–æ–π, –Ω–æ –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å stale data
await cache.set('product:123', productData, 300); // 5 –º–∏–Ω—É—Ç TTL
```

**Manual Invalidation:**
```javascript
class ProductCache {
    async updateProduct(productId, newData) {
        await database.updateProduct(productId, newData);
        
        // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏
        const keysToInvalidate = [
            `product:${productId}`,
            `category:${newData.categoryId}`,
            `search:${newData.brand}`,
            `recommendations:${productId}`
        ];
        
        await Promise.all(
            keysToInvalidate.map(key => cache.delete(key))
        );
    }
}
```

**Distributed invalidation:**
```javascript
// –ò—Å–ø–æ–ª—å–∑—É–µ–º pub/sub –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤
class DistributedInvalidation {
    async invalidate(keys) {
        // –õ–æ–∫–∞–ª—å–Ω–∞—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è
        await Promise.all(keys.map(key => this.localCache.delete(key)));
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏–µ —Å–µ—Ä–≤–µ—Ä—ã
        await redis.publish('cache:invalidate', JSON.stringify(keys));
    }
    
    setupListener() {
        redis.subscribe('cache:invalidate');
        redis.on('message', (channel, message) => {
            const keys = JSON.parse(message);
            keys.forEach(key => this.localCache.delete(key));
        });
    }
}
```

### Q10: Refresh-Ahead pattern implementation

**Answer:**
–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è TTL –¥–ª—è –¥–æ—Ä–æ–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.

```javascript
class RefreshAheadCache {
    constructor(refreshThreshold = 0.8) {
        this.cache = new Map();
        this.refreshThreshold = refreshThreshold;
        this.refreshing = new Set();
    }
    
    async get(key, loader, ttl = 3600) {
        const item = this.cache.get(key);
        
        if (!item) {
            // Cache miss - –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            const value = await loader(key);
            this.cache.set(key, {
                value,
                expiry: Date.now() + ttl * 1000,
                ttl
            });
            return value;
        }
        
        const timeToExpiry = item.expiry - Date.now();
        const refreshTime = item.ttl * 1000 * this.refreshThreshold;
        
        // –ï—Å–ª–∏ –±–ª–∏–∑–∫–æ –∫ –∏—Å—Ç–µ—á–µ–Ω–∏—é - –æ–±–Ω–æ–≤–ª—è–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        if (timeToExpiry < refreshTime && !this.refreshing.has(key)) {
            this.refreshing.add(key);
            this.refreshInBackground(key, loader, item.ttl).finally(() => {
                this.refreshing.delete(key);
            });
        }
        
        return item.value;
    }
    
    async refreshInBackground(key, loader, ttl) {
        try {
            const newValue = await loader(key);
            this.cache.set(key, {
                value: newValue,
                expiry: Date.now() + ttl * 1000,
                ttl
            });
        } catch (error) {
            console.error(`Failed to refresh ${key}:`, error);
        }
    }
}
```

## 3. ‚ö° Eviction Algorithms & Performance

### Q11: Implement LRU cache from scratch

**Answer:**
```javascript
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
    }
    
    get(key) {
        if (this.cache.has(key)) {
            // Move to end (most recently used)
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
        }
        return null;
    }
    
    put(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
            // Remove least recently used (first item)
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
}

// Thread-safe –≤–µ—Ä—Å–∏—è
class ThreadSafeLRU {
    constructor(capacity) {
        this.lru = new LRUCache(capacity);
        this.mutex = new Mutex();
    }
    
    async get(key) {
        return await this.mutex.runExclusive(() => {
            return this.lru.get(key);
        });
    }
    
    async put(key, value) {
        return await this.mutex.runExclusive(() => {
            return this.lru.put(key, value);
        });
    }
}
```

### Q12: When would you choose LFU over LRU?

**Answer:**
LFU (Least Frequently Used) –ª—É—á—à–µ –∫–æ–≥–¥–∞ –µ—Å—Ç—å clear –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—ã–º–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º–∏ –¥–æ—Å—Ç—É–ø–∞.

**–ü—Ä–∏–º–µ—Ä - –≤–∏–¥–µ–æ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**
```javascript
class LFUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.values = new Map();
        this.frequencies = new Map();
        this.frequencyGroups = new Map(); // frequency -> Set of keys
        this.minFrequency = 0;
    }
    
    get(key) {
        if (!this.values.has(key)) return null;
        
        this.incrementFrequency(key);
        return this.values.get(key);
    }
    
    put(key, value) {
        if (this.capacity === 0) return;
        
        if (this.values.has(key)) {
            this.values.set(key, value);
            this.incrementFrequency(key);
            return;
        }
        
        if (this.values.size >= this.capacity) {
            this.evictLFU();
        }
        
        this.values.set(key, value);
        this.frequencies.set(key, 1);
        this.addToFrequencyGroup(key, 1);
        this.minFrequency = 1;
    }
    
    incrementFrequency(key) {
        const freq = this.frequencies.get(key);
        this.frequencies.set(key, freq + 1);
        
        this.removeFromFrequencyGroup(key, freq);
        this.addToFrequencyGroup(key, freq + 1);
        
        if (this.frequencyGroups.get(freq).size === 0 && freq === this.minFrequency) {
            this.minFrequency++;
        }
    }
}
```

**–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å LFU:**
- –°—Ç—Ä–∏–º–∏–Ω–≥ –∫–æ–Ω—Ç–µ–Ω—Ç (–ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –≤–∏–¥–µ–æ —Å–º–æ—Ç—Ä—è—Ç —á–∞—â–µ)
- –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã (CSS/JS —Ñ–∞–π–ª—ã)
- –°–ø—Ä–∞–≤–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è

**Aging problem solution:**
```javascript
// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ —É–º–µ–Ω—å—à–∞–µ–º –≤—Å–µ —á–∞—Å—Ç–æ—Ç—ã
setInterval(() => {
    cache.decayFrequencies(0.9); // –£–º–µ–Ω—å—à–∞–µ–º –Ω–∞ 10%
}, 24 * 60 * 60 * 1000); // –†–∞–∑ –≤ –¥–µ–Ω—å
```

### Q13: Explain ARC (Adaptive Replacement Cache)

**Answer:**
ARC –∞–¥–∞–ø—Ç–∏–≤–Ω–æ –±–∞–ª–∞–Ω—Å–∏—Ä—É–µ—Ç –º–µ–∂–¥—É recency (LRU) –∏ frequency (LFU) –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç workload patterns.

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞:**
- T1: recent items (LRU)
- T2: frequent items (LFU)  
- B1: ghost cache –¥–ª—è T1
- B2: ghost cache –¥–ª—è T2

```javascript
class ARCCache {
    constructor(capacity) {
        this.c = capacity;
        this.p = 0; // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
        
        this.T1 = new LRU(); // Recent
        this.T2 = new LRU(); // Frequent  
        this.B1 = new LRU(); // Ghost for T1
        this.B2 = new LRU(); // Ghost for T2
    }
    
    get(key) {
        if (this.T1.has(key)) {
            // Move from T1 to T2 (becomes frequent)
            const value = this.T1.get(key);
            this.T1.delete(key);
            this.T2.set(key, value);
            return value;
        }
        
        if (this.T2.has(key)) {
            return this.T2.get(key);
        }
        
        return null;
    }
    
    put(key, value) {
        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ p –Ω–∞ –æ—Å–Ω–æ–≤–µ ghost hits
        if (this.B1.has(key)) {
            this.p = Math.min(this.p + Math.max(1, this.B2.size / this.B1.size), this.c);
        } else if (this.B2.has(key)) {
            this.p = Math.max(this.p - Math.max(1, this.B1.size / this.B2.size), 0);
        }
        
        this.replace(key);
        this.T1.set(key, value);
    }
}
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∞–¥–∞–ø—Ç–∏—Ä—É–µ—Ç—Å—è –∫ —Å–º–µ–Ω–µ workload patterns –±–µ–∑ —Ä—É—á–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.

### Q14: Clock/Second-Chance algorithm

**Answer:**
–ê–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è LRU —Å O(1) –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏, –∏—Å–ø–æ–ª—å–∑—É—è reference bit.

```javascript
class ClockCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.frames = new Array(capacity).fill(null);
        this.referenceBits = new Array(capacity).fill(false);
        this.clock = 0;
    }
    
    get(key) {
        const index = this.findKey(key);
        if (index !== -1) {
            this.referenceBits[index] = true; // Set reference bit
            return this.frames[index].value;
        }
        return null;
    }
    
    put(key, value) {
        const existingIndex = this.findKey(key);
        if (existingIndex !== -1) {
            this.frames[existingIndex].value = value;
            this.referenceBits[existingIndex] = true;
            return;
        }
        
        // Find victim using clock algorithm
        while (true) {
            if (this.frames[this.clock] === null) {
                // Empty slot
                this.frames[this.clock] = { key, value };
                this.referenceBits[this.clock] = true;
                this.clock = (this.clock + 1) % this.capacity;
                break;
            }
            
            if (!this.referenceBits[this.clock]) {
                // Found victim
                this.frames[this.clock] = { key, value };
                this.referenceBits[this.clock] = true;
                this.clock = (this.clock + 1) % this.capacity;
                break;
            }
            
            // Give second chance
            this.referenceBits[this.clock] = false;
            this.clock = (this.clock + 1) % this.capacity;
        }
    }
}
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –Ω–∞–¥ LRU:**
- –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è –æ–ø–µ—Ä–∞—Ü–∏–π
- –ú–µ–Ω—å—à–µ –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ –ø–∞–º—è—Ç—å
- –•–æ—Ä–æ—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ

### Q15: Cache performance metrics and monitoring

**Answer:**
**–ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏:**
```javascript
class CacheMetrics {
    constructor() {
        this.hits = 0;
        this.misses = 0;
        this.evictions = 0;
        this.latencySum = 0;
        this.operations = 0;
    }
    
    recordHit(latency) {
        this.hits++;
        this.recordLatency(latency);
    }
    
    recordMiss(latency) {
        this.misses++;
        this.recordLatency(latency);
    }
    
    recordLatency(latency) {
        this.latencySum += latency;
        this.operations++;
    }
    
    getMetrics() {
        const total = this.hits + this.misses;
        return {
            hitRate: total > 0 ? this.hits / total : 0,
            missRate: total > 0 ? this.misses / total : 0,
            avgLatency: this.operations > 0 ? this.latencySum / this.operations : 0,
            evictionRate: this.evictions,
            throughput: this.operations / timeWindow
        };
    }
}
```

**Red flags –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞:**
- Hit rate < 70%
- –†–µ–∑–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ hit rate
- –í—ã—Å–æ–∫–∞—è latency –¥–ª—è cache hits
- –ß–∞—Å—Ç—ã–µ evictions
- Memory pressure
- Connection pool exhaustion

## 4. üåê Web & HTTP Caching

### Q16: HTTP cache headers deep dive

**Answer:**
```javascript
// Express.js example –¥–ª—è user-specific API
app.get('/api/user/:id/profile', (req, res) => {
    const userId = req.params.id;
    
    if (req.user.id !== parseInt(userId)) {
        // –ü—É–±–ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è - –º–æ–∂–Ω–æ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å
        res.set({
            'Cache-Control': 'public, max-age=300', // 5 –º–∏–Ω—É—Ç
            'ETag': `"profile-${userId}-${lastModified}"`,
            'Vary': 'Accept-Encoding'
        });
    } else {
        // –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - –Ω–µ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å
        res.set({
            'Cache-Control': 'private, no-cache, must-revalidate',
            'Pragma': 'no-cache'
        });
    }
    
    // Check ETag
    if (req.get('If-None-Match') === etag) {
        return res.status(304).end();
    }
    
    res.json(userProfile);
});

// –î–ª—è API —Å —á–∞—Å—Ç—ã–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏
app.get('/api/live-data', (req, res) => {
    res.set({
        'Cache-Control': 'no-store', // –í–æ–æ–±—â–µ –Ω–µ –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å
        'Expires': new Date(Date.now() - 1000).toUTCString() // –ü—Ä–æ—à–ª–æ–µ –≤—Ä–µ–º—è
    });
});
```

### Q17: CDN caching strategies

**Answer:**
```javascript
// –°—Ç—Ä–∞—Ç–µ–≥–∏—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏–∏ breaking news
class NewsInvalidation {
    async publishBreakingNews(article) {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ DB
        await db.saveArticle(article);
        
        // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º CDN
        const urlsToInvalidate = [
            '/api/news/latest',
            '/api/news/breaking',
            `/${article.category}`,
            '/sitemap.xml'
        ];
        
        // CloudFlare API example
        await Promise.all([
            this.invalidateCloudFlare(urlsToInvalidate),
            this.invalidateAWS(urlsToInvalidate),
            this.notifyEdgeServers(article.id)
        ]);
    }
    
    async invalidateCloudFlare(urls) {
        return fetch(`https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiToken}` },
            body: JSON.stringify({ files: urls })
        });
    }
}

// Nginx –∫–æ–Ω—Ñ–∏–≥ –¥–ª—è —Ä–∞–∑–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
/*
location /api/static/ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

location /api/news/ {
    expires 5m;
    add_header Cache-Control "public, must-revalidate";
}

location /api/user/ {
    expires -1;
    add_header Cache-Control "private, no-cache";
}
*/
```

### Q18: Browser caching vs Service Worker caching

**Answer:**
```javascript
// Service Worker - –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä—É–µ–º—ã–π –∫—ç—à
self.addEventListener('fetch', event => {
    const url = new URL(event.request.url);
    
    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã - cache first
    if (url.pathname.match(/\.(css|js|png|jpg)$/)) {
        event.respondWith(
            caches.match(event.request).then(response => {
                return response || fetch(event.request).then(fetchResponse => {
                    const responseClone = fetchResponse.clone();
                    caches.open('static-v1').then(cache => {
                        cache.put(event.request, responseClone);
                    });
                    return fetchResponse;
                });
            })
        );
    }
    
    // API –¥–∞–Ω–Ω—ã–µ - network first —Å fallback
    if (url.pathname.startsWith('/api/')) {
        event.respondWith(
            fetch(event.request).then(response => {
                const responseClone = response.clone();
                caches.open('api-v1').then(cache => {
                    cache.put(event.request, responseClone);
                });
                return response;
            }).catch(() => {
                return caches.match(event.request);
            })
        );
    }
});

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ storage limits
navigator.storage.estimate().then(estimate => {
    const usageInMB = estimate.usage / (1024 * 1024);
    const quotaInMB = estimate.quota / (1024 * 1024);
    
    if (usageInMB > quotaInMB * 0.8) {
        // Cleanup old caches
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.filter(name => name.startsWith('old-')).map(name => caches.delete(name))
            );
        });
    }
});
```

### Q19: Cache busting techniques

**Answer:**
```javascript
// Webpack –∫–æ–Ω—Ñ–∏–≥ –¥–ª—è cache busting
module.exports = {
    output: {
        filename: '[name].[contenthash].js',
        chunkFilename: '[name].[contenthash].chunk.js'
    },
    optimization: {
        moduleIds: 'deterministic',
        runtimeChunk: 'single',
        splitChunks: {
            cacheGroups: {
                vendor: {
                    test: /[\\/]node_modules[\\/]/,
                    name: 'vendors',
                    chunks: 'all',
                }
            }
        }
    }
};

// CI/CD pipeline integration
class CacheBustingDeployment {
    async deploy() {
        // 1. Build —Å –Ω–æ–≤—ã–º–∏ hashes
        await this.runBuild();
        
        // 2. Upload –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
        await this.uploadAssets();
        
        // 3. Update HTML —Å –Ω–æ–≤—ã–º–∏ references
        await this.updateHTMLReferences();
        
        // 4. –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º CDN –¥–ª—è HTML
        await this.invalidateCDN(['/index.html', '/app.html']);
        
        // 5. Cleanup —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ (—Å –∑–∞–¥–µ—Ä–∂–∫–æ–π)
        setTimeout(() => this.cleanupOldAssets(), 5 * 60 * 1000);
    }
    
    async updateHTMLReferences() {
        const manifest = require('./dist/manifest.json');
        let html = fs.readFileSync('./dist/index.html', 'utf8');
        
        Object.keys(manifest).forEach(key => {
            html = html.replace(
                new RegExp(key, 'g'),
                manifest[key]
            );
        });
        
        fs.writeFileSync('./dist/index.html', html);
    }
}
```

### Q20: Reverse proxy caching (Nginx/Varnish)

**Answer:**
```nginx
# Nginx caching –∫–æ–Ω—Ñ–∏–≥
http {
    proxy_cache_path /var/cache/nginx 
                     levels=1:2 
                     keys_zone=app_cache:10m 
                     max_size=1g 
                     inactive=60m;
    
    upstream app_servers {
        server 127.0.0.1:3000;
        server 127.0.0.1:3001;
    }
    
    server {
        location /api/static/ {
            proxy_pass http://app_servers;
            proxy_cache app_cache;
            proxy_cache_valid 200 1h;
            proxy_cache_valid 404 1m;
            
            # Cache key –≤–∫–ª—é—á–∞–µ—Ç query params
            proxy_cache_key "$scheme$request_method$host$request_uri";
            
            # Headers –¥–ª—è debugging
            add_header X-Cache-Status $upstream_cache_status;
            
            # Bypass –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            proxy_cache_bypass $http_authorization;
            proxy_no_cache $http_authorization;
        }
        
        location /api/dynamic/ {
            proxy_pass http://app_servers;
            proxy_cache app_cache;
            proxy_cache_valid 200 5m;
            
            # Vary cache –ø–æ user type
            proxy_cache_key "$scheme$request_method$host$request_uri$http_user_type";
        }
    }
}
```

```javascript
// –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –æ—Ç–¥–∞–µ—Ç cache-friendly headers
app.get('/api/products', (req, res) => {
    const cacheKey = `products:${req.query.category}:${req.query.page}`;
    
    res.set({
        'Cache-Control': 'public, max-age=300',
        'Vary': 'Accept-Encoding, User-Type',
        'X-Cache-Key': cacheKey
    });
    
    // Nginx –±—É–¥–µ—Ç –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ 5 –º–∏–Ω—É—Ç
    res.json(products);
});
```

**–í–ª–∏—è–Ω–∏–µ –Ω–∞ app servers:**
- –°–Ω–∏–∂–µ–Ω–∏–µ load –Ω–∞ 60-90%
- –£–º–µ–Ω—å—à–µ–Ω–∏–µ latency –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- –ó–∞—â–∏—Ç–∞ –æ—Ç traffic spikes

## 5. üèóÔ∏è Distributed Caching & Architecture

### Q21: Design distributed cache for microservices

**Answer:**
```javascript
// –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å data locality
class MicroserviceCache {
    constructor(serviceName) {
        this.serviceName = serviceName;
        this.localCache = new LRU(1000);
        this.remoteCache = new RedisCluster();
        this.eventBus = new EventBus();
    }
    
    async get(key) {
        // L1: Local cache
        let value = this.localCache.get(key);
        if (value) {
            this.metrics.recordHit('local');
            return value;
        }
        
        // L2: Remote cache
        value = await this.remoteCache.get(this.prefixKey(key));
        if (value) {
            this.localCache.set(key, value);
            this.metrics.recordHit('remote');
            return value;
        }
        
        // L3: Database
        value = await this.loadFromDatabase(key);
        if (value) {
            await this.set(key, value);
            this.metrics.recordMiss();
            return value;
        }
        
        return null;
    }
    
    async set(key, value, ttl = 3600) {
        const prefixedKey = this.prefixKey(key);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –æ–±–∞ —É—Ä–æ–≤–Ω—è
        await Promise.all([
            this.localCache.set(key, value),
            this.remoteCache.set(prefixedKey, value, ttl)
        ]);
        
        // –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏–µ —Å–µ—Ä–≤–∏—Å—ã
        await this.eventBus.publish('cache:invalidate', {
            service: this.serviceName,
            key: prefixedKey
        });
    }
    
    prefixKey(key) {
        return `${this.serviceName}:${key}`;
    }
}

// Service mesh integration
class ServiceMeshCache {
    constructor() {
        this.serviceMap = new Map();
        this.setupServiceDiscovery();
    }
    
    async routeRequest(serviceName, operation, key) {
        const serviceInstances = this.serviceMap.get(serviceName);
        
        // Consistent hashing –¥–ª—è data locality
        const targetInstance = this.consistentHash(key, serviceInstances);
        
        return await this.makeRequest(targetInstance, operation, key);
    }
}
```

**Considerations –¥–ª—è network partitions:**
- Graceful degradation –∫ local cache
- Circuit breaker patterns
- Eventual consistency models

### Q22: Consistent hashing implementation

**Answer:**
```javascript
class ConsistentHashRing {
    constructor(virtualNodes = 150) {
        this.virtualNodes = virtualNodes;
        this.ring = new Map(); // hash -> node
        this.nodes = new Set();
        this.sortedHashes = [];
    }
    
    addNode(node) {
        this.nodes.add(node);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —É–∑–ª—ã
        for (let i = 0; i < this.virtualNodes; i++) {
            const virtualKey = `${node}:${i}`;
            const hash = this.hash(virtualKey);
            this.ring.set(hash, node);
        }
        
        this.sortedHashes = Array.from(this.ring.keys()).sort((a, b) => a - b);
    }
    
    removeNode(node) {
        this.nodes.delete(node);
        
        // –£–¥–∞–ª—è–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —É–∑–ª—ã
        for (let i = 0; i < this.virtualNodes; i++) {
            const virtualKey = `${node}:${i}`;
            const hash = this.hash(virtualKey);
            this.ring.delete(hash);
        }
        
        this.sortedHashes = Array.from(this.ring.keys()).sort((a, b) => a - b);
    }
    
    getNode(key) {
        if (this.ring.size === 0) return null;
        
        const hash = this.hash(key);
        
        // –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –ø–µ—Ä–≤–æ–≥–æ —É–∑–ª–∞ >= hash
        let left = 0;
        let right = this.sortedHashes.length - 1;
        
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (this.sortedHashes[mid] >= hash) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, –±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π (–∫–æ–ª—å—Ü–æ)
        const targetHash = left < this.sortedHashes.length ? 
                          this.sortedHashes[left] : 
                          this.sortedHashes[0];
        
        return this.ring.get(targetHash);
    }
    
    hash(key) {
        // Simple hash function (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π)
        let hash = 0;
        for (let i = 0; i < key.length; i++) {
            hash = ((hash << 5) - hash + key.charCodeAt(i)) & 0xffffffff;
        }
        return Math.abs(hash);
    }
    
    // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
    analyzeDistribution(keys) {
        const distribution = new Map();
        this.nodes.forEach(node => distribution.set(node, 0));
        
        keys.forEach(key => {
            const node = this.getNode(key);
            distribution.set(node, distribution.get(node) + 1);
        });
        
        return distribution;
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ cache cluster
class DistributedCache {
    constructor(nodes) {
        this.hashRing = new ConsistentHashRing();
        nodes.forEach(node => this.hashRing.addNode(node));
    }
    
    async get(key) {
        const node = this.hashRing.getNode(key);
        return await this.makeRequest(node, 'GET', key);
    }
    
    async set(key, value) {
        const node = this.hashRing.getNode(key);
        return await this.makeRequest(node, 'SET', key, value);
    }
    
    async addNode(newNode) {
        // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª
        this.hashRing.addNode(newNode);
        
        // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        await this.rebalanceData(newNode);
    }
    
    async rebalanceData(newNode) {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ –∫–ª—é—á–∏ –¥–æ–ª–∂–Ω—ã –ø–µ—Ä–µ–µ—Ö–∞—Ç—å
        const keysToMove = await this.findKeysToRebalance(newNode);
        
        // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∞–Ω–Ω—ã–µ
        for (const key of keysToMove) {
            const value = await this.getCurrentValue(key);
            await this.makeRequest(newNode, 'SET', key, value);
            await this.removeFromOldNode(key);
        }
    }
}
```

### Q23: Redis Cluster vs Single Instance + Replication

**Answer:**

**Redis Cluster (–¥–ª—è 1TB, HA):**
```javascript
// Redis Cluster –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const Redis = require('ioredis');

const cluster = new Redis.Cluster([
    { host: '10.0.1.1', port: 7000 },
    { host: '10.0.1.2', port: 7000 },
    { host: '10.0.1.3', port: 7000 },
    { host: '10.0.1.4', port: 7000 },
    { host: '10.0.1.5', port: 7000 },
    { host: '10.0.1.6', port: 7000 }
], {
    enableOfflineQueue: false,
    redisOptions: {
        password: 'your-password'
    },
    maxRetriesPerRequest: 3
});

class ClusterCacheClient {
    constructor() {
        this.cluster = cluster;
        this.setupErrorHandling();
    }
    
    async get(key) {
        try {
            return await this.cluster.get(key);
        } catch (error) {
            if (error.message.includes('MOVED')) {
                // Cluster –ø–µ—Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–ª—Å—è, retry
                await this.cluster.disconnect();
                await this.cluster.connect();
                return await this.cluster.get(key);
            }
            throw error;
        }
    }
    
    // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ multi-key –æ–ø–µ—Ä–∞—Ü–∏–π
    async mget(keys) {
        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∫–ª—é—á–∏ –ø–æ —Å–ª–æ—Ç–∞–º
        const pipeline = this.cluster.pipeline();
        keys.forEach(key => pipeline.get(key));
        const results = await pipeline.exec();
        
        return results.map(([error, result]) => {
            if (error) throw error;
            return result;
        });
    }
}
```

**Single Instance + Replication:**
```javascript
// Master-Slave –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
class RedisMasterSlave {
    constructor() {
        this.master = new Redis({
            host: 'redis-master',
            port: 6379,
            retryDelayOnFailover: 100,
            enableOfflineQueue: false
        });
        
        this.slaves = [
            new Redis({ host: 'redis-slave-1', port: 6379 }),
            new Redis({ host: 'redis-slave-2', port: 6379 })
        ];
        
        this.currentSlaveIndex = 0;
    }
    
    async set(key, value, ttl) {
        return await this.master.set(key, value, 'EX', ttl);
    }
    
    async get(key) {
        // Read from slaves –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è load
        const slave = this.getNextSlave();
        try {
            return await slave.get(key);
        } catch (error) {
            // Fallback –Ω–∞ master
            return await this.master.get(key);
        }
    }
    
    getNextSlave() {
        const slave = this.slaves[this.currentSlaveIndex];
        this.currentSlaveIndex = (this.currentSlaveIndex + 1) % this.slaves.length;
        return slave;
    }
}
```

**–í—ã–±–æ—Ä –¥–ª—è 1TB + HA:**
- **Redis Cluster** –µ—Å–ª–∏:
  - –ù—É–∂–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å
  - –î–∞–Ω–Ω—ã–µ –º–æ–∂–Ω–æ –ø–∞—Ä—Ç–∏—Ü–∏—Ä–æ–≤–∞—Ç—å
  - –ì–æ—Ç–æ–≤—ã –∫ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

- **Master-Slave** –µ—Å–ª–∏:
  - –ü—Ä–æ—Å—Ç–æ—Ç–∞ –≤–∞–∂–Ω–µ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç–∏
  - –ú–Ω–æ–≥–æ cross-key –æ–ø–µ—Ä–∞—Ü–∏–π
  - –ú–µ–Ω—å—à–µ operational overhead

### Q24: Cache coherence in distributed systems

**Answer:**
```javascript
// Event-driven invalidation
class CoherentDistributedCache {
    constructor(nodeId) {
        this.nodeId = nodeId;
        this.localCache = new Map();
        this.vectorClock = new Map(); // nodeId -> timestamp
        this.eventLog = [];
    }
    
    async set(key, value) {
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–≤–æ–π timestamp
        this.vectorClock.set(this.nodeId, (this.vectorClock.get(this.nodeId) || 0) + 1);
        
        const event = {
            type: 'SET',
            key,
            value,
            nodeId: this.nodeId,
            vectorClock: new Map(this.vectorClock),
            timestamp: Date.now()
        };
        
        // –õ–æ–∫–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        this.localCache.set(key, { value, vectorClock: new Map(this.vectorClock) });
        this.eventLog.push(event);
        
        // Broadcast –¥—Ä—É–≥–∏–º —É–∑–ª–∞–º
        await this.broadcast(event);
    }
    
    async handleRemoteEvent(event) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º causality —Å vector clocks
        if (this.isEventCausal(event)) {
            this.applyEvent(event);
        } else {
            // –û—Ç–∫–ª–∞–¥—ã–≤–∞–µ–º –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–µ–¥—à–µ—Å—Ç–≤—É—é—â–∏—Ö —Å–æ–±—ã—Ç–∏–π
            this.deferEvent(event);
        }
    }
    
    isEventCausal(event) {
        for (const [nodeId, timestamp] of event.vectorClock) {
            if (nodeId === event.nodeId) {
                // –°–æ–±—ã—Ç–∏–µ –æ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–∞ 1 –±–æ–ª—å—à–µ
                if (timestamp !== (this.vectorClock.get(nodeId) || 0) + 1) {
                    return false;
                }
            } else {
                // –°–æ–±—ã—Ç–∏—è –æ—Ç –¥—Ä—É–≥–∏—Ö —É–∑–ª–æ–≤ –Ω–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –±—É–¥—É—â–µ–º
                if (timestamp > (this.vectorClock.get(nodeId) || 0)) {
                    return false;
                }
            }
        }
        return true;
    }
    
    applyEvent(event) {
        if (event.type === 'SET') {
            this.localCache.set(event.key, {
                value: event.value,
                vectorClock: event.vectorClock
            });
        } else if (event.type === 'DELETE') {
            this.localCache.delete(event.key);
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤–æ–π vector clock
        this.mergeVectorClock(event.vectorClock);
    }
    
    mergeVectorClock(otherClock) {
        for (const [nodeId, timestamp] of otherClock) {
            const currentTimestamp = this.vectorClock.get(nodeId) || 0;
            this.vectorClock.set(nodeId, Math.max(currentTimestamp, timestamp));
        }
    }
}

// –ö–æ–Ω—Ñ–ª–∏–∫—Ç resolution —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
class ConflictResolver {
    static resolveByTimestamp(localValue, remoteValue) {
        return localValue.timestamp > remoteValue.timestamp ? localValue : remoteValue;
    }
    
    static resolveByBusinessLogic(localValue, remoteValue, key) {
        // –ü—Ä–∏–º–µ—Ä: –¥–ª—è —Å—á–µ—Ç—á–∏–∫–æ–≤ —Å—É–º–º–∏—Ä—É–µ–º
        if (key.startsWith('counter:')) {
            return {
                value: localValue.value + remoteValue.value,
                timestamp: Math.max(localValue.timestamp, remoteValue.timestamp)
            };
        }
        
        // –î–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ - last write wins
        return this.resolveByTimestamp(localValue, remoteValue);
    }
}
```

### Q25: Geo-distributed caching

**Answer:**
```javascript
// Multi-region cache —Å eventual consistency
class GeoDistributedCache {
    constructor(region) {
        this.region = region;
        this.localCache = new RedisCluster(this.getLocalNodes());
        this.remoteRegions = this.getRemoteRegions();
        this.replicationDelay = this.calculateReplicationDelay();
    }
    
    async get(key) {
        // –°–Ω–∞—á–∞–ª–∞ local region
        let value = await this.localCache.get(key);
        if (value) {
            return this.deserialize(value);
        }
        
        // –ï—Å–ª–∏ –∫—Ä–∏—Ç–∏—á–Ω–æ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–∏–∂–∞–π—à–∏–µ —Ä–µ–≥–∏–æ–Ω—ã
        const nearestRegions = this.getNearestRegions(2);
        for (const region of nearestRegions) {
            try {
                value = await this.getFromRegion(region, key);
                if (value) {
                    // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∫—ç—à–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ
                    this.localCache.set(key, this.serialize(value), 'EX', 300);
                    return value;
                }
            } catch (error) {
                console.warn(`Failed to fetch from ${region}:`, error);
            }
        }
        
        return null;
    }
    
    async set(key, value, options = {}) {
        const serialized = this.serialize(value);
        const ttl = options.ttl || 3600;
        
        // –õ–æ–∫–∞–ª—å–Ω–∞—è –∑–∞–ø–∏—Å—å (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        await this.localCache.set(key, serialized, 'EX', ttl);
        
        // –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –≤ –¥—Ä—É–≥–∏–µ —Ä–µ–≥–∏–æ–Ω—ã (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        if (options.replicate !== false) {
            this.replicateToRegions(key, value, ttl, options.consistency || 'eventual');
        }
    }
    
    async replicateToRegions(key, value, ttl, consistency) {
        const replicationPromises = this.remoteRegions.map(async region => {
            try {
                const latency = this.getRegionLatency(region);
                
                if (consistency === 'strong') {
                    // –ñ–¥–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
                    await this.setInRegion(region, key, value, ttl);
                } else {
                    // Eventual consistency - –Ω–µ –∂–¥–µ–º
                    setTimeout(() => {
                        this.setInRegion(region, key, value, ttl);
                    }, Math.min(latency * 2, 5000));
                }
            } catch (error) {
                console.error(`Replication to ${region} failed:`, error);
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ retry queue
                this.addToRetryQueue(region, key, value, ttl);
            }
        });
        
        if (consistency === 'strong') {
            await Promise.all(replicationPromises);
        }
    }
    
    // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è read-heavy workloads
    async prefetchFromNearestRegion(keys) {
        const nearestRegion = this.getNearestRegions(1)[0];
        
        const pipeline = this.getRegionClient(nearestRegion).pipeline();
        keys.forEach(key => pipeline.get(key));
        
        const results = await pipeline.exec();
        
        // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∫—ç—à–∏—Ä—É–µ–º –≤ local region
        results.forEach(([error, value], index) => {
            if (!error && value) {
                this.localCache.set(keys[index], value, 'EX', 300);
            }
        });
    }
    
    getRegionLatency(region) {
        const latencies = {
            'us-east-1': 20,
            'us-west-2': 50,
            'eu-west-1': 100,
            'ap-southeast-1': 200
        };
        return latencies[region] || 300;
    }
}

// Load balancing –¥–ª—è —á–∏—Ç–∞—é—â–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
class GeoLoadBalancer {
    constructor() {
        this.regionStats = new Map();
    }
    
    selectRegionForRead(key, userLocation) {
        const candidates = this.getAvailableRegions();
        
        // –í–∑–≤–µ—à–∏–≤–∞–µ–º –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –∏ –∑–∞–≥—Ä—É–∑–∫–µ
        const scores = candidates.map(region => {
            const distance = this.calculateDistance(userLocation, region);
            const load = this.getRegionLoad(region);
            const availability = this.getRegionAvailability(region);
            
            return {
                region,
                score: (1 / distance) * availability * (1 / load)
            };
        });
        
        return scores.sort((a, b) => b.score - a.score)[0].region;
    }
}
```

## 6. üîß Advanced Topics & Troubleshooting

### Q26: Debug cache performance issues

**Answer:**
**Methodology –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ø–∞–¥–µ–Ω–∏—è hit rate —Å 90% –¥–æ 60%:**

```javascript
class CacheDebugger {
    async investigateHitRateDrops() {
        const investigation = {
            timeline: await this.analyzeTimeline(),
            keyPatterns: await this.analyzeKeyPatterns(),
            evictionRate: await this.analyzeEvictions(),
            dataSize: await this.analyzeDataSizes(),
            accessPatterns: await this.analyzeAccessPatterns()
        };
        
        return this.generateReport(investigation);
    }
    
    async analyzeTimeline() {
        // –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è —Å external events
        const metrics = await this.getMetricsTimeline('1h');
        const events = await this.getSystemEvents('1h');
        
        return {
            hitRateChange: this.findChangePoints(metrics.hitRate),
            correlatedEvents: this.correlat–µWithEvents(metrics, events),
            memoryUsage: metrics.memoryUsage,
            connectionCount: metrics.connections
        };
    }
    
    async analyzeKeyPatterns() {
        // –ê–Ω–∞–ª–∏–∑ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–ª—é—á–µ–π
        const samples = await redis.scan(0, 'COUNT', 10000);
        const patterns = {};
        
        samples[1].forEach(key => {
            const prefix = key.split(':')[0];
            patterns[prefix] = (patterns[prefix] || 0) + 1;
        });
        
        return {
            distribution: patterns,
            hotKeys: await this.findHotKeys(),
            longKeys: samples[1].filter(key => key.length > 250),
            suspiciousPatterns: this.findSuspiciousPatterns(samples[1])
        };
    }
    
    async findHotKeys() {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Redis MONITOR —Å sampling
        const hotKeys = new Map();
        const monitor = redis.duplicate();
        
        return new Promise((resolve) => {
            monitor.monitor();
            const sampleSize = 10000;
            let count = 0;
            
            monitor.on('monitor', (time, args) => {
                if (count++ >= sampleSize) {
                    monitor.disconnect();
                    resolve(this.topKeys(hotKeys, 20));
                    return;
                }
                
                const key = args[1];
                if (key) {
                    hotKeys.set(key, (hotKeys.get(key) || 0) + 1);
                }
            });
        });
    }
    
    generateReport(investigation) {
        const possibleCauses = [];
        
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º findings
        if (investigation.evictionRate.current > investigation.evictionRate.baseline * 2) {
            possibleCauses.push({
                cause: 'Increased eviction rate',
                evidence: investigation.evictionRate,
                solution: 'Increase memory or optimize TTL'
            });
        }
        
        if (investigation.keyPatterns.suspiciousPatterns.length > 0) {
            possibleCauses.push({
                cause: 'Cache pollution from new access patterns',
                evidence: investigation.keyPatterns.suspiciousPatterns,
                solution: 'Implement cache partitioning or separate TTL'
            });
        }
        
        return {
            summary: `Hit rate dropped from 90% to 60%`,
            mostLikelyCause: possibleCauses[0],
            allCauses: possibleCauses,
            recommendations: this.generateRecommendations(possibleCauses)
        };
    }
}

// Automated monitoring
class CacheHealthMonitor {
    constructor() {
        this.thresholds = {
            hitRate: 0.8,
            avgLatency: 5, // ms
            memoryUsage: 0.85,
            evictionRate: 100 // per minute
        };
    }
    
    async checkHealth() {
        const metrics = await this.collectMetrics();
        const alerts = [];
        
        Object.keys(this.thresholds).forEach(metric => {
            if (this.isThresholdBreached(metrics[metric], this.thresholds[metric])) {
                alerts.push({
                    metric,
                    current: metrics[metric],
                    threshold: this.thresholds[metric],
                    severity: this.calculateSeverity(metric, metrics[metric])
                });
            }
        });
        
        if (alerts.length > 0) {
            await this.sendAlerts(alerts);
            await this.triggerAutoRemediation(alerts);
        }
        
        return { healthy: alerts.length === 0, alerts };
    }
}
```

### Q27: Memory-efficient cache implementations

**Answer:**
```javascript
// –ö–æ–º–ø—Ä–µ—Å—Å–∏—è –¥–ª—è 100M –º–∞–ª–µ–Ω—å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
class CompressedCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.data = new Map();
        this.compressor = new LZ4Compressor();
        this.stats = { compressed: 0, uncompressed: 0 };
    }
    
    set(key, value) {
        const serialized = JSON.stringify(value);
        
        // –ö–æ–º–ø—Ä–µ—Å—Å–∏—è –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç –±–æ–ª—å—à–µ threshold
        if (serialized.length > 100) {
            const compressed = this.compressor.compress(serialized);
            this.data.set(key, {
                data: compressed,
                compressed: true,
                originalSize: serialized.length
            });
            this.stats.compressed++;
        } else {
            this.data.set(key, {
                data: serialized,
                compressed: false
            });
            this.stats.uncompressed++;
        }
        
        this.evictIfNeeded();
    }
    
    get(key) {
        const item = this.data.get(key);
        if (!item) return null;
        
        const data = item.compressed ? 
                    this.compressor.decompress(item.data) : 
                    item.data;
        
        return JSON.parse(data);
    }
}

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
class PackedCache {
    constructor() {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º TypedArrays –¥–ª—è numbers
        this.intValues = new Int32Array(1000000);
        this.floatValues = new Float32Array(1000000);
        
        // Interned strings –¥–ª—è repeated values
        this.stringInterner = new Map();
        this.internedStrings = [];
        
        // Bitmap –¥–ª—è boolean flags
        this.booleanFlags = new Uint8Array(125000); // 1M bits
    }
    
    internString(str) {
        if (this.stringInterner.has(str)) {
            return this.stringInterner.get(str);
        }
        
        const index = this.internedStrings.length;
        this.internedStrings.push(str);
        this.stringInterner.set(str, index);
        return index;
    }
    
    setBoolean(index, value) {
        const byteIndex = Math.floor(index / 8);
        const bitIndex = index % 8;
        
        if (value) {
            this.booleanFlags[byteIndex] |= (1 << bitIndex);
        } else {
            this.booleanFlags[byteIndex] &= ~(1 << bitIndex);
        }
    }
    
    getBoolean(index) {
        const byteIndex = Math.floor(index / 8);
        const bitIndex = index % 8;
        return !!(this.booleanFlags[byteIndex] & (1 << bitIndex));
    }
}

// Memory pool –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è GC pressure
class MemoryPool {
    constructor(objectFactory, initialSize = 1000) {
        this.factory = objectFactory;
        this.available = [];
        this.inUse = new Set();
        
        // Pre-allocate objects
        for (let i = 0; i < initialSize; i++) {
            this.available.push(this.factory());
        }
    }
    
    acquire() {
        let obj = this.available.pop();
        if (!obj) {
            obj = this.factory();
        }
        
        this.inUse.add(obj);
        return obj;
    }
    
    release(obj) {
        if (this.inUse.has(obj)) {
            this.inUse.delete(obj);
            
            // Reset object state
            if (obj.reset) {
                obj.reset();
            }
            
            this.available.push(obj);
        }
    }
}
```

### Q28: Cache security considerations

**Answer:**
```javascript
// –ó–∞—â–∏—Ç–∞ –æ—Ç side-channel –∞—Ç–∞–∫
class SecureCache {
    constructor() {
        this.userPartitions = new Map(); // userId -> cache partition
        this.globalCache = new Map();
        this.accessLog = new RingBuffer(10000);
    }
    
    // Partition isolation
    getUserCache(userId, securityLevel) {
        const partitionKey = `${securityLevel}:${Math.floor(userId / 1000)}`;
        
        if (!this.userPartitions.has(partitionKey)) {
            this.userPartitions.set(partitionKey, new Map());
        }
        
        return this.userPartitions.get(partitionKey);
    }
    
    async get(key, userId, securityContext) {
        // –õ–æ–≥–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø –¥–ª—è audit
        this.logAccess(userId, key, 'READ', securityContext);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
        if (!this.hasAccess(userId, key, securityContext)) {
            throw new Error('Access denied');
        }
        
        // Timing-safe lookup –¥–ª—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if (securityContext.sensitive) {
            return await this.timingSafeGet(key, userId);
        }
        
        const userCache = this.getUserCache(userId, securityContext.level);
        return userCache.get(key);
    }
    
    async timingSafeGet(key, userId) {
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç hit/miss
        const startTime = process.hrtime.bigint();
        
        const userCache = this.getUserCache(userId, 'HIGH');
        const value = userCache.get(key);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—É—é –∑–∞–¥–µ—Ä–∂–∫—É –¥–æ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        const elapsed = process.hrtime.bigint() - startTime;
        const targetTime = 1000000n; // 1ms –≤ nanoseconds
        
        if (elapsed < targetTime) {
            await new Promise(resolve => 
                setTimeout(resolve, Number(targetTime - elapsed) / 1000000)
            );
        }
        
        return value;
    }
    
    // Encryption –¥–ª—è sensitive data
    async setEncrypted(key, value, userId, encryptionKey) {
        const encrypted = await this.encrypt(JSON.stringify(value), encryptionKey);
        const userCache = this.getUserCache(userId, 'HIGH');
        
        userCache.set(key, {
            data: encrypted,
            encrypted: true,
            checksum: this.calculateChecksum(encrypted)
        });
    }
    
    async getEncrypted(key, userId, encryptionKey) {
        const userCache = this.getUserCache(userId, 'HIGH');
        const item = userCache.get(key);
        
        if (!item || !item.encrypted) return null;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å
        if (this.calculateChecksum(item.data) !== item.checksum) {
            throw new Error('Cache integrity violation');
        }
        
        const decrypted = await this.decrypt(item.data, encryptionKey);
        return JSON.parse(decrypted);
    }
    
    // Audit logging
    logAccess(userId, key, operation, context) {
        this.accessLog.push({
            timestamp: Date.now(),
            userId,
            key: this.hashKey(key), // –ù–µ –ª–æ–≥–∏—Ä—É–µ–º actual keys
            operation,
            securityLevel: context.level,
            ipAddress: context.ipAddress,
            userAgent: context.userAgent
        });
    }
    
    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∞–Ω–æ–º–∞–ª—å–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
    detectAnomalousAccess(userId) {
        const recentAccess = this.accessLog.filter(
            log => log.userId === userId && 
                   Date.now() - log.timestamp < 3600000 // –ü–æ—Å–ª–µ–¥–Ω–∏–π —á–∞—Å
        );
        
        const anomalies = [];
        
        // –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤
        if (recentAccess.length > 1000) {
            anomalies.push('HIGH_FREQUENCY_ACCESS');
        }
        
        // –î–æ—Å—Ç—É–ø –∫ –Ω–µ–æ–±—ã—á–Ω—ã–º –∫–ª—é—á–∞–º
        const keyPatterns = recentAccess.map(log => log.key.substring(0, 10));
        const uniquePatterns = new Set(keyPatterns);
        if (uniquePatterns.size > 50) {
            anomalies.push('UNUSUAL_KEY_PATTERNS');
        }
        
        // –î–æ—Å—Ç—É–ø —Å —Ä–∞–∑–Ω—ã—Ö IP
        const ipAddresses = new Set(recentAccess.map(log => log.ipAddress));
        if (ipAddresses.size > 5) {
            anomalies.push('MULTIPLE_IP_ACCESS');
        }
        
        return anomalies;
    }
}

// Data encryption –¥–ª—è cache
class CacheEncryption {
    constructor(masterKey) {
        this.masterKey = masterKey;
        this.keyDerivation = new PBKDF2();
    }
    
    async encrypt(data, userId) {
        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º user-specific –∫–ª—é—á
        const userKey = await this.keyDerivation.derive(
            this.masterKey, 
            `cache:${userId}`, 
            256
        );
        
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher('aes-256-gcm', userKey);
        cipher.setAAD(Buffer.from(userId.toString()));
        
        let encrypted = cipher.update(data, 'utf8', 'base64');
        encrypted += cipher.final('base64');
        
        const authTag = cipher.getAuthTag();
        
        return {
            data: encrypted,
            iv: iv.toString('base64'),
            authTag: authTag.toString('base64')
        };
    }
    
    async decrypt(encryptedData, userId) {
        const userKey = await this.keyDerivation.derive(
            this.masterKey, 
            `cache:${userId}`, 
            256
        );
        
        const decipher = crypto.createDecipher('aes-256-gcm', userKey);
        decipher.setAAD(Buffer.from(userId.toString()));
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'base64'));
        
        let decrypted = decipher.update(encryptedData.data, 'base64', 'utf8');
        decrypted += decipher.final('utf8');
        
### Q29: Machine Learning for cache optimization

**Answer:**
```javascript
// Predictive prefetching —Å ML
class MLCachePrefetcher {
    constructor() {
        this.accessHistory = new CircularBuffer(100000);
        this.model = new LSTMModel();
        this.features = new FeatureExtractor();
        this.prefetchQueue = new PriorityQueue();
    }
    
    // –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞—Ö –¥–æ—Å—Ç—É–ø–∞
    async trainModel() {
        const trainingData = this.prepareTrainingData();
        
        // Features: time, user, previous keys, session context
        const sequences = trainingData.map(session => {
            return session.accesses.map(access => ({
                timestamp: access.timestamp,
                userId: this.hashUserId(access.userId),
                keyHash: this.hashKey(access.key),
                timeOfDay: new Date(access.timestamp).getHours(),
                dayOfWeek: new Date(access.timestamp).getDay(),
                sessionAge: access.timestamp - session.startTime,
                previousKeys: this.getPreviousKeys(access, 5)
            }));
        });
        
        await this.model.train(sequences, {
            epochs: 100,
            batchSize: 32,
            learningRate: 0.001
        });
    }
    
    // –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–∏—Ö –∫–ª—é—á–µ–π
    async predictNextKeys(userId, currentKey, context) {
        const features = this.features.extract({
            userId,
            currentKey,
            timestamp: Date.now(),
            context
        });
        
        const predictions = await this.model.predict(features);
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º predictions –≤ ranked —Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–π
        return predictions
            .map((prob, index) => ({
                key: this.indexToKey(index),
                probability: prob,
                confidence: this.calculateConfidence(prob)
            }))
            .filter(pred => pred.probability > 0.3)
            .sort((a, b) => b.probability - a.probability)
            .slice(0, 10);
    }
    
    // Adaptive prefetching
    async onCacheAccess(userId, key, hit) {
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
        this.accessHistory.push({
            userId, key, hit,
            timestamp: Date.now()
        });
        
        // –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–µ –∫–ª—é—á–∏
        const predictions = await this.predictNextKeys(userId, key, {
            recentKeys: this.getRecentKeys(userId, 10)
        });
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å prefetch
        for (const pred of predictions) {
            if (pred.confidence > 0.7 && !this.cache.has(pred.key)) {
                this.prefetchQueue.enqueue({
                    key: pred.key,
                    userId,
                    priority: pred.probability,
                    scheduledTime: Date.now() + this.calculateDelay(pred.probability)
                });
            }
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–¥–µ–ª—å incrementally
        if (this.accessHistory.length % 1000 === 0) {
            await this.updateModelIncremental();
        }
    }
    
    // Continuous learning –¥–ª—è adaptation –∫ drift
    async handleModelDrift() {
        const recentAccuracy = this.calculateRecentAccuracy();
        const baselineAccuracy = this.getBaselineAccuracy();
        
        if (recentAccuracy < baselineAccuracy * 0.9) {
            console.log('Model drift detected, retraining...');
            
            // –°–º–µ—à–∏–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∏ –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
            const recentData = this.getRecentTrainingData(7); // –ü–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
            const historicalData = this.getHistoricalData(0.3); // 30% –æ—Ç —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            
            await this.model.retrain([...historicalData, ...recentData]);
            this.updateBaselineAccuracy();
        }
    }
    
    calculateDelay(probability) {
        // –í—ã—Å–æ–∫–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å = –º–µ–Ω—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        return Math.max(100, 1000 * (1 - probability));
    }
}

// Feature engineering –¥–ª—è cache patterns
class CacheFeatureExtractor {
    extractTemporalFeatures(timestamp) {
        const date = new Date(timestamp);
        return {
            hourOfDay: date.getHours() / 24,
            dayOfWeek: date.getDay() / 7,
            dayOfMonth: date.getDate() / 31,
            month: date.getMonth() / 12,
            isWeekend: date.getDay() === 0 || date.getDay() === 6 ? 1 : 0,
            isBusinessHours: (date.getHours() >= 9 && date.getHours() < 17) ? 1 : 0
        };
    }
    
    extractSequentialFeatures(accessHistory, windowSize = 10) {
        const recent = accessHistory.slice(-windowSize);
        
        return {
            accessFrequency: recent.length / windowSize,
            keyDiversity: new Set(recent.map(a => a.key)).size / recent.length,
            avgTimeBetweenAccess: this.calculateAvgTimeBetween(recent),
            mostCommonKeyType: this.getMostCommonKeyType(recent),
            sessionDuration: recent.length > 0 ? 
                recent[recent.length - 1].timestamp - recent[0].timestamp : 0
        };
    }
    
    extractUserBehaviorFeatures(userId, globalStats) {
        const userStats = globalStats.users.get(userId) || {};
        
        return {
            userActivityLevel: (userStats.totalAccesses || 0) / globalStats.avgUserAccesses,
            userUniqueness: (userStats.uniqueKeys || 0) / globalStats.avgUniqueKeys,
            userSessionLength: (userStats.avgSessionLength || 0) / globalStats.avgSessionLength,
            userReturnProbability: userStats.returnRate || 0
        };
    }
}
```

### Q30: Cache testing strategies

**Answer:**
```javascript
// Unit testing –¥–ª—è cache behavior
class CacheTestSuite {
    async testBasicOperations() {
        const cache = new LRUCache(100);
        
        // Test set/get
        cache.set('key1', 'value1');
        assert.equal(cache.get('key1'), 'value1');
        
        // Test miss
        assert.equal(cache.get('nonexistent'), null);
        
        // Test eviction
        for (let i = 0; i < 101; i++) {
            cache.set(`key${i}`, `value${i}`);
        }
        
        // First key should be evicted
        assert.equal(cache.get('key1'), null);
        assert.equal(cache.get('key100'), 'value100');
    }
    
    async testConcurrency() {
        const cache = new ThreadSafeLRU(1000);
        const promises = [];
        
        // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        for (let i = 0; i < 100; i++) {
            promises.push(
                Promise.all([
                    cache.set(`key${i}`, `value${i}`),
                    cache.get(`key${i - 1}`),
                    cache.delete(`key${i - 2}`)
                ])
            );
        }
        
        await Promise.all(promises);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º consistency
        const finalSize = await cache.size();
        assert(finalSize <= 1000, 'Cache size exceeded capacity');
    }
    
    async testTTLBehavior() {
        const cache = new TTLCache();
        
        cache.set('shortLived', 'value', 100); // 100ms TTL
        cache.set('longLived', 'value', 10000); // 10s TTL
        
        assert.equal(cache.get('shortLived'), 'value');
        
        await new Promise(resolve => setTimeout(resolve, 150));
        
        assert.equal(cache.get('shortLived'), null);
        assert.equal(cache.get('longLived'), 'value');
    }
    
    // Test cache stampede protection
    async testStampedeProtection() {
        const cache = new StampedeProtectedCache();
        const loadCallCount = { count: 0 };
        
        const slowLoader = async (key) => {
            loadCallCount.count++;
            await new Promise(resolve => setTimeout(resolve, 100));
            return `loaded-${key}`;
        };
        
        // Parallel requests –¥–ª—è –æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞
        const promises = Array(10).fill().map(() => 
            cache.get('testKey', slowLoader)
        );
        
        const results = await Promise.all(promises);
        
        // Loader –¥–æ–ª–∂–µ–Ω –≤—ã–∑–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
        assert.equal(loadCallCount.count, 1);
        results.forEach(result => 
            assert.equal(result, 'loaded-testKey')
        );
    }
}

// Load testing —Å simulation cache warming/eviction
class CacheLoadTester {
    constructor(cacheInstance) {
        this.cache = cacheInstance;
        this.metrics = new PerformanceMetrics();
    }
    
    async runLoadTest(config) {
        const {
            duration = 60000, // 1 minute
            concurrency = 50,
            readWriteRatio = 0.8, // 80% reads, 20% writes
            keyDistribution = 'zipfian', // realistic distribution
            dataSize = 1024 // bytes per value
        } = config;
        
        const keyGenerator = this.createKeyGenerator(keyDistribution);
        const endTime = Date.now() + duration;
        
        // Warm-up phase
        await this.warmupCache(1000);
        
        // Main load test
        const workers = Array(concurrency).fill().map(() => 
            this.runWorker(keyGenerator, readWriteRatio, dataSize, endTime)
        );
        
        await Promise.all(workers);
        
        return this.metrics.getResults();
    }
    
    async runWorker(keyGenerator, readWriteRatio, dataSize, endTime) {
        while (Date.now() < endTime) {
            const key = keyGenerator.next();
            const startTime = process.hrtime.bigint();
            
            try {
                if (Math.random() < readWriteRatio) {
                    // Read operation
                    const value = await this.cache.get(key);
                    this.metrics.recordRead(startTime, value !== null);
                } else {
                    // Write operation
                    const value = this.generateValue(dataSize);
                    await this.cache.set(key, value);
                    this.metrics.recordWrite(startTime);
                }
            } catch (error) {
                this.metrics.recordError(error);
            }
            
            // Small random delay
            await new Promise(resolve => 
                setTimeout(resolve, Math.random() * 10)
            );
        }
    }
    
    createKeyGenerator(distribution) {
        if (distribution === 'zipfian') {
            return new ZipfianGenerator(10000, 1.0); // 80/20 rule
        } else if (distribution === 'uniform') {
            return new UniformGenerator(10000);
        }
        throw new Error(`Unknown distribution: ${distribution}`);
    }
    
    async warmupCache(numKeys) {
        console.log(`Warming cache with ${numKeys} keys...`);
        
        const promises = [];
        for (let i = 0; i < numKeys; i++) {
            promises.push(
                this.cache.set(`warmup:${i}`, this.generateValue(1024))
            );
            
            // Batch —Ä–∞–∑–º–µ—Ä –¥–ª—èÈÅøÂÖçoverwhelming
            if (promises.length >= 100) {
                await Promise.all(promises);
                promises.length = 0;
            }
        }
        
        if (promises.length > 0) {
            await Promise.all(promises);
        }
        
        console.log('Cache warmup completed');
    }
    
    generateValue(size) {
        return 'x'.repeat(size);
    }
}

// Performance metrics collection
class PerformanceMetrics {
    constructor() {
        this.operations = [];
        this.errors = [];
        this.startTime = Date.now();
    }
    
    recordRead(startTime, hit) {
        const latency = Number(process.hrtime.bigint() - startTime) / 1000000; // ms
        this.operations.push({
            type: 'read',
            latency,
            hit,
            timestamp: Date.now()
        });
    }
    
    recordWrite(startTime) {
        const latency = Number(process.hrtime.bigint() - startTime) / 1000000;
        this.operations.push({
            type: 'write',
            latency,
            timestamp: Date.now()
        });
    }
    
    getResults() {
        const reads = this.operations.filter(op => op.type === 'read');
        const writes = this.operations.filter(op => op.type === 'write');
        const hits = reads.filter(op => op.hit);
        
        const totalDuration = (Date.now() - this.startTime) / 1000; // seconds
        
        return {
            duration: totalDuration,
            totalOperations: this.operations.length,
            throughput: this.operations.length / totalDuration,
            
            reads: {
                count: reads.length,
                hitRate: hits.length / reads.length,
                avgLatency: this.calculateAverage(reads.map(r => r.latency)),
                p95Latency: this.calculatePercentile(reads.map(r => r.latency), 0.95),
                p99Latency: this.calculatePercentile(reads.map(r => r.latency), 0.99)
            },
            
            writes: {
                count: writes.length,
                avgLatency: this.calculateAverage(writes.map(w => w.latency)),
                p95Latency: this.calculatePercentile(writes.map(w => w.latency), 0.95)
            },
            
            errors: {
                count: this.errors.length,
                rate: this.errors.length / this.operations.length
            }
        };
    }
    
    calculatePercentile(values, percentile) {
        const sorted = values.sort((a, b) => a - b);
        const index = Math.ceil(sorted.length * percentile) - 1;
        return sorted[index];
    }
    
    calculateAverage(values) {
        return values.reduce((sum, val) => sum + val, 0) / values.length;
    }
}

// Zipfian distribution generator (—Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–∞)
class ZipfianGenerator {
    constructor(numItems, skew = 1.0) {
        this.numItems = numItems;
        this.skew = skew;
        
        // Pre-compute cumulative probabilities
        this.probabilities = [];
        let sum = 0;
        
        for (let i = 1; i <= numItems; i++) {
            sum += 1 / Math.pow(i, skew);
        }
        
        let cumulative = 0;
        for (let i = 1; i <= numItems; i++) {
            cumulative += (1 / Math.pow(i, skew)) / sum;
            this.probabilities.push(cumulative);
        }
    }
    
    next() {
        const random = Math.random();
        
        // Binary search –¥–ª—è finding index
        let left = 0;
        let right = this.probabilities.length - 1;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (this.probabilities[mid] < random) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return `key:${left}`;
    }
}
```

## üí° Practical Scenarios - Detailed Solutions

### Scenario A: E-commerce Product Catalog

**Requirements Analysis:**
- 1M products, 10K categories
- 1000 requests/second  
- Product data changes hourly
- Category structure rarely changes

```javascript
class EcommerceCache {
    constructor() {
        // Multi-level caching strategy
        this.l1Cache = new LRU(5000);        // Hot products
        this.l2Cache = new Redis();          // All products  
        this.categoryCache = new LRU(10000); // Categories (stable)
        this.searchCache = new LRU(1000);    // Search results
        
        this.invalidationBus = new EventBus();
        this.setupInvalidationHandlers();
    }
    
    async getProduct(productId) {
        // L1: Hot products cache
        let product = this.l1Cache.get(productId);
        if (product) {
            this.metrics.record('l1_hit');
            return product;
        }
        
        // L2: Redis cache
        product = await this.l2Cache.get(`product:${productId}`);
        if (product) {
            this.metrics.record('l2_hit');
            
            // Promote to L1 if frequently accessed
            this.l1Cache.set(productId, product);
            return JSON.parse(product);
        }
        
        // L3: Database
        product = await this.db.getProduct(productId);
        if (product) {
            this.metrics.record('db_hit');
            
            // Cache at both levels
            await this.l2Cache.set(`product:${productId}`, JSON.stringify(product), 3600);
            this.l1Cache.set(productId, product);
            
            return product;
        }
        
        return null;
    }
    
    async getCategory(categoryId) {
        // Categories change rarely - longer TTL
        let category = this.categoryCache.get(categoryId);
        if (category) return category;
        
        category = await this.l2Cache.get(`category:${categoryId}`);
        if (category) {
            this.categoryCache.set(categoryId, JSON.parse(category));
            return JSON.parse(category);
        }
        
        category = await this.db.getCategory(categoryId);
        if (category) {
            await this.l2Cache.set(`category:${categoryId}`, JSON.stringify(category), 86400); // 24h
            this.categoryCache.set(categoryId, category);
        }
        
        return category;
    }
    
    async updateProduct(productId, newData) {
        // Update database
        await this.db.updateProduct(productId, newData);
        
        // Smart invalidation
        await this.invalidateProduct(productId, newData);
    }
    
    async invalidateProduct(productId, newData) {
        const keysToInvalidate = [
            `product:${productId}`,
            `category:${newData.categoryId}`,
            `brand:${newData.brandId}`,
            `search:${newData.name.toLowerCase()}`
        ];
        
        // Local invalidation
        this.l1Cache.delete(productId);
        
        // Distributed invalidation
        await Promise.all(
            keysToInvalidate.map(key => this.l2Cache.delete(key))
        );
        
        // Notify other instances
        await this.invalidationBus.publish('product:updated', {
            productId,
            keysToInvalidate
        });
    }
    
    setupInvalidationHandlers() {
        this.invalidationBus.subscribe('product:updated', async (event) => {
            // Invalidate local caches
            this.l1Cache.delete(event.productId);
            event.keysToInvalidate.forEach(key => {
                if (key.startsWith('category:')) {
                    const categoryId = key.split(':')[1];
                    this.categoryCache.delete(categoryId);
                }
            });
        });
    }
}
```

### Scenario B: Social Media Feed

**Requirements:**
- User-specific content
- Real-time updates  
- 100M users, 10K posts/second
- Geographic distribution

```javascript
class SocialMediaFeedCache {
    constructor(region) {
        this.region = region;
        this.feedCache = new Redis();
        this.userCache = new LRU(100000);
        this.contentCache = new Redis();
        this.realtimeUpdates = new WebSocketManager();
        
        this.setupRealtimeInvalidation();
    }
    
    async getUserFeed(userId, page = 0, limit = 20) {
        const feedKey = `feed:${userId}:${page}:${limit}`;
        
        // Try cache first
        let feed = await this.feedCache.get(feedKey);
        if (feed) {
            return this.hydrateFeed(JSON.parse(feed));
        }
        
        // Generate feed
        feed = await this.generateFeed(userId, page, limit);
        
        // Cache with short TTL (personalized content)
        await this.feedCache.set(feedKey, JSON.stringify(feed), 300); // 5 minutes
        
        return this.hydrateFeed(feed);
    }
    
    async generateFeed(userId, page, limit) {
        // Get user's social graph
        const connections = await this.getUserConnections(userId);
        
        // Get recent posts from connections
        const postIds = await this.getRecentPosts(connections, page * limit, limit);
        
        // Rank posts –ø–æ algorithm (engagement, recency, etc.)
        const rankedPosts = await this.rankPosts(postIds, userId);
        
        return rankedPosts;
    }
    
    async hydrateFeed(feedIds) {
        // Batch load post details
        const pipeline = this.contentCache.pipeline();
        feedIds.forEach(id => pipeline.get(`post:${id}`));
        
        const results = await pipeline.exec();
        
        return results
            .map(([error, result]) => result ? JSON.parse(result) : null)
            .filter(post => post !== null);
    }
    
    async publishPost(userId, postData) {
        const postId = await this.db.createPost(userId, postData);
        
        // Cache post content
        await this.contentCache.set(
            `post:${postId}`, 
            JSON.stringify(postData), 
            86400 // 24h
        );
        
        // Invalidate feeds of followers
        await this.invalidateFollowerFeeds(userId);
        
        // Real-time push to active followers
        await this.pushToActiveFollowers(userId, postData);
        
        return postId;
    }
    
    async invalidateFollowerFeeds(userId) {
        const followers = await this.getFollowers(userId);
        
        // Batch invalidation
        const pipeline = this.feedCache.pipeline();
        followers.forEach(followerId => {
            // Invalidate all pages of follower's feed
            for (let page = 0; page < 10; page++) {
                pipeline.del(`feed:${followerId}:${page}:20`);
            }
        });
        
        await pipeline.exec();
    }
    
    async pushToActiveFollowers(userId, postData) {
        const activeFollowers = await this.getActiveFollowers(userId);
        
        // Push via WebSocket to online users
        activeFollowers.forEach(followerId => {
            this.realtimeUpdates.push(followerId, {
                type: 'new_post',
                data: postData,
                author: userId
            });
        });
    }
    
    setupRealtimeInvalidation() {
        // Listen for real-time events
        this.realtimeUpdates.on('post_liked', async (event) => {
            // Update post engagement in cache
            const postKey = `post:${event.postId}`;
            const post = await this.contentCache.get(postKey);
            if (post) {
                const postData = JSON.parse(post);
                postData.likes = (postData.likes || 0) + 1;
                await this.contentCache.set(postKey, JSON.stringify(postData), 86400);
            }
        });
        
        this.realtimeUpdates.on('user_followed', async (event) => {
            // Invalidate both users' feeds
            await Promise.all([
                this.invalidateUserFeeds(event.followerId),
                this.invalidateUserFeeds(event.followedId)
            ]);
        });
    }
}
```

## üèÜ Advanced Troubleshooting Scenarios

### Performance Investigation Checklist

```javascript
class CacheHealthChecker {
    async performHealthCheck() {
        const checks = await Promise.all([
            this.checkHitRates(),
            this.checkLatency(),
            this.checkMemoryUsage(),
            this.checkEvictionPatterns(),
            this.checkConnectionHealth(),
            this.checkKeyDistribution()
        ]);
        
        return this.generateHealthReport(checks);
    }
    
    async checkHitRates() {
        const stats = await this.redis.info('stats');
        const hitRate = stats.keyspace_hits / (stats.keyspace_hits + stats.keyspace_misses);
        
        return {
            name: 'Hit Rate',
            value: hitRate,
            healthy: hitRate > 0.8,
            recommendation: hitRate < 0.8 ? 'Investigate cache warming or TTL settings' : null
        };
    }
    
    async checkLatency() {
        const samples = [];
        for (let i = 0; i < 100; i++) {
            const start = process.hrtime.bigint();
            await this.redis.ping();
            const latency = Number(process.hrtime.bigint() - start) / 1000000;
            samples.push(latency);
        }
        
        const avgLatency = samples.reduce((a, b) => a + b) / samples.length;
        const p95Latency = samples.sort((a, b) => a - b)[Math.floor(samples.length * 0.95)];
        
        return {
            name: 'Latency',
            value: { avg: avgLatency, p95: p95Latency },
            healthy: avgLatency < 5 && p95Latency < 10,
            recommendation: avgLatency > 5 ? 'Check network or Redis performance' : null
        };
    }
}
```

---

## üìã Quick Reference Answers

### Key Takeaways for Each Level:

**Junior Developer –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å:**
- Cache-aside pattern
- TTL concepts  
- HTTP cache headers basics
- When NOT to use cache

**Middle Developer –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å:**
- Write-through vs Write-behind
- LRU implementation
- Cache stampede solutions
- Distributed invalidation

**Senior Developer –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å:**
- Consistent hashing
- Cache coherence
- Performance optimization
- Security considerations
- ML-driven caching

### Red Flags –≤ –æ—Ç–≤–µ—Ç–∞—Ö:
- ‚ùå "Cache –≤—Å–µ–≥–¥–∞ —É—Å–∫–æ—Ä—è–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"
- ‚ùå –ù–µ –ø–æ–Ω–∏–º–∞–µ—Ç trade-offs –º–µ–∂–¥—É consistency –∏ performance  
- ‚ùå –ù–µ –∑–Ω–∞–µ—Ç –∫–∞–∫ debugger cache –ø—Ä–æ–±–ª–µ–º—ã
- ‚ùå –ò–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç security implications

### Green Flags –≤ –æ—Ç–≤–µ—Ç–∞—Ö:
- ‚úÖ –£–ø–æ–º–∏–Ω–∞–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ tools –∏ metrics
- ‚úÖ –ü–æ–Ω–∏–º–∞–µ—Ç business impact —Ä–µ—à–µ–Ω–∏–π
- ‚úÖ –†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç failure scenarios  
- ‚úÖ –ó–Ω–∞–µ—Ç operational considerations