# 🌐 Блок 3: Сеть и хранение данных

*Комплексное изучение сетевых возможностей Docker и управления данными*

---

## 📋 Обзор блока

В этом блоке мы глубоко изучим два критически важных аспекта работы с Docker:
- **Сетевые возможности** - как контейнеры общаются друг с другом и внешним миром
- **Управление данными** - как сохранять и управлять данными в контейнерах
- **Безопасность** - как защитить контейнеры и данные

---

## 🌐 Глава 3.1: Сетевые возможности Docker
**Время изучения:** 5-6 дней

### 🎯 Концептуальное понимание сетей Docker

#### Что такое сеть в контексте Docker?

Docker сеть - это **виртуальная сетевая инфраструктура**, которая позволяет контейнерам безопасно взаимодействовать друг с другом и с внешним миром. Представьте это как **невидимые мосты** между контейнерами.

```
Физический хост
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ┌─────────────┐    Docker Bridge Network    ┌──────────────┐│
│  │ Контейнер A │◄─────────────────────────────► Контейнер B ││
│  └─────────────┘                              └──────────────┘│
│         │                                              │     │
│         │              ┌─────────────┐                │     │
│         └──────────────►│Docker Daemon│◄───────────────┘     │
│                        └─────────────┘                      │
│                               │                             │
│                        ┌─────────────┐                      │
│                        │   Host OS   │                      │
│                        └─────────────┘                      │
└─────────────────────────────────────────────────────────────┘
```

### 📊 Типы сетей Docker

Docker предоставляет несколько типов сетей, каждая с своими особенностями:

#### 1. Bridge Network (По умолчанию)

**Концепция:** Это как **локальная сеть внутри вашего компьютера** только для контейнеров.

```
Host Machine (192.168.1.100)
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Docker Bridge (172.17.0.1)                        │
│  ┌─────────────────────────────────────────────────┐ │
│  │                                                 │ │
│  │  Container A        Container B                 │ │
│  │  (172.17.0.2)      (172.17.0.3)               │ │
│  │  ┌─────────┐        ┌─────────┐                │ │
│  │  │   App   │◄──────►│Database │                │ │
│  │  └─────────┘        └─────────┘                │ │
│  └─────────────────────────────────────────────────┘ │
│                      │                              │
│  ┌─────────────────────────────────────────────────┐ │
│  │            Host Network                         │ │
│  └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

**Особенности Bridge сети:**
- Контейнеры получают **приватные IP адреса**
- Автоматическое **DNS разрешение** между контейнерами
- **Изоляция** от хост-системы
- Нужно **явно пробрасывать порты** для доступа извне

#### 2. Host Network

**Концепция:** Контейнер **разделяет сетевое пространство** с хост-системой.

```
Host Machine (192.168.1.100)
┌─────────────────────────────────────────────────────┐
│                                                     │
│  ┌─────────────────────────────────────────────────┐ │
│  │         Host Network Namespace                  │ │
│  │                                                 │ │
│  │  ┌─────────┐      ┌─────────┐                  │ │
│  │  │Host App │      │Container│                  │ │
│  │  │Port 80  │      │Port 3000│                  │ │
│  │  └─────────┘      └─────────┘                  │ │
│  │                                                 │ │
│  │  Все используют один сетевой интерфейс          │ │
│  └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

**Когда использовать:**
- Нужна **максимальная производительность** сети
- Контейнер должен **напрямую взаимодействовать** с сетевыми интерфейсами хоста
- **Мониторинг сети** или **сетевые утилиты**

#### 3. Overlay Network

**Концепция:** Сеть для **распределенных контейнеров** на разных хостах.

```
Host A (192.168.1.100)          Host B (192.168.1.101)
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│  ┌─────────────────────┐│      │┌─────────────────────┐  │
│  │  Overlay Network    ││      ││  Overlay Network    │  │
│  │  (10.0.0.0/24)      ││◄────►││  (10.0.0.0/24)      │  │
│  │                     ││      ││                     │  │
│  │  Container A        ││      ││  Container B        │  │
│  │  (10.0.0.2)         ││      ││  (10.0.0.3)         │  │
│  └─────────────────────┘│      │└─────────────────────┘  │
│                         │      │                         │
└─────────────────────────┘      └─────────────────────────┘
                │                              │
                └──────────────────────────────┘
                        Internet/VPN
```

#### 4. Macvlan Network

**Концепция:** Каждый контейнер получает **уникальный MAC адрес** и выглядит как физическое устройство в сети.

```
Physical Network (192.168.1.0/24)
┌─────────────────────────────────────────────────────┐
│                                                     │
│  Router          Host Machine        Other Device   │
│  (.1) ◄─────────► (.100) ◄──────────► (.50)        │
│                    │                                │
│                    │                                │
│              ┌─────────────┐                        │
│              │   Macvlan   │                        │
│              │             │                        │
│              │ Container A │ Container B            │
│              │   (.110)    │   (.111)               │
│              └─────────────┘                        │
└─────────────────────────────────────────────────────┘
```

### 🔧 DNS в Docker сетях

Docker предоставляет **встроенный DNS сервер**, который работает как **телефонная книга** для контейнеров:

```
User-defined Network
┌─────────────────────────────────────────────────────┐
│                                                     │
│  ┌─────────────┐           ┌─────────────┐          │
│  │   web-app   │──────────►│  database   │          │
│  │             │  ping     │             │          │
│  │             │ database  │             │          │
│  └─────────────┘           └─────────────┘          │
│                                                     │
│          ┌─────────────────────────────┐            │
│          │     Docker DNS Server       │            │
│          │                             │            │
│          │  web-app    → 172.20.0.2    │            │
│          │  database   → 172.20.0.3    │            │
│          └─────────────────────────────┘            │
└─────────────────────────────────────────────────────┘
```

**Важные правила DNS:**
- Работает **только в пользовательских сетях**
- Контейнеры обращаются друг к другу **по имени**
- Автоматическое **обновление записей** при запуске/остановке контейнеров

### 🎓 Практические сценарии

#### Сценарий 1: Веб-приложение с базой данных

```
Frontend Network                Backend Network
┌─────────────────┐            ┌──────────────────┐
│                 │            │                  │
│  ┌─────────────┐│            │┌─────────────────┐│
│  │   Nginx     ││◄──────────►││   API Server    ││
│  │ (Port 80)   ││            ││  (Port 3000)    ││
│  └─────────────┘│            │└─────────────────┘│
│                 │            │        │         │
└─────────────────┘            │        │         │
                               │┌─────────────────┐│
                               ││   PostgreSQL    ││
                               ││  (Port 5432)    ││
                               │└─────────────────┘│
                               └──────────────────┘
```

**Почему используем разные сети?**
- **Безопасность**: База данных недоступна напрямую из интернета
- **Контроль трафика**: Можем настроить правила между сетями
- **Масштабирование**: Легко добавлять новые сервисы

#### Сценарий 2: Микросервисная архитектура

```
                    API Gateway Network
                   ┌─────────────────────┐
                   │  ┌─────────────────┐│
                   │  │   API Gateway   ││
                   │  │   (Port 80)     ││
                   │  └─────────────────┘│
                   └─────────┬───────────┘
                            │
            ┌───────────────┼───────────────┐
            │               │               │
  ┌─────────────────┐┌─────────────────┐┌─────────────────┐
  │   User Service  ││  Order Service  ││ Payment Service │
  │                 ││                 ││                 │
  │ ┌─────────────┐ ││ ┌─────────────┐ ││ ┌─────────────┐ │
  │ │    API      │ ││ │    API      │ ││ │    API      │ │
  │ └─────────────┘ ││ └─────────────┘ ││ └─────────────┘ │
  │ ┌─────────────┐ ││ ┌─────────────┐ ││ ┌─────────────┐ │
  │ │  Database   │ ││ │  Database   │ ││ │  Database   │ │
  │ └─────────────┘ ││ └─────────────┘ ││ └─────────────┘ │
  └─────────────────┘└─────────────────┘└─────────────────┘
```

### 🛠 Создание и управление сетями

#### Команды управления сетями

```bash
# Просмотр существующих сетей
docker network ls

# Детальная информация о сети
docker network inspect bridge

# Создание пользовательской сети
docker network create --driver bridge my-app-network

# Создание сети с конкретными параметрами
docker network create \
  --driver bridge \
  --subnet=192.168.100.0/24 \
  --ip-range=192.168.100.128/25 \
  --gateway=192.168.100.1 \
  my-custom-network

# Подключение контейнера к сети
docker network connect my-app-network my-container

# Отключение от сети
docker network disconnect my-app-network my-container

# Удаление сети
docker network rm my-app-network
```

### ⚡ Лучшие практики сетевой безопасности

1. **Используйте пользовательские сети**
   - Избегайте сеть по умолчанию для production
   - Каждое приложение - отдельная сеть

2. **Принцип минимальных привилегий**
   - Открывайте только необходимые порты
   - Используйте внутренние сети для межсервисного общения

3. **Сегментация сети**
   - Разделяйте frontend, backend, и database сети
   - Используйте прокси для внешнего доступа

```
Internet
    │
    ▼
┌─────────────┐
│   Nginx     │ ◄── Public Network
│   Proxy     │
└─────────────┘
    │
    ▼
┌─────────────┐
│ Application │ ◄── App Network  
│  Services   │
└─────────────┘
    │
    ▼
┌─────────────┐
│  Database   │ ◄── Database Network
│   Cluster   │
└─────────────┘
```

### 🎯 Практические задания

#### Задание 1: Создание изолированной среды разработки
Создайте сеть для веб-приложения с базой данных, где:
- База данных недоступна извне
- Веб-сервер доступен только на порту 8080
- Используется пользовательское DNS имя

#### Задание 2: Мультисервисная архитектура  
Спроектируйте сетевую архитектуру для системы с:
- API Gateway
- 3 микросервиса
- 2 базы данных
- Система мониторинга

#### Задание 3: Отладка сетевых проблем
Научитесь диагностировать:
- Проблемы с DNS разрешением
- Недоступность портов
- Проблемы маршрутизации между сетями

---

## 💾 Глава 3.2: Управление данными
**Время изучения:** 5-6 дней

### 🎯 Фундаментальные концепции хранения данных

#### Проблема временности контейнеров

Контейнеры по своей природе **эфемерны** (временны). Это означает:
- При удалении контейнера **все данные исчезают**
- Перезапуск контейнера **может привести к потере изменений**
- Обновление образа **требует миграции данных**

```
Жизненный цикл контейнера
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  docker run     Контейнер работает     docker stop      │
│      │               │                     │            │
│      ▼               ▼                     ▼            │
│  ┌────────┐     ┌──────────┐         ┌──────────┐       │
│  │Создание│────►│ Работа   │────────►│Остановка │       │
│  └────────┘     └──────────┘         └──────────┘       │
│                       │                     │            │
│                       │  docker rm          │            │
│                       ▼                     ▼            │
│                 ┌──────────┐         ┌──────────┐       │
│                 │Изменения │         │ Удаление │       │
│                 │  данных  │         │          │       │
│                 └──────────┘         └──────────┘       │
│                       │                     │            │
│                   ❌ ПОТЕРЯ              ❌ ПОТЕРЯ       │
│                    ДАННЫХ                ДАННЫХ         │
└─────────────────────────────────────────────────────────┘
```

### 📊 Типы хранения данных в Docker

Docker предоставляет три основных способа хранения данных:

#### 1. Volumes (Тома) - Рекомендуемый способ

**Концепция:** Тома - это **управляемые Docker директории**, которые существуют независимо от контейнеров.

```
Host File System
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  /var/lib/docker/volumes/                               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  my-volume/                                         │ │
│  │  ├── _data/                ◄─────────────────────┐  │ │
│  │  │   ├── database.db                            │  │ │
│  │  │   ├── logs/                                  │  │ │
│  │  │   └── config/                                │  │ │
│  │                                                 │  │ │
│  └─────────────────────────────────────────────────│──┘ │
│                                                    │    │
│  ┌─────────────────────────────────────────────────│──┐ │
│  │                     Container                   │  │ │
│  │                                                 │  │ │
│  │  /app/data/ ◄───────────────────────────────────┘  │ │
│  │  ├── database.db                                   │ │
│  │  ├── logs/                                         │ │
│  │  └── config/                                       │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**Преимущества Volumes:**
- **Управляются Docker** - автоматическое создание и очистка
- **Независимы от контейнеров** - данные сохраняются после удаления контейнера
- **Кроссплатформенность** - работают одинаково на всех ОС
- **Высокая производительность** - оптимизированы для I/O операций
- **Простое резервное копирование**

#### 2. Bind Mounts (Привязанные монтирования)

**Концепция:** Прямая **привязка директории хоста** к контейнеру.

```
Host File System                          Container
┌─────────────────────────────────┐      ┌───────────────────┐
│                                 │      │                   │
│  /home/user/project/            │      │                   │
│  ├── src/                       │◄────►│  /app/            │
│  │   ├── index.js               │      │  ├── src/         │
│  │   └── package.json           │      │  │   ├── index.js │
│  ├── docs/                      │      │  │   └── package. │
│  └── README.md                  │      │  ├── docs/        │
│                                 │      │  └── README.md    │
│  Изменения синхронизируются     │      │                   │
│  в реальном времени             │      │                   │
└─────────────────────────────────┘      └───────────────────┘
```

**Когда использовать Bind Mounts:**
- **Разработка** - изменения в коде сразу видны в контейнере
- **Конфигурационные файлы** - когда нужен контроль над местоположением
- **Логи** - когда нужно читать логи инструментами хоста

#### 3. tmpfs Mounts (Временная файловая система)

**Концепция:** Данные хранятся **в памяти хоста**, не записываются на диск.

```
Host Memory
┌─────────────────────────────────────────────────────────┐
│                                RAM                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                tmpfs Mount                          │ │
│  │                                                     │ │
│  │  ┌─────────────┐              ┌─────────────────┐   │ │
│  │  │ Container   │◄────────────►│   Temporary     │   │ │
│  │  │             │              │   File System   │   │ │
│  │  │ /tmp/cache  │              │                 │   │ │
│  │  └─────────────┘              └─────────────────┘   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  ❌ НЕТ записи на диск                                  │
│  ⚡ Очень быстрый доступ                                │
│  🔒 Данные исчезают при остановке                       │
└─────────────────────────────────────────────────────────┘
```

**Когда использовать tmpfs:**
- **Временные файлы** - кеш, сессии, временные вычисления  
- **Конфиденциальные данные** - не должны попасть на диск
- **Высокопроизводительные операции** - максимальная скорость I/O

### 🔄 Сравнение типов хранения

```
┌─────────────────┬─────────────┬─────────────┬─────────────┐
│   Критерий      │  Volumes    │Bind Mounts  │   tmpfs     │
├─────────────────┼─────────────┼─────────────┼─────────────┤
│ Управление      │ Docker      │ Пользователь│ Docker      │
│ Производительн. │ Высокая     │ Средняя     │ Максимальная│
│ Переносимость   │ Отличная    │ Ограничен.  │ Отличная    │
│ Персистентность │ Да          │ Да          │ Нет         │
│ Безопасность    │ Изолирован  │ Доступ к    │ Изолирован  │
│                 │             │ хост-системе│             │
│ Резерв. копир.  │ Простое     │ Внешние     │ Невозможно  │
│                 │             │ инструменты │             │
└─────────────────┴─────────────┴─────────────┴─────────────┘
```

### 🛠 Практическая работа с Volume

#### Жизненный цикл Volume

```
1. Создание Volume
   docker volume create my-data
   
2. Использование в контейнере  
   ┌─────────────────────────────────────┐
   │              Host                   │
   │  ┌─────────────────────────────────┐ │
   │  │      Docker Volume              │ │
   │  │      my-data                    │ │
   │  └─────────────┬───────────────────┘ │
   │                │                     │
   │  ┌─────────────▼───────────────────┐ │
   │  │         Container               │ │
   │  │         /app/data               │ │
   │  └─────────────────────────────────┘ │
   └─────────────────────────────────────┘

3. Контейнер удален - данные сохранены
   ┌─────────────────────────────────────┐
   │              Host                   │
   │  ┌─────────────────────────────────┐ │
   │  │      Docker Volume              │ │
   │  │      my-data ✓ СОХРАНЕН         │ │
   │  └─────────────────────────────────┘ │
   │                                     │
   │  ❌ Container удален                │
   └─────────────────────────────────────┘

4. Новый контейнер - те же данные
   ┌─────────────────────────────────────┐
   │              Host                   │
   │  ┌─────────────────────────────────┐ │
   │  │      Docker Volume              │ │
   │  │      my-data                    │ │
   │  └─────────────┬───────────────────┘ │
   │                │                     │
   │  ┌─────────────▼───────────────────┐ │
   │  │      New Container              │ │
   │  │      /app/data ✓ ДАННЫЕ ТАМ     │ │
   │  └─────────────────────────────────┘ │
   └─────────────────────────────────────┘
```

### 🗄 database с персистентными данными

#### Проблема: База данных без Volume

```
БЕЗ VOLUME - Данные теряются
┌─────────────────────────────────────────────────────────┐
│  Контейнер PostgreSQL                                   │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  /var/lib/postgresql/data/                          │ │
│  │  ├── база_данных.db                                 │ │
│  │  ├── таблицы                                        │ │
│  │  └── индексы                                        │ │
│  │                                                     │ │
│  │  ❌ При docker rm - ВСЕ ПОТЕРЯНО                    │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### Решение: База данных с Volume

```
С VOLUME - Данные сохраняются
┌─────────────────────────────────────────────────────────┐
│  Host System                                            │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Docker Volume: postgres-data                       │ │
│  │  /var/lib/docker/volumes/postgres-data/_data/       │ │
│  │  ├── база_данных.db                                 │ │
│  │  ├── таблицы                                        │ │
│  │  └── индексы                                        │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  Container PostgreSQL                               │ │
│  │  /var/lib/postgresql/data/ ◄── Монтирован           │ │
│  │                                                     │ │
│  │  ✅ Данные ВСЕГДА доступны                          │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🔐 Резервное копирование и восстановление

#### Стратегия резервного копирования

```
Backup Process
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. Volume с данными                                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  my-app-data                                        │ │
│  │  ├── important.db                                   │ │
│  │  ├── config/                                        │ │
│  │  └── logs/                                          │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  2. Backup контейнер                                    │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  alpine container                                   │ │
│  │  ├── /source  ◄─── монтирован my-app-data           │ │
│  │  └── /backup  ◄─── монтирован backup директория     │ │
│  │                                                     │ │
│  │  tar czf /backup/backup.tar.gz -C /source .         │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  3. Результат                                           │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  /host/backups/                                     │ │
│  │  └── backup-2024-01-15.tar.gz ✅                    │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### Процесс восстановления

```
Restore Process
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. Backup файл                                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  /host/backups/backup-2024-01-15.tar.gz             │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  2. Restore контейнер                                   │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  alpine container                                   │ │
│  │  ├── /backup  ◄─── монтирован backup директория     │ │
│  │  └── /target  ◄─── монтирован новый volume          │ │
│  │                                                     │ │
│  │  tar xzf /backup/backup.tar.gz -C /target           │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  3. Восстановленный Volume                              │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  restored-data                                      │ │
│  │  ├── important.db ✅                                │ │
│  │  ├── config/ ✅                                     │ │
│  │  └── logs/ ✅                                       │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🎯 Практические сценарии

#### Сценарий 1: Веб-приложение с пользовательскими загрузками

```
Application Architecture
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  nginx (Веб-сервер)                                 │ │
│  │  ├── /etc/nginx/nginx.conf ◄── bind mount           │ │
│  │  └── /var/log/nginx/ ◄──────── volume: nginx-logs   │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  app (Node.js приложение)                           │ │
│  │  ├── /app/uploads/ ◄──────── volume: user-uploads   │ │
│  │  ├── /app/cache/ ◄────────── tmpfs mount            │ │
│  │  └── /app/src/ ◄───────────── bind mount (dev)      │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  database (PostgreSQL)                              │ │
│  │  └── /var/lib/postgresql/data/ ◄─ volume: db-data   │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**Почему такая архитектура?**
- **nginx-logs** (volume): Логи нужно анализировать и ротировать
- **user-uploads** (volume): Файлы пользователей должны сохраняться
- **app-cache** (tmpfs): Кеш быстрый, но временный
- **app-src** (bind mount): Разработка - изменения видны сразу
- **db-data** (volume): База данных - критически важные данные

#### Сценарий 2: Многоуровневое резервное копирование

```
Backup Strategy
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Production Volumes          Backup Levels              │
│  ┌─────────────────┐                                    │
│  │   app-data      │                                    │
│  │   db-data       │         Level 1: Local Backup     │
│  │   user-files    │──────►  ┌─────────────────────┐    │
│  └─────────────────┘         │  /backups/daily/    │    │
│           │                  │  ├── app-backup.gz  │    │
│           │                  │  ├── db-backup.sql  │    │
│           │                  │  └── files.tar.gz   │    │
│           │                  └─────────────────────┘    │
│           │                            │                │
│           │                  Level 2: Cloud Backup     │
│           │                  ┌─────────────────────┐    │
│           └─────────────────►│   AWS S3 / GCS      │    │
│                              │   ├── weekly/       │    │
│                              │   ├── monthly/      │    │
│                              │   └── yearly/       │    │
│                              └─────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### ⚡ Лучшие практики управления данными

#### 1. Выбор правильного типа хранения

```
Решение по типу данных
┌─────────────────┬─────────────────┬─────────────────┐
│   Тип данных    │  Рекомендация   │    Причина      │
├─────────────────┼─────────────────┼─────────────────┤
│ База данных     │ Named Volume    │ Персистентность│
│ Конфигурация    │ Bind Mount      │ Контроль        │
│ Логи            │ Named Volume    │ Ротация         │
│ Кеш/Сессии      │ tmpfs           │ Производительн. │
│ Исходный код    │ Bind Mount      │ Разработка      │
│ Секреты         │ tmpfs/Secrets   │ Безопасность    │
└─────────────────┴─────────────────┴─────────────────┘
```

#### 2. Именование и организация

```
Naming Convention
├── app-name-data          (основные данные)
├── app-name-logs          (логи)  
├── app-name-config        (конфигурация)
├── app-name-cache         (кеш)
└── app-name-db-data       (база данных)

Directory Structure
/docker/
├── volumes/
│   ├── production/
│   ├── staging/
│   └── development/
├── backups/
│   ├── daily/
│   ├── weekly/
│   └── monthly/
└── configs/
    ├── nginx/
    ├── postgres/
    └── app/
```

#### 3. Мониторинг дискового пространства

```
Volume Space Monitoring
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Volume Usage Dashboard                                 │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  app-data:     [████████░░] 80% (8GB/10GB)         │ │
│  │  db-data:      [██████████] 95% (19GB/20GB) ⚠️     │ │
│  │  logs:         [███░░░░░░░] 30% (3GB/10GB)         │ │
│  │  user-files:   [██████░░░░] 60% (60GB/100GB)       │ │
│  │                                                     │ │
│  │  🚨 Alert: db-data > 90% - Need cleanup/resize     │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🎯 Практические задания

#### Задание 1: Создание надежной системы хранения
Спроектируйте систему хранения для блога с требованиями:
- Статьи (персистентные)
- Загружаемые изображения (персистентные) 
- Кеш поиска (временный)
- Логи доступа (с ротацией)

#### Задание 2: Система резервного копирования
Создайте автоматизированную систему резервного копирования:
- Ежедневные инкрементальные бэкапы
- Еженедельные полные бэкапы
- Автоматическая очистка старых бэкапов
- Проверка целостности бэкапов

#### Задание 3: Миграция данных
Спланируйте миграцию работающего приложения:
- Без потери данных
- С минимальным downtime
- С возможностью отката

---

## 🔒 Глава 3.3: Безопасность в Docker
**Время изучения:** 4-5 дней

### 🎯 Фундаментальные принципы безопасности

#### Поверхность атаки в контейнерах

Контейнеры создают **несколько уровней потенциальных уязвимостей**:

```
Attack Surface Layers
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. Application Layer                                   │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  • Уязвимости в коде приложения                     │ │
│  │  • Небезопасные зависимости                         │ │
│  │  │  • SQL Injection                                 │ │
│  │  │  • XSS атаки                                     │ │
│  │  └── • Небезопасная десериализация                  │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  2. Container Runtime Layer                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  • Побег из контейнера                              │ │
│  │  • Привилегированные контейнеры                     │ │
│  │  │  • Небезопасные capabilities                     │ │
│  │  │  • Монтирование host директорий                  │ │
│  │  └── • Совместное ядро с хостом                     │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  3. Host System Layer                                   │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  • Уязвимости в Docker daemon                       │ │
│  │  • Неправильные права доступа                       │ │
│  │  │  • Docker socket доступ                          │ │
│  │  │  • Host network sharing                          │ │
│  │  └── • Kernel уязвимости                            │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 👤 Пользователи и права доступа

#### Проблема root пользователя

По умолчанию контейнеры **запускаются от root**, что создает серьезные риски:

```
Root Container Risk
┌─────────────────────────────────────────────────────────┐
│  Container (root user)          Host System             │
│  ┌─────────────────────────┐    ┌─────────────────────┐  │
│  │                         │    │                     │  │
│  │  Process: nginx         │    │  Docker Daemon      │  │
│  │  User: root (uid=0)     │◄──►│  User: root         │  │
│  │  Capabilities: ALL      │    │                     │  │
│  │                         │    │  ⚠️ Если контейнер  │  │
│  │  ⚠️ Если скомпрометиров.│    │     скомпромет.,    │  │
│  │     может повлиять на   │    │     может получить  │  │
│  │     host систему        │    │     доступ к хосту  │  │
│  └─────────────────────────┘    └─────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

#### Решение: Non-root пользователь

```
Non-root Container Security
┌─────────────────────────────────────────────────────────┐
│  Container (non-root)           Host System             │
│  ┌─────────────────────────┐    ┌─────────────────────┐  │
│  │                         │    │                     │  │
│  │  Process: nginx         │    │  Docker Daemon      │  │
│  │  User: appuser(uid=1001)│◄──►│  User: root         │  │
│  │  Capabilities: LIMITED  │    │                     │  │
│  │                         │    │  ✅ Даже если       │  │
│  │  ✅ Ограниченные права  │    │     контейнер       │  │
│  │     минимальный ущерб   │    │     скомпромет.,    │  │
│  │     при компрометации   │    │     ущерб ограничен│  │
│  └─────────────────────────┘    └─────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

#### Создание безопасного пользователя в Dockerfile

```dockerfile
# Правильный способ создания non-root пользователя
FROM node:16-alpine

# Создаем группу и пользователя
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs

# Создаем директории с правильными правами
WORKDIR /app
RUN chown -R nextjs:nodejs /app

# Устанавливаем зависимости как root
COPY package*.json ./
RUN npm ci --only=production

# Копируем приложение и меняем владельца
COPY --chown=nextjs:nodejs . .

# Переключаемся на non-root пользователя
USER nextjs

# Запускаем приложение
CMD ["node", "server.js"]
```

### 🔍 Сканирование образов на уязвимости

#### Что такое уязвимости в образах?

Образы содержат **множество компонентов**, каждый может иметь уязвимости:

```
Image Vulnerability Layers
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Application Image                                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Application Code                                   │ │
│  │  ├── app.js                                         │ │
│  │  └── package.json                                   │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Dependencies Layer                                 │ │
│  │  ├── express@4.17.1 ⚠️ CVE-2022-24999              │ │
│  │  ├── lodash@4.17.20 🚨 CVE-2021-23337 (Critical)   │ │
│  │  └── jsonwebtoken@8.5.1 ✅ No known vulnerabilities│ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Base OS Layer                                      │ │
│  │  ├── glibc 2.28 🚨 CVE-2023-4911 (High)            │ │
│  │  ├── openssl 1.1.1 ⚠️ CVE-2023-0286 (Medium)       │ │
│  │  └── curl 7.68.0 ✅ Patched                         │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### Процесс сканирования

```
Vulnerability Scanning Process
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. Build Image                                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  docker build -t my-app:latest .                    │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  2. Scan Image                                          │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  docker scout cves my-app:latest                    │ │
│  │                                                     │ │
│  │  Scanning layers...                                 │ │
│  │  └── Checking CVE database                          │ │
│  │  └── Analyzing dependencies                         │ │
│  │  └── Checking base image                            │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  3. Security Report                                     │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  🚨 Critical: 2                                     │ │
│  │  ⚠️  High: 5                                        │ │
│  │  ⚠️  Medium: 12                                     │ │
│  │  ℹ️  Low: 8                                         │ │
│  │                                                     │ │
│  │  Recommended actions:                               │ │
│  │  • Update base image                                │ │
│  │  • Upgrade vulnerable packages                      │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  4. Fix & Rescan                                        │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  Apply fixes → Rebuild → Scan again                 │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🔐 Управление секретами

#### Проблема: Секреты в образах

**НИКОГДА не включайте секреты в образы!**

```
❌ НЕПРАВИЛЬНО - Секреты в образе
┌─────────────────────────────────────────────────────────┐
│  Dockerfile                                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  FROM node:16                                       │ │
│  │  COPY .env .                                        │ │
│  │  ENV DB_PASSWORD=secret123                          │ │
│  │  ENV API_KEY=abc123xyz                              │ │
│  │                                                     │ │
│  │  ⚠️ Секреты теперь НАВСЕГДА в образе!               │ │
│  │  ⚠️ Любой с доступом к образу видит секреты!       │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### Правильные способы управления секретами

```
✅ ПРАВИЛЬНО - Секреты извне
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Method 1: Environment Variables                        │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  docker run -e DB_PASSWORD_FILE=/run/secrets/db_pass│ │
│  │              -v /host/secrets:/run/secrets my-app   │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  Method 2: Docker Secrets (Swarm)                      │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  echo "secret123" | docker secret create db_pass -  │ │
│  │  docker service create --secret db_pass my-app      │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  Method 3: External Secret Management                   │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  ┌─────────────┐    ┌─────────────┐                │ │
│  │  │ Vault/K8s   │◄──►│ Init Container│               │ │
│  │  │ Secrets     │    │             │               │ │
│  │  └─────────────┘    └─────────────┘               │ │
│  │                           │                        │ │
│  │                    ┌─────────────┐                │ │
│  │                    │Main App     │               │ │
│  │                    │Container    │               │ │
│  │                    └─────────────┘               │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🛡 Принцип наименьших привилегий

#### Linux Capabilities

Вместо полных root прав, используйте **только необходимые capabilities**:

```
Capabilities Concept
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Traditional Root Access                                │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  root user = ALL CAPABILITIES                       │ │
│  │  • CAP_NET_BIND_SERVICE (bind ports < 1024)         │ │
│  │  • CAP_NET_ADMIN (network config)                   │ │
│  │  • CAP_SYS_ADMIN (system administration)            │ │
│  │  • CAP_DAC_OVERRIDE (ignore file permissions)       │ │
│  │  • ... ALL OTHER CAPABILITIES                       │ │
│  │                                                     │ │
│  │  ⚠️ Если скомпрометирован = полный контроль         │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  Capability-based Access                                │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  non-root user + specific capabilities              │ │
│  │  • CAP_NET_BIND_SERVICE ✅ (only this one!)         │ │
│  │  • CAP_NET_ADMIN ❌                                 │ │
│  │  • CAP_SYS_ADMIN ❌                                 │ │
│  │  • CAP_DAC_OVERRIDE ❌                              │ │
│  │                                                     │ │
│  │  ✅ Минимальные права = минимальный риск            │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### Практические примеры capabilities

```bash
# Веб-сервер нуждается только в привязке к портам < 1024
docker run --cap-drop=ALL \
           --cap-add=CAP_NET_BIND_SERVICE \
           --user 1001:1001 \
           my-web-server

# База данных может нуждаться в дополнительных правах файловой системы
docker run --cap-drop=ALL \
           --cap-add=CAP_SETUID \
           --cap-add=CAP_SETGID \
           --user postgres \
           postgres:13

# Мониторинг системы
docker run --cap-drop=ALL \
           --cap-add=CAP_SYS_NICE \
           --cap-add=CAP_NET_RAW \
           --user monitor \
           monitoring-agent
```

### 🔒 Сетевая безопасность

#### Изоляция сетей

```
Network Security Architecture
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Internet                                               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  DMZ Network                                            │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  ┌─────────────┐      ┌─────────────┐               │ │
│  │  │   Nginx     │      │Load Balancer│               │ │
│  │  │   Proxy     │      │             │               │ │
│  │  └─────────────┘      └─────────────┘               │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  Application Network (Internal)                         │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  ┌─────────────┐      ┌─────────────┐               │ │
│  │  │   API       │◄────►│   Auth      │               │ │
│  │  │  Service    │      │  Service    │               │ │
│  │  └─────────────┘      └─────────────┘               │ │
│  └─────────────────┬───────────────────────────────────┘ │
│                    │                                     │
│  Database Network (Private)                             │
│  ┌─────────────────▼───────────────────────────────────┐ │
│  │  ┌─────────────┐      ┌─────────────┐               │ │
│  │  │ PostgreSQL  │      │    Redis    │               │ │
│  │  │             │      │    Cache    │               │ │
│  │  └─────────────┘      └─────────────┘               │ │
│  │                                                     │ │
│  │  🚫 Недоступна из интернета                         │ │
│  │  🚫 Недоступна из DMZ                               │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 📊 Безопасный Dockerfile

#### Пример безопасного многослойного Dockerfile

```dockerfile
# Используем минимальный базовый образ
FROM node:16-alpine AS base

# Обновляем пакеты для устранения уязвимостей
RUN apk update && apk upgrade && \
    apk add --no-cache dumb-init && \
    rm -rf /var/cache/apk/*

# Создаем non-root пользователя
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs

# Стадия зависимостей
FROM base AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Стадия сборки
FROM base AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Финальная стадия
FROM base AS runner
WORKDIR /app

# Копируем только необходимые файлы
COPY --from=deps --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json

# Переключаемся на non-root пользователя
USER nextjs

# Настраиваем безопасность
EXPOSE 3000
ENV NODE_ENV=production

# Используем dumb-init для правильной обработки сигналов
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/server.js"]

# Добавляем health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js
```

### 🎯 Безопасность в production

#### Чек-лист безопасности

```
Production Security Checklist
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  📋 Image Security                                      │
│  ├── ✅ Используются официальные базовые образы         │
│  ├── ✅ Регулярное обновление базовых образов           │
│  ├── ✅ Минимальные образы (alpine, distroless)         │
│  ├── ✅ Multi-stage builds для уменьшения размера       │
│  ├── ✅ Сканирование на уязвимости в CI/CD             │
│  └── ✅ Подписывание образов                            │
│                                                         │
│  👤 Container Runtime Security                          │
│  ├── ✅ Non-root пользователи                           │
│  ├── ✅ Минимальные capabilities                        │
│  ├── ✅ Read-only файловая система где возможно         │
│  ├── ✅ Ограничения ресурсов (CPU, память)             │
│  ├── ✅ Отключение ненужных системных вызовов          │
│  └── ✅ Использование AppArmor/SELinux                  │
│                                                         │
│  🌐 Network Security                                    │
│  ├── ✅ Пользовательские сети вместо bridge по умолч.   │
│  ├── ✅ Принцип минимальных сетевых привилегий          │
│  ├── ✅ TLS для всех внешних соединений                 │
│  ├── ✅ Firewall правила для контейнеров                │
│  └── ✅ Мониторинг сетевого трафика                     │
│                                                         │
│  💾 Data Security                                       │
│  ├── ✅ Шифрование данных в покое                       │
│  ├── ✅ Безопасное управление секретами                 │
│  ├── ✅ Регулярные бэкапы с проверкой восстановления    │
│  ├── ✅ Логирование доступа к данным                    │
│  └── ✅ Принцип минимального доступа к данным           │
│                                                         │
│  🔧 Host Security                                       │
│  ├── ✅ Регулярные обновления Docker daemon             │
│  ├── ✅ Защищенный доступ к Docker socket               │
│  ├── ✅ Мониторинг активности хост-системы              │
│  ├── ✅ Логирование всех Docker операций                │
│  └── ✅ Настройка Docker daemon в rootless режиме       │
└─────────────────────────────────────────────────────────┘
```

#### Мониторинг безопасности

```
Security Monitoring Pipeline
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. Runtime Security Monitoring                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  Container Behavior Analysis                        │ │
│  │  ├── Falco (аномальная активность)                 │ │
│  │  ├── Sysdig (системные вызовы)                     │ │
│  │  ├── AppArmor/SELinux (принудительный контроль)     │ │
│  │  └── Custom monitoring (логи доступа)              │ │
│  │                                                     │ │
│  │  Alerts:                                            │ │
│  │  🚨 Попытка записи в /etc                           │ │
│  │  🚨 Выполнение shell в production контейнере        │ │
│  │  🚨 Сетевые соединения на подозрительные порты      │ │
│  │  🚨 Изменение системных файлов                      │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  2. Vulnerability Management                            │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  Continuous Scanning                                │ │
│  │  ├── Scheduled image scans (daily)                 │ │
│  │  ├── Registry webhooks (on push)                   │ │
│  │  ├── Runtime scanning (running containers)         │ │
│  │  └── Dependency tracking (SCA tools)               │ │
│  │                                                     │ │
│  │  Vulnerability Database                             │ │
│  │  ├── CVE feeds                                     │ │
│  │  ├── Vendor advisories                             │ │
│  │  ├── Threat intelligence                           │ │
│  │  └── Custom security rules                         │ │
│  └─────────────────────────────────────────────────────┘ │
│                             │                           │
│  3. Incident Response                                   │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  Automated Response                                 │ │
│  │  ├── Stop suspicious containers                    │ │
│  │  ├── Isolate affected networks                     │ │
│  │  ├── Create forensic snapshots                     │ │
│  │  └── Notify security team                          │ │
│  │                                                     │ │
│  │  Manual Investigation                               │ │
│  │  ├── Log analysis                                  │ │
│  │  ├── Network traffic inspection                    │ │
│  │  ├── File system changes                           │ │
│  │  └── Process execution history                     │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🛡 Расширенные техники безопасности

#### 1. Rootless Docker

**Концепция:** Запуск Docker daemon **без root привилегий** на хост-системе.

```
Traditional Docker vs Rootless Docker
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Traditional Docker                                     │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Host System                                        │ │
│  │  ├── Docker Daemon (root)                           │ │
│  │  │   ├── Container A (user: root → host: root)      │ │
│  │  │   └── Container B (user: app → host: root)       │ │
│  │  │                                                 │ │
│  │  │   ⚠️ Если daemon скомпрометирован = полный       │ │
│  │  │      контроль над хост-системой                  │ │
│  │  └── User processes                                 │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  Rootless Docker                                        │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Host System                                        │ │
│  │  ├── Docker Daemon (user: dockeruser)               │ │
│  │  │   ├── Container A (user: root → host: dockeruser)│ │
│  │  │   └── Container B (user: app → host: dockeruser) │ │
│  │  │                                                 │ │
│  │  │   ✅ Даже если daemon скомпрометирован,          │ │
│  │  │      нет root доступа к хосту                    │ │
│  │  └── User processes                                 │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### 2. Distroless образы

**Концепция:** Образы **только с приложением**, без ОС утилит.

```
Traditional vs Distroless Images
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Traditional Image (ubuntu:20.04 + app)                │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Application Layer                                  │ │
│  │  ├── my-app                                         │ │
│  │  └── config/                                        │ │
│  └─────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Language Runtime                                   │ │
│  │  ├── node                                           │ │
│  │  └── npm                                            │ │
│  └─────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  OS Utilities (ATTACK SURFACE!)                     │ │
│  │  ├── bash, sh                                       │ │
│  │  ├── curl, wget                                     │ │
│  │  ├── package managers                               │ │
│  │  ├── system utilities                               │ │
│  │  └── ... hundreds of binaries                       │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  Distroless Image                                       │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Application Layer                                  │ │
│  │  ├── my-app                                         │ │
│  │  └── config/                                        │ │
│  └─────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Language Runtime                                   │ │
│  │  ├── node                                           │ │
│  │  └── minimal libraries                              │ │
│  └─────────────────────────────────────────────────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │  Base Layer (MINIMAL!)                              │ │
│  │  ├── libc                                           │ │
│  │  ├── ca-certificates                                │ │
│  │  └── timezone data                                  │ │
│  │                                                     │ │
│  │  ✅ Нет shell - нет возможности выполнить команды   │ │
│  │  ✅ Нет пакетных менеджеров                         │ │
│  │  ✅ Минимальная поверхность атаки                   │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### 3. Security Contexts и Namespaces

```
Container Isolation Mechanisms
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Host System Namespaces                                 │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                                                     │ │
│  │  PID Namespace Isolation                            │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │ │
│  │  │Container A  │  │Container B  │  │   Host      │  │ │
│  │  │             │  │             │  │             │  │ │
│  │  │PID 1: app   │  │PID 1: nginx │  │PID 1: init  │  │ │
│  │  │PID 2: worker│  │PID 2: worker│  │PID 2: kernel│  │ │
│  │  │             │  │             │  │   ...       │  │ │
│  │  │✅ Не видят  │  │✅ Не видят  │  │✅ Видит все │  │ │
│  │  │  друг друга │  │  друг друга │  │  процессы   │  │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  │ │
│  │                                                     │ │
│  │  Network Namespace Isolation                        │ │
│  │  Container A          Container B                   │ │
│  │  ┌─────────────┐      ┌─────────────┐              │ │
│  │  │eth0: 172.17.│      │eth0: 172.17.│              │ │
│  │  │    0.2      │      │    0.3      │              │ │
│  │  │lo: 127.0.0.1│      │lo: 127.0.0.1│              │ │
│  │  └─────────────┘      └─────────────┘              │ │
│  │         │                     │                     │ │
│  │         └─────────┬───────────┘                     │ │
│  │                   │                                 │ │
│  │            ┌─────────────┐                          │ │
│  │            │Docker Bridge│                          │ │
│  │            │172.17.0.1   │                          │ │
│  │            └─────────────┘                          │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 🎯 Практические задания по безопасности

#### Задание 1: Создание безопасного образа
Создайте максимально безопасный образ для веб-приложения:
- Non-root пользователь
- Минимальный базовый образ
- Проверка на уязвимости
- Только необходимые capabilities
- Health checks

#### Задание 2: Сетевая сегментация
Спроектируйте сетевую архитектуру для e-commerce системы:
- Публичная зона (веб-сервер)
- Приложенческая зона (API)
- Зона данных (база данных)
- Система мониторинга
- Правила файрвола между зонами

#### Задание 3: Система мониторинга безопасности
Настройте систему обнаружения аномалий:
- Мониторинг файловых изменений
- Анализ сетевого трафика
- Детекция подозрительных системных вызовов
- Автоматические алерты
- Журналирование событий безопасности

---

## 🎓 Заключение блока и подготовка к следующему

### 📊 Что мы изучили в блоке 3

```
Knowledge Map - Block 3 Complete
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  🌐 Docker Networking                                   │
│  ├── ✅ Типы сетей (bridge, host, overlay, macvlan)     │
│  ├── ✅ DNS в Docker сетях                              │
│  ├── ✅ Пользовательские сети                           │
│  ├── ✅ Межконтейнерное взаимодействие                  │
│  ├── ✅ Сетевая безопасность                            │
│  └── ✅ Архитектурные паттерны                          │
│                                                         │
│  💾 Data Management                                     │
│  ├── ✅ Volumes, Bind Mounts, tmpfs                     │
│  ├── ✅ Персистентность данных                          │
│  ├── ✅ Резервное копирование                           │
│  ├── ✅ Миграция данных                                 │
│  ├── ✅ Производительность I/O                          │
│  └── ✅ Стратегии хранения                              │
│                                                         │
│  🔒 Container Security                                  │
│  ├── ✅ Принципы безопасности контейнеров               │
│  ├── ✅ Управление пользователями                       │
│  ├── ✅ Сканирование уязвимостей                        │
│  ├── ✅ Управление секретами                            │
│  ├── ✅ Мониторинг безопасности                         │
│  └── ✅ Production security checklist                   │
└─────────────────────────────────────────────────────────┘
```

### 🔄 Связь с предыдущими блоками

```
Learning Progression
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Block 1: Fundamentals                                  │
│  ├── Основы контейнеризации                             │
│  ├── Docker архитектура                                 │
│  └── Первые команды                                     │
│                   │                                     │
│                   ▼                                     │
│  Block 2: Images & Containers                           │
│  ├── Dockerfile создание                                │
│  ├── Управление образами                                │
│  └── Жизненный цикл контейнеров                         │
│                   │                                     │
│                   ▼                                     │
│  Block 3: Network & Storage ◄── МЫ ЗДЕСЬ               │
│  ├── Сетевое взаимодействие                             │
│  ├── Управление данными                                 │
│  └── Безопасность                                       │
│                   │                                     │
│                   ▼                                     │
│  Block 4: Compose & Orchestration ◄── СЛЕДУЮЩИЙ        │
│  ├── Multi-container приложения                         │
│  ├── Сервис-ориентированная архитектура                 │
│  └── Введение в оркестрацию                             │
└─────────────────────────────────────────────────────────┘
```

### 🎯 Ключевые навыки, которые вы должны освоить

После завершения этого блока вы должны уметь:

```
Skill Assessment Checklist
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  📋 Networking Skills                                   │
│  ├── □ Создавать пользовательские сети                  │
│  ├── □ Настраивать межконтейнерное взаимодействие       │
│  ├── □ Диагностировать сетевые проблемы                 │
│  ├── □ Планировать сетевую архитектуру                  │
│  └── □ Применять принципы сетевой безопасности          │
│                                                         │
│  💾 Storage Skills                                      │
│  ├── □ Выбирать подходящий тип хранения                 │
│  ├── □ Настраивать персистентные данные                 │
│  ├── □ Создавать системы резервного копирования         │
│  ├── □ Мигрировать данные между контейнерами            │
│  └── □ Оптимизировать производительность I/O            │
│                                                         │
│  🔒 Security Skills                                     │
│  ├── □ Создавать безопасные образы                      │
│  ├── □ Настраивать non-root контейнеры                  │
│  ├── □ Сканировать образы на уязвимости                 │
│  ├── □ Управлять секретами                              │
│  ├── □ Настраивать мониторинг безопасности              │
│  └── □ Применять принцип наименьших привилегий          │
│                                                         │
│  🛠 Troubleshooting Skills                              │
│  ├── □ Диагностировать проблемы с сетью                 │
│  ├── □ Решать проблемы с монтированием данных           │
│  ├── □ Анализировать проблемы безопасности              │
│  ├── □ Использовать инструменты отладки                 │
│  └── □ Читать и интерпретировать логи                   │
└─────────────────────────────────────────────────────────┘
```

### 🚀 Подготовка к блоку 4: Docker Compose

Следующий блок будет посвящен **оркестрации multi-container приложений**. Вот что вас ждет:

```
Preview: Block 4 - Docker Compose & Orchestration
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  🎼 Docker Compose                                      │
│  ├── YAML конфигурация сервисов                         │
│  ├── Управление жизненным циклом приложений             │
│  ├── Сервис-ориентированная архитектура                 │
│  └── Переменные окружения и конфигурация                │
│                                                         │
│  🔧 Advanced Compose                                    │
│  ├── Override файлы и профили                           │
│  ├── Health checks и зависимости                        │
│  ├── Масштабирование сервисов                           │
│  └── Production-ready конфигурации                      │
│                                                         │
│  ⚖️ Container Orchestration                             │
│  ├── Введение в Docker Swarm                            │
│  ├── Основы кластеризации                               │
│  ├── Service discovery                                  │
│  └── Load balancing                                     │
│                                                         │
│  Практические проекты:                                  │
│  ├── Микросервисное приложение                          │
│  ├── Multi-tier веб-приложение                          │
│  ├── Система мониторинга                                │
│  └── High availability кластер                          │
└─────────────────────────────────────────────────────────┘
```

### 💡 Финальные рекомендации

```
Learning Tips for Success
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  🎯 Практикуйтесь постоянно                             │
│  ├── Создавайте реальные проекты                        │
│  ├── Экспериментируйте с различными конфигурациями      │
│  ├── Читайте чужой код и docker-compose файлы           │
│  └── Участвуйте в открытых проектах                     │
│                                                         │
│  📚 Углубляйте знания                                   │
│  ├── Изучайте best practices                            │
│  ├── Читайте документацию Docker                        │
│  ├── Следите за обновлениями экосистемы                 │
│  └── Изучайте смежные технологии (Kubernetes, etc.)     │
│                                                         │
│  🤝 Развивайте сообщество                               │
│  ├── Присоединяйтесь к Docker сообществам               │
│  ├── Делитесь опытом и задавайте вопросы                │
│  ├── Помогайте новичкам                                 │
│  └── Участвуйте в конференциях и митапах                │
│                                                         │
│  🔄 Итеративно улучшайтесь                              │
│  ├── Регулярно пересматривайте старые проекты           │
│  ├── Применяйте новые знания к существующим решениям     │
│  ├── Рефакторьте и оптимизируйте                        │
│  └── Документируйте lessons learned                     │
└─────────────────────────────────────────────────────────┘
```

---

**🎉 Поздравляем с завершением блока 3!**

Вы освоили критически важные аспекты работы с Docker: сетевое взаимодействие, управление данными и безопасность. Эти знания формируют прочную основу для создания production-ready приложений.

**Готовы к следующему вызову? Блок 4 ждет вас! 🚀**