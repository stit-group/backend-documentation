# 🛠 Блок 2: Работа с образами и контейнерами
*Время изучения: 3-4 недели | 8-12 часов в неделю*

---

## 🎯 Цели блока
После изучения этого блока вы будете:
- Мастерски управлять образами Docker
- Создавать собственные образы с помощью Dockerfile
- Применять стратегии оптимизации размера образов
- Использовать multi-stage builds для production-ready образов
- Профессионально управлять жизненным циклом контейнеров
- Настраивать ресурсы, сети и политики перезапуска

---

## 🏗️ Глава 2.1: Управление образами
**Время изучения:** 5-6 дней

### 🔍 Глубокое понимание образов

Образы Docker - это не просто файлы, это сложная система слоев с метаданными:

```
┌─────────────────────────────────────────────────────────────┐
│                    АНАТОМИЯ DOCKER ОБРАЗА                   │
└─────────────────────────────────────────────────────────────┘

СТРУКТУРА ОБРАЗА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📋 МАНИФЕСТ (JSON)                                         │
│  ├─ Конфигурация образа                                     │
│  ├─ Список слоев                                            │
│  ├─ Архитектура (amd64, arm64)                              │
│  └─ Метаданные                                              │
│                                                             │
│  🎯 КОНФИГУРАЦИЯ                                            │
│  ├─ ENV переменные                                          │
│  ├─ WORKDIR                                                 │
│  ├─ EXPOSE порты                                            │
│  ├─ CMD команда                                             │
│  └─ ENTRYPOINT                                              │
│                                                             │
│  🍰 СЛОИ (Layers)                                           │
│  ├─ Layer N: sha256:abc123... (приложение)                 │
│  ├─ Layer 2: sha256:def456... (зависимости)                │
│  └─ Layer 1: sha256:ghi789... (базовая ОС)                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ХРАНЕНИЕ НА ДИСКЕ:
/var/lib/docker/
├── image/
│   └── overlay2/
│       ├── imagedb/         ← Метаданные образов
│       └── layerdb/         ← Информация о слоях
├── overlay2/               ← Файловая система слоев
│   ├── l/                  ← Символьные ссылки
│   └── [layer-id]/         ← Содержимое слоев
└── containers/             ← Данные контейнеров
```

### 🏷️ Стратегии тегирования

Правильное тегирование - основа управления образами в production:

```
┌─────────────────────────────────────────────────────────────┐
│                   СТРАТЕГИИ ТЕГИРОВАНИЯ                     │
└─────────────────────────────────────────────────────────────┘

🎯 СЕМАНТИЧЕСКОЕ ВЕРСИОНИРОВАНИЕ:
┌─────────────────────────────────────────────────────────────┐
│ my-app:1.2.3        ← Точная версия (production)           │
│ my-app:1.2          ← Минорная версия (стабильные обновления)│
│ my-app:1            ← Мажорная версия (автообновления)      │
│ my-app:latest       ← Последняя стабильная (НЕ для prod!)   │
└─────────────────────────────────────────────────────────────┘

🔄 ОКРУЖЕНИЯ И ВЕТКИ:
┌─────────────────────────────────────────────────────────────┐
│ my-app:dev-latest   ← Разработка                            │
│ my-app:staging-v1.2 ← Предпродакшн                          │
│ my-app:prod-v1.2    ← Production                            │
│ my-app:feature-auth ← Функциональная ветка                  │
└─────────────────────────────────────────────────────────────┘

📅 ВРЕМЕННЫЕ МЕТКИ:
┌─────────────────────────────────────────────────────────────┐
│ my-app:2024-01-15   ← Дата сборки                           │
│ my-app:2024-01-15-abc123  ← Дата + commit hash              │
│ my-app:build-1234   ← Номер сборки CI/CD                    │
└─────────────────────────────────────────────────────────────┘

🏗️ ВАРИАНТЫ СБОРКИ:
┌─────────────────────────────────────────────────────────────┐
│ my-app:1.2-alpine   ← Минимальный размер                    │
│ my-app:1.2-ubuntu   ← Полнофункциональный                   │
│ my-app:1.2-debug    ← С отладочными инструментами           │
│ my-app:1.2-slim     ← Без dev-зависимостей                  │
└─────────────────────────────────────────────────────────────┘

❌ АНТИПАТТЕРНЫ:
┌─────────────────────────────────────────────────────────────┐
│ ❌ Использование :latest в production                       │
│ ❌ Перезапись существующих тегов                            │
│ ❌ Слишком общие теги (test, temp)                          │
│ ❌ Отсутствие версионирования                               │
└─────────────────────────────────────────────────────────────┘
```

### 📊 Анализ размера образов

Понимание размера образов критично для оптимизации:

```
┌─────────────────────────────────────────────────────────────┐
│                 АНАЛИЗ РАЗМЕРА ОБРАЗА                       │
└─────────────────────────────────────────────────────────────┘

СРАВНЕНИЕ БАЗОВЫХ ОБРАЗОВ:
┌─────────────────────────────────────────────────────────────┐
│ ubuntu:20.04        ────────────────── 72.8 MB             │
│ debian:11-slim      ─────────── 80.5 MB                    │
│ alpine:3.17         ──── 5.6 MB       ⭐ МИНИМАЛЬНЫЙ       │
│ node:18             ──────────────────────── 993 MB        │
│ node:18-alpine      ────────── 172 MB  ⭐ ОПТИМАЛЬНЫЙ      │
│ python:3.11         ──────────────────────── 920 MB        │
│ python:3.11-slim    ────────── 126 MB                      │
│ python:3.11-alpine  ───────── 54 MB                        │
└─────────────────────────────────────────────────────────────┘

СОСТАВ ТИПИЧНОГО ОБРАЗА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📊 РАСПРЕДЕЛЕНИЕ РАЗМЕРА                                   │
│                                                             │
│  ████████████████████████████████████ 65% Базовая ОС       │
│  ████████████████ 25% Зависимости                          │
│  ████ 8% Исходный код приложения                            │
│  ██ 2% Конфигурация                                         │
│                                                             │
│  💡 ОСНОВНАЯ ОПТИМИЗАЦИЯ: Выбор базового образа            │
└─────────────────────────────────────────────────────────────┘

КОМАНДЫ АНАЛИЗА:
┌─────────────────────────────────────────────────────────────┐
│ # Размер образов                                            │
│ docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"│
│                                                             │
│ # История слоев                                             │
│ docker history my-app:latest                                │
│                                                             │
│ # Детальная информация                                      │
│ docker inspect my-app:latest                                │
│                                                             │
│ # Использование дискового пространства                      │
│ docker system df                                            │
└─────────────────────────────────────────────────────────────┘
```

### 🧹 Очистка и maintenance

Регулярная очистка - важная часть DevOps практик:

```
┌─────────────────────────────────────────────────────────────┐
│                    СТРАТЕГИИ ОЧИСТКИ                        │
└─────────────────────────────────────────────────────────────┘

🎯 ТИПЫ НЕИСПОЛЬЗУЕМЫХ ДАННЫХ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📦 DANGLING IMAGES (висячие образы)                        │
│  ├─ Образы без тегов (<none>)                               │
│  ├─ Промежуточные слои сборки                               │
│  └─ Перезаписанные образы                                   │
│                                                             │
│  🗑️ UNUSED IMAGES (неиспользуемые)                         │
│  ├─ Образы без связанных контейнеров                        │
│  ├─ Старые версии                                           │
│  └─ Тестовые образы                                         │
│                                                             │
│  📁 BUILD CACHE                                             │
│  ├─ Кеш сборки Dockerfile                                   │
│  ├─ Промежуточные контейнеры                                │
│  └─ Скачанные слои                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

КОМАНДЫ ОЧИСТКИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 СЕЛЕКТИВНАЯ ОЧИСТКА:                                    │
│  ├─ docker image prune              ← Только dangling       │
│  ├─ docker image prune -a           ← Все неиспользуемые    │
│  ├─ docker container prune          ← Остановленные        │
│  └─ docker volume prune             ← Неиспользуемые тома   │
│                                                             │
│  💥 ПОЛНАЯ ОЧИСТКА:                                         │
│  ├─ docker system prune             ← Безопасная очистка    │
│  ├─ docker system prune -a          ← Агрессивная очистка   │
│  └─ docker system prune -a --volumes ← Все + тома          │
│                                                             │
│  📊 АНАЛИЗ ПЕРЕД ОЧИСТКОЙ:                                  │
│  ├─ docker system df                ← Использование места   │
│  ├─ docker system df -v             ← Детальная информация  │
│  └─ docker system events            ← События в реальном времени│
│                                                             │
└─────────────────────────────────────────────────────────────┘

АВТОМАТИЗАЦИЯ ОЧИСТКИ:
┌─────────────────────────────────────────────────────────────┐
│ # Cron job для еженедельной очистки                         │
│ 0 2 * * 0 docker system prune -f                           │
│                                                             │
│ # Bash скрипт с логированием                                │
│ #!/bin/bash                                                 │
│ echo "$(date): Starting cleanup"                            │
│ docker system prune -f                                      │
│ docker system df                                            │
│ echo "$(date): Cleanup completed"                           │
└─────────────────────────────────────────────────────────────┘
```

### 🔍 Поиск и фильтрация образов

Эффективный поиск образов экономит время:

```
┌─────────────────────────────────────────────────────────────┐
│                   ПОИСК И ФИЛЬТРАЦИЯ                        │
└─────────────────────────────────────────────────────────────┘

ПОИСК В DOCKER HUB:
┌─────────────────────────────────────────────────────────────┐
│ docker search nginx                                         │
│ docker search --filter stars=100 nginx                     │
│ docker search --filter is-official=true python             │
│ docker search --limit 5 database                           │
└─────────────────────────────────────────────────────────────┘

ФИЛЬТРАЦИЯ ЛОКАЛЬНЫХ ОБРАЗОВ:
┌─────────────────────────────────────────────────────────────┐
│ # По имени репозитория                                      │
│ docker images nginx                                         │
│ docker images "nginx*"                                      │
│                                                             │
│ # По времени создания                                       │
│ docker images --filter "before=nginx:latest"               │
│ docker images --filter "since=ubuntu:20.04"                │
│                                                             │
│ # По размеру (dangling образы)                              │
│ docker images --filter "dangling=true"                     │
│                                                             │
│ # Форматированный вывод                                     │
│ docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedSince}}"│
│                                                             │
│ # JSON формат для скриптов                                  │
│ docker images --format "{{json .}}"                        │
└─────────────────────────────────────────────────────────────┘

ПРАКТИЧЕСКИЕ СЦЕНАРИИ:
┌─────────────────────────────────────────────────────────────┐
│ # Найти все образы старше недели                            │
│ docker images --filter "until=168h" --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedAt}}"│
│                                                             │
│ # Образы больше 1GB                                         │
│ docker images --format "table {{.Repository}}\t{{.Size}}" | grep GB│
│                                                             │
│ # Количество образов по репозиториям                        │
│ docker images --format "{{.Repository}}" | sort | uniq -c  │
└─────────────────────────────────────────────────────────────┘
```

### 💾 Экспорт и импорт образов

Иногда нужно перенести образы без registry:

```
┌─────────────────────────────────────────────────────────────┐
│                 ЭКСПОРТ/ИМПОРТ ОБРАЗОВ                      │
└─────────────────────────────────────────────────────────────┘

SAVE/LOAD - ДЛЯ ОБРАЗОВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  💾 СОХРАНЕНИЕ:                                             │
│  ├─ docker save nginx > nginx.tar                          │
│  ├─ docker save nginx:latest nginx:alpine > multi.tar      │
│  └─ docker save nginx | gzip > nginx.tar.gz                │
│                                                             │
│  📥 ЗАГРУЗКА:                                               │
│  ├─ docker load < nginx.tar                                │
│  ├─ docker load --input nginx.tar                          │
│  └─ gunzip -c nginx.tar.gz | docker load                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

EXPORT/IMPORT - ДЛЯ КОНТЕЙНЕРОВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📤 ЭКСПОРТ КОНТЕЙНЕРА:                                     │
│  ├─ docker export my-container > container.tar             │
│  └─ docker export my-container | gzip > container.tar.gz   │
│                                                             │
│  📥 ИМПОРТ КАК ОБРАЗ:                                       │
│  ├─ docker import container.tar new-image:tag              │
│  └─ cat container.tar | docker import - new-image:tag      │
│                                                             │
│  ⚠️ ВАЖНО: import создает плоский образ без истории        │
│                                                             │
└─────────────────────────────────────────────────────────────┘

СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ:
┌─────────────────────────────────────────────────────────────┐
│ 🎯 КОГДА ИСПОЛЬЗОВАТЬ SAVE/LOAD:                            │
│ ├─ Перенос между окружениями без интернета                  │
│ ├─ Бэкап критических образов                                │
│ ├─ Развертывание в air-gapped средах                        │
│ └─ Создание offline инсталляторов                           │
│                                                             │
│ 🎯 КОГДА ИСПОЛЬЗОВАТЬ EXPORT/IMPORT:                        │
│ ├─ Создание базового образа из настроенного контейнера      │
│ ├─ Уменьшение количества слоев                              │
│ ├─ Очистка истории образа                                   │
│ └─ Миграция legacy приложений                               │
└─────────────────────────────────────────────────────────────┘
```

### 🎯 Практическое задание: Управление образами

**Цель:** Освоить продвинутые техники работы с образами

**Задания:**

1. **Анализ существующих образов:**
   ```bash
   # Найти все образы Node.js
   docker search node --limit 10
   
   # Скачать разные варианты
   docker pull node:18
   docker pull node:18-alpine
   docker pull node:18-slim
   
   # Сравнить размеры
   docker images node
   ```

2. **Создание стратегии тегирования:**
   - Создайте схему тегирования для вашего проекта
   - Примените теги к существующему образу
   - Продемонстрируйте semantic versioning

3. **Эксперимент с очисткой:**
   ```bash
   # Проанализировать использование
   docker system df -v
   
   # Создать тестовые образы
   docker run --name test1 nginx
   docker run --name test2 nginx
   
   # Остановить и удалить
   docker stop test1 test2
   docker rm test1 test2
   
   # Очистить неиспользуемые образы
   docker image prune
   ```

---

## 📝 Глава 2.2: Dockerfile - создание образов
**Время изучения:** 7-8 дней

### 🏗️ Философия Dockerfile

Dockerfile - это декларативный способ описания того, как собрать образ:

```
┌─────────────────────────────────────────────────────────────┐
│                   ФИЛОСОФИЯ DOCKERFILE                      │
└─────────────────────────────────────────────────────────────┘

🎯 ПРИНЦИПЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📜 ДЕКЛАРАТИВНОСТЬ                                         │
│  └─ Описываем ЧТО нужно, а не КАК делать                   │
│                                                             │
│  🔄 ВОСПРОИЗВОДИМОСТЬ                                       │
│  └─ Один Dockerfile = одинаковый образ везде                │
│                                                             │
│  📚 ЧИТАЕМОСТЬ                                              │
│  └─ Dockerfile = документация по сборке                     │
│                                                             │
│  ⚡ ЭФФЕКТИВНОСТЬ                                           │
│  └─ Оптимизация слоев и кеширования                         │
│                                                             │
│  🔐 БЕЗОПАСНОСТЬ                                            │
│  └─ Минимальные права, проверенные источники                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ЖИЗНЕННЫЙ ЦИКЛ СБОРКИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📝 Dockerfile  ──docker build──► 📦 Image ──docker run──► 🏃 Container│
│       │                              │                       │
│       │                              │                       │
│   ┌───▼────┐                    ┌────▼────┐             ┌────▼────┐
│   │Context │                    │ Layers  │             │Runtime  │
│   │ (.)    │                    │Metadata │             │ State   │
│   │Files   │                    │Config   │             │         │
│   └────────┘                    └─────────┘             └─────────┘
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 📋 Основные инструкции Dockerfile

Каждая инструкция создает новый слой образа:

```
┌─────────────────────────────────────────────────────────────┐
│                   ОСНОВНЫЕ ИНСТРУКЦИИ                       │
└─────────────────────────────────────────────────────────────┘

🏗️ СТРУКТУРНЫЕ ИНСТРУКЦИИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  FROM ubuntu:20.04                                          │
│  ├─ Базовый образ (всегда первая инструкция)                │
│  ├─ Можно использовать несколько FROM (multi-stage)         │
│  └─ FROM scratch - пустой образ                             │
│                                                             │
│  WORKDIR /app                                               │
│  ├─ Рабочая директория для последующих команд               │
│  ├─ Создается автоматически если не существует              │
│  └─ Лучше абсолютных путей в RUN, COPY, ADD                 │
│                                                             │
│  USER appuser                                               │
│  ├─ Пользователь для выполнения команд                      │
│  ├─ По умолчанию root (небезопасно!)                        │
│  └─ Можно указать UID:GID                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🔧 ИНСТРУКЦИИ ВЫПОЛНЕНИЯ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  RUN apt-get update && apt-get install -y python3          │
│  ├─ Выполняется во время сборки образа                      │
│  ├─ Каждый RUN = новый слой                                 │
│  ├─ Форма shell: RUN command                                │
│  └─ Форма exec: RUN ["executable", "param1", "param2"]     │
│                                                             │
│  COPY . /app                                                │
│  ├─ Копирует файлы из build context                         │
│  ├─ Простое копирование без дополнительных функций          │
│  └─ Рекомендуется вместо ADD                                │
│                                                             │
│  ADD https://example.com/file.tar.gz /app/                  │
│  ├─ Копирует + автораспаковка архивов                       │
│  ├─ Может скачивать URL                                     │
│  └─ Использовать осторожно (неожиданное поведение)          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

⚙️ ИНСТРУКЦИИ КОНФИГУРАЦИИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ENV NODE_ENV=production                                    │
│  ├─ Переменные окружения                                    │
│  ├─ Доступны во время сборки и выполнения                   │
│  └─ ENV KEY=value или ENV KEY value                         │
│                                                             │
│  EXPOSE 3000                                                │
│  ├─ Документирует открытые порты                            │
│  ├─ Не открывает порты автоматически                        │
│  └─ Используется docker run -P                              │
│                                                             │
│  VOLUME ["/data"]                                           │
│  ├─ Создает точку монтирования                              │
│  ├─ Данные сохраняются между контейнерами                   │
│  └─ Лучше указывать при запуске контейнера                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🚀 ИНСТРУКЦИИ ЗАПУСКА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  CMD ["npm", "start"]                                       │
│  ├─ Команда по умолчанию при запуске контейнера             │
│  ├─ Переопределяется аргументами docker run                 │
│  ├─ Только одна CMD в Dockerfile                            │
│  └─ Формы: exec, shell, как параметры ENTRYPOINT           │
│                                                             │
│  ENTRYPOINT ["./entrypoint.sh"]                             │
│  ├─ Точка входа, выполняется всегда                         │
│  ├─ Аргументы docker run добавляются к ENTRYPOINT          │
│  ├─ Используется для инициализации                          │
│  └─ Комбинируется с CMD                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🎯 CMD vs ENTRYPOINT - детальное понимание

Различие между CMD и ENTRYPOINT часто вызывает путаницу:

```
┌─────────────────────────────────────────────────────────────┐
│                    CMD vs ENTRYPOINT                        │
└─────────────────────────────────────────────────────────────┘

ТОЛЬКО CMD:
┌─────────────────────────────────────────────────────────────┐
│ Dockerfile: CMD ["echo", "hello"]                           │
│                                                             │
│ docker run myapp                    → echo hello            │
│ docker run myapp echo goodbye       → echo goodbye          │
│ docker run myapp ls                 → ls                    │
│                                                             │
│ ✅ CMD полностью заменяется аргументами                     │
└─────────────────────────────────────────────────────────────┘

ТОЛЬКО ENTRYPOINT:
┌─────────────────────────────────────────────────────────────┐
│ Dockerfile: ENTRYPOINT ["echo"]                             │
│                                                             │
│ docker run myapp                    → echo                  │
│ docker run myapp hello              → echo hello            │
│ docker run myapp hello world        → echo hello world     │
│                                                             │
│ ✅ Аргументы добавляются к ENTRYPOINT                       │
└─────────────────────────────────────────────────────────────┘

ENTRYPOINT + CMD:
┌─────────────────────────────────────────────────────────────┐
│ Dockerfile:                                                 │
│ ENTRYPOINT ["echo"]                                         │
│ CMD ["hello"]                                               │
│                                                             │
│ docker run myapp                    → echo hello            │
│ docker run myapp goodbye            → echo goodbye          │
│ docker run myapp hello world        → echo hello world     │
│                                                             │
│ ✅ CMD = аргументы по умолчанию для ENTRYPOINT             │
└─────────────────────────────────────────────────────────────┘

ПРАКТИЧЕСКИЕ ПАТТЕРНЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ 🎯 ПРОСТОЕ ПРИЛОЖЕНИЕ:                                      │
│ CMD ["python", "app.py"]                                    │
│                                                             │
│ 🎯 CLI ИНСТРУМЕНТ:                                          │
│ ENTRYPOINT ["./my-tool"]                                    │
│ CMD ["--help"]                                              │
│                                                             │
│ 🎯 ВЕБИ СЕРВЕР:                                             │
│ ENTRYPOINT ["./entrypoint.sh"]                              │
│ CMD ["start-server"]                                        │
│                                                             │
│ 🎯 БАЗА ДАННЫХ:                                             │
│ ENTRYPOINT ["docker-entrypoint.sh"]                         │
│ CMD ["mysqld"]                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 📚 Лучшие практики Dockerfile

Следование best practices критично для production:

```
┌─────────────────────────────────────────────────────────────┐
│                   ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────┘

🎯 ОПТИМИЗАЦИЯ СЛОЕВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ ❌ ПЛОХО:                                                   │
│ RUN apt-get update                                          │
│ RUN apt-get install -y python3                             │
│ RUN apt-get install -y pip                                 │
│ RUN apt-get clean                                           │
│ # = 4 слоя                                                  │
│                                                             │
│ ✅ ХОРОШО:                                                  │
│ RUN apt-get update && \                                     │
│     apt-get install -y python3 pip && \                    │
│     apt-get clean && \                                      │
│     rm -rf /var/lib/apt/lists/*                             │
│ # = 1 слой                                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🎯 ПОРЯДОК СЛОЕВ (для кеширования):
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ ✅ ОТ НАИМЕНЕЕ ИЗМЕНЯЕМОГО К НАИБОЛЕЕ:                      │
│                                                             │
│ FROM node:16-alpine          ← Базовый образ (стабильный)   │
│ WORKDIR /app                 ← Структура (редко меняется)   │
│ COPY package*.json ./        ← Зависимости (иногда)         │
│ RUN npm ci --only=production ← Установка зависимостей       │
│ COPY . .                     ← Исходный код (часто)         │
│ CMD ["npm", "start"]         ← Команда запуска              │
│                                                             │
│ 💡 Изменение исходного кода не пересобирает зависимости!   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🎯 БЕЗОПАСНОСТЬ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ ✅ СОЗДАНИЕ ПОЛЬЗОВАТЕЛЯ:                                   │
│ RUN groupadd -r appgroup && \                               │
│     useradd -r -g appgroup appuser                          │
│ USER appuser                                                │
│                                                             │
│ ✅ МИНИМАЛЬНЫЕ ПРИВИЛЕГИИ:                                  │
│ RUN chmod +x /app/start.sh                                  │
│ USER 1001:1001                                              │
│                                                             │
│ ✅ ПРОВЕРКА ПОДПИСЕЙ:                                       │
│ ADD https://example.com/app.tar.gz.sig /tmp/               │
│ RUN gpg --verify /tmp/app.tar.gz.sig                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🎯 РАЗМЕР ОБРАЗА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ ✅ ОЧИСТКА КЕШЕЙ:                                           │
│ RUN apt-get update && \                                     │
│     apt-get install -y package && \                        │
│     apt-get clean && \                                      │
│     rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*          │
│                                                             │
│ ✅ ИСПОЛЬЗОВАНИЕ .dockerignore:                             │
│ # .dockerignore                                             │
│ node_modules                                                │
│ .git                                                        │
│ *.log                                                       │
│ coverage/                                                   │
│                                                             │
│ ✅ ALPINE ВАРИАНТЫ:                                         │
│ FROM node:16-alpine  # вместо node:16                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🏗️ Multi-stage builds - революция в оптимизации

Multi-stage builds позволяют создавать минимальные production образы:

```
┌─────────────────────────────────────────────────────────────┐
│                   MULTI-STAGE BUILDS                        │
└─────────────────────────────────────────────────────────────┘

ПРОБЛЕМА БЕЗ MULTI-STAGE:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📦 PRODUCTION ОБРАЗ СОДЕРЖИТ:                              │
│  ├─ ✅ Скомпилированное приложение (10MB)                   │
│  ├─ ❌ Компилятор (200MB)                                   │
│  ├─ ❌ Dev зависимости (150MB)                              │
│  ├─ ❌ Исходный код (50MB)                                  │
│  ├─ ❌ Тестовые файлы (30MB)                                │
│  └─ ❌ Build инструменты (100MB)                            │
│                                                             │
│  📊 ИТОГО: 540MB (вместо 10MB!)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

РЕШЕНИЕ С MULTI-STAGE:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🏗️ STAGE 1: BUILD                                         │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ FROM node:16 AS builder                             │    │
│  │ WORKDIR /app                                        │    │
│  │ COPY package*.json ./                               │    │
│  │ RUN npm install                                     │    │
│  │ COPY . .                                            │    │
│  │ RUN npm run build                                   │    │
│  └─────────────────────────────────────────────────────┘    │
│                          │                                  │
│                          ▼ Копируем только результат        │
│  🚀 STAGE 2: PRODUCTION                                     │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ FROM nginx:alpine                                   │    │
│  │ COPY --from=builder /app/dist /usr/share/nginx/html │    │
│  │ EXPOSE 80                                           │    │
│  │ CMD ["nginx", "-g", "daemon off;"]                  │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  📊 ИТОГО: 15MB (nginx + app)                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПРИМЕРЫ ДЛЯ РАЗНЫХ ЯЗЫКОВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ 🐹 GO APPLICATION:                                          │
│ # Build stage                                               │
│ FROM golang:1.19-alpine AS builder                         │
│ WORKDIR /app                                                │
│ COPY go.mod go.sum ./                                       │
│ RUN go mod download                                         │
│ COPY . .                                                    │
│ RUN go build -o main .                                      │
│                                                             │
│ # Production stage                                          │
│ FROM alpine:latest                                          │
│ RUN apk --no-cache add ca-certificates                      │
│ WORKDIR /root/                                              │
│ COPY --from=builder /app/main .                             │
│ CMD ["./main"]                                              │
│                                                             │
│ 📊 Результат: 10MB вместо 300MB+                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ ☕ JAVA APPLICATION:                                        │
│ # Build stage                                               │
│ FROM maven:3.8-openjdk-17 AS builder                       │
│ WORKDIR /app                                                │
│ COPY pom.xml .                                              │
│ RUN mvn dependency:go-offline                               │
│ COPY src ./src                                              │
│ RUN mvn package -DskipTests                                 │
│                                                             │
│ # Production stage                                          │
│ FROM openjdk:17-jre-slim                                    │
│ COPY --from=builder /app/target/app.jar app.jar            │
│ EXPOSE 8080                                                 │
│ CMD ["java", "-jar", "app.jar"]                             │
│                                                             │
│ 📊 Результат: 200MB вместо 800MB+                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🎯 Практическое задание: Создание Dockerfile

**Цель:** Создать оптимизированный Dockerfile с multi-stage build

**Задание 1: Простой Node.js Dockerfile**
```dockerfile
# Создайте Dockerfile для Express приложения
# Требования:
# - Использовать официальный Node.js образ
# - Копировать только необходимые файлы
# - Установить только production зависимости
# - Запускать под non-root пользователем
# - Оптимизировать для кеширования слоев
```

**Задание 2: Multi-stage build**
```dockerfile
# Создайте multi-stage Dockerfile для:
# 1. Сборки React приложения
# 2. Развертывания через nginx
# Цель: минимальный размер финального образа
```

**Задание 3: Сравнение оптимизаций**
```bash
# Соберите три версии образа:
# 1. Неоптимизированный
# 2. С базовыми оптимизациями
# 3. С multi-stage build
# 
# Сравните размеры и время сборки
```

---

## 🎮 Глава 2.3: Управление контейнерами
**Время изучения:** 6-7 дней

### 🔄 Глубокое понимание жизненного цикла

Контейнер проходит через различные состояния с момента создания до удаления:

```
┌─────────────────────────────────────────────────────────────┐
│                ДЕТАЛЬНЫЙ ЖИЗНЕННЫЙ ЦИКЛ                     │
└─────────────────────────────────────────────────────────────┘

ПОЛНАЯ ДИАГРАММА СОСТОЯНИЙ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│     📦 IMAGE                                                │
│        │                                                    │
│        │ docker create                                      │
│        ▼                                                    │
│     🔨 CREATED ──docker start──► 🏃 RUNNING                 │
│        │                           │    │                   │
│        │                           │    │ docker pause      │
│        │ docker run                │    ▼                   │
│        │ (create+start)            │  ⏸️ PAUSED             │
│        │                           │    │                   │
│        │                           │    │ docker unpause    │
│        │                           │    ▼                   │
│        └──────────────────────────► │  🏃 RUNNING           │
│                                     │    │                   │
│                                     │    │ docker stop       │
│                                     │    │ docker kill       │
│                                     │    │ процесс завершился │
│                                     │    ▼                   │
│                                     │  ⏹️ STOPPED (EXITED)   │
│                                     │    │                   │
│                                     │    │ docker start      │
│                                     │    │                   │
│                                     │    ├──────────────────►│
│                                     │    │                   │
│                                     │    │ docker rm         │
│                                     │    ▼                   │
│                                     │  🗑️ DELETED           │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ДЕТАЛИ ПЕРЕХОДОВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ CREATED → RUNNING:                                          │
│ ├─ Создается namespace (PID, Network, Mount)                │
│ ├─ Настраивается cgroup для ограничения ресурсов           │
│ ├─ Монтируются volumes                                      │
│ ├─ Настраивается сеть                                       │
│ └─ Запускается процесс ENTRYPOINT/CMD                       │
│                                                             │
│ RUNNING → STOPPED:                                          │
│ ├─ SIGTERM отправляется главному процессу                   │
│ ├─ Ожидание graceful shutdown (grace period)               │
│ ├─ SIGKILL если процесс не завершился                       │
│ └─ Освобождение ресурсов                                    │
│                                                             │
│ STOPPED → DELETED:                                          │
│ ├─ Удаление writable layer контейнера                       │
│ ├─ Отмонтирование volumes (если не named)                   │
│ ├─ Очистка network endpoints                                │
│ └─ Удаление metadata                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🌐 Порты и сетевые настройки

Сетевая настройка контейнеров - ключевой аспект их использования:

```
┌─────────────────────────────────────────────────────────────┐
│                   СЕТЕВЫЕ НАСТРОЙКИ                        │
└─────────────────────────────────────────────────────────────┘

ПРОБРОС ПОРТОВ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🔌 ОСНОВНЫЕ ВАРИАНТЫ:                                      │
│  ├─ -p 8080:80          ← Конкретный порт хоста             │
│  ├─ -p 127.0.0.1:8080:80 ← Только localhost                │
│  ├─ -p 8080-8085:80-85  ← Диапазон портов                   │
│  ├─ -p 80               ← Случайный порт хоста              │
│  └─ -P                  ← Все EXPOSE порты                  │
│                                                             │
│  🎯 ПРАКТИЧЕСКИЕ ПРИМЕРЫ:                                   │
│  ├─ docker run -p 3000:3000 my-app    ← Веб-приложение     │
│  ├─ docker run -p 5432:5432 postgres  ← База данных        │
│  ├─ docker run -p 80:8080 nginx       ← Обратный прокси    │
│  └─ docker run -P my-app              ← Автоматически       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ВИЗУАЛИЗАЦИЯ ПРОБРОСА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🖥️ ХОСТ                           🐳 КОНТЕЙНЕР             │
│  ┌─────────────────┐               ┌─────────────────┐       │
│  │                 │               │                 │       │
│  │  Port 8080 ────────────────────► Port 80          │       │
│  │  (доступен      │               │ (nginx)         │       │
│  │   извне)        │               │                 │       │
│  │                 │               │                 │       │
│  │  Port 5432 ────────────────────► Port 5432        │       │
│  │  (только        │               │ (postgres)      │       │
│  │   localhost)    │               │                 │       │
│  │                 │               │                 │       │
│  └─────────────────┘               └─────────────────┘       │
│                                                             │
│  🌐 Клиент:                                                 │
│  curl http://localhost:8080  ──► nginx внутри контейнера   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

СЕТЕВЫЕ РЕЖИМЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🌉 --network bridge (по умолчанию)                         │
│  ├─ Собственная сеть контейнера                             │
│  ├─ NAT для доступа в интернет                              │
│  └─ Port mapping для входящих соединений                    │
│                                                             │
│  🏠 --network host                                          │
│  ├─ Использует сеть хоста напрямую                          │
│  ├─ Максимальная производительность                         │
│  └─ Нет изоляции (небезопасно)                              │
│                                                             │
│  🚫 --network none                                          │
│  ├─ Без сетевого доступа                                    │
│  ├─ Только loopback интерфейс                               │
│  └─ Максимальная изоляция                                   │
│                                                             │
│  🔗 --network custom-network                                │
│  ├─ Пользовательская сеть                                   │
│  ├─ DNS резолюция по именам контейнеров                     │
│  └─ Лучший контроль и безопасность                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🔧 Переменные окружения

Переменные окружения - основной способ конфигурации контейнеров:

```
┌─────────────────────────────────────────────────────────────┐
│                 ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ                        │
└─────────────────────────────────────────────────────────────┘

СПОСОБЫ ПЕРЕДАЧИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🔧 КОМАНДНАЯ СТРОКА:                                       │
│  ├─ docker run -e NODE_ENV=production my-app               │
│  ├─ docker run -e PORT=3000 -e DEBUG=true my-app           │
│  └─ docker run -e "API_KEY=secret-key-123" my-app          │
│                                                             │
│  📄 ФАЙЛ ПЕРЕМЕННЫХ:                                        │
│  ├─ docker run --env-file .env my-app                      │
│  ├─ docker run --env-file production.env my-app            │
│  └─ Формат файла: KEY=value (по строке)                    │
│                                                             │
│  🐳 DOCKERFILE:                                             │
│  ├─ ENV NODE_ENV=production                                 │
│  ├─ ENV PORT=3000                                           │
│  └─ Встроены в образ (значения по умолчанию)               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПРИОРИТЕТ ПЕРЕМЕННЫХ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  1️⃣ docker run -e KEY=value        ← Высший приоритет      │
│  2️⃣ docker run --env-file file     ← Средний приоритет     │
│  3️⃣ ENV KEY=value в Dockerfile     ← Низший приоритет      │
│                                                             │
│  💡 Переменные из -e перезаписывают все остальные          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПАТТЕРНЫ ИСПОЛЬЗОВАНИЯ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🗄️ КОНФИГУРАЦИЯ БАЗ ДАННЫХ:                               │
│  ├─ POSTGRES_DB=myapp                                       │
│  ├─ POSTGRES_USER=admin                                     │
│  ├─ POSTGRES_PASSWORD=secret                                │
│  └─ DATABASE_URL=postgresql://admin:secret@db:5432/myapp    │
│                                                             │
│  🌐 ВЕБ-ПРИЛОЖЕНИЯ:                                         │
│  ├─ NODE_ENV=production                                     │
│  ├─ PORT=3000                                               │
│  ├─ API_BASE_URL=https://api.example.com                    │
│  └─ LOG_LEVEL=info                                          │
│                                                             │
│  🔐 СЕКРЕТЫ:                                                │
│  ├─ API_KEY_FILE=/run/secrets/api_key                       │
│  ├─ JWT_SECRET_FILE=/run/secrets/jwt                        │
│  └─ Лучше использовать файлы вместо переменных             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПРИМЕР .env ФАЙЛА:
┌─────────────────────────────────────────────────────────────┐
│ # .env                                                      │
│ NODE_ENV=production                                         │
│ PORT=3000                                                   │
│ DATABASE_URL=postgresql://user:pass@localhost:5432/db      │
│ REDIS_URL=redis://localhost:6379                           │
│ LOG_LEVEL=info                                              │
│ # Комментарии поддерживаются                               │
│ API_TIMEOUT=30000                                           │
└─────────────────────────────────────────────────────────────┘
```

### ⚙️ Ограничения ресурсов

Управление ресурсами предотвращает проблемы производительности:

```
┌─────────────────────────────────────────────────────────────┐
│                  ОГРАНИЧЕНИЯ РЕСУРСОВ                      │
└─────────────────────────────────────────────────────────────┘

💾 ПАМЯТЬ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 ОСНОВНЫЕ ПАРАМЕТРЫ:                                     │
│  ├─ --memory="512m"           ← Максимум памяти             │
│  ├─ --memory-swap="1g"        ← Память + swap               │
│  ├─ --memory-reservation="256m" ← Мягкий лимит              │
│  └─ --oom-kill-disable        ← Отключить OOM killer        │
│                                                             │
│  📊 ЕДИНИЦЫ ИЗМЕРЕНИЯ:                                      │
│  ├─ b, k, m, g - байты, килобайты, мегабайты, гигабайты    │
│  ├─ 512m = 512 мегабайт                                     │
│  ├─ 1g = 1 гигабайт                                         │
│  └─ 2048m = 2g                                              │
│                                                             │
│  ⚠️ ПОВЕДЕНИЕ ПРИ ПРЕВЫШЕНИИ:                               │
│  ├─ Контейнер убивается OOM killer                          │
│  ├─ Exit code 137 (SIGKILL)                                │
│  └─ Автоматический рестарт (если настроен)                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🔥 CPU:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 СПОСОБЫ ОГРАНИЧЕНИЯ:                                    │
│  ├─ --cpus="1.5"             ← Количество CPU ядер         │
│  ├─ --cpu-shares=512         ← Относительный вес (legacy)   │
│  ├─ --cpuset-cpus="0,1"      ← Конкретные ядра              │
│  └─ --cpu-quota=50000        ← Микросекунды в период        │
│                                                             │
│  📈 ПРИМЕРЫ:                                                │
│  ├─ --cpus="0.5"    ← 50% одного ядра                      │
│  ├─ --cpus="2"      ← 2 полных ядра                        │
│  ├─ --cpus="1.5"    ← 1.5 ядра                             │
│  └─ --cpuset-cpus="0-2" ← Ядра 0, 1, 2                     │
│                                                             │
│  ⚠️ ПОВЕДЕНИЕ ПРИ ПРЕВЫШЕНИИ:                               │
│  ├─ Throttling (замедление)                                 │
│  ├─ Контейнер не убивается                                  │
│  └─ Производительность снижается                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

💽 ДИСК I/O:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 ОГРАНИЧЕНИЯ:                                            │
│  ├─ --device-read-bps=/dev/sda:1mb  ← Чтение               │
│  ├─ --device-write-bps=/dev/sda:1mb ← Запись               │
│  ├─ --device-read-iops=/dev/sda:1000 ← IOPS чтения         │
│  └─ --device-write-iops=/dev/sda:1000 ← IOPS записи        │
│                                                             │
│  📊 МОНИТОРИНГ:                                             │
│  ├─ docker stats                     ← Реальное время      │
│  ├─ docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"│
│  └─ docker exec container iostat -x 1 ← Детали I/O         │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПРАКТИЧЕСКИЕ ПРИМЕРЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│ 🗄️ БАЗА ДАННЫХ:                                            │
│ docker run -d \                                             │
│   --memory="2g" \                                           │
│   --cpus="1.5" \                                            │
│   --name postgres \                                         │
│   postgres:13                                               │
│                                                             │
│ 🌐 ВЕБ-СЕРВЕР:                                              │
│ docker run -d \                                             │
│   --memory="512m" \                                         │
│   --memory-reservation="256m" \                             │
│   --cpus="0.5" \                                            │
│   --name nginx \                                            │
│   nginx:alpine                                              │
│                                                             │
│ 🔍 МИКРОСЕРВИС:                                             │
│ docker run -d \                                             │
│   --memory="256m" \                                         │
│   --cpus="0.25" \                                           │
│   --name api \                                              │
│   my-api:latest                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🔄 Политики перезапуска

Restart policies обеспечивают отказоустойчивость:

```
┌─────────────────────────────────────────────────────────────┐
│                  ПОЛИТИКИ ПЕРЕЗАПУСКА                       │
└─────────────────────────────────────────────────────────────┘

ТИПЫ ПОЛИТИК:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🚫 no (по умолчанию)                                       │
│  ├─ Никогда не перезапускать                                │
│  ├─ Подходит для одноразовых задач                          │
│  └─ docker run --restart=no my-app                          │
│                                                             │
│  🔄 always                                                  │
│  ├─ Всегда перезапускать при остановке                      │
│  ├─ Даже после перезагрузки Docker daemon                   │
│  ├─ Подходит для критических сервисов                       │
│  └─ docker run --restart=always nginx                       │
│                                                             │
│  ❌ on-failure[:max-retries]                                │
│  ├─ Только при ошибке (exit code != 0)                     │
│  ├─ Можно ограничить количество попыток                     │
│  ├─ docker run --restart=on-failure:5 my-app               │
│  └─ Подходит для нестабильных приложений                    │
│                                                             │
│  ⏹️ unless-stopped                                          │
│  ├─ Всегда, кроме ручной остановки                          │
│  ├─ Не запускается после перезагрузки если был остановлен   │
│  ├─ Рекомендуется для production                            │
│  └─ docker run --restart=unless-stopped my-app             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ЛОГИКА РАБОТЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📊 МАТРИЦА ПОВЕДЕНИЯ:                                      │
│                                                             │
│  Событие              │ no │always│on-failure│unless-stopped│
│  ─────────────────────┼────┼──────┼──────────┼──────────────│
│  Exit code 0          │ ❌  │  ✅   │    ❌     │      ✅       │
│  Exit code != 0       │ ❌  │  ✅   │    ✅     │      ✅       │
│  docker stop          │ ❌  │  ✅   │    ❌     │      ❌       │
│  docker kill          │ ❌  │  ✅   │    ❌     │      ❌       │
│  daemon restart       │ ❌  │  ✅   │    ❌     │      ❌*      │
│                                                             │
│  *unless-stopped: запустится если не был остановлен вручную │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ПРАКТИЧЕСКИЕ СЦЕНАРИИ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🌐 ВЕБ-СЕРВЕР (критический):                               │
│  docker run -d --restart=always \                          │
│    --name web nginx                                         │
│  # Всегда работает, даже после перезагрузки сервера        │
│                                                             │
│  🗄️ БАЗА ДАННЫХ (production):                              │
│  docker run -d --restart=unless-stopped \                  │
│    --name db postgres                                       │
│  # Работает пока не остановлена вручную                    │
│                                                             │
│  🔧 BATCH ЗАДАЧА (нестабильная):                            │
│  docker run -d --restart=on-failure:3 \                    │
│    --name worker my-worker                                  │
│  # Максимум 3 попытки при ошибках                          │
│                                                             │
│  🧪 ТЕСТИРОВАНИЕ (одноразовое):                             │
│  docker run --restart=no \                                 │
│    --name tests my-tests                                    │
│  # Запустить один раз и завершить                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

МОНИТОРИНГ ПЕРЕЗАПУСКОВ:
┌─────────────────────────────────────────────────────────────┐
│ # Количество перезапусков                                   │
│ docker ps -a --format "table {{.Names}}\t{{.Status}}"      │
│                                                             │
│ # Детальная информация                                      │
│ docker inspect my-container | grep RestartCount            │
│                                                             │
│ # Логи с таймстампами                                       │
│ docker logs -t --since="1h" my-container                   │
└─────────────────────────────────────────────────────────────┘

### 📊 Мониторинг контейнеров

Эффективный мониторинг - основа stable production:

```
┌─────────────────────────────────────────────────────────────┐
│                    МОНИТОРИНГ КОНТЕЙНЕРОВ                   │
└─────────────────────────────────────────────────────────────┘

БАЗОВЫЕ КОМАНДЫ МОНИТОРИНГА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📊 docker stats                                            │
│  ├─ Использование ресурсов в реальном времени               │
│  ├─ CPU, память, сеть, диск I/O                            │
│  ├─ docker stats --no-stream  ← Одноразовый снимок         │
│  └─ docker stats container1 container2  ← Конкретные       │
│                                                             │
│  📋 docker ps                                               │
│  ├─ Список запущенных контейнеров                           │
│  ├─ docker ps -a  ← Все контейнеры (включая остановленные) │
│  ├─ docker ps --filter status=running                      │
│  └─ docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"│
│                                                             │
│  📜 docker logs                                             │
│  ├─ Логи контейнера                                         │
│  ├─ docker logs -f container  ← Следить в реальном времени │
│  ├─ docker logs --since="2h" container  ← За последние 2ч  │
│  ├─ docker logs --tail=100 container  ← Последние 100 строк│
│  └─ docker logs -t container  ← С таймстампами              │
│                                                             │
│  🔍 docker inspect                                          │
│  ├─ Полная информация о контейнере                          │
│  ├─ JSON формат с метаданными                               │
│  ├─ docker inspect container | jq '.State'                 │
│  └─ docker inspect --format='{{.State.Status}}' container  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

РАСШИРЕННЫЙ МОНИТОРИНГ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🏃 ПРОЦЕССЫ ВНУТРИ КОНТЕЙНЕРА:                             │
│  ├─ docker exec container ps aux                           │
│  ├─ docker exec container htop                             │
│  └─ docker exec container netstat -tulpn                   │
│                                                             │
│  📊 РЕСУРСЫ ХОСТОВОЙ СИСТЕМЫ:                               │
│  ├─ docker system df  ← Использование диска                │
│  ├─ docker system events  ← События в реальном времени     │
│  └─ docker system info  ← Информация о Docker              │
│                                                             │
│  🔧 HEALTH CHECKS:                                          │
│  ├─ docker container ls --filter health=unhealthy          │
│  ├─ docker inspect --format='{{.State.Health.Status}}' container│
│  └─ docker logs container | grep health                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘

ВИЗУАЛИЗАЦИЯ DOCKER STATS:
┌─────────────────────────────────────────────────────────────┐
│ CONTAINER ID   NAME      CPU %   MEM USAGE / LIMIT     MEM %│
│ abc123def456   web       2.50%   256.3MiB / 512.0MiB   50.1%│
│ def456ghi789   db        15.32%  1.2GiB / 2.0GiB       60.0%│
│ ghi789jkl012   cache     0.25%   64.5MiB / 128.0MiB    50.4%│
│                                                             │
│ NET I/O        BLOCK I/O   PIDS                             │
│ 1.2MB / 3.4MB  45MB / 12MB  25                              │
│ 15MB / 8.3MB   120MB / 89MB 150                             │
│ 156kB / 89kB   2.3MB / 1.1MB 5                              │
│                                                             │
│ 💡 ИНТЕРПРЕТАЦИЯ:                                           │
│ ├─ CPU % - процент использования CPU                        │
│ ├─ MEM USAGE/LIMIT - текущая/максимальная память            │
│ ├─ NET I/O - входящий/исходящий трафик                      │
│ ├─ BLOCK I/O - чтение/запись на диск                        │
│ └─ PIDS - количество процессов                              │
└─────────────────────────────────────────────────────────────┘

АВТОМАТИЗАЦИЯ МОНИТОРИНГА:
┌─────────────────────────────────────────────────────────────┐
│ #!/bin/bash                                                 │
│ # Скрипт мониторинга                                        │
│                                                             │
│ while true; do                                              │
│   echo "=== $(date) ==="                                   │
│   docker stats --no-stream --format \                      │
│     "table {{.Container}}\t{{.CPUPerc}}\t{{.MemPerc}}"     │
│   echo                                                      │
│   sleep 60                                                  │
│ done                                                        │
│                                                             │
│ # Алерты при высокой нагрузке                               │
│ HIGH_CPU=$(docker stats --no-stream --format "{{.CPUPerc}}" | \│
│           sed 's/%//' | awk '$1 > 80 {print $1}')          │
│ if [ ! -z "$HIGH_CPU" ]; then                              │
│   echo "ALERT: High CPU usage: $HIGH_CPU%" | \             │
│   mail -s "Docker Alert" admin@example.com                 │
│ fi                                                          │
└─────────────────────────────────────────────────────────────┘
```

### 💡 Продвинутые техники управления

Эти техники помогают в сложных сценариях:

```
┌─────────────────────────────────────────────────────────────┐
│                 ПРОДВИНУТЫЕ ТЕХНИКИ                         │
└─────────────────────────────────────────────────────────────┘

🔧 ЗАПУСК МНОЖЕСТВЕННЫХ КОМАНД:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 ПРОБЛЕМА:                                               │
│  Нужно запустить несколько процессов в одном контейнере     │
│                                                             │
│  ❌ НЕПРАВИЛЬНО:                                            │
│  CMD service nginx start && service php-fpm start          │
│  # Второй процесс не запустится если первый завершится     │
│                                                             │
│  ✅ ПРАВИЛЬНО - SUPERVISOR:                                 │
│  # Dockerfile                                               │
│  RUN apt-get install -y supervisor                         │
│  COPY supervisord.conf /etc/supervisor/conf.d/             │
│  CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/supervisord.conf"]│
│                                                             │
│  ✅ ПРАВИЛЬНО - ENTRYPOINT SCRIPT:                          │
│  # entrypoint.sh                                            │
│  #!/bin/bash                                                │
│  service nginx start                                        │
│  service php-fpm start                                      │
│  tail -f /var/log/nginx/access.log                         │
│                                                             │
│  ✅ ЛУЧШЕ ВСЕГО - ОТДЕЛЬНЫЕ КОНТЕЙНЕРЫ:                     │
│  # docker-compose.yml                                       │
│  services:                                                  │
│    nginx: ...                                               │
│    php-fpm: ...                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🎭 ВРЕМЕННЫЕ И ОТЛАДОЧНЫЕ КОНТЕЙНЕРЫ:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🔍 ОТЛАДКА РАБОТАЮЩЕГО КОНТЕЙНЕРА:                         │
│  ├─ docker exec -it container bash                         │
│  ├─ docker exec -it container sh  # если нет bash          │
│  ├─ docker exec container ps aux                           │
│  └─ docker exec container cat /etc/hosts                   │
│                                                             │
│  🗑️ ВРЕМЕННЫЕ КОНТЕЙНЕРЫ:                                  │
│  ├─ docker run --rm alpine echo "test"                     │
│  ├─ docker run --rm -it ubuntu bash                        │
│  ├─ docker run --rm -v $(pwd):/data alpine ls /data        │
│  └─ --rm автоматически удаляет контейнер после завершения  │
│                                                             │
│  🔧 SIDECARS ДЛЯ ОТЛАДКИ:                                   │
│  # Контейнер с инструментами в той же сети                 │
│  docker run -it --rm --network container:my-app \          │
│    --name debug nicolaka/netshoot                          │
│                                                             │
│  🎯 КОПИРОВАНИЕ ФАЙЛОВ:                                     │
│  ├─ docker cp file.txt container:/app/                     │
│  ├─ docker cp container:/app/logs/ ./logs/                 │
│  └─ Работает с запущенными и остановленными контейнерами   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🏥 HEALTH CHECKS:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  📋 В DOCKERFILE:                                           │
│  HEALTHCHECK --interval=30s --timeout=10s --start-period=5s \│
│    --retries=3 CMD curl -f http://localhost/ || exit 1     │
│                                                             │
│  🏃 ПРИ ЗАПУСКЕ:                                            │
│  docker run -d --health-cmd="curl -f http://localhost/ || exit 1" \│
│    --health-interval=30s --health-timeout=10s \            │
│    --health-retries=3 nginx                                │
│                                                             │
│  📊 МОНИТОРИНГ ЗДОРОВЬЯ:                                    │
│  ├─ docker ps  # показывает статус health                  │
│  ├─ healthy, unhealthy, starting                           │
│  ├─ docker inspect container | grep Health                 │
│  └─ docker events --filter container=my-app                │
│                                                             │
│  💡 АВТОМАТИЧЕСКИЕ ДЕЙСТВИЯ:                                │
│  ├─ Рестарт нездоровых контейнеров                         │
│  ├─ Исключение из load balancer                            │
│  └─ Уведомления администраторам                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘

🎲 ПОЛЕЗНЫЕ ФЛАГИ ЗАПУСКА:
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  🎯 ИНТЕРАКТИВНОСТЬ:                                        │
│  ├─ -i, --interactive  ← Держать STDIN открытым             │
│  ├─ -t, --tty         ← Псевдо-TTY                         │
│  ├─ -d, --detach      ← Запуск в фоне                      │
│  └─ --rm              ← Автоудаление после завершения       │
│                                                             │
│  🔧 БЕЗОПАСНОСТЬ:                                           │
│  ├─ --read-only       ← Файловая система только для чтения │
│  ├─ --user 1000:1000  ← Запуск под пользователем           │
│  ├─ --cap-drop ALL    ← Убрать все capabilities            │
│  └─ --security-opt no-new-privileges  ← Запрет повышения   │
│                                                             │
│  🎛️ ИМЕНОВАНИЕ И LABELS:                                    │
│  ├─ --name my-app     ← Удобное имя                        │
│  ├─ --hostname web01  ← Имя хоста внутри контейнера        │
│  ├─ --label env=prod  ← Метки для организации              │
│  └─ --label version=1.2.3                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🎯 Лабораторная работа: Полнофункциональное приложение

**Цель:** Создать мониторинг-дашборд с несколькими контейнерами

**Компоненты системы:**
1. **Веб-приложение** (Node.js/Python)
2. **База данных** (PostgreSQL)
3. **Кеш** (Redis)
4. **Мониторинг** (простой status endpoint)

**Задание:**

```bash
# 1. Создайте простое веб-приложение
mkdir monitoring-dashboard && cd monitoring-dashboard

# 2. Создайте файлы:
# - app.js (простой Express сервер)
# - package.json
# - Dockerfile
# - .dockerignore

# 3. Запустите PostgreSQL с ограничениями ресурсов
docker run -d \
  --name postgres-db \
  --restart=unless-stopped \
  --memory="512m" \
  --cpus="0.5" \
  -e POSTGRES_DB=dashboard \
  -e POSTGRES_USER=admin \
  -e POSTGRES_PASSWORD=secret123 \
  -p 5432:5432 \
  postgres:13-alpine

# 4. Запустите Redis для кеширования
docker run -d \
  --name redis-cache \
  --restart=unless-stopped \
  --memory="128m" \
  --cpus="0.25" \
  -p 6379:6379 \
  redis:6-alpine

# 5. Соберите и запустите веб-приложение
docker build -t my-dashboard .
docker run -d \
  --name web-app \
  --restart=unless-stopped \
  --memory="256m" \
  --cpus="0.5" \
  -p 3000:3000 \
  -e DATABASE_URL=postgresql://admin:secret123@host.docker.internal:5432/dashboard \
  -e REDIS_URL=redis://host.docker.internal:6379 \
  my-dashboard

# 6. Создайте скрипт мониторинга
cat > monitor.sh << 'EOF'
#!/bin/bash
echo "=== Monitoring Dashboard $(date) ==="
echo
echo "Container Status:"
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
echo
echo "Resource Usage:"
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemPerc}}"
echo
echo "Health Checks:"
curl -s http://localhost:3000/health || echo "Web app unhealthy"
echo
EOF

chmod +x monitor.sh

# 7. Протестируйте систему
./monitor.sh
```

**Ожидаемый результат:**
- Все три контейнера работают стабильно
- Ресурсы ограничены согласно требованиям
- Мониторинг показывает статус системы
- Веб-приложение отвечает на запросы

---

## 🎓 Резюме блока

### ✅ Что мы изучили:

1. **Управление образами:**
   - Стратегии тегирования и версионирования
   - Анализ размера и оптимизация
   - Очистка и maintenance
   - Экспорт/импорт образов

2. **Создание образов с Dockerfile:**
   - Философия и лучшие практики
   - Основные инструкции и их назначение
   - Multi-stage builds для оптимизации
   - Безопасность и производительность

3. **Профессиональное управление контейнерами:**
   - Жизненный цикл и состояния
   - Сетевые настройки и порты
   - Ограничения ресурсов
   - Политики перезапуска
   - Мониторинг и отладка

### 🎯 Контрольные вопросы:

1. Какие стратегии тегирования подходят для production?
2. В чем различие между CMD и ENTRYPOINT?
3. Как работает multi-stage build и зачем он нужен?
4. Какую restart policy выбрать для критического сервиса?
5. Как ограничить использование памяти контейнером?
6. Что происходит при превышении лимитов CPU vs памяти?

### 📈 Готовность к следующему блоку:

Вы готовы к изучению Блока 3, если можете:
- [ ] Создавать оптимизированные Dockerfile
- [ ] Применять multi-stage builds
- [ ] Управлять ресурсами контейнеров
- [ ] Настраивать политики перезапуска
- [ ] Мониторить состояние контейнеров
- [ ] Отлаживать проблемы в контейнерах

---

## 🚀 Что дальше?

В **Блоке 3** мы изучим:
- Сетевые возможности Docker
- Управление данными и volumes
- Безопасность контейнеров
- Резервное копирование
- Продвинутые техники storage

**Готовы к изучению сетей и данных? 🌐💾**