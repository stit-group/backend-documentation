# Развернутые ответы: Интервью Backend разработчика по тестированию микросервисов

## 1. Основы и стратегия тестирования

### Вопрос 1: Пирамида тестирования в микросервисах

**Развернутый ответ:**

Пирамида тестирования в микросервисах кардинально отличается от монолитной архитектуры. В монолите соотношение составляет примерно 70% unit, 20% integration, 10% E2E. В микросервисах это соотношение сдвигается к 60% unit, 30% integration, 10% E2E, при этом добавляется новый слой - contract testing.

**Ключевые отличия:**
- **Больше integration тестов** - необходимо тестировать взаимодействие между сервисами
- **Contract testing** - размещается между unit и integration тестами
- **Service-level testing** - тестирование отдельного сервиса в изоляции
- **Testing in production** - становится критически важным

**Пример стратегии для e-commerce системы:**

```javascript
// Unit Tests (60%)
class OrderService {
  calculateTotal(items, discounts) {
    return items.reduce((sum, item) => sum + item.price, 0) - discounts;
  }
}

// Integration Tests (30%) 
describe('OrderService Integration', () => {
  it('should create order with payment processing', async () => {
    const orderService = new OrderService(realPaymentClient, mockInventory);
    const result = await orderService.processOrder(orderData);
    expect(result.status).toBe('created');
  });
});

// Contract Tests (новый слой)
const orderToPaymentContract = {
  consumer: 'OrderService',
  provider: 'PaymentService',
  interactions: [{
    description: 'process payment',
    request: { method: 'POST', path: '/payments' },
    response: { status: 200, body: { transactionId: 'tx-123' } }
  }]
};

// E2E Tests (10%)
describe('Full Purchase Flow', () => {
  it('complete order journey', async () => {
    // Полный флоу через все сервисы
  });
});
```

### Вопрос 2: Изоляция и test doubles

**Развернутый ответ:**

Изоляция в distributed environment - это баланс между реализмом и скоростью выполнения тестов. Существует три основных подхода:

**1. Mocks/Stubs** - быстро, но может скрывать реальные проблемы интеграции
**2. TestContainers** - реалистично, но медленнее
**3. Contract testing** - лучший баланс для межсервисного взаимодействия

**Практический пример для OrderService:**

```javascript
class OrderService {
  constructor(paymentClient, inventoryClient, eventBus) {
    this.paymentClient = paymentClient;
    this.inventoryClient = inventoryClient;
    this.eventBus = eventBus;
  }

  async processOrder(orderData) {
    // 1. Проверяем наличие товара
    const availability = await this.inventoryClient.checkAvailability(orderData.items);
    if (!availability.available) {
      throw new Error('Items not available');
    }

    // 2. Создаем заказ
    const order = await this.createOrder(orderData);

    // 3. Обрабатываем платеж
    const payment = await this.paymentClient.processPayment({
      amount: order.total,
      orderId: order.id
    });

    // 4. Публикуем событие
    await this.eventBus.publish('order.created', { orderId: order.id });

    return order;
  }
}

// Unit Test с моками
describe('OrderService Unit Tests', () => {
  let orderService, mockPayment, mockInventory, mockEventBus;

  beforeEach(() => {
    mockPayment = { processPayment: jest.fn() };
    mockInventory = { checkAvailability: jest.fn() };
    mockEventBus = { publish: jest.fn() };
    orderService = new OrderService(mockPayment, mockInventory, mockEventBus);
  });

  it('should process order successfully', async () => {
    // Arrange
    mockInventory.checkAvailability.mockResolvedValue({ available: true });
    mockPayment.processPayment.mockResolvedValue({ transactionId: 'tx-123' });

    // Act
    const result = await orderService.processOrder(orderData);

    // Assert
    expect(mockPayment.processPayment).toHaveBeenCalledWith({
      amount: expect.any(Number),
      orderId: expect.any(String)
    });
    expect(mockEventBus.publish).toHaveBeenCalledWith('order.created', expect.any(Object));
  });

  it('should handle inventory unavailability', async () => {
    mockInventory.checkAvailability.mockResolvedValue({ available: false });
    
    await expect(orderService.processOrder(orderData))
      .rejects.toThrow('Items not available');
  });
});
```

## 2. Unit и Integration тестирование

### Вопрос 3: Практика unit тестирования

**Развернутый ответ:**

Unit тестирование в микросервисах должно покрывать бизнес-логику сервиса в полной изоляции. Ключевые принципы: Fast, Independent, Repeatable, Self-validating, Timely (FIRST).

**Критические edge cases для OrderService:**
- Недоступность внешних сервисов
- Некорректные данные заказа
- Concurrent операции
- Timeout scenarios
- Partial failures

**Расширенный пример с обработкой ошибок:**

```javascript
describe('OrderService Edge Cases', () => {
  it('should handle payment service timeout', async () => {
    const timeoutError = new Error('Payment timeout');
    timeoutError.code = 'TIMEOUT';
    mockPayment.processPayment.mockRejectedValue(timeoutError);

    const result = await orderService.processOrder(orderData);
    
    expect(result.status).toBe('payment_pending');
    expect(mockEventBus.publish).toHaveBeenCalledWith('payment.timeout', expect.any(Object));
  });

  it('should validate order data', async () => {
    const invalidOrder = { items: [], total: -100 };
    
    await expect(orderService.processOrder(invalidOrder))
      .rejects.toThrow('Invalid order data');
  });

  it('should handle concurrent order processing', async () => {
    const promises = Array(5).fill().map(() => 
      orderService.processOrder({ ...orderData, id: Math.random() })
    );
    
    const results = await Promise.allSettled(promises);
    const successful = results.filter(r => r.status === 'fulfilled');
    
    expect(successful).toHaveLength(5);
  });
});
```

### Вопрос 4: Integration тестирование с TestContainers

**Развернутый ответ:**

Integration тесты с TestContainers обеспечивают реальную среду выполнения с минимальными накладными расходами. Это особенно важно для тестирования database interactions, message queues, и external APIs.

**Практический пример:**

```javascript
const { GenericContainer } = require('testcontainers');
const { Pool } = require('pg');

describe('OrderRepository Integration Tests', () => {
  let container, pool;

  beforeAll(async () => {
    // Запускаем PostgreSQL контейнер
    container = await new GenericContainer('postgres:13')
      .withEnvironment({
        POSTGRES_USER: 'test',
        POSTGRES_PASSWORD: 'test',
        POSTGRES_DB: 'orders'
      })
      .withExposedPorts(5432)
      .start();

    const port = container.getMappedPort(5432);
    pool = new Pool({
      host: 'localhost',
      port: port,
      database: 'orders',
      user: 'test',
      password: 'test'
    });

    // Создаем схему
    await pool.query(`
      CREATE TABLE orders (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL,
        total DECIMAL(10,2) NOT NULL,
        status VARCHAR(50) NOT NULL,
        created_at TIMESTAMP DEFAULT NOW()
      );
      
      CREATE TABLE order_items (
        id SERIAL PRIMARY KEY,
        order_id INTEGER REFERENCES orders(id),
        product_id INTEGER NOT NULL,
        quantity INTEGER NOT NULL,
        price DECIMAL(10,2) NOT NULL
      );
    `);
  });

  afterAll(async () => {
    await pool.end();
    await container.stop();
  });

  afterEach(async () => {
    // Очищаем данные между тестами
    await pool.query('TRUNCATE orders CASCADE');
  });

  it('should create order with items', async () => {
    const orderRepo = new OrderRepository(pool);
    
    const orderData = {
      userId: 123,
      items: [
        { productId: 1, quantity: 2, price: 50.00 },
        { productId: 2, quantity: 1, price: 30.00 }
      ]
    };

    const order = await orderRepo.createOrderWithItems(orderData);

    expect(order.id).toBeDefined();
    expect(order.total).toBe(130.00);

    // Проверяем, что items созданы корректно
    const items = await pool.query(
      'SELECT * FROM order_items WHERE order_id = $1',
      [order.id]
    );
    expect(items.rows).toHaveLength(2);
  });

  it('should find orders by user with pagination', async () => {
    // Создаем тестовые данные
    for (let i = 0; i < 15; i++) {
      await pool.query(
        'INSERT INTO orders (user_id, total, status) VALUES ($1, $2, $3)',
        [123, 100 + i, 'completed']
      );
    }

    const orderRepo = new OrderRepository(pool);
    const result = await orderRepo.findByUser(123, { page: 2, limit: 5 });

    expect(result.orders).toHaveLength(5);
    expect(result.total).toBe(15);
    expect(result.page).toBe(2);
  });
});
```

## 3. Contract Testing

### Вопрос 5: Consumer-Driven Contracts

**Развернутый ответ:**

Contract testing решает проблему "integration testing без интеграции". Consumer определяет контракт, Provider его выполняет. Это обеспечивает эволюцию API без breaking changes.

**Ключевые преимущества:**
- Быстрая обратная связь при изменении API
- Документирование зависимостей между сервисами
- Возможность независимой разработки команд

**Практический пример с Pact:**

```javascript
// Consumer side (OrderService)
const { Pact } = require('@pact-foundation/pact');
const { ProductService } = require('../src/ProductService');

describe('OrderService -> ProductService Contract', () => {
  const provider = new Pact({
    consumer: 'OrderService',
    provider: 'ProductService',
    port: 9001
  });

  beforeAll(() => provider.setup());
  afterEach(() => provider.verify());
  afterAll(() => provider.finalize());

  it('should get product details', async () => {
    // Определяем ожидания
    await provider
      .given('product with id 123 exists')
      .uponReceiving('a request for product details')
      .withRequest({
        method: 'GET',
        path: '/products/123',
        headers: { 'Accept': 'application/json' }
      })
      .willRespondWith({
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: {
          id: 123,
          name: 'Test Product',
          price: 99.99,
          inStock: true
        }
      });

    // Выполняем тест
    const productService = new ProductService('http://localhost:9001');
    const product = await productService.getProduct(123);

    expect(product.id).toBe(123);
    expect(product.price).toBe(99.99);
  });

  it('should handle product not found', async () => {
    await provider
      .given('product with id 999 does not exist')
      .uponReceiving('a request for non-existent product')
      .withRequest({
        method: 'GET',
        path: '/products/999'
      })
      .willRespondWith({
        status: 404,
        body: { error: 'Product not found' }
      });

    const productService = new ProductService('http://localhost:9001');
    
    await expect(productService.getProduct(999))
      .rejects.toThrow('Product not found');
  });
});

// Provider side (ProductService) - verification
describe('ProductService Provider Verification', () => {
  it('should satisfy OrderService contract', async () => {
    const verificationOptions = {
      provider: 'ProductService',
      providerBaseUrl: 'http://localhost:3000',
      pactUrls: ['path/to/orderservice-productservice.json'],
      stateHandlers: {
        'product with id 123 exists': () => {
          // Подготавливаем состояние: создаем продукт в БД
          return ProductModel.create({
            id: 123,
            name: 'Test Product',
            price: 99.99,
            inStock: true
          });
        },
        'product with id 999 does not exist': () => {
          // Убеждаемся, что продукта нет
          return ProductModel.destroy({ where: { id: 999 } });
        }
      }
    };

    await new Verifier(verificationOptions).verifyProvider();
  });
});
```

**Обработка эволюции API:**

```javascript
// Версия 1 контракта
const contractV1 = {
  response: {
    body: {
      id: 123,
      name: 'Product',
      price: 99.99
    }
  }
};

// Версия 2 - добавляем новое поле (backward compatible)
const contractV2 = {
  response: {
    body: {
      id: 123,
      name: 'Product',
      price: 99.99,
      category: 'Electronics' // Новое поле
    }
  }
};

// Provider может вернуть дополнительные поля
// Consumer игнорирует неизвестные поля
```

## 4. E2E и Performance тестирование

### Вопрос 6: End-to-End strategy

**Развернутый ответ:**

E2E тесты в микросервисах должны покрывать критичные user journeys, но быть минимальными по количеству. Стратегия: "узкие, но глубокие" тесты, которые проходят через все слои системы.

**Принципы E2E тестирования:**
- Тестируем happy path + критичные error scenarios
- Один E2E тест заменяет множество integration тестов
- Используем реальные данные, но изолированные тестовые среды

**Пример архитектуры E2E теста:**

```javascript
describe('Purchase Flow E2E', () => {
  let testEnvironment;

  beforeAll(async () => {
    // Настраиваем изолированную среду
    testEnvironment = await TestEnvironment.setup({
      services: ['auth', 'products', 'orders', 'payments', 'notifications'],
      database: 'clean',
      externalMocks: ['payment-gateway', 'email-service']
    });
  });

  afterAll(async () => {
    await testEnvironment.cleanup();
  });

  it('should complete full purchase journey', async () => {
    // 1. Аутентификация пользователя
    const user = await testEnvironment.createUser({
      email: 'test@example.com',
      verified: true
    });
    
    const authToken = await authenticateUser(user.email, 'password');

    // 2. Просмотр каталога товаров
    const products = await apiClient.get('/products', {
      headers: { Authorization: `Bearer ${authToken}` }
    });
    expect(products.data).toHaveLength(10);

    // 3. Добавление товара в корзину
    const product = products.data[0];
    await apiClient.post('/cart/items', {
      productId: product.id,
      quantity: 2
    }, {
      headers: { Authorization: `Bearer ${authToken}` }
    });

    // 4. Оформление заказа
    const orderResponse = await apiClient.post('/orders', {
      paymentMethod: 'card',
      shippingAddress: testEnvironment.addresses.default
    }, {
      headers: { Authorization: `Bearer ${authToken}` }
    });

    expect(orderResponse.status).toBe(201);
    const order = orderResponse.data;

    // 5. Проверяем, что все события произошли
    await testEnvironment.waitForEvents([
      'order.created',
      'payment.processed',
      'inventory.reserved',
      'notification.sent'
    ], { timeout: 5000 });

    // 6. Проверяем финальное состояние
    const finalOrder = await apiClient.get(`/orders/${order.id}`, {
      headers: { Authorization: `Bearer ${authToken}` }
    });

    expect(finalOrder.data.status).toBe('confirmed');
    expect(finalOrder.data.paymentStatus).toBe('paid');
  });

  it('should handle payment failure gracefully', async () => {
    // Настраиваем mock для отказа платежа
    testEnvironment.mockPaymentGateway.setup({
      scenario: 'payment_declined',
      response: { error: 'Insufficient funds' }
    });

    const user = await testEnvironment.createUser();
    const authToken = await authenticateUser(user.email, 'password');

    const orderResponse = await apiClient.post('/orders', {
      paymentMethod: 'card',
      amount: 999999 // Большая сумма для отклонения
    }, {
      headers: { Authorization: `Bearer ${authToken}` }
    });

    // Заказ создается, но остается в статусе "payment_failed"
    expect(orderResponse.status).toBe(201);
    
    await testEnvironment.waitForEvents(['payment.failed'], { timeout: 3000 });

    const order = await apiClient.get(`/orders/${orderResponse.data.id}`, {
      headers: { Authorization: `Bearer ${authToken}` }
    });

    expect(order.data.status).toBe('payment_failed');
    expect(order.data.paymentError).toContain('Insufficient funds');
  });
});
```

### Вопрос 7: Performance и Load Testing

**Развернутый ответ:**

Performance тестирование микросервисов требует понимания bottlenecks в distributed системе. Основные метрики: throughput, latency (p50, p95, p99), error rate.

**Пример с K6:**

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// Кастомные метрики
const orderCreationRate = new Rate('order_creation_success');
const orderProcessingTime = new Trend('order_processing_duration');

export let options = {
  stages: [
    { duration: '5m', target: 100 },  // Постепенное увеличение
    { duration: '10m', target: 100 }, // Стабильная нагрузка
    { duration: '5m', target: 200 },  // Пиковая нагрузка
    { duration: '10m', target: 200 }, // Удержание пика
    { duration: '5m', target: 0 },    // Снижение нагрузки
  ],
  thresholds: {
    http_req_duration: ['p(95)<2000'], // 95% запросов быстрее 2 сек
    http_req_failed: ['rate<0.1'],     // Менее 10% ошибок
    order_creation_success: ['rate>0.9'], // 90% заказов успешно
  }
};

export default function() {
  // 1. Аутентификация
  const authResponse = http.post('http://api-gateway/auth/login', {
    email: 'loadtest@example.com',
    password: 'password123'
  });

  check(authResponse, {
    'auth successful': (r) => r.status === 200,
  });

  const authToken = authResponse.json('token');

  // 2. Получение товаров
  const productsResponse = http.get('http://api-gateway/products', {
    headers: { Authorization: `Bearer ${authToken}` }
  });

  check(productsResponse, {
    'products loaded': (r) => r.status === 200,
    'products count > 0': (r) => r.json('data').length > 0,
  });

  // 3. Создание заказа
  const orderStartTime = Date.now();
  const orderResponse = http.post('http://api-gateway/orders', {
    items: [
      { productId: 1, quantity: Math.floor(Math.random() * 5) + 1 },
      { productId: 2, quantity: Math.floor(Math.random() * 3) + 1 }
    ],
    paymentMethod: 'card'
  }, {
    headers: { Authorization: `Bearer ${authToken}` }
  });

  const orderSuccess = check(orderResponse, {
    'order created': (r) => r.status === 201,
    'order has id': (r) => r.json('id') !== undefined,
  });

  // Записываем метрики
  orderCreationRate.add(orderSuccess);
  orderProcessingTime.add(Date.now() - orderStartTime);

  sleep(Math.random() * 3 + 1); // Случайная пауза 1-4 сек
}

// Сценарий для stress testing
export function stressTest() {
  // Тестируем поведение при перегрузке
  for (let i = 0; i < 10; i++) {
    http.post('http://api-gateway/orders', /* большой payload */);
  }
}
```

## 5. Chaos Engineering и Observability

### Вопрос 8: Resilience testing

**Развернутый ответ:**

Chaos Engineering тестирует гипотезы о поведении системы в условиях отказов. В микросервисах это критично из-за распределенной природы системы.

**Основные эксперименты:**
- Network partitions между сервисами
- Resource exhaustion (CPU, memory, disk)
- Service dependencies failures
- Database connection pool exhaustion

**Пример Chaos эксперимента:**

```javascript
// Chaos Experiment: Network latency injection
const chaosExperiment = {
  name: 'payment-service-latency',
  hypothesis: 'Order processing should gracefully handle payment service delays up to 5 seconds',
  
  async setup() {
    // Базовые метрики до эксперимента
    this.baselineMetrics = await this.collectMetrics();
  },

  async experiment() {
    // Вводим латентность 3-5 сек в payment service
    await this.networkChaos.injectLatency({
      target: 'payment-service',
      latency: '3s-5s',
      duration: '10m'
    });

    // Генерируем нагрузку
    const loadTest = new LoadGenerator({
      scenario: 'order_creation',
      duration: '10m',
      rps: 50
    });

    return await loadTest.run();
  },

  async verify(results) {
    const metrics = await this.collectMetrics();
    
    return {
      success_rate: metrics.order_success_rate > 0.95,
      response_time: metrics.p99_response_time < 8000, // 8 сек с учетом 5 сек латентности
      circuit_breaker: metrics.circuit_breaker_trips > 0, // CB должен сработать
      fallback_usage: metrics.fallback_payments > 0 // Fallback механизм активировался
    };
  },

  async cleanup() {
    await this.networkChaos.restore();
  }
};

// Реализация с использованием Litmus Chaos
const litmusExperiment = {
  apiVersion: 'litmuschaos.io/v1alpha1',
  kind: 'ChaosEngine',
  metadata: {
    name: 'payment-latency-chaos',
    namespace: 'production'
  },
  spec: {
    engineState: 'active',
    appinfo: {
      appns: 'ecommerce',
      applabel: 'app=payment-service'
    },
    experiments: [{
      name: 'pod-network-latency',
      spec: {
        components: {
          env: [{
            name: 'NETWORK_LATENCY',
            value: '3000' // 3 секунды
          }, {
            name: 'TARGET_PODS',
            value: 'payment-service'
          }]
        }
      }
    }]
  }
};
```

### Вопрос 9: Testing Observability

**Развернутый ответ:**

Observability в тестах помогает понять, где и почему тесты падают в distributed environment. Три столпа: logs, metrics, traces.

**Пример интеграции трейсинга в тесты:**

```javascript
const opentelemetry = require('@opentelemetry/api');
const { NodeTracerProvider } = require('@opentelemetry/node');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');

class TestObservability {
  constructor() {
    this.tracer = opentelemetry.trace.getTracer('integration-tests');
  }

  async runTracedTest(testName, testFunction) {
    const span = this.tracer.startSpan(`test:${testName}`);
    
    try {
      const result = await testFunction();
      span.setStatus({ code: opentelemetry.SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.recordException(error);
      span.setStatus({
        code: opentelemetry.SpanStatusCode.ERROR,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }
}

describe('Order Processing with Tracing', () => {
  const observability = new TestObservability();

  it('should trace order creation flow', async () => {
    await observability.runTracedTest('order-creation', async () => {
      const span = observability.tracer.startSpan('order-creation-test');
      
      // Добавляем атрибуты для поиска в Jaeger
      span.setAttributes({
        'test.type': 'integration',
        'test.service': 'order-service',
        'test.scenario': 'happy-path'
      });

      const childSpan = observability.tracer.startSpan('create-order-request', {
        parent: span
      });

      try {
        const order = await orderService.createOrder({
          userId: 123,
          items: [{ productId: 1, quantity: 2 }]
        });

        childSpan.setAttributes({
          'order.id': order.id,
          'order.total': order.total
        });

        expect(order.status).toBe('created');
        
        return order;
      } finally {
        childSpan.end();
        span.end();
      }
    });
  });
});

// Метрики для тестов
class TestMetrics {
  constructor() {
    this.metrics = {
      test_duration: new Histogram('test_duration_seconds'),
      test_success_rate: new Counter('test_success_total'),
      test_failure_rate: new Counter('test_failure_total')
    };
  }

  recordTestResult(testName, duration, success) {
    this.metrics.test_duration.observe({ test: testName }, duration);
    
    if (success) {
      this.metrics.test_success_rate.inc({ test: testName });
    } else {
      this.metrics.test_failure_rate.inc({ test: testName });
    }
  }
}
```

## 6. CI/CD и масштабирование

### Вопрос 10: Testing Pipeline

**Развернутый ответ:**

CI/CD pipeline для микросервисов должен обеспечивать быструю обратную связь при минимальных ресурсозатратах. Ключевой принцип: fail fast, fail cheap.

**Архитектура pipeline:**

```yaml
# .gitlab-ci.yml
stages:
  - validate
  - unit-test
  - integration-test
  - contract-test
  - security-scan
  - deploy-staging
  - e2e-test
  - deploy-production

variables:
  DOCKER_REGISTRY: registry.example.com
  SERVICE_NAME: order-service

# Stage 1: Быстрая валидация (1-2 мин)
validate:
  stage: validate
  script:
    - npm run lint
    - npm run type-check
    - npm audit --audit-level moderate
  cache:
    paths:
      - node_modules/

# Stage 2: Unit тесты (2-3 мин)
unit-test:
  stage: unit-test
  script:
    - npm run test:unit -- --coverage
    - npm run test:unit -- --reporter=junit --outputFile=test-results.xml
  artifacts:
    reports:
      junit: test-results.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Stage 3: Integration тесты (5-7 мин)
integration-test:
  stage: integration-test
  services:
    - postgres:13
    - redis:6
  variables:
    DATABASE_URL: postgresql://test:test@postgres:5432/test_db
    REDIS_URL: redis://redis:6379
  script:
    - npm run test:integration
  artifacts:
    reports:
      junit: integration-test-results.xml
  parallel:
    matrix:
      - TEST_SUITE: [repository, external-apis, messaging]

# Stage 4: Contract тесты
contract-test:
  stage: contract-test
  script:
    # Consumer contracts
    - npm run test:pact
    # Publish contracts to Pact Broker
    - npx pact-broker publish pacts/ --broker-base-url=$PACT_BROKER_URL
  artifacts:
    paths:
      - pacts/
```

**Стратегия для монорепо с 10+ сервисами:**

```javascript
// pipeline-orchestrator.js
class PipelineOrchestrator {
  constructor(changedFiles) {
    this.changedFiles = changedFiles;
    this.dependencyGraph = this.buildDependencyGraph();
  }

  getAffectedServices() {
    const affectedServices = new Set();
    
    for (const file of this.changedFiles) {
      const service = this.getServiceFromPath(file);
      if (service) {
        affectedServices.add(service);
        // Добавляем зависимые сервисы
        this.addDependentServices(service, affectedServices);
      }
    }

    return Array.from(affectedServices);
  }

  async runOptimizedPipeline() {
    const affectedServices = this.getAffectedServices();
    
    // Параллельно запускаем тесты для независимых сервисов
    const batches = this.createExecutionBatches(affectedServices);
    
    for (const batch of batches) {
      await Promise.all(batch.map(service => this.runServiceTests(service)));
    }
  }

  createExecutionBatches(services) {
    // Топологическая сортировка по зависимостям
    const batches = [];
    const processed = new Set();
    
    while (processed.size < services.length) {
      const currentBatch = services.filter(service => 
        !processed.has(service) && 
        this.allDependenciesProcessed(service, processed)
      );
      
      batches.push(currentBatch);
      currentBatch.forEach(service => processed.add(service));
    }
    
    return batches;
  }
}
```

### Вопрос 11: Масштабирование practices

**Развернутый ответ:**

При масштабировании на 50+ микросервисов критично стандартизировать подходы и создать shared infrastructure для тестирования.

**Governance framework:**

```javascript
// shared-testing-library/src/TestFramework.js
class EnterpriseTestFramework {
  constructor(config) {
    this.config = config;
    this.standards = this.loadTestingStandards();
  }

  // Стандартные матчеры для всех команд
  getCustomMatchers() {
    return {
      toBeValidApiResponse: (received) => {
        const hasRequiredFields = received.data && received.meta;
        const hasCorrectStatus = [200, 201, 202].includes(received.status);
        
        return {
          pass: hasRequiredFields && hasCorrectStatus,
          message: () => `Expected valid API response format`
        };
      },

      toFollowNamingConvention: (received, type) => {
        const conventions = {
          endpoint: /^\/api\/v\d+\/[a-z-]+$/,
          event: /^[a-z]+\.[a-z]+$/,
          service: /^[a-z]+-service$/
        };
        
        return {
          pass: conventions[type].test(received),
          message: () => `Expected ${type} to follow naming convention`
        };
      }
    };
  }

  // Общие утилиты для работы с тестовыми данными
  createTestDataFactory(serviceType) {
    const factories = {
      user: () => ({
        id: Math.floor(Math.random() * 10000),
        email: `test-${Date.now()}@example.com`,
        verified: true
      }),
      
      order: () => ({
        id: `order-${Date.now()}`,
        userId: Math.floor(Math.random() * 1000),
        total: Math.round(Math.random() * 1000 * 100) / 100,
        status: 'pending'
      })
    };

    return factories[serviceType] || (() => ({}));
  }

  // Стандартные health checks для интеграционных тестов
  async verifyServiceHealth(serviceName) {
    const healthEndpoint = `${this.config.serviceUrls[serviceName]}/health`;
    
    const response = await fetch(healthEndpoint);
    const health = await response.json();

    expect(response.status).toBe(200);
    expect(health).toMatchObject({
      status: 'healthy',
      version: expect.any(String),
      timestamp: expect.any(String)
    });

    return health;
  }
}

// Метрики качества тестирования
class TestQualityMetrics {
  constructor(metricsCollector) {
    this.metrics = metricsCollector;
  }

  trackTestExecution(testResult) {
    this.metrics.increment('tests.executed', {
      service: testResult.service,
      type: testResult.type,
      result: testResult.passed ? 'pass' : 'fail'
    });

    this.metrics.histogram('tests.duration', testResult.duration, {
      service: testResult.service,
      type: testResult.type
    });
  }

  generateQualityReport() {
    return {
      coverage: this.calculateCoverage(),
      flakiness: this.calculateFlakiness(),
      performance: this.calculatePerformanceMetrics(),
      recommendations: this.generateRecommendations()
    };
  }

  calculateFlakiness() {
    // Анализируем историю тестов за последние 30 дней
    const flakyTests = this.metrics.query(`
      SELECT test_name, 
             COUNT(CASE WHEN result = 'fail' THEN 1 END) as failures,
             COUNT(*) as total_runs,
             (COUNT(CASE WHEN result = 'fail' THEN 1 END) * 100.0 / COUNT(*)) as failure_rate
      FROM test_executions 
      WHERE timestamp > NOW() - INTERVAL '30 days'
      GROUP BY test_name
      HAVING failure_rate > 5 AND failure_rate < 95
      ORDER BY failure_rate DESC
    `);

    return flakyTests;
  }
}
```

**Организационные практики:**

```markdown
## Testing Communities of Practice

### 1. Testing Guild (еженедельно)
- Обмен опытом между командами
- Обсуждение новых инструментов и практик
- Ревью сложных тестовых сценариев

### 2. Shared Testing Infrastructure
- Единый Pact Broker для contract testing
- Centralized test data management
- Common CI/CD templates

### 3. Quality Gates
- Минимальное покрытие: 80% unit, 60% integration
- Contract testing для всех межсервисных взаимодействий
- Performance benchmarks для критичных endpoints

### 4. Training Program
- Onboarding checklist для новых разработчиков
- Advanced testing workshops (quarterly)
- Internal documentation и best practices
```

---

## Заключение

Эти ответы покрывают все ключевые аспекты тестирования микросервисов: от базовых unit тестов до enterprise-level масштабирования. Каждый пример демонстрирует не только "как делать", но и "почему именно так", что критично для senior-level позиций.

**Ключевые takeaways:**
- Тестирование микросервисов требует balance между изоляцией и реализмом
- Contract testing - критический инструмент для эволюции API
- Observability в тестах помогает debugging в distributed environment
- Масштабирование требует стандартизации и shared infrastructure
- Quality gates и метрики необходимы для поддержания качества на уровне организации