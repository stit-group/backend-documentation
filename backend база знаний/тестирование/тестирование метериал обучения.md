**Python пример Hexagonal Architecture:**
```python
# Порты (интерфейсы)
from abc import ABC, abstractmethod
from typing import List, Optional

class UserRepository(ABC):
    @abstractmethod
    def save(self, user: User) -> User:
        pass
    
    @abstractmethod
    def find_by_id(self, user_id: int) -> Optional[User]:
        pass
    
    @abstractmethod
    def find_by_email(self, email: str) -> Optional[User]:
        pass

class EmailService(ABC):
    @abstractmethod
    def send_welcome_email(self, email: str, name: str) -> bool:
        pass

class NotificationService(ABC):
    @abstractmethod
    def send_notification(self, user_id: int, message: str) -> bool:
        pass

# Доменная модель (ядро)
class User:
    def __init__(self, email: str, name: str, user_id: int = None):
        self.id = user_id
        self.email = email
        self.name = name
        self.is_active = True
        self.created_at = None
    
    def deactivate(self):
        """Бизнес-логика деактивации"""
        if not self.is_active:
            raise ValueError("User is already inactive")
        self.is_active = False
    
    def update_profile(self, name: str = None, email: str = None):
        """Бизнес-логика обновления профиля"""
        if name:
            if len(name.strip()) < 2:
                raise ValueError("Name must be at least 2 characters")
            self.name = name.strip()
        
        if email:
            if "@" not in email:
                raise ValueError("Invalid email format")
            self.email = email.lower()

# Сервисы приложения (use cases)
class UserService:
    def __init__(self, 
                 user_repository: UserRepository,
                 email_service: EmailService,
                 notification_service: NotificationService):
        self._user_repository = user_repository
        self._email_service = email_service
        self._notification_service = notification_service
    
    def register_user(self, email: str, name: str) -> User:
        """Use case: регистрация нового пользователя"""
        # Проверяем что пользователь не существует
        existing_user = self._user_repository.find_by_email(email)
        if existing_user:
            raise ValueError("User with this email already exists")
        
        # Создаем пользователя
        user = User(email=email, name=name)
        
        # Сохраняем в репозитории
        saved_user = self._user_repository.save(user)
        
        # Отправляем welcome email
        self._email_service.send_welcome_email(saved_user.email, saved_user.name)
        
        # Отправляем уведомление
        self._notification_service.send_notification(
            saved_user.id, 
            "Welcome to our platform!"
        )
        
        return saved_user
    
    def update_user_profile(self, user_id: int, name: str = None, email: str = None) -> User:
        """Use case: обновление профиля пользователя"""
        user = self._user_repository.find_by_id(user_id)
        if not user:
            raise ValueError("User not found")
        
        # Если меняется email, проверяем уникальность
        if email and email != user.email:
            existing_user = self._user_repository.find_by_email(email)
            if existing_user:
                raise ValueError("Email already taken")
        
        # Обновляем профиль (бизнес-логика в доменной модели)
        user.update_profile(name=name, email=email)
        
        # Сохраняем изменения
        updated_user = self._user_repository.save(user)
        
        return updated_user
    
    def deactivate_user(self, user_id: int) -> User:
        """Use case: деактивация пользователя"""
        user = self._user_repository.find_by_id(user_id)
        if not user:
            raise ValueError("User not found")
        
        # Деактивируем (бизнес-логика в доменной модели)
        user.deactivate()
        
        # Сохраняем изменения
        updated_user = self._user_repository.save(user)
        
        # Уведомляем о деактивации
        self._notification_service.send_notification(
            user.id,
            "Your account has been deactivated"
        )
        
        return updated_user

# Адаптеры (внешний слой)
class SqlUserRepository(UserRepository):
    def __init__(self, db_session):
        self.db_session = db_session
    
    def save(self, user: User) -> User:
        # SQL логика сохранения
        if user.id:
            # Обновление
            db_user = self.db_session.query(UserModel).filter_by(id=user.id).first()
            db_user.email = user.email
            db_user.name = user.name
            db_user.is_active = user.is_active
        else:
            # Создание
            db_user = UserModel(
                email=user.email,
                name=user.name,
                is_active=user.is_active
            )
            self.db_session.add(db_user)
        
        self.db_session.commit()
        
        # Конвертируем обратно в доменную модель
        return User(
            email=db_user.email,
            name=db_user.name,
            user_id=db_user.id
        )
    
    def find_by_id(self, user_id: int) -> Optional[User]:
        db_user = self.db_session.query(UserModel).filter_by(id=user_id).first()
        if not db_user:
            return None
        
        return User(
            email=db_user.email,
            name=db_user.name,
            user_id=db_user.id
        )
    
    def find_by_email(self, email: str) -> Optional[User]:
        db_user = self.db_session.query(UserModel).filter_by(email=email).first()
        if not db_user:
            return None
        
        return User(
            email=db_user.email,
            name=db_user.name,
            user_id=db_user.id
        )

class SmtpEmailService(EmailService):
    def __init__(self, smtp_config):
        self.smtp_config = smtp_config
    
    def send_welcome_email(self, email: str, name: str) -> bool:
        try:
            # SMTP логика отправки
            subject = f"Welcome, {name}!"
            body = f"Hello {name}, welcome to our platform!"
            
            # Здесь код отправки через SMTP
            return True
        except Exception:
            return False

class PushNotificationService(NotificationService):
    def __init__(self, push_service_url):
        self.push_service_url = push_service_url
    
    def send_notification(self, user_id: int, message: str) -> bool:
        try:
            # Логика отправки push уведомления
            payload = {
                "user_id": user_id,
                "message": message
            }
            # HTTP запрос к сервису уведомлений
            return True
        except Exception:
            return False

# Тестирование доменной логики (изолированно)
class TestUserDomainLogic:
    def test_user_deactivation(self):
        """Тестируем чистую бизнес-логику без зависимостей"""
        user = User(email="test@example.com", name="Test User", user_id=1)
        
        # Пользователь активен по умолчанию
        assert user.is_active is True
        
        # Деактивируем
        user.deactivate()
        assert user.is_active is False
        
        # Повторная деактивация должна вызвать ошибку
        with pytest.raises(ValueError, match="already inactive"):
            user.deactivate()
    
    def test_user_profile_update_validation(self):
        """Тестируем валидацию обновления профиля"""
        user = User(email="test@example.com", name="Test User")
        
        # Валидное обновление
        user.update_profile(name="New Name", email="new@example.com")
        assert user.name == "New Name"
        assert user.email == "new@example.com"
        
        # Невалидное имя
        with pytest.raises(ValueError, match="at least 2 characters"):
            user.update_profile(name="A")
        
        # Невалидный email
        with pytest.raises(ValueError, match="Invalid email format"):
            user.update_profile(email="invalid-email")

# Тестирование сервисов приложения с моками
class TestUserService:
    @pytest.fixture
    def mock_dependencies(self):
        return {
            'user_repository': Mock(spec=UserRepository),
            'email_service': Mock(spec=EmailService), 
            'notification_service': Mock(spec=NotificationService)
        }
    
    @pytest.fixture
    def user_service(self, mock_dependencies):
        return UserService(**mock_dependencies)
    
    def test_register_user_success(self, user_service, mock_dependencies):
        """Тестируем успешную регистрацию пользователя"""
        # Arrange
        mock_dependencies['user_repository'].find_by_email.return_value = None
        mock_dependencies['user_repository'].save.return_value = User(
            email="test@example.com", 
            name="Test User", 
            user_id=1
        )
        mock_dependencies['email_service'].send_welcome_email.return_value = True
        mock_dependencies['notification_service'].send_notification.return_value = True
        
        # Act
        user = user_service.register_user("test@example.com", "Test User")
        
        # Assert
        assert user.email == "test@example.com"
        assert user.name == "Test User"
        assert user.id == 1
        
        # Проверяем вызовы зависимостей
        mock_dependencies['user_repository'].find_by_email.assert_called_once_with("test@example.com")
        mock_dependencies['user_repository'].save.assert_called_once()
        mock_dependencies['email_service'].send_welcome_email.assert_called_once_with("test@example.com", "Test User")
        mock_dependencies['notification_service'].send_notification.assert_called_once()
    
    def test_register_user_duplicate_email(self, user_service, mock_dependencies):
        """Тестируем регистрацию с существующим email"""
        # Arrange
        existing_user = User(email="test@example.com", name="Existing User", user_id=999)
        mock_dependencies['user_repository'].find_by_email.return_value = existing_user
        
        # Act & Assert
        with pytest.raises(ValueError, match="already exists"):
            user_service.register_user("test@example.com", "Test User")
        
        # Email сервис не должен вызываться
        mock_dependencies['email_service'].send_welcome_email.assert_not_called()
    
    def test_update_user_profile_success(self, user_service, mock_dependencies):
        """Тестируем успешное обновление профиля"""
        # Arrange
        existing_user = User(email="old@example.com", name="Old Name", user_id=1)
        mock_dependencies['user_repository'].find_by_id.return_value = existing_user
        mock_dependencies['user_repository'].find_by_email.return_value = None  # Email свободен
        
        updated_user = User(email="new@example.com", name="New Name", user_id=1)
        mock_dependencies['user_repository'].save.return_value = updated_user
        
        # Act
        result = user_service.update_user_profile(1, name="New Name", email="new@example.com")
        
        # Assert
        assert result.name == "New Name"
        assert result.email == "new@example.com"
        mock_dependencies['user_repository'].save.assert_called_once()

# Интеграционные тесты с реальными адаптерами
class TestUserServiceIntegration:
    @pytest.fixture
    def real_dependencies(self, db_session):
        return {
            'user_repository': SqlUserRepository(db_session),
            'email_service': Mock(spec=EmailService),  # Мокаем внешние сервисы
            'notification_service': Mock(spec=NotificationService)
        }
    
    @pytest.fixture
    def user_service(self, real_dependencies):
        return UserService(**real_dependencies)
    
    def test_user_registration_end_to_end(self, user_service, real_dependencies):
        """Интеграционный тест регистрации с реальной БД"""
        # Arrange
        real_dependencies['email_service'].send_welcome_email.return_value = True
        real_dependencies['notification_service'].send_notification.return_value = True
        
        # Act
        user = user_service.register_user("integration@example.com", "Integration User")
        
        # Assert
        assert user.id is not None
        assert user.email == "integration@example.com"
        
        # Проверяем что пользователь действительно сохранен в БД
        found_user = real_dependencies['user_repository'].find_by_id(user.id)
        assert found_user is not None
        assert found_user.email == "integration@example.com"
        
        # Проверяем что внешние сервисы были вызваны
        real_dependencies['email_service'].send_welcome_email.assert_called_once()
```

**Go пример тестируемой архитектуры:**
```go
// Интерфейсы (порты)
package domain

import "context"

type User struct {
    ID       int    `json:"id"`
    Email    string `json:"email"`
    Name     string `json:"name"`
    IsActive bool   `json:"is_active"`
}

type UserRepository interface {
    Save(ctx context.Context, user *User) (*User, error)
    FindByID(ctx context.Context, id int) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
}

type EmailService interface {
    SendWelcomeEmail(ctx context.Context, email, name string) error
}

type NotificationService interface {
    SendNotification(ctx context.Context, userID int, message string) error
}

// Доменная логика
func (u *User) Deactivate() error {
    if !u.IsActive {
        return errors.New("user is already inactive")
    }
    u.IsActive = false
    return nil
}

func (u *User) UpdateProfile(name, email string) error {
    if name != "" {
        if len(strings.TrimSpace(name)) < 2 {
            return errors.New("name must be at least 2 characters")
        }
        u.Name = strings.TrimSpace(name)
    }
    
    if email != "" {
        if !strings.Contains(email, "@") {
            return errors.New("invalid email format")
        }
        u.Email = strings.ToLower(email)
    }
    
    return nil
}

// Сервис приложения
type UserService struct {
    userRepo     UserRepository
    emailSvc     EmailService
    notifSvc     NotificationService
}

func NewUserService(userRepo UserRepository, emailSvc EmailService, notifSvc NotificationService) *UserService {
    return &UserService{
        userRepo: userRepo,
        emailSvc: emailSvc,
        notifSvc: notifSvc,
    }
}

func (s *UserService) RegisterUser(ctx context.Context, email, name string) (*User, error) {
    // Проверяем существование пользователя
    existingUser, err := s.userRepo.FindByEmail(ctx, email)
    if err != nil {
        return nil, fmt.Errorf("failed to check existing user: %w", err)
    }
    if existingUser != nil {
        return nil, errors.New("user with this email already exists")
    }
    
    // Создаем пользователя
    user := &User{
        Email:    email,
        Name:     name,
        IsActive: true,
    }
    
    // Сохраняем
    savedUser, err := s.userRepo.Save(ctx, user)
    if err != nil {
        return nil, fmt.Errorf("failed to save user: %w", err)
    }
    
    // Отправляем welcome email (не критично для успеха операции)
    if err := s.emailSvc.SendWelcomeEmail(ctx, savedUser.Email, savedUser.Name); err != nil {
        // Логируем ошибку, но не прерываем выполнение
        log.Printf("Failed to send welcome email: %v", err)
    }
    
    // Отправляем уведомление
    if err := s.notifSvc.SendNotification(ctx, savedUser.ID, "Welcome to our platform!"); err != nil {
        log.Printf("Failed to send notification: %v", err)
    }
    
    return savedUser, nil
}

func (s *UserService) UpdateUserProfile(ctx context.Context, userID int, name, email string) (*User, error) {
    user, err := s.userRepo.FindByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to find user: %w", err)
    }
    if user == nil {
        return nil, errors.New("user not found")
    }
    
    // Если меняется email, проверяем уникальность
    if email != "" && email != user.Email {
        existingUser, err := s.userRepo.FindByEmail(ctx, email)
        if err != nil {
            return nil, fmt.Errorf("failed to check email uniqueness: %w", err)
        }
        if existingUser != nil {
            return nil, errors.New("email already taken")
        }
    }
    
    // Обновляем профиль (доменная логика)
    if err := user.UpdateProfile(name, email); err != nil {
        return nil, fmt.Errorf("profile update failed: %w", err)
    }
    
    // Сохраняем изменения
    updatedUser, err := s.userRepo.Save(ctx, user)
    if err != nil {
        return nil, fmt.Errorf("failed to save updated user: %w", err)
    }
    
    return updatedUser, nil
}

// Тесты доменной логики
func TestUserDomainLogic(t *testing.T) {
    t.Run("User deactivation", func(t *testing.T) {
        user := &User{
            ID:       1,
            Email:    "test@example.com",
            Name:     "Test User",
            IsActive: true,
        }
        
        // Деактивируем пользователя
        err := user.Deactivate()
        assert.NoError(t, err)
        assert.False(t, user.IsActive)
        
        // Повторная деактивация должна вызвать ошибку
        err = user.Deactivate()
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "already inactive")
    })
    
    t.Run("Profile update validation", func(t *testing.T) {
        user := &User{
            Email: "test@example.com",
            Name:  "Test User",
        }
        
        // Валидное обновление
        err := user.UpdateProfile("New Name", "new@example.com")
        assert.NoError(t, err)
        assert.Equal(t, "New Name", user.Name)
        assert.Equal(t, "new@example.com", user.Email)
        
        // Невалидное имя
        err = user.UpdateProfile("A", "")
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "at least 2 characters")
        
        // Невалидный email
        err = user.UpdateProfile("", "invalid-email")
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "invalid email format")
    })
}

// Моки для тестирования
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Save(ctx context.Context, user *User) (*User, error) {
    args := m.Called(ctx, user)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) FindByID(ctx context.Context, id int) (*User, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

func (m *MockUserRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    args := m.Called(ctx, email)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*User), args.Error(1)
}

type MockEmailService struct {
    mock.Mock
}

func (m *MockEmailService) SendWelcomeEmail(ctx context.Context, email, name string) error {
    args := m.Called(ctx, email, name)
    return args.Error(0)
}

type MockNotificationService struct {
    mock.Mock
}

func (m *MockNotificationService) SendNotification(ctx context.Context, userID int, message string) error {
    args := m.Called(ctx, userID, message)
    return args.Error(0)
}

// Тесты сервиса с моками
func TestUserService(t *testing.T) {
    setup := func() (*UserService, *MockUserRepository, *MockEmailService, *MockNotificationService) {
        mockRepo := new(MockUserRepository)
        mockEmail := new(MockEmailService)
        mockNotif := new(MockNotificationService)
        
        service := NewUserService(mockRepo, mockEmail, mockNotif)
        return service, mockRepo, mockEmail, mockNotif
    }
    
    t.Run("Register user success", func(t *testing.T) {
        service, mockRepo, mockEmail, mockNotif := setup()
        ctx := context.Background()
        
        // Arrange
        mockRepo.On("FindByEmail", ctx, "test@example.com").Return((*User)(nil), nil)
        expectedUser := &User{ID: 1, Email: "test@example.com", Name: "Test User", IsActive: true}
        mockRepo.On("Save", ctx, mock.AnythingOfType("*domain.User")).Return(expectedUser, nil)
        mockEmail.On("SendWelcomeEmail", ctx, "test@example.com", "Test User").Return(nil)
        mockNotif.On("SendNotification", ctx, 1, "Welcome to our platform!").Return(nil)
        
        // Act
        user, err := service.RegisterUser(ctx, "test@example.com", "Test User")
        
        // Assert
        assert.NoError(t, err)
        assert.Equal(t, 1, user.ID)
        assert.Equal(t, "test@example.com", user.Email)
        assert.Equal(t, "Test User", user.Name)
        assert.True(t, user.IsActive)
        
        mockRepo.AssertExpectations(t)
        mockEmail.AssertExpectations(t)
        mockNotif.AssertExpectations(t)
    })
    
    t.Run("Register user with duplicate email", func(t *testing.T) {
        service, mockRepo, mockEmail, mockNotif := setup()
        ctx := context.Background()
        
        // Arrange
        existingUser := &User{ID: 999, Email: "test@example.com", Name: "Existing User"}
        mockRepo.On("FindByEmail", ctx, "test@example.com").Return(existingUser, nil)
        
        // Act
        user, err := service.RegisterUser(ctx, "test@example.com", "Test User")
        
        // Assert
        assert.Error(t, err)
        assert.Nil(t, user)
        assert.Contains(t, err.Error(), "already exists")
        
        // Email и notification сервисы не должны вызываться
        mockEmail.AssertNotCalled(t, "SendWelcomeEmail")
        mockNotif.AssertNotCalled(t, "SendNotification")
    })
    
    t.Run("Update user profile success", func(t *testing.T) {
        service, mockRepo, mockEmail, mockNotif := setup()
        ctx := context.Background()
        
        // Arrange
        existingUser := &User{ID: 1, Email: "old@example.com", Name: "Old Name", IsActive: true}
        mockRepo.On("FindByID", ctx, 1).Return(existingUser, nil)
        mockRepo.On("FindByEmail", ctx, "new@example.com").Return((*User)(nil), nil)
        
        updatedUser := &User{ID: 1, Email: "new@example.com", Name: "New Name", IsActive: true}
        mockRepo.On("Save", ctx, mock.AnythingOfType("*domain.User")).Return(updatedUser, nil)
        
        // Act
        user, err := service.UpdateUserProfile(ctx, 1, "New Name", "new@example.com")
        
        // Assert
        assert.NoError(t, err)
        assert.Equal(t, "New Name", user.Name)
        assert.Equal(t, "new@example.com", user.Email)
        
        mockRepo.AssertExpectations(t)
    })
}

// Интеграционные тесты
func TestUserServiceIntegration(t *testing.T) {
    // Настройка тестовой базы данных
    testDB := setupTestDatabase(t)
    defer testDB.Cleanup(t)
    
    // Реальные адаптеры
    realRepo := NewSQLUserRepository(testDB.DB)
    mockEmail := new(MockEmailService)
    mockNotif := new(MockNotificationService)
    
    service := NewUserService(realRepo, mockEmail, mockNotif)
    
    t.Run("End-to-end user registration", func(t *testing.T) {
        ctx := context.Background()
        
        // Arrange
        mockEmail.On("SendWelcomeEmail", ctx, "integration@example.com", "Integration User").Return(nil)
        mockNotif.On("SendNotification", ctx, mock.AnythingOfType("int"), "Welcome to our platform!").Return(nil)
        
        // Act
        user, err := service.RegisterUser(ctx, "integration@example.com", "Integration User")
        
        // Assert
        assert.NoError(t, err)
        assert.NotZero(t, user.ID)
        assert.Equal(t, "integration@example.com", user.Email)
        
        // Проверяем что пользователь действительно сохранен в БД
        foundUser, err := realRepo.FindByID(ctx, user.ID)
        assert.NoError(t, err)
        assert.NotNil(t, foundUser)
        assert.Equal(t, "integration@example.com", foundUser.Email)
        
        mockEmail.AssertExpectations(t)
        mockNotif.AssertExpectations(t)
    })
}
```

### 🔧 Legacy код и рефакторинг

**Стратегия работы с legacy кодом:**
```
1. Characterization Tests → Покрываем существующее поведение
2. Seam identification → Находим точки для внедрения тестов
3. Strangler Fig → Постепенно заменяем старый код
4. Golden Master → Сохраняем текущий вывод как эталон
```

**Python Legacy код тестирование:**
```python
# legacy_system.py - старый монолитный код без тестов
class LegacyOrderProcessor:
    """Старый код без тестов, который нужно рефакторить"""
    
    def __init__(self):
        self.db_connection = None
        self.email_client = None
        self.payment_gateway = None
    
    def process_order(self, order_data):
        """Огромный метод который делает все"""
        try:
            # Валидация заказа (смешана с бизнес-логикой)
            if not order_data.get('customer_id'):
                return {'error': 'Missing customer ID', 'status': 'failed'}
            
            if not order_data.get('items') or len(order_data['items']) == 0:
                return {'error': 'No items in order', 'status': 'failed'}
            
            # Расчет цены (сложная логика)
            total_price = 0
            for item in order_data['items']:
                base_price = item['price'] * item['quantity']
                
                # Скидки (хардкод)
                if item['category'] == 'electronics':
                    discount = 0.1 if base_price > 1000 else 0.05
                elif item['category'] == 'books':
                    discount = 0.15 if item['quantity'] > 5 else 0.1
                else:
                    discount = 0.05
                
                # Налоги (зависит от региона)
                customer_region = self._get_customer_region(order_data['customer_id'])
                if customer_region == 'CA':
                    tax_rate = 0.13
                elif customer_region == 'NY':
                    tax_rate = 0.08
                else:
                    tax_rate = 0.06
                
                item_total = base_price * (1 - discount) * (1 + tax_rate)
                total_price += item_total
            
            # Обработка платежа (внешний сервис)
            payment_result = self._process_payment(order_data['customer_id'], total_price)
            if not payment_result['success']:
                return {'error': 'Payment failed', 'status': 'payment_failed'}
            
            # Сохранение в базу (прямые SQL запросы)
            order_id = self._save_order_to_database(order_data, total_price, payment_result['transaction_id'])
            
            # Отправка email (жестко закодировано)
            self._send_confirmation_email(order_data['customer_id'], order_id, total_price)
            
            # Обновление инвентаря
            self._update_inventory(order_data['items'])
            
            return {
                'status': 'success',
                'order_id': order_id,
                'total_price': total_price,
                'transaction_id': payment_result['transaction_id']
            }
            
        except Exception as e:
            # Плохая обработка ошибок
            return {'error': str(e), 'status': 'error'}
    
    def _get_customer_region(self, customer_id):
        # Прямое обращение к БД
        cursor = self.db_connection.cursor()
        cursor.execute("SELECT region FROM customers WHERE id = %s", (customer_id,))
        result = cursor.fetchone()
        return result[0] if result else 'US'
    
    def _process_payment(self, customer_id, amount):
        # Вызов внешнего сервиса
        import requests
        response = requests.post('https://payment-gateway.com/charge', {
            'customer_id': customer_id,
            'amount': amount
        })
        return response.json()
    
    def _save_order_to_database(self, order_data, total_price, transaction_id):
        # Прямые SQL запросы
        cursor = self.db_connection.cursor()
        cursor.execute("""
            INSERT INTO orders (customer_id, total_price, transaction_id, status)
            VALUES (%s, %s, %s, 'confirmed')
            RETURNING id
        """, (order_data['customer_id'], total_price, transaction_id))
        
        order_id = cursor.fetchone()[0]
        
        for item in order_data['items']:
            cursor.execute("""
                INSERT INTO order_items (order_id, product_id, quantity, price)
                VALUES (%s, %s, %s, %s)
            """, (order_id, item['product_id'], item['quantity'], item['price']))
        
        self.db_connection.commit()
        return order_id
    
    def _send_confirmation_email(self, customer_id, order_id, total_price):
        # Жестко закодированная отправка email
        pass
    
    def _update_inventory(self, items):
        # Обновление остатков товара
        cursor = self.db_connection.cursor()
        for item in items:
            cursor.execute("""
                UPDATE products SET stock = stock - %s WHERE id = %s
            """, (item['quantity'], item['product_id']))
        self.db_connection.commit()

# Шаг 1: Characterization Tests (покрываем существующее поведение)
class TestLegacyOrderProcessorCharacterization:
    """Тесты которые документируют текущее поведение системы"""
    
    @pytest.fixture
    def legacy_processor(self):
        processor = LegacyOrderProcessor()
        # Мокаем зависимости для изоляции
        processor.db_connection = Mock()
        processor.email_client = Mock()
        processor.payment_gateway = Mock()
        return processor
    
    def test_valid_order_processing_golden_master(self, legacy_processor):
        """Golden master test - сохраняем текущий результат как эталон"""
        # Arrange
        order_data = {
            'customer_id': 123,
            'items': [
                {
                    'product_id': 1,
                    'price': 100.0,
                    'quantity': 2,
                    'category': 'electronics'
                },
                {
                    'product_id': 2,
                    'price': 50.0,
                    'quantity': 1,
                    'category': 'books'
                }
            ]
        }
        
        # Мокаем внешние зависимости для предсказуемого результата
        legacy_processor._get_customer_region = Mock(return_value='CA')
        legacy_processor._process_payment = Mock(return_value={
            'success': True,
            'transaction_id': 'txn_12345'
        })
        legacy_processor._save_order_to_database = Mock(return_value=999)
        legacy_processor._send_confirmation_email = Mock()
        legacy_processor._update_inventory = Mock()
        
        # Act
        result = legacy_processor.process_order(order_data)
        
        # Assert - сохраняем точный результат как "золотой стандарт"
        expected_result = {
            'status': 'success',
            'order_id': 999,
            'total_price': 237.825,  # Точное значение после всех расчетов
            'transaction_id': 'txn_12345'
        }
        
        assert result == expected_result
    
    def test_edge_cases_characterization(self, legacy_processor):
        """Документируем граничные случаи"""
        test_cases = [
            # Отсутствующий customer_id
            ({}, {'error': 'Missing customer ID', 'status': 'failed'}),
            
            # Пустой список товаров
            ({'customer_id': 123, 'items': []}, 
             {'error': 'No items in order', 'status': 'failed'}),
            
            # Отсутствующие товары
            ({'customer_id': 123}, 
             {'error': 'No items in order', 'status': 'failed'}),
        ]
        
        for order_data, expected_result in test_cases:
            result = legacy_processor.process_order(order_data)
            assert result == expected_result, f"Failed for input: {order_data}"
    
    @pytest.mark.parametrize("region,expected_tax_rate", [
        ('CA', 0.13),
        ('NY', 0.08),
        ('TX', 0.06),  # default case
        ('', 0.06),    # empty region
    ])
    def test_tax_calculation_by_region(self, legacy_processor, region, expected_tax_rate):
        """Документируем логику налогообложения"""
        order_data = {
            'customer_id': 123,
            'items': [{'product_id': 1, 'price': 100.0, 'quantity': 1, 'category': 'other'}]
        }
        
        legacy_processor._get_customer_region = Mock(return_value=region)
        legacy_processor._process_payment = Mock(return_value={'success': True, 'transaction_id': 'test'})
        legacy_processor._save_order_to_database = Mock(return_value=1)
        legacy_processor._send_confirmation_email = Mock()
        legacy_processor._update_inventory = Mock()
        
        result = legacy_processor.process_order(order_data)
        
        # Вычисляем ожидаемую цену: 100 * 0.95 (скидка 5%) * (1 + tax_rate)
        expected_price = 100 * 0.95 * (1 + expected_tax_rate)
        assert abs(result['total_price'] - expected_price) < 0.01

# Шаг 2: Выделение Seam'ов для рефакторинга
class OrderCalculator:
    """Выделяем логику расчетов в отдельный класс"""
    
    @staticmethod
    def calculate_item_discount(item):
        """Извлекаем логику скидок"""
        base_price = item['price'] * item['quantity']
        
        if item['category'] == 'electronics':
            return 0.1 if base_price > 1000 else 0.05
        elif item['category'] == 'books':
            return 0.15 if item['quantity'] > 5 else 0.1
        else:
            return 0.05
    
    @staticmethod
    def calculate_tax_rate(region):
        """Извлекаем логику налогов"""
        tax_rates = {
            'CA': 0.13,
            'NY': 0.08
        }
        return tax_rates.get(region, 0.06)
    
    @staticmethod
    def calculate_total_price(items, customer_region):
        """Извлекаем общую логику расчета"""
        total_price = 0
        tax_rate = OrderCalculator.calculate_tax_rate(customer_region)
        
        for item in items:
            base_price = item['price'] * item['quantity']
            discount = OrderCalculator.calculate_item_discount(item)
            item_total = base_price * (1 - discount) * (1 + tax_rate)
            total_price += item_total
        
        return total_price

# Шаг 3: Тестируем новые компоненты изолированно
class TestOrderCalculator:
    """Тестируем извлеченную логику"""
    
    def test_item_discount_calculation(self):
        """Тестируем логику скидок"""
        test_cases = [
            # Electronics
            ({'price': 100, 'quantity': 20, 'category': 'electronics'}, 0.1),  # > 1000
            ({'price': 100, 'quantity': 5, 'category': 'electronics'}, 0.05),   # <= 1000
            
            # Books
            ({'price': 10, 'quantity': 10, 'category': 'books'}, 0.15),  # > 5 qty
            ({'price': 10, 'quantity': 3, 'category': 'books'}, 0.1),    # <= 5 qty
            
            # Other
            ({'price': 50, 'quantity': 1, 'category': 'other'}, 0.05),
        ]
        
        for item, expected_discount in test_cases:
            discount = OrderCalculator.calculate_item_discount(item)
            assert discount == expected_discount
    
    def test_tax_rate_calculation(self):
        """Тестируем расчет налогов"""
        assert OrderCalculator.calculate_tax_rate('CA') == 0.13
        assert OrderCalculator.calculate_tax_rate('NY') == 0.08
        assert OrderCalculator.calculate_tax_rate('TX') == 0.06  # default
        assert OrderCalculator.calculate_tax_rate('') == 0.06    # default
    
    def test_total_price_calculation(self):
        """Тестируем общий расчет цены"""
        items = [
            {'price': 100, 'quantity': 1, 'category': 'electronics'},
            {'price': 20, 'quantity': 2, 'category': 'books'}
        ]
        
        total = OrderCalculator.calculate_total_price(items, 'CA')
        
        # Electronics: 100 * 0.95 * 1.13 = 107.35
        # Books: 40 * 0.9 * 1.13 = 40.68
        # Total: 148.03
        expected_total = 107.35 + 40.68
        assert abs(total - expected_total) < 0.01

# Шаг 4: Постепенная замена (Strangler Fig)
class RefactoredOrderProcessor:
    """Новая версия с улучшенной архитектурой"""
    
    def __init__(self, customer_repo, payment_service, order_repo, email_service, inventory_service):
        self.customer_repo = customer_repo
        self.payment_service = payment_service
        self.order_repo = order_repo
        self.email_service = email_service
        self.inventory_service = inventory_service
        self.calculator = OrderCalculator()
    
    def process_order(self, order_data):
        """Рефакторенная версия с четким разделением ответственности"""
        try:
            # Валидация
            validation_result = self._validate_order(order_data)
            if not validation_result['valid']:
                return {'error': validation_result['error'], 'status': 'failed'}
            
            # Получение данных клиента
            customer = self.customer_repo.find_by_id(order_data['customer_id'])
            if not customer:
                return {'error': 'Customer not found', 'status': 'failed'}
            
            # Расчет цены
            total_price = self.calculator.calculate_total_price(
                order_data['items'], 
                customer.region
            )
            
            # Обработка платежа
            payment_result = self.payment_service.process_payment(
                customer.id, 
                total_price
            )
            if not payment_result.success:
                return {'error': 'Payment failed', 'status': 'payment_failed'}
            
            # Создание заказа
            order = self.order_repo.create_order(
                customer_id=customer.id,
                items=order_data['items'],
                total_price=total_price,
                transaction_id=payment_result.transaction_id
            )
            
            # Отправка уведомления
            self.email_service.send_order_confirmation(customer.email, order)
            
            # Обновление инвентаря
            self.inventory_service.reserve_items(order_data['items'])
            
            return {
                'status': 'success',
                'order_id': order.id,
                'total_price': total_price,
                'transaction_id': payment_result.transaction_id
            }
            
        except Exception as e:
            # Улучшенная обработка ошибок
            logger.error(f"Order processing failed: {e}")
            return {'error': 'Internal error', 'status': 'error'}
    
    def _validate_order(self, order_data):
        """Выделенная валидация"""
        if not order_data.get('customer_id'):
            return {'valid': False, 'error': 'Missing customer ID'}
        
        if not order_data.get('items') or len(order_data['items']) == 0:
            return {'valid': False, 'error': 'No items in order'}
        
        return {'valid': True}

# Шаг 5: Миграционные тесты (проверяем совместимость)
class TestLegacyToRefactoredMigration:
    """Проверяем что новая версия ведет себя также как старая"""
    
    @pytest.fixture
    def comparable_processors(self):
        """Создаем сравнимые версии процессоров"""
        # Legacy processor с моками
        legacy = LegacyOrderProcessor()
        legacy.db_connection = Mock()
        
        # Refactored processor с моками
        customer_repo = Mock()
        customer_repo.find_by_id.return_value = Mock(id=123, region='CA', email='test@example.com')
        
        payment_service = Mock()
        payment_service.process_payment.return_value = Mock(
            success=True, 
            transaction_id='txn_12345'
        )
        
        order_repo = Mock()
        order_repo.create_order.return_value = Mock(id=999)
        
        email_service = Mock()
        inventory_service = Mock()
        
        refactored = RefactoredOrderProcessor(
            customer_repo, payment_service, order_repo, email_service, inventory_service
        )
        
        return legacy, refactored
    
    def test_behavior_parity(self, comparable_processors):
        """Проверяем что результаты идентичны"""
        legacy, refactored = comparable_processors
        
        # Мокаем методы legacy для предсказуемости
        legacy._get_customer_region = Mock(return_value='CA')
        legacy._process_payment = Mock(return_value={
            'success': True,
            'transaction_id': 'txn_12345'
        })
        legacy._save_order_to_database = Mock(return_value=999)
        legacy._send_confirmation_email = Mock()
        legacy._update_inventory = Mock()
        
        order_data = {
            'customer_id': 123,
            'items': [
                {'product_id': 1, 'price': 100.0, 'quantity': 1, 'category': 'electronics'}
            ]
        }
        
        # Выполняем обработку в обеих версиях
        legacy_result = legacy.process_order(order_data)
        refactored_result = refactored.process_order(order_data)
        
        # Результаты должны быть идентичными
        assert legacy_result['status'] == refactored_result['status']
        assert legacy_result['order_id'] == refactored_result['order_id']
        assert abs(legacy_result['total_price'] - refactored_result['total_price']) < 0.01
        assert legacy_result['transaction_id'] == refactored_result['transaction_id']
```

### 👥 Командные практики тестирования

**Code Review Guidelines для тестов:**
```python
# code_review_checklist.py
"""
Чеклист для Code Review тестов:

✅ Покрытие:
   - Покрывают ли тесты новый функционал?
   - Есть ли тесты для граничных случаев?
   - Протестированы ли ошибочные сценарии?

✅ Читаемость:
   - Понятны ли имена тестов?
   - Следует ли структура AAA (Arrange-Act-Assert)?
   - Есть ли комментарии для сложной логики?

✅ Независимость:
   - Могут ли тесты выполняться в любом порядке?
   - Не зависят ли тесты друг от друга?
   - Очищается ли состояние после тестов?

✅ Производительность:
   - Выполняются ли тесты быстро?
   - Используются ли моки для внешних зависимостей?
   - Нет ли избыточных операций?

✅ Поддерживаемость:
   - Легко ли понять что тестируется?
   - Легко ли модифицировать тесты?
   - Нет ли дублирования в тестах?
"""

class TestCodeReviewExamples:
    """Примеры хороших и плохих практик для Code Review"""
    
    # ❌ ПЛОХО - неясное название теста
    def test_user_method(self):
        user = User("test@example.com")
        result = user.some_method()
        assert result
    
    # ✅ ХОРОШО - описательное название
    def test_user_activation_sends_welcome_email_when_user_is_inactive(self):
        # Arrange
        user = User("test@example.com", is_active=False)
        email_service = Mock()
        user.email_service = email_service
        
        # Act
        user.activate()
        
        # Assert
        email_service.send_welcome_email.assert_called_once_with("test@example.com")
        assert user.is_active is True
    
    # ❌ ПЛОХО - тест зависит от внешнего состояния
    def test_user_count(self):
        # Полагается на существующих пользователей в БД
        count = UserService.get_user_count()
        UserService.create_user("new@example.com")
        new_count = UserService.get_user_count()
        assert new_count == count + 1
    
    # ✅ ХОРОШО - изолированный тест
    def test_user_count_increases_after_creating_user(self):
        # Arrange
        user_repo = Mock()
        user_repo.count.side_effect = [5, 6]  # До и после создания
        user_repo.save.return_value = User("new@example.com", user_id=1)
        
        user_service = UserService(user_repo)
        
        # Act
        initial_count = user_service.get_user_count()
        user_service.create_user("new@example.com")
        final_count = user_service.get_user_count()
        
        # Assert
        assert final_count == initial_count + 1
    
    # ❌ ПЛОХО - слишком сложный тест
    def test_complex_order_processing(self):
        # Создаем 10 пользователей, 20 товаров, 5 заказов...
        # 50 строк setup кода
        # Множественные assertions
        pass
    
    # ✅ ХОРОШО - фокусированный тест
    def test_order_total_calculation_includes_tax(self):
        # Arrange
        items = [OrderItem(price=100, quantity=1)]
        tax_calculator = Mock()
        tax_calculator.calculate_tax.return_value = 8.0
        
        order = Order(items, tax_calculator)
        
        # Act
        total = order.calculate_total()
        
        # Assert
        assert total == 108.0
        tax_calculator.calculate_tax.assert_called_once_with(100)

# Инструменты для командной работы
class TestingMetrics:
    """Метрики для отслеживания качества тестов"""
    
    @staticmethod
    def calculate_test_coverage(source_dir, test_dir):
        """Вычисляет покрытие кода тестами"""
        import coverage
        
        cov = coverage.Coverage()
        cov.start()
        
        # Запускаем тесты
        import subprocess
        subprocess.run(['pytest', test_dir])
        
        cov.stop()
        cov.save()
        
        # Получаем отчет
        report = cov.report(show_missing=True)
        return report
    
    @staticmethod
    def analyze_test_performance():
        """Анализирует производительность тестов"""
        import time
        import pytest
        
        # Запускаем тесты с профилированием
        start_time = time.time()
        pytest.main(['--durations=10', '--tb=short'])
        total_time = time.time() - start_time
        
        return {
            'total_execution_time': total_time,
            'recommendation': 'fast' if total_time < 60 else 'optimize'
        }
    
    @staticmethod
    def detect_flaky_tests(test_runs=10):
        """Обнаруживает нестабильные тесты"""
        import subprocess
        
        results = []
        for i in range(test_runs):
            result = subprocess.run(['pytest', '--tb=no'], capture_output=True)
            results.append(result.returncode == 0)
        
        success_rate = sum(results) / len(results)
        
        if success_rate < 1.0:
            return {
                'flaky_detected': True,
                'success_rate': success_rate,
                'recommendation': 'investigate failing tests'
            }
        
        return {'flaky_detected': False, 'success_rate': 1.0}

# Автоматизация качества тестов
class TestQualityGate:
    """Автоматические проверки качества тестов"""
    
    def __init__(self, min_coverage=80, max_test_time=300):
        self.min_coverage = min_coverage
        self.max_test_time = max_test_time
    
    def check_quality_gates(self):
        """Проверяет все gates качества"""
        results = {
            'coverage': self._check_coverage(),
            'performance': self._check_performance(),
            'style': self._check_test_style(),
            'dependencies': self._check_test_dependencies()
        }
        
        all_passed = all(result['passed'] for result in results.values())
        
        return {
            'overall_status': 'PASSED' if all_passed else 'FAILED',
            'details': results
        }
    
    def _check_coverage(self):
        """Проверяет покрытие кода"""
        coverage_report = TestingMetrics.calculate_test_coverage('src/', 'tests/')
        
        return {
            'passed': coverage_report >= self.min_coverage,
            'actual': coverage_report,
            'required': self.min_coverage,
            'message': f"Coverage: {coverage_report}% (required: {self.min_coverage}%)"
        }
    
    def _check_performance(self):
        """Проверяет время выполнения тестов"""
        perf_data = TestingMetrics.analyze_test_performance()
        
        return {
            'passed': perf_data['total_execution_time'] <= self.max_test_time,
            'actual': perf_data['total_execution_time'],
            'required': self.max_test_time,
            'message': f"Test execution: {perf_data['total_execution_time']:.1f}s (max: {self.max_test_time}s)"
        }
    
    def _check_test_style(self):
        """Проверяет стиль написания тестов"""
        # Проверяем соглашения об именовании
        import ast
        import os
        
        issues = []
        for root, dirs, files in os.walk('tests/'):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    issues.extend(self._analyze_test_file(file_path))
        
        return {
            'passed': len(issues) == 0,
            'issues': issues,
            'message': f"Style issues found: {len(issues)}"
        }
    
    def _analyze_test_file(self, file_path):
        """Анализирует отдельный файл с тестами"""
        with open(file_path, 'r') as f:
            content = f.read()
        
        try:
            tree = ast.parse(content)
        except SyntaxError:
            return [f"Syntax error in {file_path}"]
        
        issues = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name.startswith('test_'):
                # Проверяем длину имени теста
                if len(node.name) < 10:
                    issues.append(f"Test name too short: {node.name} in {file_path}")
                
                # Проверяем наличие docstring
                if not ast.get_docstring(node):
                    issues.append(f"Missing docstring: {node.name} in {file_path}")
                
                # Проверяем структуру теста (хотя бы один assert)
                has_assert = any(
                    isinstance(child, ast.Assert) 
                    for child in ast.walk(node)
                )
                if not has_assert:
                    issues.append(f"No assertions found: {node.name} in {file_path}")
        
        return issues
    
    def _check_test_dependencies(self):
        """Проверяет зависимости между тестами"""
        flaky_analysis = TestingMetrics.detect_flaky_tests()
        
        return {
            'passed': not flaky_analysis['flaky_detected'],
            'success_rate': flaky_analysis['success_rate'],
            'message': f"Test stability: {flaky_analysis['success_rate']:.1%}"
        }
```

---

## 🎯 Заключение: Путь от новичка к эксперту

### 📊 Прогресс по уровням

**Уровень Новичок (Недели 1-6):**
```
✅ Понимание пирамиды тестирования
✅ Написание базовых юнит-тестов  
✅ Использование AAA паттерна
✅ Мокирование простых зависимостей
✅ Запуск тестов в IDE/командной строке

Метрики успеха:
- Покрытие кода >70%
- Время выполнения тестов <30 секунд
- Понимание красного-зеленого цикла TDD
```

**Уровень Средний (Недели 7-12):**
```
✅ Интеграционные тесты с реальными БД
✅ API тестирование REST/GraphQL
✅ Применение TDD в ежедневной работе
✅ Настройка CI/CD пайплайнов
✅ Работа с test containers

Метрики успеха:
- Покрытие >85% с качественными тестами
- Автоматические тесты в CI/CD
- Время обратной связи <5 минут
- Стабильные тесты (>99% success rate)
```

**Уровень Продвинутый (Недели 13-18):**
```
✅ Нагрузочное тестирование
✅ Тестирование безопасности
✅ Property-based тесты
✅ Mutation тестирование
✅ Архитектура для тестируемости

Метрики успеха:
- Тесты находят >90% багов до продакшена
- SLA производительности соблюдается
- Покрытие мутационных тестов >80%
- Zero security vulnerabilities
```

**Уровень Эксперт (Недели 19-26):**
```
✅ Chaos Engineering
✅ Рефакторинг legacy систем
✅ Обучение команды
✅ Создание тестовых фреймворков
✅ Метрики и улучшение процессов

Метрики успеха:
- Время восстановления после сбоев <10 минут
- Команда следует best practices
- Техдолг по тестам снижается
- ROI от тестирования >300%
```

### 🎭 Роли тестировщика на разных уровнях

```
Новичок      → Пишет тесты для своего кода
Средний      → Помогает команде с тестированием  
Продвинутый  → Влияет на архитектуру для тестируемости
Эксперт      → Формирует культуру качества в организации
```

### 🔧 Инструментарий по языкам

**Python Ecosystem:**
```
Testing:     pytest, unittest, nose2
Mocking:     unittest.mock, responses, VCR.py
Coverage:    coverage.py, pytest-cov
API:         requests, httpx, FastAPI TestClient
Load:        locust, molotov
Property:    hypothesis
Security:    bandit, safety
CI/CD:       GitHub Actions, GitLab CI, Jenkins
```

**Go Ecosystem:**
```
Testing:     testing, testify, ginkgo
Mocking:     testify/mock, gomock, counterfeiter
Coverage:    go test -cover, gocov
API:         httptest, net/http/httptest
Load:        vegeta, hey, bombardier
Property:    gopter
Security:    gosec, nancy
Containers:  testcontainers-go
CI/CD:       GitHub Actions, GitLab CI, Drone
```

**JavaScript/Node.js Ecosystem:**
```
Testing:     Jest, Mocha, Vitest
Mocking:     sinon, jest.mock, nock
API:         supertest, axios-mock-adapter
E2E:         Playwright, Cypress, Puppeteer
Load:        k6, Artillery
Property:    fast-check
Security:    npm audit, snyk
```

### 🏆 Лучшие практики для каждого уровня

**Новичок - Создание фундамента:**
```python
# Золотые правила для начинающих:

1. Один тест = одна проверка
def test_user_creation_sets_correct_email():
    user = User("test@example.com")
    assert user.email == "test@example.com"

def test_user_creation_sets_active_status():
    user = User("test@example.com") 
    assert user.is_active is True

2. Говорящие имена тестов
✅ test_calculate_total_price_with_discount_returns_discounted_amount()
❌ test_calculate()

3. AAA структура всегда
def test_something():
    # Arrange - подготовка
    # Act - действие  
    # Assert - проверка
```

**Средний - Расширение навыков:**
```python
# Паттерны для среднего уровня:

1. Фикстуры для переиспользования
@pytest.fixture
def sample_user():
    return User("test@example.com", "Test User")

2. Параметризованные тесты для edge cases
@pytest.mark.parametrize("age,expected", [
    (0, False),    # граница
    (17, False),   # ниже лимита
    (18, True),    # точно на границе
    (25, True),    # норма
    (150, True),   # верхняя граница
    (151, False)   # превышение
])
def test_age_validation(age, expected):
    assert is_valid_age(age) == expected

3. Интеграционные тесты с cleanup
def test_user_registration_integration(db_session):
    # Test with real database
    service = UserService(db_session)
    user = service.register("test@example.com")
    
    assert user.id is not None
    # Cleanup автоматический через фикстуру
```

**Продвинутый - Мастерство:**
```python
# Техники продвинутого уровня:

1. Property-based тестирование
@given(st.text(min_size=1), st.emails())
def test_user_invariants(name, email):
    user = User(email, name)
    # Инварианты которые ВСЕГДА должны быть true
    assert user.email == email.lower()
    assert len(user.name.strip()) > 0
    assert user.created_at <= datetime.now()

2. Contract тестирование
def test_user_service_contract():
    """Тест контракта между сервисами"""
    user_service = UserServicePact()
    
    # Ожидания от внешнего сервиса
    user_service.given("user exists") \
                .upon_receiving("get user request") \
                .with_request(method="GET", path="/users/123") \
                .will_respond_with(status=200, body=USER_SCHEMA)

3. Chaos Engineering
def test_system_resilience():
    with chaos_experiment("network_partition"):
        simulate_network_partition(duration=30)
        # Система должна восстановиться
        assert health_check_passes(timeout=60)
```

**Эксперт - Лидерство:**
```python
# Экспертные практики:

1. Создание DSL для тестов  
def test_complex_business_scenario():
    Given.user("john").with_balance(1000) \
         .And.product("laptop").costs(800) \
         .When.user_purchases_product() \
         .Then.user_balance_should_be(200) \
         .And.order_should_be_created() \
         .And.inventory_should_be_updated()

2. Метрики качества тестов
class TestMetrics:
    def mutation_score(self) -> float:
        """Процент убитых мутантов"""
        pass
    
    def flakiness_rate(self) -> float:
        """Процент нестабильных тестов"""
        pass
    
    def maintenance_burden(self) -> float:
        """Сложность поддержки тестов"""
        pass

3. Обучение команды
def create_testing_workshop():
    """Создание образовательных материалов"""
    return [
        "hands_on_tdd_session.py",
        "mocking_best_practices.py", 
        "performance_testing_guide.py",
        "code_review_checklist.md"
    ]
```

### 🚀 Roadmap развития на 6 месяцев

**Месяц 1-2: Основы**
```
Неделя 1: Настройка окружения и первые тесты
Неделя 2: TDD красно-зелено-рефакторинг
Неделя 3: Моки и стабы
Неделя 4: Структура тестов и именование
Неделя 5: Покрытие кода и метрики
Неделя 6: Параметризованные тесты
Неделя 7: Фикстуры и teardown
Неделя 8: Первые интеграционные тесты
```

**Месяц 3-4: Интеграция и автоматизация**
```
Неделя 9-10: API тестирование 
Неделя 11-12: База данных и контейнеры
Неделя 13-14: CI/CD пайплайны
Неделя 15-16: Тестовые окружения
```

**Месяц 5-6: Продвинутые техники**
```
Неделя 17-18: Нагрузочное тестирование
Неделя 19-20: Безопасность
Неделя 21-22: Property-based и Chaos
Неделя 23-24: Legacy рефакторинг
Неделя 25-26: Экспертиза и обучение
```

### 💡 Частые ошибки и как их избежать

**Ошибки новичков:**
```
❌ Тестирование implementation вместо behavior
✅ Фокус на том ЧТО делает код, а не КАК

❌ Слишком сложные тесты
✅ Один тест = одна концепция

❌ Зависимость между тестами  
✅ Каждый тест независим

❌ Плохие имена тестов
✅ Имя описывает сценарий полностью
```

**Ошибки среднего уровня:**
```
❌ Переиспользование production кода в тестах
✅ Тесты должны быть простыми

❌ Моки для всего подряд
✅ Мокать только внешние зависимости

❌ Игнорирование медленных тестов
✅ Постоянная оптимизация времени выполнения

❌ Отсутствие интеграционных тестов
✅ Баланс между unit и integration
```

**Ошибки продвинутых:**
```
❌ Чрезмерное усложнение архитектуры тестов
✅ Простота важнее элегантности

❌ Игнорирование flaky тестов
✅ Немедленное исправление нестабильных тестов

❌ Тестирование ради метрик покрытия
✅ Качество важнее количества

❌ Отсутствие документации процессов
✅ Описание всех практик и стандартов
```

### 🎓 Ресурсы для дальнейшего изучения

**Книги:**
```
📚 Обязательные:
- "Test Driven Development" - Kent Beck
- "Working Effectively with Legacy Code" - Michael Feathers  
- "Growing Object-Oriented Software, Guided by Tests" - Freeman & Pryce
- "The Art of Unit Testing" - Roy Osherove

📚 Продвинутые:
- "Building Microservices" - Sam Newman (тестирование микросервисов)
- "Release It!" - Michael Nygard (reliability testing)
- "Chaos Engineering" - Casey Rosenthal
```

**Онлайн ресурсы:**
```
🌐 Документация:
- pytest.org - документация pytest
- testcontainers.org - контейнеры для тестирования
- k6.io - нагрузочное тестирование

🌐 Блоги:
- martinfowler.com/testing - статьи Мартина Фаулера
- testingbot.com/blog - практические примеры
- Ministry of Testing - сообщество тестировщиков
```

**Практика:**
```
🛠️ Проекты для тренировки:
1. Todo API с полным покрытием тестами
2. E-commerce система с микросервисами  
3. Chat приложение с WebSocket тестированием
4. Legacy проект для рефакторинга

🛠️ Open Source участие:
- Внесение тестов в популярные проекты
- Создание тестовых утилит
- Участие в тестировании release candidates
```

### 🏁 Итоговые рекомендации

**Золотые правила тестирования:**

1. **Начинайте с простого** - не пытайтесь внедрить все сразу
2. **Тесты - это инвестиция** - они окупаются в долгосрочной перспективе  
3. **Качество важнее количества** - лучше 50 хороших тестов чем 500 плохих
4. **TDD меняет дизайн** - попробуйте хотя бы месяц писать тесты первыми
5. **Автоматизируйте все** - ручное тестирование не масштабируется
6. **Учитесь у команды** - делитесь знаниями и практиками
7. **Измеряйте эффективность** - следите за метриками и ROI
8. **Не бойтесь рефакторить тесты** - они тоже код и требуют ухода

**Путь к мастерству:**
```
Практика → Ошибки → Анализ → Улучшение → Обучение других → Экспертиза
    ↑                                                        ↓
    ←←←←←←←←←←←←← Непрерывное развитие ←←←←←←←←←←←←←←←←←←←←←←←←←
```

**Помните:** Тестирование - это не просто проверка кода, это инструмент для создания лучшего дизайна, повышения уверенности в системе и ускорения разработки. Мастерство приходит с опытом, но правильный фундамент поможет избежать многих ошибок на пути.

Удачи в изучении тестирования! 🧪✨

---

*"Любой код без тестов - legacy код с момента написания"* - Michael Feathers

*"Тесты - это не о поиске багов, это о дизайне ПО"* - Kent Beck

*"Лучшее время для написания тестов - вчера. Второе лучшее время - сейчас"* - Древняя программистская мудрость* 😄# 🧪 Полное руководство по тестированию для Backend разработчика
*От новичка до эксперта за 18-26 недель*

---

## 📚 Модуль 1: Основы тестирования (2-3 недели)

### 🎯 Зачем нужно тестирование?

**Стоимость исправления багов:**
```
Разработка    $1
Тестирование  $10  
Продакшен     $100
Пользователи  $1000
```

**Проблема без тестов:**
```
Изменение кода → Страх сломать что-то → Медленная разработка → Технический долг
```

**С тестами:**
```
Изменение кода → Запуск тестов → Уверенность → Быстрая итерация → Качественный код
```

### 🏗️ Пирамида тестирования

```
           /\
          /E2E\     ← 10% - Медленные, дорогие, хрупкие
         /------\     Полный пользовательский сценарий
        /        \
       /Integration\ ← 20% - Проверка взаимодействий
      /------------\   Слои, API, база данных
     /              \
    /   Unit Tests   \ ← 70% - Быстрые, надежные, изолированные  
   /------------------\  Функции, методы, классы
```

**Почему именно такая пропорция?**
- Unit тесты дают быстрый feedback
- Integration тесты проверяют совместную работу
- E2E тесты подтверждают пользовательские сценарии

### 🔄 Test-Driven Development (TDD)

```
1. Red (Красный)    → Пишем падающий тест
         ↓
2. Green (Зеленый)  → Минимальный код для прохождения  
         ↓
3. Refactor         → Улучшаем код, тесты остаются зелеными
         ↑
         └─────────────┘
```

**Python пример TDD:**
```python
# 1. RED - пишем тест (он падает)
def test_calculate_age():
    person = Person(birth_year=1990)
    assert person.get_age() == 33  # Тест упадет - метода нет

# 2. GREEN - минимальная реализация
class Person:
    def __init__(self, birth_year):
        self.birth_year = birth_year
    
    def get_age(self):
        return 33  # Хардкод для прохождения теста

# 3. REFACTOR - правильная реализация
class Person:
    def __init__(self, birth_year):
        self.birth_year = birth_year
    
    def get_age(self):
        from datetime import datetime
        return datetime.now().year - self.birth_year
```

**Go пример TDD:**
```go
// 1. RED - тест падает
func TestCalculateAge(t *testing.T) {
    person := Person{BirthYear: 1990}
    got := person.GetAge()
    want := 33
    
    if got != want {
        t.Errorf("GetAge() = %d, want %d", got, want)
    }
}

// 2. GREEN - минимальная реализация
type Person struct {
    BirthYear int
}

func (p Person) GetAge() int {
    return 33 // Хардкод
}

// 3. REFACTOR - правильная реализация
func (p Person) GetAge() int {
    return time.Now().Year() - p.BirthYear
}
```

### 🎭 Behavior-Driven Development (BDD)

**Структура Given-When-Then:**
```
Given (Дано)    → Начальное состояние
When (Когда)    → Действие
Then (Тогда)    → Ожидаемый результат
```

**Python с pytest-bdd:**
```python
# features/user_registration.feature
"""
Feature: User Registration
  
Scenario: Successful user registration
  Given a user with email "test@example.com"
  When they register with valid data
  Then they should receive confirmation email
  And their account should be created
"""

# test_registration.py
from pytest_bdd import given, when, then, scenario

@scenario('features/user_registration.feature', 'Successful user registration')
def test_user_registration():
    pass

@given('a user with email "test@example.com"')
def user_email():
    return {"email": "test@example.com", "password": "secure123"}

@when('they register with valid data')
def register_user(user_email, user_service):
    return user_service.register(user_email)

@then('they should receive confirmation email')
def check_confirmation_email(email_service):
    assert email_service.sent_emails_count() == 1

@then('their account should be created') 
def check_account_created(user_repository):
    users = user_repository.find_all()
    assert len(users) == 1
    assert users[0].email == "test@example.com"
```

### 📊 Принципы FIRST

```
F - Fast         → Тесты должны выполняться быстро (мс, секунды)
I - Independent  → Тесты не зависят друг от друга
R - Repeatable   → Одинаковый результат при каждом запуске
S - Self-validating → Четкий результат: pass/fail
T - Timely       → Тесты пишутся вовремя (в TDD - до кода)
```

**Пример нарушения принципов:**
```python
# ❌ ПЛОХО - тесты зависят друг от друга
class TestUserService:
    user_id = None
    
    def test_create_user(self):
        user = user_service.create("John")
        self.user_id = user.id  # Состояние сохраняется!
        assert user.name == "John"
    
    def test_get_user(self):
        # Зависит от предыдущего теста!
        user = user_service.get(self.user_id)
        assert user is not None

# ✅ ХОРОШО - независимые тесты
class TestUserService:
    def test_create_user(self):
        user = user_service.create("John")
        assert user.name == "John"
    
    def test_get_user(self):
        # Создаем пользователя в каждом тесте
        user = user_service.create("Jane") 
        found_user = user_service.get(user.id)
        assert found_user.name == "Jane"
```

### 📈 Метрики покрытия кода

```
Line Coverage     → % покрытых строк кода
Branch Coverage   → % покрытых ветвей (if/else)
Function Coverage → % покрытых функций
Condition Coverage → % покрытых условий
```

**Python - coverage.py:**
```bash
# Установка
pip install coverage

# Запуск тестов с измерением покрытия
coverage run -m pytest

# Отчет в терминале
coverage report

# HTML отчет
coverage html
```

**Go - встроенная поддержка:**
```bash
# Запуск тестов с покрытием
go test -cover

# Детальный отчет
go test -coverprofile=coverage.out
go tool cover -html=coverage.out
```

---

## 🧩 Модуль 2: Юнит-тестирование (3-4 недели)

### 🎯 Анатомия юнит-теста

**Структура AAA (Arrange-Act-Assert):**
```
Arrange → Подготовка данных и зависимостей
Act     → Выполнение тестируемого действия
Assert  → Проверка результата
```

**Python пример:**
```python
import pytest
from decimal import Decimal
from shopping_cart import ShoppingCart, Product

class TestShoppingCart:
    def test_add_product_increases_total(self):
        # Arrange
        cart = ShoppingCart()
        product = Product("Laptop", Decimal("999.99"))
        
        # Act  
        cart.add_product(product, quantity=2)
        
        # Assert
        assert cart.get_total() == Decimal("1999.98")
        assert cart.get_item_count() == 2

    def test_remove_product_decreases_total(self):
        # Arrange
        cart = ShoppingCart()
        product = Product("Mouse", Decimal("29.99"))
        cart.add_product(product, quantity=3)
        
        # Act
        cart.remove_product(product, quantity=1)
        
        # Assert
        assert cart.get_total() == Decimal("59.98")
        assert cart.get_item_count() == 2

    def test_empty_cart_has_zero_total(self):
        # Arrange
        cart = ShoppingCart()
        
        # Act & Assert
        assert cart.get_total() == Decimal("0.00")
        assert cart.is_empty() is True
```

**Go пример:**
```go
package main

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestShoppingCart(t *testing.T) {
    t.Run("AddProduct increases total", func(t *testing.T) {
        // Arrange
        cart := NewShoppingCart()
        product := Product{Name: "Laptop", Price: 999.99}
        
        // Act
        cart.AddProduct(product, 2)
        
        // Assert
        assert.Equal(t, 1999.98, cart.GetTotal())
        assert.Equal(t, 2, cart.GetItemCount())
    })
    
    t.Run("RemoveProduct decreases total", func(t *testing.T) {
        // Arrange
        cart := NewShoppingCart()
        product := Product{Name: "Mouse", Price: 29.99}
        cart.AddProduct(product, 3)
        
        // Act
        cart.RemoveProduct(product, 1)
        
        // Assert
        assert.Equal(t, 59.98, cart.GetTotal())
        assert.Equal(t, 2, cart.GetItemCount())
    })
    
    t.Run("Empty cart has zero total", func(t *testing.T) {
        // Arrange
        cart := NewShoppingCart()
        
        // Act & Assert
        assert.Equal(t, 0.0, cart.GetTotal())
        assert.True(t, cart.IsEmpty())
    })
}
```

### 🎭 Мокирование зависимостей

**Зачем нужны моки?**
```
Без моков:
UserService → Database → Network → Файловая система → Медленно, ненадежно

С моками:
UserService → Mock Database → Быстро, контролируемо, надежно
```

**Python с unittest.mock:**
```python
from unittest.mock import Mock, patch
import pytest
from user_service import UserService
from email_service import EmailService

class TestUserService:
    def test_register_user_sends_welcome_email(self):
        # Arrange
        mock_email_service = Mock(spec=EmailService)
        mock_user_repository = Mock()
        mock_user_repository.save.return_value = User(id=1, email="test@example.com")
        
        user_service = UserService(mock_user_repository, mock_email_service)
        
        # Act
        user_data = {"email": "test@example.com", "password": "secret"}
        user = user_service.register(user_data)
        
        # Assert
        mock_user_repository.save.assert_called_once()
        mock_email_service.send_welcome_email.assert_called_once_with("test@example.com")
        assert user.id == 1

    @patch('user_service.datetime')
    def test_get_user_age_calculation(self, mock_datetime):
        # Arrange
        mock_datetime.now.return_value.year = 2023
        user = User(birth_year=1990)
        
        # Act
        age = user.get_age()
        
        # Assert
        assert age == 33

    def test_user_service_handles_database_error(self):
        # Arrange
        mock_repository = Mock()
        mock_repository.save.side_effect = DatabaseError("Connection failed")
        user_service = UserService(mock_repository, Mock())
        
        # Act & Assert
        with pytest.raises(UserRegistrationError):
            user_service.register({"email": "test@example.com"})
```

**Go с testify/mock:**
```go
package main

import (
    "testing"
    "errors"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock объекты
type MockUserRepository struct {
    mock.Mock
}

func (m *MockUserRepository) Save(user User) (User, error) {
    args := m.Called(user)
    return args.Get(0).(User), args.Error(1)
}

type MockEmailService struct {
    mock.Mock
}

func (m *MockEmailService) SendWelcomeEmail(email string) error {
    args := m.Called(email)
    return args.Error(0)
}

func TestUserService(t *testing.T) {
    t.Run("Register user sends welcome email", func(t *testing.T) {
        // Arrange
        mockRepo := new(MockUserRepository)
        mockEmail := new(MockEmailService)
        
        expectedUser := User{ID: 1, Email: "test@example.com"}
        mockRepo.On("Save", mock.AnythingOfType("User")).Return(expectedUser, nil)
        mockEmail.On("SendWelcomeEmail", "test@example.com").Return(nil)
        
        userService := NewUserService(mockRepo, mockEmail)
        
        // Act
        userData := UserData{Email: "test@example.com", Password: "secret"}
        user, err := userService.Register(userData)
        
        // Assert
        assert.NoError(t, err)
        assert.Equal(t, 1, user.ID)
        mockRepo.AssertExpectations(t)
        mockEmail.AssertExpectations(t)
    })
    
    t.Run("Register handles database error", func(t *testing.T) {
        // Arrange
        mockRepo := new(MockUserRepository)
        mockEmail := new(MockEmailService)
        
        mockRepo.On("Save", mock.AnythingOfType("User")).Return(User{}, errors.New("DB connection failed"))
        
        userService := NewUserService(mockRepo, mockEmail)
        
        // Act
        userData := UserData{Email: "test@example.com"}
        _, err := userService.Register(userData)
        
        // Assert
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "failed to save user")
        mockRepo.AssertExpectations(t)
    })
}
```

### 🎯 Параметризованные тесты

**Python с pytest.mark.parametrize:**
```python
import pytest
from password_validator import PasswordValidator

class TestPasswordValidator:
    @pytest.mark.parametrize("password,expected", [
        ("password123", False),     # Слишком простой
        ("12345678", False),        # Только цифры
        ("Password!", True),        # Хороший пароль
        ("Sup3rStr0ng!", True),     # Отличный пароль  
        ("weak", False),            # Слишком короткий
        ("ALLCAPS123!", False),     # Без строчных букв
        ("alllower123!", False),    # Без заглавных букв
    ])
    def test_password_strength(self, password, expected):
        validator = PasswordValidator()
        result = validator.is_strong(password)
        assert result == expected

    @pytest.mark.parametrize("email", [
        "valid@example.com",
        "user.name@domain.co.uk",
        "test+tag@gmail.com",
        "user123@sub.domain.org"
    ])
    def test_valid_emails(self, email):
        validator = EmailValidator()
        assert validator.is_valid(email) is True

    @pytest.mark.parametrize("invalid_email", [
        "invalid-email",
        "@domain.com",
        "user@",
        "spaces in@email.com",
        "user@domain",
    ])
    def test_invalid_emails(self, invalid_email):
        validator = EmailValidator()
        assert validator.is_valid(invalid_email) is False
```

**Go с table-driven tests:**
```go
func TestPasswordValidator(t *testing.T) {
    tests := []struct {
        name     string
        password string
        expected bool
    }{
        {"weak password", "password123", false},
        {"only numbers", "12345678", false},
        {"good password", "Password!", true},
        {"excellent password", "Sup3rStr0ng!", true},
        {"too short", "weak", false},
        {"all caps", "ALLCAPS123!", false},
        {"all lowercase", "alllower123!", false},
    }

    validator := NewPasswordValidator()
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := validator.IsStrong(tt.password)
            assert.Equal(t, tt.expected, result)
        })
    }
}

func TestEmailValidator(t *testing.T) {
    validEmails := []string{
        "valid@example.com",
        "user.name@domain.co.uk", 
        "test+tag@gmail.com",
        "user123@sub.domain.org",
    }
    
    invalidEmails := []string{
        "invalid-email",
        "@domain.com",
        "user@",
        "spaces in@email.com",
        "user@domain",
    }
    
    validator := NewEmailValidator()
    
    for _, email := range validEmails {
        t.Run("valid: "+email, func(t *testing.T) {
            assert.True(t, validator.IsValid(email))
        })
    }
    
    for _, email := range invalidEmails {
        t.Run("invalid: "+email, func(t *testing.T) {
            assert.False(t, validator.IsValid(email))
        })
    }
}
```

### 🚨 Тестирование исключений

**Python:**
```python
import pytest
from bank_account import BankAccount, InsufficientFundsError

class TestBankAccount:
    def test_withdraw_more_than_balance_raises_error(self):
        # Arrange
        account = BankAccount(initial_balance=100.0)
        
        # Act & Assert
        with pytest.raises(InsufficientFundsError) as exc_info:
            account.withdraw(150.0)
        
        assert "Insufficient funds" in str(exc_info.value)
        assert exc_info.value.available_balance == 100.0
        assert exc_info.value.requested_amount == 150.0

    def test_negative_deposit_raises_error(self):
        account = BankAccount(initial_balance=0.0)
        
        with pytest.raises(ValueError, match="Amount must be positive"):
            account.deposit(-50.0)

    def test_successful_withdrawal(self):
        # Arrange
        account = BankAccount(initial_balance=200.0)
        
        # Act
        account.withdraw(50.0)
        
        # Assert
        assert account.get_balance() == 150.0
```

**Go:**
```go
func TestBankAccount(t *testing.T) {
    t.Run("Withdraw more than balance returns error", func(t *testing.T) {
        // Arrange
        account := NewBankAccount(100.0)
        
        // Act
        err := account.Withdraw(150.0)
        
        // Assert
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "insufficient funds")
        assert.Equal(t, 100.0, account.GetBalance())
    })
    
    t.Run("Negative deposit returns error", func(t *testing.T) {
        account := NewBankAccount(0.0)
        
        err := account.Deposit(-50.0)
        
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "amount must be positive")
    })
    
    t.Run("Successful withdrawal", func(t *testing.T) {
        // Arrange
        account := NewBankAccount(200.0)
        
        // Act
        err := account.Withdraw(50.0)
        
        // Assert
        assert.NoError(t, err)
        assert.Equal(t, 150.0, account.GetBalance())
    })
}
```

---

## 🔗 Модуль 3: Интеграционное тестирование (2-3 недели)

### 🎯 Уровни интеграционного тестирования

```
Application Level     ← Полная интеграция всех компонентов
       ↓
Service Level        ← Интеграция сервисов и внешних API  
       ↓
Component Level      ← Интеграция слоев внутри приложения
       ↓
Module Level         ← Интеграция классов и модулей
```

### 🗄️ Тестирование слоя базы данных

**Python с pytest и SQLAlchemy:**
```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, User, Order
from repositories import UserRepository, OrderRepository

@pytest.fixture
def db_session():
    # Используем in-memory SQLite для тестов
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    
    Session = sessionmaker(bind=engine)
    session = Session()
    
    yield session
    
    session.close()

class TestUserRepository:
    def test_save_and_find_user(self, db_session):
        # Arrange
        repo = UserRepository(db_session)
        user_data = {
            "email": "john@example.com",
            "name": "John Doe",
            "age": 30
        }
        
        # Act
        saved_user = repo.save(user_data)
        found_user = repo.find_by_email("john@example.com")
        
        # Assert
        assert saved_user.id is not None
        assert found_user.email == "john@example.com"
        assert found_user.name == "John Doe"
        assert found_user.age == 30

    def test_find_users_by_age_range(self, db_session):
        # Arrange
        repo = UserRepository(db_session)
        users_data = [
            {"email": "young@test.com", "name": "Young User", "age": 25},
            {"email": "middle@test.com", "name": "Middle User", "age": 35},
            {"email": "old@test.com", "name": "Old User", "age": 65},
        ]
        
        for user_data in users_data:
            repo.save(user_data)
        
        # Act
        middle_aged_users = repo.find_by_age_range(30, 40)
        
        # Assert
        assert len(middle_aged_users) == 1
        assert middle_aged_users[0].name == "Middle User"

    def test_user_orders_relationship(self, db_session):
        # Arrange
        user_repo = UserRepository(db_session)
        order_repo = OrderRepository(db_session)
        
        user = user_repo.save({"email": "customer@test.com", "name": "Customer"})
        
        # Act
        order1 = order_repo.save({"user_id": user.id, "total": 99.99, "status": "pending"})
        order2 = order_repo.save({"user_id": user.id, "total": 149.99, "status": "completed"})
        
        user_orders = order_repo.find_by_user_id(user.id)
        
        # Assert
        assert len(user_orders) == 2
        total_amount = sum(order.total for order in user_orders)
        assert total_amount == 249.98
```

**Go с database/sql и testcontainers:**
```go
package main

import (
    "database/sql"
    "testing"
    "context"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    _ "github.com/lib/pq"
)

func setupTestDB(t *testing.T) (*sql.DB, func()) {
    ctx := context.Background()
    
    // Запускаем PostgreSQL в контейнере
    postgresContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:13"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("test"),
        postgres.WithPassword("test"),
    )
    require.NoError(t, err)
    
    connStr, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
    require.NoError(t, err)
    
    db, err := sql.Open("postgres", connStr)
    require.NoError(t, err)
    
    // Создаем схему
    schema := `
        CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE NOT NULL,
            name VARCHAR(255) NOT NULL,
            age INTEGER
        );
        
        CREATE TABLE orders (
            id SERIAL PRIMARY KEY,
            user_id INTEGER REFERENCES users(id),
            total DECIMAL(10,2),
            status VARCHAR(50)
        );
    `
    _, err = db.Exec(schema)
    require.NoError(t, err)
    
    cleanup := func() {
        db.Close()
        postgresContainer.Terminate(ctx)
    }
    
    return db, cleanup
}

func TestUserRepository(t *testing.T) {
    db, cleanup := setupTestDB(t)
    defer cleanup()
    
    repo := NewUserRepository(db)
    
    t.Run("Save and find user", func(t *testing.T) {
        // Arrange
        userData := User{
            Email: "john@example.com",
            Name:  "John Doe",
            Age:   30,
        }
        
        // Act
        savedUser, err := repo.Save(userData)
        require.NoError(t, err)
        
        foundUser, err := repo.FindByEmail("john@example.com")
        require.NoError(t, err)
        
        // Assert
        assert.NotZero(t, savedUser.ID)
        assert.Equal(t, "john@example.com", foundUser.Email)
        assert.Equal(t, "John Doe", foundUser.Name)
        assert.Equal(t, 30, foundUser.Age)
    })
    
    t.Run("Find users by age range", func(t *testing.T) {
        // Arrange
        users := []User{
            {Email: "young@test.com", Name: "Young User", Age: 25},
            {Email: "middle@test.com", Name: "Middle User", Age: 35},
            {Email: "old@test.com", Name: "Old User", Age: 65},
        }
        
        for _, user := range users {
            _, err := repo.Save(user)
            require.NoError(t, err)
        }
        
        // Act
        middleAgedUsers, err := repo.FindByAgeRange(30, 40)
        require.NoError(t, err)
        
        // Assert
        assert.Len(t, middleAgedUsers, 1)
        assert.Equal(t, "Middle User", middleAgedUsers[0].Name)
    })
}
```

### 🌐 Тестирование HTTP клиентов

**Python с responses библиотекой:**
```python
import responses
import requests
from weather_service import WeatherService

class TestWeatherService:
    @responses.activate
    def test_get_weather_success(self):
        # Arrange
        responses.add(
            responses.GET,
            "https://api.weather.com/v1/current",
            json={
                "temperature": 22.5,
                "humidity": 65,
                "description": "Partly cloudy"
            },
            status=200
        )
        
        service = WeatherService(api_key="test-key")
        
        # Act
        weather = service.get_current_weather("London")
        
        # Assert
        assert weather.temperature == 22.5
        assert weather.humidity == 65
        assert weather.description == "Partly cloudy"

    @responses.activate
    def test_get_weather_api_error(self):
        # Arrange
        responses.add(
            responses.GET,
            "https://api.weather.com/v1/current",
            json={"error": "City not found"},
            status=404
        )
        
        service = WeatherService(api_key="test-key")
        
        # Act & Assert
        with pytest.raises(WeatherServiceError) as exc_info:
            service.get_current_weather("InvalidCity")
        
        assert "City not found" in str(exc_info.value)

    @responses.activate
    def test_get_weather_with_retry(self):
        # Arrange - первый запрос падает, второй успешен
        responses.add(responses.GET, "https://api.weather.com/v1/current", 
                     status=500)
        responses.add(responses.GET, "https://api.weather.com/v1/current",
                     json={"temperature": 20.0}, status=200)
        
        service = WeatherService(api_key="test-key", retry_count=2)
        
        # Act
        weather = service.get_current_weather("London")
        
        # Assert
        assert weather.temperature == 20.0
        assert len(responses.calls) == 2  # Проверяем что было 2 запроса
```

**Go с httptest:**
```go
func TestWeatherService(t *testing.T) {
    t.Run("Get weather success", func(t *testing.T) {
        // Arrange
        server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            assert.Equal(t, "/v1/current", r.URL.Path)
            assert.Equal(t, "London", r.URL.Query().Get("city"))
            assert.Equal(t, "test-key", r.URL.Query().Get("api_key"))
            
            response := `{
                "temperature": 22.5,
                "humidity": 65,
                "description": "Partly cloudy"
            }`
            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(response))
        }))
        defer server.Close()
        
        service := NewWeatherService("test-key")
        service.BaseURL = server.URL  // Переопределяем URL на тестовый
        
        // Act
        weather, err := service.GetCurrentWeather("London")
        
        // Assert
        require.NoError(t, err)
        assert.Equal(t, 22.5, weather.Temperature)
        assert.Equal(t, 65, weather.Humidity)
        assert.Equal(t, "Partly cloudy", weather.Description)
    })
    
    t.Run("Get weather API error", func(t *testing.T) {
        // Arrange
        server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusNotFound)
            w.Write([]byte(`{"error": "City not found"}`))
        }))
        defer server.Close()
        
        service := NewWeatherService("test-key")
        service.BaseURL = server.URL
        
        // Act
        _, err := service.GetCurrentWeather("InvalidCity")
        
        // Assert
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "City not found")
    })
}
```

### 📨 Тестирование очередей сообщений

**Python с pika (RabbitMQ):**
```python
import pytest
import pika
from unittest.mock import Mock, patch
from notification_service import NotificationService

class TestNotificationService:
    @patch('pika.BlockingConnection')
    def test_send_email_notification(self, mock_connection):
        # Arrange
        mock_channel = Mock()
        mock_connection.return_value.channel.return_value = mock_channel
        
        service = NotificationService()
        notification = {
            "type": "email",
            "recipient": "user@example.com",
            "subject": "Welcome!",
            "body": "Welcome to our service"
        }
        
        # Act
        service.send_notification(notification)
        
        # Assert
        mock_channel.queue_declare.assert_called_with(queue='email_notifications', durable=True)
        mock_channel.basic_publish.assert_called_once()
        
        # Проверяем содержимое сообщения
        call_args = mock_channel.basic_publish.call_args
        assert call_args[1]['routing_key'] == 'email_notifications'
        
    def test_process_notification_message(self):
        # Arrange
        mock_email_sender = Mock()
        processor = NotificationProcessor(mock_email_sender)
        
        message_body = '''
        {
            "type": "email",
            "recipient": "test@example.com", 
            "subject": "Test",
            "body": "Test message"
        }
        '''
        
        # Act
        processor.process_message(message_body)
        
        # Assert
        mock_email_sender.send.assert_called_once_with(
            to="test@example.com",
            subject="Test", 
            body="Test message"
        )

# Интеграционный тест с реальным RabbitMQ
@pytest.mark.integration 
def test_end_to_end_notification_flow():
    # Требует запущенного RabbitMQ (можно через docker-compose)
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # Очищаем очередь перед тестом
    channel.queue_delete(queue='test_notifications')
    channel.queue_declare(queue='test_notifications', durable=True)
    
    # Отправляем сообщение
    notification = {
        "type": "email",
        "recipient": "integration@test.com",
        "subject": "Integration Test"
    }
    
    channel.basic_publish(
        exchange='',
        routing_key='test_notifications',
        body=json.dumps(notification)
    )
    
    # Читаем сообщение
    method_frame, header_frame, body = channel.basic_get(queue='test_notifications')
    
    assert method_frame is not None
    received_notification = json.loads(body)
    assert received_notification['recipient'] == "integration@test.com"
    
    connection.close()
```

---

## 🌐 Модуль 4: API тестирование (2-3 недели)

### 🎯 Компоненты API тестирования

```
HTTP Request Testing:
├── Methods (GET, POST, PUT, DELETE, PATCH)
├── Status Codes (200, 201, 400, 401, 404, 500)
├── Headers (Content-Type, Authorization, Cache-Control)  
├── Body (JSON, XML, Form Data)
├── Query Parameters
└── Path Parameters

API Contract Testing:
├── Request Schema Validation
├── Response Schema Validation
├── API Versioning
└── Backward Compatibility
```

### 📡 REST API тестирование

**Python с pytest и requests:**
```python
import pytest
import requests
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

class TestUserAPI:
    def test_create_user_success(self):
        # Arrange
        user_data = {
            "email": "newuser@example.com",
            "name": "New User",
            "age": 25
        }
        
        # Act
        response = client.post("/users", json=user_data)
        
        # Assert
        assert response.status_code == 201
        response_data = response.json()
        assert response_data["email"] == "newuser@example.com"
        assert response_data["name"] == "New User"
        assert "id" in response_data
        assert "created_at" in response_data

    def test_create_user_validation_error(self):
        # Arrange
        invalid_user_data = {
            "email": "invalid-email",  # Невалидный email
            "name": "",               # Пустое имя
            "age": -5                 # Отрицательный возраст
        }
        
        # Act
        response = client.post("/users", json=invalid_user_data)
        
        # Assert
        assert response.status_code == 422
        error_data = response.json()
        assert "detail" in error_data
        
        # Проверяем конкретные ошибки валидации
        errors = error_data["detail"]
        email_errors = [e for e in errors if e["loc"] == ["email"]]
        name_errors = [e for e in errors if e["loc"] == ["name"]]
        age_errors = [e for e in errors if e["loc"] == ["age"]]
        
        assert len(email_errors) > 0
        assert len(name_errors) > 0  
        assert len(age_errors) > 0

    def test_get_user_by_id(self):
        # Arrange - создаем пользователя
        user_data = {"email": "gettest@example.com", "name": "Get Test User"}
        create_response = client.post("/users", json=user_data)
        user_id = create_response.json()["id"]
        
        # Act
        response = client.get(f"/users/{user_id}")
        
        # Assert
        assert response.status_code == 200
        user = response.json()
        assert user["id"] == user_id
        assert user["email"] == "gettest@example.com"

    def test_get_nonexistent_user(self):
        # Act
        response = client.get("/users/99999")
        
        # Assert
        assert response.status_code == 404
        error_data = response.json()
        assert "User not found" in error_data["detail"]

    def test_update_user(self):
        # Arrange
        user_data = {"email": "update@example.com", "name": "Update User"}
        create_response = client.post("/users", json=user_data)
        user_id = create_response.json()["id"]
        
        update_data = {"name": "Updated Name", "age": 30}
        
        # Act
        response = client.put(f"/users/{user_id}", json=update_data)
        
        # Assert
        assert response.status_code == 200
        updated_user = response.json()
        assert updated_user["name"] == "Updated Name"
        assert updated_user["age"] == 30
        assert updated_user["email"] == "update@example.com"  # Не изменился

    def test_delete_user(self):
        # Arrange
        user_data = {"email": "delete@example.com", "name": "Delete User"}
        create_response = client.post("/users", json=user_data)
        user_id = create_response.json()["id"]
        
        # Act
        delete_response = client.delete(f"/users/{user_id}")
        
        # Assert
        assert delete_response.status_code == 204
        
        # Проверяем что пользователь действительно удален
        get_response = client.get(f"/users/{user_id}")
        assert get_response.status_code == 404

    def test_list_users_with_pagination(self):
        # Arrange - создаем несколько пользователей
        for i in range(15):
            user_data = {"email": f"user{i}@example.com", "name": f"User {i}"}
            client.post("/users", json=user_data)
        
        # Act
        response = client.get("/users?page=1&limit=10")
        
        # Assert
        assert response.status_code == 200
        data = response.json()
        assert "users" in data
        assert "total" in data
        assert "page" in data
        assert "limit" in data
        
        assert len(data["users"]) == 10
        assert data["page"] == 1
        assert data["limit"] == 10
        assert data["total"] >= 15

    def test_search_users_by_name(self):
        # Arrange
        client.post("/users", json={"email": "john@example.com", "name": "John Doe"})
        client.post("/users", json={"email": "jane@example.com", "name": "Jane Smith"}) 
        client.post("/users", json={"email": "bob@example.com", "name": "Bob Johnson"})
        
        # Act
        response = client.get("/users?search=john")
        
        # Assert
        assert response.status_code == 200
        users = response.json()["users"]
        
        # Должны найти John Doe и Bob Johnson
        names = [user["name"] for user in users]
        assert "John Doe" in names
        assert "Bob Johnson" in names
        assert "Jane Smith" not in names
```

**Go с Gin и httptest:**
```go
package main

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "strconv"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func setupRouter() *gin.Engine {
    gin.SetMode(gin.TestMode)
    r := gin.Default()
    
    // Настраиваем роуты
    r.POST("/users", createUser)
    r.GET("/users/:id", getUser)
    r.PUT("/users/:id", updateUser)
    r.DELETE("/users/:id", deleteUser)
    r.GET("/users", listUsers)
    
    return r
}

func TestUserAPI(t *testing.T) {
    router := setupRouter()
    
    t.Run("Create user success", func(t *testing.T) {
        // Arrange
        userData := User{
            Email: "newuser@example.com",
            Name:  "New User",
            Age:   25,
        }
        
        jsonData, _ := json.Marshal(userData)
        
        // Act
        req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
        req.Header.Set("Content-Type", "application/json")
        
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusCreated, w.Code)
        
        var response User
        err := json.Unmarshal(w.Body.Bytes(), &response)
        require.NoError(t, err)
        
        assert.Equal(t, "newuser@example.com", response.Email)
        assert.Equal(t, "New User", response.Name)
        assert.NotZero(t, response.ID)
        assert.NotZero(t, response.CreatedAt)
    })
    
    t.Run("Create user validation error", func(t *testing.T) {
        // Arrange
        invalidData := map[string]interface{}{
            "email": "invalid-email",
            "name":  "",
            "age":   -5,
        }
        
        jsonData, _ := json.Marshal(invalidData)
        
        // Act
        req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
        req.Header.Set("Content-Type", "application/json")
        
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusBadRequest, w.Code)
        
        var errorResponse map[string]interface{}
        err := json.Unmarshal(w.Body.Bytes(), &errorResponse)
        require.NoError(t, err)
        
        assert.Contains(t, errorResponse, "error")
    })
    
    t.Run("Get user by ID", func(t *testing.T) {
        // Arrange - создаем пользователя
        userData := User{Email: "gettest@example.com", Name: "Get Test User"}
        jsonData, _ := json.Marshal(userData)
        
        req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        var createdUser User
        json.Unmarshal(w.Body.Bytes(), &createdUser)
        
        // Act
        req, _ = http.NewRequest("GET", "/users/"+strconv.Itoa(createdUser.ID), nil)
        w = httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusOK, w.Code)
        
        var response User
        err := json.Unmarshal(w.Body.Bytes(), &response)
        require.NoError(t, err)
        
        assert.Equal(t, createdUser.ID, response.ID)
        assert.Equal(t, "gettest@example.com", response.Email)
    })
    
    t.Run("Get nonexistent user", func(t *testing.T) {
        // Act
        req, _ := http.NewRequest("GET", "/users/99999", nil)
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusNotFound, w.Code)
    })
    
    t.Run("Update user", func(t *testing.T) {
        // Arrange - создаем пользователя
        userData := User{Email: "update@example.com", Name: "Update User"}
        jsonData, _ := json.Marshal(userData)
        
        req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonData))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        var createdUser User
        json.Unmarshal(w.Body.Bytes(), &createdUser)
        
        // Act - обновляем пользователя
        updateData := map[string]interface{}{
            "name": "Updated Name",
            "age":  30,
        }
        jsonData, _ = json.Marshal(updateData)
        
        req, _ = http.NewRequest("PUT", "/users/"+strconv.Itoa(createdUser.ID), bytes.NewBuffer(jsonData))
        req.Header.Set("Content-Type", "application/json")
        w = httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusOK, w.Code)
        
        var response User
        err := json.Unmarshal(w.Body.Bytes(), &response)
        require.NoError(t, err)
        
        assert.Equal(t, "Updated Name", response.Name)
        assert.Equal(t, 30, response.Age)
        assert.Equal(t, "update@example.com", response.Email) // Не изменился
    })
    
    t.Run("List users with pagination", func(t *testing.T) {
        // Act
        req, _ := http.NewRequest("GET", "/users?page=1&limit=5", nil)
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        // Assert
        assert.Equal(t, http.StatusOK, w.Code)
        
        var response map[string]interface{}
        err := json.Unmarshal(w.Body.Bytes(), &response)
        require.NoError(t, err)
        
        assert.Contains(t, response, "users")
        assert.Contains(t, response, "total")
        assert.Contains(t, response, "page")
        assert.Contains(t, response, "limit")
    })
}
```

### 🔒 Тестирование аутентификации и авторизации

**Python JWT тестирование:**
```python
import jwt
from datetime import datetime, timedelta

class TestAuthAPI:
    def test_login_with_valid_credentials(self):
        # Arrange
        credentials = {
            "email": "user@example.com",
            "password": "correct_password"
        }
        
        # Act
        response = client.post("/auth/login", json=credentials)
        
        # Assert
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert "refresh_token" in data
        assert data["token_type"] == "bearer"
        
        # Проверяем что токен валиден
        token = data["access_token"]
        payload = jwt.decode(token, options={"verify_signature": False})
        assert payload["email"] == "user@example.com"

    def test_login_with_invalid_credentials(self):
        # Arrange
        credentials = {
            "email": "user@example.com", 
            "password": "wrong_password"
        }
        
        # Act
        response = client.post("/auth/login", json=credentials)
        
        # Assert
        assert response.status_code == 401
        assert "Invalid credentials" in response.json()["detail"]

    def test_access_protected_endpoint_with_token(self):
        # Arrange - получаем токен
        credentials = {"email": "user@example.com", "password": "correct_password"}
        login_response = client.post("/auth/login", json=credentials)
        token = login_response.json()["access_token"]
        
        # Act
        headers = {"Authorization": f"Bearer {token}"}
        response = client.get("/protected/profile", headers=headers)
        
        # Assert
        assert response.status_code == 200
        profile = response.json()
        assert profile["email"] == "user@example.com"

    def test_access_protected_endpoint_without_token(self):
        # Act
        response = client.get("/protected/profile")
        
        # Assert
        assert response.status_code == 401
        assert "Not authenticated" in response.json()["detail"]

    def test_access_protected_endpoint_with_expired_token(self):
        # Arrange - создаем просроченный токен
        payload = {
            "email": "user@example.com",
            "exp": datetime.utcnow() - timedelta(hours=1)  # Просрочен на час
        }
        expired_token = jwt.encode(payload, "secret", algorithm="HS256")
        
        # Act
        headers = {"Authorization": f"Bearer {expired_token}"}
        response = client.get("/protected/profile", headers=headers)
        
        # Assert
        assert response.status_code == 401
        assert "Token expired" in response.json()["detail"]

    def test_refresh_token_endpoint(self):
        # Arrange
        credentials = {"email": "user@example.com", "password": "correct_password"}
        login_response = client.post("/auth/login", json=credentials)
        refresh_token = login_response.json()["refresh_token"]
        
        # Act
        response = client.post("/auth/refresh", 
                              json={"refresh_token": refresh_token})
        
        # Assert
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"

    def test_role_based_access_control(self):
        # Arrange - логинимся как обычный пользователь
        user_credentials = {"email": "user@example.com", "password": "password"}
        user_login = client.post("/auth/login", json=user_credentials)
        user_token = user_login.json()["access_token"]
        
        # Act - пытаемся получить доступ к админ эндпоинту
        headers = {"Authorization": f"Bearer {user_token}"}
        response = client.get("/admin/users", headers=headers)
        
        # Assert
        assert response.status_code == 403
        assert "Insufficient permissions" in response.json()["detail"]

    def test_admin_access_control(self):
        # Arrange - логинимся как админ
        admin_credentials = {"email": "admin@example.com", "password": "admin_password"}
        admin_login = client.post("/auth/login", json=admin_credentials)
        admin_token = admin_login.json()["access_token"]
        
        # Act
        headers = {"Authorization": f"Bearer {admin_token}"}
        response = client.get("/admin/users", headers=headers)
        
        # Assert
        assert response.status_code == 200
        users_data = response.json()
        assert "users" in users_data
```

### 📊 Schema Validation тестирование

**Python с jsonschema:**
```python
import jsonschema
from jsonschema import validate

# Определяем схемы для валидации
USER_SCHEMA = {
    "type": "object",
    "properties": {
        "id": {"type": "integer", "minimum": 1},
        "email": {"type": "string", "format": "email"},
        "name": {"type": "string", "minLength": 1, "maxLength": 100},
        "age": {"type": "integer", "minimum": 0, "maximum": 150},
        "created_at": {"type": "string", "format": "date-time"},
        "updated_at": {"type": "string", "format": "date-time"}
    },
    "required": ["id", "email", "name", "created_at"],
    "additionalProperties": False
}

USER_LIST_SCHEMA = {
    "type": "object", 
    "properties": {
        "users": {
            "type": "array",
            "items": USER_SCHEMA
        },
        "total": {"type": "integer", "minimum": 0},
        "page": {"type": "integer", "minimum": 1},
        "limit": {"type": "integer", "minimum": 1, "maximum": 100}
    },
    "required": ["users", "total", "page", "limit"]
}

class TestAPISchemaValidation:
    def test_create_user_response_schema(self):
        # Arrange
        user_data = {"email": "schema@example.com", "name": "Schema User"}
        
        # Act
        response = client.post("/users", json=user_data)
        
        # Assert
        assert response.status_code == 201
        response_data = response.json()
        
        # Валидируем схему ответа
        try:
            validate(instance=response_data, schema=USER_SCHEMA)
        except jsonschema.exceptions.ValidationError as e:
            pytest.fail(f"Response schema validation failed: {e}")

    def test_list_users_response_schema(self):
        # Act
        response = client.get("/users?page=1&limit=10")
        
        # Assert
        assert response.status_code == 200
        response_data = response.json()
        
        # Валидируем схему списка пользователей
        try:
            validate(instance=response_data, schema=USER_LIST_SCHEMA)
        except jsonschema.exceptions.ValidationError as e:
            pytest.fail(f"User list schema validation failed: {e}")

    def test_error_response_schema(self):
        # Arrange
        ERROR_SCHEMA = {
            "type": "object",
            "properties": {
                "detail": {"type": "string"},
                "error_code": {"type": "string"}
            },
            "required": ["detail"]
        }
        
        # Act
        response = client.get("/users/99999")  # Несуществующий пользователь
        
        # Assert
        assert response.status_code == 404
        error_data = response.json()
        
        try:
            validate(instance=error_data, schema=ERROR_SCHEMA)
        except jsonschema.exceptions.ValidationError as e:
            pytest.fail(f"Error response schema validation failed: {e}")
```

---

## ⚡ Модуль 5: Тестирование производительности (2 недели)

### 🎯 Типы нагрузочного тестирования

```
Load Testing      │████████████│     Обычная рабочая нагрузка
                  │            │     Проверяем стабильность
                  
Stress Testing    │████████████████│ Пиковая нагрузка
                  │                │ Ищем точку отказа
                  
Spike Testing     │██│    │████│    Резкие скачки нагрузки
                  │  │    │    │    Проверяем восстановление
                  
Volume Testing    │████████████████│ Большие объемы данных
                  │    Big Data    │ Тестируем масштабирование
```

### 📊 Ключевые метрики производительности

```
Response Time    → Время ответа (latency)
                   ├── P50 (медиана)
                   ├── P95 (95-й процентиль) 
                   └── P99 (99-й процентиль)

Throughput       → Пропускная способность
                   ├── RPS (requests per second)
                   ├── TPS (transactions per second)
                   └── Concurrent users

Error Rate       → Процент ошибок
                   ├── HTTP errors (4xx, 5xx)
                   ├── Timeouts
                   └── Connection errors

Resource Usage   → Использование ресурсов
                   ├── CPU utilization
                   ├── Memory usage
                   ├── Disk I/O
                   └── Network bandwidth
```

### 🏋️ Нагрузочное тестирование с k6

**JavaScript (k6):**
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';

// Кастомные метрики
export let errorRate = new Rate('errors');
export let responseTime = new Trend('response_time');
export let successfulLogins = new Counter('successful_logins');

// Конфигурация нагрузки
export let options = {
    stages: [
        { duration: '2m', target: 10 },   // Разогрев: 10 пользователей за 2 мин
        { duration: '5m', target: 50 },   // Нормальная нагрузка: 50 пользователей
        { duration: '2m', target: 100 },  // Пиковая нагрузка: 100 пользователей
        { duration: '5m', target: 100 },  // Удерживаем пик 5 минут
        { duration: '2m', target: 0 },    // Плавный спуск
    ],
    thresholds: {
        'response_time': ['p(95)<500'],          // 95% запросов быстрее 500мс
        'errors': ['rate<0.01'],                 // Менее 1% ошибок
        'http_req_duration': ['med<200'],        // Медиана быстрее 200мс
        'successful_logins': ['count>100'],      // Минимум 100 успешных логинов
    },
};

// Тестовые данные
const users = [
    { email: 'user1@example.com', password: 'password123' },
    { email: 'user2@example.com', password: 'password123' },
    { email: 'user3@example.com', password: 'password123' },
];

export function setup() {
    // Подготовка данных перед тестом
    console.log('Setting up test data...');
    
    // Создаем тестовых пользователей
    users.forEach(user => {
        let response = http.post('http://api.example.com/users', JSON.stringify(user), {
            headers: { 'Content-Type': 'application/json' },
        });
        
        check(response, {
            'user created successfully': (r) => r.status === 201,
        });
    });
    
    return { baseUrl: 'http://api.example.com' };
}

export default function(data) {
    const baseUrl = data.baseUrl;
    
    // Выбираем случайного пользователя
    const user = users[Math.floor(Math.random() * users.length)];
    
    // Сценарий 1: Логин
    let loginResponse = http.post(`${baseUrl}/auth/login`, JSON.stringify(user), {
        headers: { 'Content-Type': 'application/json' },
    });
    
    let loginSuccess = check(loginResponse, {
        'login status is 200': (r) => r.status === 200,
        'login response time < 300ms': (r) => r.timings.duration < 300,
        'has access token': (r) => JSON.parse(r.body).access_token !== undefined,
    });
    
    errorRate.add(!loginSuccess);
    responseTime.add(loginResponse.timings.duration);
    
    if (loginSuccess) {
        successfulLogins.add(1);
        
        let token = JSON.parse(loginResponse.body).access_token;
        let headers = {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
        };
        
        // Сценарий 2: Получение профиля пользователя
        let profileResponse = http.get(`${baseUrl}/users/profile`, { headers });
        
        check(profileResponse, {
            'profile status is 200': (r) => r.status === 200,
            'profile response time < 200ms': (r) => r.timings.duration < 200,
            'profile has user data': (r) => JSON.parse(r.body).email !== undefined,
        });
        
        // Сценарий 3: Получение списка постов
        let postsResponse = http.get(`${baseUrl}/posts?limit=20`, { headers });
        
        check(postsResponse, {
            'posts status is 200': (r) => r.status === 200,
            'posts response time < 400ms': (r) => r.timings.duration < 400,
            'posts list not empty': (r) => JSON.parse(r.body).posts.length > 0,
        });
        
        // Сценарий 4: Создание поста (20% пользователей)
        if (Math.random() < 0.2) {
            let postData = {
                title: `Test Post ${Math.random()}`,
                content: 'This is a test post content for load testing',
                tags: ['test', 'performance']
            };
            
            let createPostResponse = http.post(`${baseUrl}/posts`, JSON.stringify(postData), { headers });
            
            check(createPostResponse, {
                'create post status is 201': (r) => r.status === 201,
                'create post response time < 500ms': (r) => r.timings.duration < 500,
            });
        }
    }
    
    // Пауза между итерациями (имитация пользовательского поведения)
    sleep(Math.random() * 3 + 1); // 1-4 секунды
}

export function teardown(data) {
    // Очистка после тестирования
    console.log('Cleaning up test data...');
}
```

**Python с locust:**
```python
from locust import HttpUser, task, between
import random
import json

class WebsiteUser(HttpUser):
    wait_time = between(1, 3)  # Пауза между запросами 1-3 секунды
    
    def on_start(self):
        """Выполняется при запуске каждого пользователя"""
        # Логинимся при старте
        self.login()
    
    def login(self):
        """Авторизация пользователя"""
        credentials = {
            "email": f"user{random.randint(1, 100)}@example.com",
            "password": "password123"
        }
        
        with self.client.post("/auth/login", 
                             json=credentials, 
                             catch_response=True) as response:
            if response.status_code == 200:
                self.token = response.json().get("access_token")
                response.success()
            else:
                response.failure(f"Login failed with status {response.status_code}")
    
    @property
    def headers(self):
        """Заголовки с токеном авторизации"""
        return {"Authorization": f"Bearer {self.token}"} if hasattr(self, 'token') else {}
    
    @task(3)  # Вес 3 - выполняется чаще
    def view_profile(self):
        """Просмотр профиля пользователя"""
        with self.client.get("/users/profile", 
                           headers=self.headers,
                           catch_response=True) as response:
            if response.status_code == 200:
                profile = response.json()
                if "email" in profile:
                    response.success()
                else:
                    response.failure("Profile data incomplete")
            else:
                response.failure(f"Profile request failed: {response.status_code}")
    
    @task(5)  # Вес 5 - самое частое действие
    def browse_posts(self):
        """Просмотр списка постов"""
        params = {
            "page": random.randint(1, 10),
            "limit": random.choice([10, 20, 50])
        }
        
        with self.client.get("/posts", 
                           params=params,
                           headers=self.headers,
                           catch_response=True) as response:
            if response.status_code == 200:
                posts_data = response.json()
                if "posts" in posts_data and len(posts_data["posts"]) > 0:
                    response.success()
                else:
                    response.failure("No posts found")
            else:
                response.failure(f"Posts request failed: {response.status_code}")
    
    @task(1)  # Вес 1 - редкое действие
    def create_post(self):
        """Создание нового поста"""
        post_data = {
            "title": f"Load Test Post {random.randint(1, 1000)}",
            "content": "This is a test post created during load testing. " * 10,
            "tags": random.sample(["tech", "python", "testing", "performance", "api"], 2)
        }
        
        with self.client.post("/posts",
                            json=post_data,
                            headers=self.headers,
                            catch_response=True) as response:
            if response.status_code == 201:
                response.success()
            elif response.status_code == 429:  # Rate limiting
                response.failure("Rate limited")
            else:
                response.failure(f"Post creation failed: {response.status_code}")
    
    @task(2)
    def search_posts(self):
        """Поиск постов"""
        search_terms = ["python", "golang", "testing", "api", "performance"]
        query = random.choice(search_terms)
        
        with self.client.get(f"/posts/search?q={query}",
                           headers=self.headers,
                           catch_response=True) as response:
            if response.status_code == 200:
                search_results = response.json()
                response.success()
            else:
                response.failure(f"Search failed: {response.status_code}")

# Запуск:
# locust -f locustfile.py --host=http://localhost:8000
```

**Go нагрузочное тестирование:**
```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "math/rand"
    "net/http"
    "sync"
    "time"
    "testing"
)

type LoadTestResult struct {
    TotalRequests    int
    SuccessRequests  int
    FailedRequests   int
    AverageLatency   time.Duration
    MaxLatency       time.Duration
    MinLatency       time.Duration
    RequestsPerSecond float64
}

type TestScenario struct {
    Name        string
    URL         string
    Method      string
    Body        interface{}
    Headers     map[string]string
    Weight      int // Вес сценария (частота выполнения)
}

func BenchmarkAPIEndpoints(b *testing.B) {
    baseURL := "http://localhost:8080"
    
    // Получаем токен для авторизации
    token := getAuthToken(baseURL)
    
    scenarios := []TestScenario{
        {
            Name:   "GetProfile",
            URL:    baseURL + "/users/profile",
            Method: "GET",
            Headers: map[string]string{
                "Authorization": "Bearer " + token,
            },
            Weight: 3,
        },
        {
            Name:   "ListPosts",
            URL:    baseURL + "/posts?limit=20",
            Method: "GET", 
            Headers: map[string]string{
                "Authorization": "Bearer " + token,
            },
            Weight: 5,
        },
        {
            Name:   "CreatePost",
            URL:    baseURL + "/posts",
            Method: "POST",
            Body: map[string]interface{}{
                "title":   "Benchmark Post",
                "content": "Content for benchmark testing",
                "tags":    []string{"test", "benchmark"},
            },
            Headers: map[string]string{
                "Authorization": "Bearer " + token,
                "Content-Type":  "application/json",
            },
            Weight: 1,
        },
    }
    
    b.ResetTimer()
    
    // Параллельный тест
    b.RunParallel(func(pb *testing.PB) {
        client := &http.Client{Timeout: 5 * time.Second}
        
        for pb.Next() {
            scenario := selectScenario(scenarios)
            executeScenario(client, scenario)
        }
    })
}

func TestConcurrentLoad(t *testing.T) {
    const (
        concurrency = 50        // Количество одновременных пользователей
        duration    = 30        // Длительность теста в секундах
        baseURL     = "http://localhost:8080"
    )
    
    token := getAuthToken(baseURL)
    
    var wg sync.WaitGroup
    results := make(chan time.Duration, concurrency*duration*2)
    errors := make(chan error, concurrency*duration*2)
    
    startTime := time.Now()
    
    // Запускаем горутины для имитации пользователей
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func(userID int) {
            defer wg.Done()
            
            client := &http.Client{Timeout: 5 * time.Second}
            
            for time.Since(startTime) < time.Duration(duration)*time.Second {
                latency, err := makeRequest(client, baseURL+"/users/profile", token)
                
                if err != nil {
                    errors <- err
                } else {
                    results <- latency
                }
                
                // Пауза между запросами
                time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
            }
        }(i)
    }
    
    // Ждем завершения всех горутин
    wg.Wait()
    close(results)
    close(errors)
    
    // Анализируем результаты
    result := analyzeResults(results, errors, duration)
    
    t.Logf("Load Test Results:")
    t.Logf("Total Requests: %d", result.TotalRequests)
    t.Logf("Success Rate: %.2f%%", float64(result.SuccessRequests)/float64(result.TotalRequests)*100)
    t.Logf("Average Latency: %v", result.AverageLatency)
    t.Logf("Max Latency: %v", result.MaxLatency)
    t.Logf("Min Latency: %v", result.MinLatency)
    t.Logf("Requests/Second: %.2f", result.RequestsPerSecond)
    
    // Проверяем что результаты в пределах допустимого
    if result.AverageLatency > 500*time.Millisecond {
        t.Errorf("Average latency too high: %v", result.AverageLatency)
    }
    
    if float64(result.SuccessRequests)/float64(result.TotalRequests) < 0.99 {
        t.Errorf("Success rate too low: %.2f%%", 
                float64(result.SuccessRequests)/float64(result.TotalRequests)*100)
    }
}

func getAuthToken(baseURL string) string {
    credentials := map[string]string{
        "email":    "test@example.com",
        "password": "password123",
    }
    
    jsonData, _ := json.Marshal(credentials)
    resp, err := http.Post(baseURL+"/auth/login", "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        panic("Failed to get auth token: " + err.Error())
    }
    defer resp.Body.Close()
    
    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)
    
    return result["access_token"].(string)
}

func makeRequest(client *http.Client, url, token string) (time.Duration, error) {
    req, err := http.NewRequest("GET", url, nil)
    if err != nil {
        return 0, err
    }
    
    req.Header.Set("Authorization", "Bearer "+token)
    
    start := time.Now()
    resp, err := client.Do(req)
    latency := time.Since(start)
    
    if err != nil {
        return latency, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 400 {
        return latency, fmt.Errorf("HTTP error: %d", resp.StatusCode)
    }
    
    return latency, nil
}

func selectScenario(scenarios []TestScenario) TestScenario {
    totalWeight := 0
    for _, s := range scenarios {
        totalWeight += s.Weight
    }
    
    r := rand.Intn(totalWeight)
    for _, s := range scenarios {
        r -= s.Weight
        if r < 0 {
            return s
        }
    }
    
    return scenarios[0] // Fallback
}

func executeScenario(client *http.Client, scenario TestScenario) error {
    var body []byte
    if scenario.Body != nil {
        var err error
        body, err = json.Marshal(scenario.Body)
        if err != nil {
            return err
        }
    }
    
    req, err := http.NewRequest(scenario.Method, scenario.URL, bytes.NewBuffer(body))
    if err != nil {
        return err
    }
    
    for key, value := range scenario.Headers {
        req.Header.Set(key, value)
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    return nil
}

func analyzeResults(results chan time.Duration, errors chan error, duration int) LoadTestResult {
    var latencies []time.Duration
    errorCount := 0
    
    // Собираем все результаты
    for latency := range results {
        latencies = append(latencies, latency)
    }
    
    for range errors {
        errorCount++
    }
    
    if len(latencies) == 0 {
        return LoadTestResult{}
    }
    
    // Вычисляем статистики
    totalRequests := len(latencies) + errorCount
    successRequests := len(latencies)
    
    var totalLatency time.Duration
    minLatency := latencies[0]
    maxLatency := latencies[0]
    
    for _, latency := range latencies {
        totalLatency += latency
        if latency < minLatency {
            minLatency = latency
        }
        if latency > maxLatency {
            maxLatency = latency
        }
    }
    
    avgLatency := totalLatency / time.Duration(len(latencies))
    rps := float64(totalRequests) / float64(duration)
    
    return LoadTestResult{
        TotalRequests:     totalRequests,
        SuccessRequests:   successRequests,
        FailedRequests:    errorCount,
        AverageLatency:    avgLatency,
        MaxLatency:        maxLatency,
        MinLatency:        minLatency,
        RequestsPerSecond: rps,
    }
}
```

### 📊 Мониторинг производительности

**Python с профилированием:**
```python
import cProfile
import pstats
import pytest
from memory_profiler import profile
import time
import psutil
import os

class TestPerformanceMonitoring:
    
    def test_function_execution_time(self):
        """Тест времени выполнения функции"""
        start_time = time.time()
        
        # Тестируемая функция
        result = heavy_computation_function(1000)
        
        execution_time = time.time() - start_time
        
        # Проверяем что функция выполняется быстро
        assert execution_time < 1.0, f"Function too slow: {execution_time:.2f}s"
        assert result is not None
    
    @profile  # Декоратор для профилирования памяти
    def test_memory_usage(self):
        """Тест использования памяти"""
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # Выполняем операцию которая может потреблять память
        large_data = create_large_dataset(100000)
        
        peak_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = peak_memory - initial_memory
        
        # Проверяем что память не утекает
        assert memory_increase < 100, f"Memory usage too high: {memory_increase:.2f}MB"
        
        # Очищаем данные
        del large_data
    
    def test_database_query_performance(self, db_session):
        """Тест производительности запросов к БД"""
        # Создаем тестовые данные
        for i in range(1000):
            user = User(email=f"user{i}@test.com", name=f"User {i}")
            db_session.add(user)
        db_session.commit()
        
        start_time = time.time()
        
        # Тестируем сложный запрос
        users = db_session.query(User).filter(
            User.name.like('%User%')
        ).order_by(User.created_at.desc()).limit(50).all()
        
        query_time = time.time() - start_time
        
        assert len(users) == 50
        assert query_time < 0.1, f"Query too slow: {query_time:.3f}s"
    
    def test_concurrent_requests_performance(self):
        """Тест производительности при конкурентных запросах"""
        import threading
        import queue
        
        results = queue.Queue()
        errors = queue.Queue()
        
        def make_request():
            try:
                start = time.time()
                response = client.get("/users/profile")
                latency = time.time() - start
                
                if response.status_code == 200:
                    results.put(latency)
                else:
                    errors.put(f"HTTP {response.status_code}")
            except Exception as e:
                errors.put(str(e))
        
        # Запускаем 20 одновременных запросов
        threads = []
        for _ in range(20):
            thread = threading.Thread(target=make_request)
            threads.append(thread)
            thread.start()
        
        # Ждем завершения всех потоков
        for thread in threads:
            thread.join()
        
        # Анализируем результаты
        latencies = []
        while not results.empty():
            latencies.append(results.get())
        
        error_count = errors.qsize()
        
        assert error_count == 0, f"Found {error_count} errors"
        assert len(latencies) == 20, "Not all requests completed"
        
        avg_latency = sum(latencies) / len(latencies)
        max_latency = max(latencies)
        
        assert avg_latency < 0.5, f"Average latency too high: {avg_latency:.3f}s"
        assert max_latency < 1.0, f"Max latency too high: {max_latency:.3f}s"

def profile_function(func):
    """Декоратор для профилирования функций"""
    def wrapper(*args, **kwargs):
        pr = cProfile.Profile()
        pr.enable()
        
        result = func(*args, **kwargs)
        
        pr.disable()
        stats = pstats.Stats(pr)
        stats.sort_stats('cumulative')
        stats.print_stats(10)  # Топ 10 медленных функций
        
        return result
    return wrapper

@profile_function
def heavy_computation_function(n):
    """Функция для тестирования производительности"""
    total = 0
    for i in range(n):
        total += i ** 2
    return total

def create_large_dataset(size):
    """Создает большой датасет для тестирования памяти"""
    return [{"id": i, "data": f"item_{i}" * 100} for i in range(size)]
```

---

## 🛡️ Модуль 6: Тестирование безопасности (1-2 недели)

### 🎯 Карта угроз безопасности

```
OWASP Top 10 2021:
├── A01 - Broken Access Control     → Нарушение контроля доступа
├── A02 - Cryptographic Failures    → Криптографические ошибки
├── A03 - Injection                 → SQL/NoSQL/Command инъекции
├── A04 - Insecure Design          → Небезопасный дизайн
├── A05 - Security Misconfiguration → Неправильная конфигурация
├── A06 - Vulnerable Components     → Уязвимые компоненты
├── A07 - Auth & Session Management → Проблемы аутентификации
├── A08 - Software & Data Integrity → Целостность ПО и данных
├── A09 - Security Logging         → Недостаточное логирование
└── A10 - Server-Side Request Forgery → SSRF атаки
```

### 💉 Тестирование SQL Injection

**Python тесты на SQL инъекции:**
```python
import pytest
from sqlalchemy.exc import SQLAlchemyError
from user_service import UserService, DatabaseError

class TestSQLInjectionPrevention:
    
    def test_user_search_prevents_sql_injection(self):
        """Проверяем защиту от SQL инъекции в поиске пользователей"""
        malicious_inputs = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "'; DELETE FROM users WHERE '1'='1'; --", 
            "' UNION SELECT password FROM users --",
            "admin'--",
            "' OR 1=1#",
            "'; EXEC xp_cmdshell('dir'); --"
        ]
        
        user_service = UserService()
        
        for malicious_input in malicious_inputs:
            # Должен либо вернуть пустой результат, либо ошибку валидации
            # НО НЕ выполнить SQL инъекцию
            try:
                result = user_service.search_users(malicious_input)
                # Если поиск прошел, результат должен быть безопасным
                assert isinstance(result, list)
                # Проверяем что таблица users все еще существует
                users_count = user_service.count_all_users()
                assert users_count >= 0
            except (ValueError, DatabaseError) as e:
                # Ошибка валидации - это нормально
                assert "invalid" in str(e).lower() or "forbidden" in str(e).lower()
    
    def test_login_prevents_sql_injection(self):
        """Тестируем защиту от SQL инъекции в логине"""
        malicious_credentials = [
            {"email": "admin'--", "password": "anything"},
            {"email": "' OR 1=1 --", "password": ""},
            {"email": "'; DROP TABLE users; --", "password": "test"},
        ]
        
        auth_service = AuthService()
        
        for credentials in malicious_credentials:
            # Логин должен безопасно обработать вредоносный ввод
            result = auth_service.authenticate(
                credentials["email"], 
                credentials["password"]
            )
            
            # Логин должен провалиться
            assert result is None or result.get("success") is False
            
            # Проверяем что база данных не повреждена
            user_count = auth_service.user_repository.count_all()
            assert user_count >= 0
    
    def test_parameterized_queries_usage(self):
        """Проверяем что используются параметризованные запросы"""
        # Этот тест проверяет код на использование безопасных запросов
        import inspect
        from user_repository import UserRepository
        
        repo = UserRepository()
        
        # Получаем исходный код методов
        search_method_source = inspect.getsource(repo.search_by_name)
        find_by_email_source = inspect.getsource(repo.find_by_email)
        
        # Проверяем что НЕ используется конкатенация строк
        dangerous_patterns = [
            "SELECT * FROM users WHERE name = '" + ",",
            'SELECT * FROM users WHERE name = "' + ',
            "% " + " %",
            ".format(",
            "f\"SELECT",
            "f'SELECT"
        ]
        
        for pattern in dangerous_patterns:
            assert pattern not in search_method_source, \
                f"Dangerous pattern found: {pattern}"
            assert pattern not in find_by_email_source, \
                f"Dangerous pattern found: {pattern}"
        
        # Проверяем что используются безопасные паттерны
        safe_patterns = [
            ".query(",
            "bindparam(",
            "text(",
            ":name",  # Именованные параметры
            "?",      # Позиционные параметры
        ]
        
        has_safe_pattern = any(
            pattern in search_method_source for pattern in safe_patterns
        )
        assert has_safe_pattern, "No safe query patterns found"

    @pytest.mark.integration
    def test_stored_procedures_injection_prevention(self, db_connection):
        """Тестируем защиту от инъекций в хранимых процедурах"""
        cursor = db_connection.cursor()
        
        # Вредоносные данные для процедуры
        malicious_data = [
            "'; EXEC xp_cmdshell('rm -rf /'); --",
            "test'; DROP PROCEDURE GetUserStats; --"
        ]
        
        for malicious_input in malicious_data:
            try:
                # Вызываем хранимую процедуру с вредоносными данными
                cursor.callproc('GetUserStats', [malicious_input])
                results = cursor.fetchall()
                
                # Процедура должна обработать данные безопасно
                assert isinstance(results, (list, tuple))
                
                # Проверяем что процедура все еще существует
                cursor.execute("SELECT COUNT(*) FROM information_schema.routines WHERE routine_name = 'GetUserStats'")
                proc_count = cursor.fetchone()[0]
                assert proc_count == 1, "Stored procedure was deleted!"
                
            except Exception as e:
                # Ошибка выполнения - приемлемо, если это ошибка валидации
                assert "syntax error" not in str(e).lower(), \
                    f"SQL syntax error suggests injection vulnerability: {e}"
```

**Go тестирование SQL инъекций:**
```go
package security

import (
    "database/sql"
    "strings"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestSQLInjectionPrevention(t *testing.T) {
    db := setupTestDatabase(t)
    defer db.Close()
    
    userRepo := NewUserRepository(db)
    
    maliciousInputs := []string{
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "'; DELETE FROM users; --",
        "' UNION SELECT password FROM users --",
        "admin'--",
        "' OR 1=1#",
    }
    
    // Создаем тестового пользователя
    testUser := User{Name: "testuser", Email: "test@example.com"}
    _, err := userRepo.Create(testUser)
    require.NoError(t, err)
    
    originalCount, err := userRepo.Count()
    require.NoError(t, err)
    
    for _, maliciousInput := range maliciousInputs {
        t.Run("Malicious input: "+maliciousInput, func(t *testing.T) {
            // Тестируем поиск пользователей
            users, err := userRepo.SearchByName(maliciousInput)
            
            // Запрос должен либо вернуть пустой результат, либо ошибку валидации
            if err != nil {
                // Ошибка должна быть связана с валидацией, а не с SQL
                assert.NotContains(t, strings.ToLower(err.Error()), "syntax error")
                assert.NotContains(t, strings.ToLower(err.Error()), "near")
            } else {
                // Если запрос прошел, должен вернуть безопасный результат
                assert.IsType(t, []User{}, users)
            }
            
            // Проверяем что таблица не была повреждена
            currentCount, err := userRepo.Count()
            require.NoError(t, err)
            assert.Equal(t, originalCount, currentCount, 
                "User count changed - possible injection attack succeeded")
        })
    }
}

func TestParameterizedQueries(t *testing.T) {
    db := setupTestDatabase(t)
    defer db.Close()
    
    // Проверяем что запросы используют параметры
    testCases := []struct {
        name     string
        query    string
        args     []interface{}
        expected bool
    }{
        {
            name:     "Parameterized query",
            query:    "SELECT * FROM users WHERE name = ? AND email = ?",
            args:     []interface{}{"John", "john@example.com"},
            expected: true,
        },
        {
            name:     "Named parameters",
            query:    "SELECT * FROM users WHERE name = :name AND email = :email",
            args:     []interface{}{sql.Named("name", "John"), sql.Named("email", "john@example.com")},
            expected: true,
        },
    }
    
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            rows, err := db.Query(tc.query, tc.args...)
            if tc.expected {
                assert.NoError(t, err)
                if rows != nil {
                    rows.Close()
                }
            } else {
                assert.Error(t, err)
            }
        })
    }
}

func TestStoredProcedureInjection(t *testing.T) {
    db := setupTestDatabase(t)
    defer db.Close()
    
    maliciousInputs := []string{
        "'; EXEC sp_configure 'show advanced options', 1; --",
        "test'; DROP PROCEDURE GetUserStats; --",
    }
    
    for _, input := range maliciousInputs {
        t.Run("Testing stored procedure with: "+input, func(t *testing.T) {
            // Вызываем хранимую процедуру с потенциально вредоносными данными
            rows, err := db.Query("CALL GetUserStats(?)", input)
            
            if err != nil {
                // Ошибка должна быть связана с валидацией, не с SQL синтаксисом
                assert.NotContains(t, strings.ToLower(err.Error()), "syntax error")
            } else {
                // Если запрос прошел, закрываем rows
                if rows != nil {
                    rows.Close()
                }
            }
            
            // Проверяем что процедура все еще существует
            var procCount int
            err = db.QueryRow("SELECT COUNT(*) FROM information_schema.routines WHERE routine_name = 'GetUserStats'").Scan(&procCount)
            require.NoError(t, err)
            assert.Equal(t, 1, procCount, "Stored procedure was deleted - injection succeeded!")
        })
    }
}
```

### 🔐 Тестирование аутентификации и авторизации

**Python тестирование JWT безопасности:**
```python
import jwt
import pytest
from datetime import datetime, timedelta
from freezegun import freeze_time

class TestJWTSecurity:
    
    def test_jwt_token_expiration(self):
        """Проверяем что токены истекают"""
        auth_service = AuthService()
        
        # Создаем токен
        user_data = {"email": "test@example.com", "user_id": 1}
        token = auth_service.create_access_token(user_data, expires_in=3600)  # 1 час
        
        # Токен должен быть валиден сейчас
        payload = auth_service.verify_token(token)
        assert payload["email"] == "test@example.com"
        
        # Перемещаемся в будущее на 2 часа
        with freeze_time(datetime.utcnow() + timedelta(hours=2)):
            # Токен должен быть просрочен
            with pytest.raises(jwt.ExpiredSignatureError):
                auth_service.verify_token(token)
    
    def test_jwt_token_tampering_detection(self):
        """Проверяем защиту от подделки токенов"""
        auth_service = AuthService()
        
        user_data = {"email": "user@example.com", "user_id": 1, "role": "user"}
        token = auth_service.create_access_token(user_data)
        
        # Пытаемся изменить payload токена
        header, payload, signature = token.split('.')
        
        # Декодируем payload и изменяем роль
        import base64
        import json
        
        payload_data = json.loads(base64.urlsafe_b64decode(payload + '=='))
        payload_data["role"] = "admin"  # Повышаем привилегии
        
        # Кодируем обратно
        modified_payload = base64.urlsafe_b64encode(
            json.dumps(payload_data).encode()
        ).decode().rstrip('=')
        
        tampered_token = f"{header}.{modified_payload}.{signature}"
        
        # Проверка должна провалиться
        with pytest.raises(jwt.InvalidSignatureError):
            auth_service.verify_token(tampered_token)
    
    def test_weak_jwt_secrets_prevention(self):
        """Проверяем что не используются слабые секреты"""
        weak_secrets = [
            "secret",
            "123456",
            "password",
            "jwt_secret",
            "your-256-bit-secret",
            ""
        ]
        
        for weak_secret in weak_secrets:
            with pytest.raises((ValueError, AssertionError)):
                # AuthService должен отклонить слабые секреты
                AuthService(jwt_secret=weak_secret)
    
    def test_password_hashing_security(self):
        """Проверяем безопасность хеширования паролей"""
        auth_service = AuthService()
        
        password = "user_password_123"
        
        # Хешируем пароль
        hashed1 = auth_service.hash_password(password)
        hashed2 = auth_service.hash_password(password)
        
        # Хеши должны быть разными (salt)
        assert hashed1 != hashed2
        
        # Но оба должны проходить проверку
        assert auth_service.verify_password(password, hashed1)
        assert auth_service.verify_password(password, hashed2)
        
        # Неправильный пароль не должен проходить
        assert not auth_service.verify_password("wrong_password", hashed1)
        
        # Хеш должен быть достаточно длинным (bcrypt/scrypt/argon2)
        assert len(hashed1) > 50
        
        # Хеш не должен содержать исходный пароль
        assert password not in hashed1
    
    def test_rate_limiting_authentication(self):
        """Тестируем ограничение попыток входа"""
        auth_service = AuthService()
        
        # Делаем много неудачных попыток входа
        for attempt in range(6):  # Превышаем лимит в 5 попыток
            result = auth_service.authenticate(
                "user@example.com", 
                "wrong_password"
            )
            
            if attempt < 5:
                # Первые 5 попыток должны просто провалиться
                assert result is None or not result.get("success")
            else:
                # 6-я попытка должна быть заблокирована
                assert result is not None
                assert "rate_limited" in result or "too_many_attempts" in str(result)
    
    def test_session_fixation_prevention(self):
        """Проверяем защиту от фиксации сессии"""
        session_service = SessionService()
        
        # Создаем анонимную сессию
        anon_session_id = session_service.create_anonymous_session()
        
        # Логинимся пользователем
        user = {"email": "test@example.com", "user_id": 1}
        auth_session_id = session_service.login_user(user)
        
        # ID сессии должен измениться после логина
        assert anon_session_id != auth_session_id
        
        # Старая сессия должна быть недействительна
        assert not session_service.is_valid_session(anon_session_id)
        assert session_service.is_valid_session(auth_session_id)
    
    def test_privilege_escalation_prevention(self):
        """Тестируем защиту от повышения привилегий"""
        auth_service = AuthService()
        
        # Создаем пользователя с обычными правами
        user_token = auth_service.create_access_token({
            "email": "user@example.com",
            "user_id": 1,
            "role": "user"
        })
        
        # Пытаемся получить доступ к админским функциям
        headers = {"Authorization": f"Bearer {user_token}"}
        
        admin_endpoints = [
            "/admin/users",
            "/admin/settings", 
            "/admin/logs",
            "/api/admin/delete_user"
        ]
        
        for endpoint in admin_endpoints:
            response = client.get(endpoint, headers=headers)
            # Должен быть отказ в доступе
            assert response.status_code in [401, 403]
            assert "insufficient" in response.json().get("detail", "").lower() or \
                   "forbidden" in response.json().get("detail", "").lower()
```

### 🌐 Тестирование безопасности API

**Python тестирование CORS и заголовков безопасности:**
```python
class TestAPISecurity:
    
    def test_cors_headers_configuration(self):
        """Проверяем правильную настройку CORS"""
        # Тест preflight запроса
        response = client.options("/api/users", headers={
            "Origin": "https://example.com",
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "Content-Type,Authorization"
        })
        
        assert response.status_code == 200
        
        # Проверяем CORS заголовки
        assert "Access-Control-Allow-Origin" in response.headers
        assert "Access-Control-Allow-Methods" in response.headers
        assert "Access-Control-Allow-Headers" in response.headers
        
        # Проверяем что не разрешен доступ с любых доменов
        assert response.headers["Access-Control-Allow-Origin"] != "*"
    
    def test_security_headers_presence(self):
        """Проверяем наличие заголовков безопасности"""
        response = client.get("/api/users")
        
        required_security_headers = {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
            "Content-Security-Policy": lambda val: "default-src" in val,
            "Referrer-Policy": "strict-origin-when-cross-origin"
        }
        
        for header, expected_value in required_security_headers.items():
            assert header in response.headers, f"Missing security header: {header}"
            
            if callable(expected_value):
                assert expected_value(response.headers[header]), \
                    f"Invalid {header}: {response.headers[header]}"
            else:
                assert response.headers[header] == expected_value, \
                    f"Invalid {header}: {response.headers[header]}"
    
    def test_sensitive_data_exposure_prevention(self):
        """Проверяем что чувствительные данные не утекают"""
        # Создаем пользователя
        user_data = {
            "email": "sensitive@example.com",
            "password": "secret_password_123",
            "ssn": "123-45-6789"
        }
        
        response = client.post("/users", json=user_data)
        assert response.status_code == 201
        
        user_response = response.json()
        
        # Пароль не должен возвращаться
        assert "password" not in user_response
        
        # SSN должен быть замаскирован или отсутствовать
        if "ssn" in user_response:
            ssn = user_response["ssn"]
            assert "***" in ssn or "XXX" in ssn, f"SSN not masked: {ssn}"
        
        # Получаем пользователя через API
        user_id = user_response["id"]
        get_response = client.get(f"/users/{user_id}")
        get_data = get_response.json()
        
        # Чувствительные данные не должны быть в публичном API
        sensitive_fields = ["password", "password_hash", "secret_key"]
        for field in sensitive_fields:
            assert field not in get_data, f"Sensitive field exposed: {field}"
    
    def test_input_validation_and_sanitization(self):
        """Тестируем валидацию и санитизацию ввода"""
        malicious_inputs = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "../../etc/passwd",
            "../../../windows/system32",
            "'; DROP TABLE users; --",
            "\x00\x01\x02",  # Null bytes
            "A" * 10000,     # Очень длинная строка
        ]
        
        for malicious_input in malicious_inputs:
            # Тестируем создание пользователя с вредоносными данными
            user_data = {
                "name": malicious_input,
                "email": f"test{hash(malicious_input)}@example.com",
                "bio": malicious_input
            }
            
            response = client.post("/users", json=user_data)
            
            if response.status_code == 201:
                # Если пользователь создан, данные должны быть санитизированы
                created_user = response.json()
                
                # XSS скрипты должны быть удалены или экранированы
                assert "<script>" not in created_user.get("name", "")
                assert "javascript:" not in created_user.get("name", "")
                
                # Path traversal должен быть заблокирован
                assert "../" not in created_user.get("name", "")
                
            elif response.status_code == 422:
                # Ошибка валидации - приемлемо
                error_data = response.json()
                assert "detail" in error_data
            else:
                pytest.fail(f"Unexpected response for malicious input: {response.status_code}")
    
    def test_file_upload_security(self):
        """Тестируем безопасность загрузки файлов"""
        # Создаем различные типы файлов для тестирования
        test_files = {
            "valid_image.jpg": (b"\xFF\xD8\xFF", "image/jpeg"),
            "malicious.php": (b"<?php system($_GET['cmd']); ?>", "application/x-php"),
            "script.js": (b"alert('XSS');", "application/javascript"),
            "large_file.txt": (b"A" * (10 * 1024 * 1024), "text/plain"),  # 10MB
            "empty_file.txt": (b"", "text/plain"),
        }
        
        for filename, (content, content_type) in test_files.items():
            files = {"file": (filename, content, content_type)}
            
            response = client.post("/upload", files=files)
            
            if filename == "valid_image.jpg":
                # Валидный файл должен загружаться
                assert response.status_code in [200, 201]
            
            elif filename in ["malicious.php", "script.js"]:
                # Исполняемые файлы должны блокироваться
                assert response.status_code in [400, 403, 422]
                error_msg = response.json().get("detail", "").lower()
                assert any(word in error_msg for word in ["forbidden", "invalid", "not allowed"])
            
            elif filename == "large_file.txt":
                # Слишком большие файлы должны отклоняться
                assert response.status_code in [413, 422]
            
            elif filename == "empty_file.txt":
                # Пустые файлы могут быть отклонены или приняты
                assert response.status_code in [200, 201, 400, 422]
    
    def test_api_rate_limiting(self):
        """Тестируем ограничение скорости API"""
        import time
        
        # Делаем много запросов подряд
        responses = []
        for i in range(101):  # Превышаем лимит в 100 запросов
            response = client.get("/api/public-endpoint")
            responses.append(response)
            
            if response.status_code == 429:  # Too Many Requests
                break
        
        # Должен сработать rate limiting
        rate_limited_responses = [r for r in responses if r.status_code == 429]
        assert len(rate_limited_responses) > 0, "Rate limiting not working"
        
        # Проверяем заголовки rate limiting
        last_response = responses[-1]
        if last_response.status_code == 429:
            assert "Retry-After" in last_response.headers or \
                   "X-RateLimit-Reset" in last_response.headers
```

---

## 🏗️ Модуль 7: Инфраструктура тестирования (2-3 недели)

### 🔄 CI/CD Pipeline с тестами

**Современная схема CI/CD:**
```
Code Push → Pre-commit hooks → CI Pipeline → Deployment Pipeline
     ↓            ↓               ↓              ↓
   Linting    Unit Tests     Integration    Production
   Format     Coverage       E2E Tests      Monitoring
   Security   Build          Performance    Rollback
```

**GitHub Actions Configuration:**
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  DATABASE_URL: postgresql://test:test@localhost:5432/testdb
  REDIS_URL: redis://localhost:6379
  SECRET_KEY: test-secret-key-for-ci

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install poetry
          poetry install --with dev
      
      - name: Lint with flake8
        run: poetry run flake8 src/ tests/
      
      - name: Format check with black
        run: poetry run black --check src/ tests/
      
      - name: Type check with mypy
        run: poetry run mypy src/
      
      - name: Security check with bandit
        run: poetry run bandit -r src/

  unit-tests:
    runs-on: ubuntu-latest
    needs: lint
    
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          pip install poetry
          poetry install
      
      - name: Run unit tests
        run: |
          poetry run pytest tests/unit/ \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --junit-xml=test-results.xml
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: true
      
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ matrix.python-version }}
          path: test-results.xml

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install poetry
          poetry install
      
      - name: Run database migrations
        run: poetry run alembic upgrade head
      
      - name: Run integration tests
        run: |
          poetry run pytest tests/integration/ \
            --junit-xml=integration-results.xml
      
      - name: Upload integration test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: integration-test-results
          path: integration-results.xml

  security-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'http://localhost:8000'

  performance-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up application
        run: |
          pip install poetry
          poetry install
          poetry run python manage.py runserver &
          sleep 10
      
      - name: Run k6 performance tests
        uses: grafana/k6-action@v0.2.0
        with:
          filename: tests/performance/load_test.js
        env:
          K6_OUT: json=test-results.json
      
      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: test-results.json

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, security-tests]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .
          docker tag myapp:${{ github.sha }} myapp:latest
      
      - name: Run container smoke tests
        run: |
          docker run -d --name test-container -p 8000:8000 myapp:latest
          sleep 10
          curl -f http://localhost:8000/health || exit 1
          docker stop test-container
      
      - name: Deploy to staging
        if: success()
        run: |
          echo "Deploying to staging environment..."
          # Здесь логика деплоя
```

**Go CI/CD с GitHub Actions:**
```yaml
# .github/workflows/go-test.yml
name: Go Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        go-version: ['1.19', '1.20', '1.21']
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go ${{ matrix.go-version }}
        uses: actions/setup-go@v4
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Install dependencies
        run: go mod download
      
      - name: Run linter
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
      
      - name: Run unit tests
        run: |
          go test -v -race -covermode atomic -coverprofile=coverage.out ./...
      
      - name: Run integration tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/testdb?sslmode=disable
        run: |
          go test -v -tags=integration ./tests/integration/...
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
      
      - name: Run benchmarks
        run: |
          go test -bench=. -benchmem ./... | tee benchmark.txt
      
      - name: Upload benchmark results
        uses: actions/upload-artifact@v3
        with:
          name: benchmark-results-${{ matrix.go-version }}
          path: benchmark.txt

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Run Gosec Security Scanner
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: './...'
      
      - name: Run Nancy (dependency vulnerability check)
        run: |
          go list -json -m all | docker run --rm -i sonatypecommunity/nancy:latest sleuth

  build:
    needs: [test, security]
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Build application
        run: |
          CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
      
      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          format: 'table'
```

### 🐳 Docker тестовые окружения

**Docker Compose для тестирования:**
```yaml
# docker-compose.test.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.test
    environment:
      - DATABASE_URL=postgresql://test:test@postgres:5432/testdb
      - REDIS_URL=redis://redis:6379
      - ENV=test
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: pytest tests/ --junit-xml=/tmp/test-results.xml
    volumes:
      - test-results:/tmp

  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: testdb
      POSTGRES_USER: test
      POSTGRES_PASSWORD: test
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U test"]
      interval: 10s
      timeout: 5s
      retries: 5
    ports:
      - "5433:5432"

  redis:
    image: redis:7-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    ports:
      - "6380:6379"

  test-db-migration:
    image: migrate/migrate
    depends_on:
      postgres:
        condition: service_healthy
    command: [
      "-path", "/migrations",
      "-database", "postgresql://test:test@postgres:5432/testdb?sslmode=disable",
      "up"
    ]
    volumes:
      - ./migrations:/migrations

volumes:
  test-results:
```

**Dockerfile.test:**
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Установка системных зависимостей
RUN apt-get update && apt-get install -y \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Копирование файлов зависимостей
COPY requirements.txt pyproject.toml poetry.lock ./

# Установка Python зависимостей
RUN pip install poetry && \
    poetry config virtualenvs.create false && \
    poetry install --with dev,test

# Копирование кода приложения
COPY . .

# Скрипт для ожидания готовности БД
COPY wait-for-db.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/wait-for-db.sh

# Healthcheck
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

CMD ["wait-for-db.sh", "postgres:5432", "--", "pytest"]
```

### 🔧 Управление тестовыми данными

**Python фикстуры и сиды:**
```python
# conftest.py
import pytest
import asyncio
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from testcontainers.postgres import PostgresContainer

@pytest.fixture(scope="session")
def postgres_container():
    with PostgresContainer("postgres:13") as postgres:
        yield postgres

@pytest.fixture(scope="session")
def database_url(postgres_container):
    return postgres_container.get_connection_url()

@pytest.fixture(scope="session")
def engine(database_url):
    return create_engine(database_url)

@pytest.fixture(scope="function")
def db_session(engine):
    # Создаем сессию для каждого теста
    Session = sessionmaker(bind=engine)
    session = Session()
    
    # Начинаем транзакцию
    transaction = session.begin()
    
    yield session
    
    # Откатываем транзакцию после теста
    transaction.rollback()
    session.close()

@pytest.fixture
def sample_users(db_session):
    """Создает тестовых пользователей"""
    users = [
        User(email="john@example.com", name="John Doe", age=30),
        User(email="jane@example.com", name="Jane Smith", age=25),
        User(email="admin@example.com", name="Admin User", age=35, role="admin"),
    ]
    
    for user in users:
        db_session.add(user)
    db_session.commit()
    
    return users

@pytest.fixture
def authenticated_client(sample_users):
    """Клиент с аутентифицированным пользователем"""
    auth_service = AuthService()
    token = auth_service.create_access_token({
        "email": sample_users[0].email,
        "user_id": sample_users[0].id
    })
    
    client = TestClient(app)
    client.headers.update({"Authorization": f"Bearer {token}"})
    return client

class DatabaseSeeder:
    """Класс для создания больших наборов тестовых данных"""
    
    def __init__(self, session):
        self.session = session
    
    def seed_users(self, count=100):
        """Создает указанное количество пользователей"""
        from faker import Faker
        fake = Faker()
        
        users = []
        for i in range(count):
            user = User(
                email=fake.email(),
                name=fake.name(),
                age=fake.random_int(min=18, max=65),
                created_at=fake.date_time_between(start_date='-1y', end_date='now')
            )
            users.append(user)
        
        self.session.add_all(users)
        self.session.commit()
        return users
    
    def seed_posts(self, users, posts_per_user=5):
        """Создает посты для пользователей"""
        from faker import Faker
        fake = Faker()
        
        posts = []
        for user in users:
            for _ in range(posts_per_user):
                post = Post(
                    title=fake.sentence(),
                    content=fake.text(),
                    author_id=user.id,
                    created_at=fake.date_time_between(start_date='-6m', end_date='now')
                )
                posts.append(post)
        
        self.session.add_all(posts)
        self.session.commit()
        return posts
    
    def seed_comments(self, posts, comments_per_post=3):
        """Создает комментарии к постам"""
        from faker import Faker
        fake = Faker()
        
        comments = []
        for post in posts:
            for _ in range(comments_per_post):
                comment = Comment(
                    content=fake.text(max_nb_chars=200),
                    post_id=post.id,
                    author_id=fake.random_element(elements=[u.id for u in self.session.query(User).all()]),
                    created_at=fake.date_time_between(start_date=post.created_at, end_date='now')
                )
                comments.append(comment)
        
        self.session.add_all(comments)
        self.session.commit()
        return comments

@pytest.fixture
def large_dataset(db_session):
    """Создает большой набор данных для тестирования производительности"""
    seeder = DatabaseSeeder(db_session)
    
    users = seeder.seed_users(1000)
    posts = seeder.seed_posts(users[:100], posts_per_user=10)  # 1000 постов
    comments = seeder.seed_comments(posts, comments_per_post=5)  # 5000 комментариев
    
    return {
        "users": users,
        "posts": posts,
        "comments": comments
    }

# Хелперы для очистки данных
@pytest.fixture(autouse=True)
def cleanup_data(db_session):
    """Автоматически очищает данные после каждого теста"""
    yield
    # После теста - очищаем все таблицы
    for table in reversed(Base.metadata.sorted_tables):
        db_session.execute(table.delete())
    db_session.commit()

# Фикстуры для внешних сервисов
@pytest.fixture
def mock_email_service():
    """Мок email сервиса"""
    with patch('app.services.email_service.EmailService') as mock:
        mock_instance = Mock()
        mock.return_value = mock_instance
        mock_instance.send_email.return_value = True
```

**Go тестовые фикстуры:**
```go
package testutils

import (
    "database/sql"
    "fmt"
    "testing"
    "context"
    "time"
    
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/stretchr/testify/require"
    "github.com/go-faker/faker/v4"
)

// TestDatabase представляет тестовую базу данных
type TestDatabase struct {
    Container testcontainers.Container
    DB        *sql.DB
    URL       string
}

// SetupTestDatabase создает тестовую базу данных в контейнере
func SetupTestDatabase(t *testing.T) *TestDatabase {
    ctx := context.Background()
    
    postgresContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:13"),
        postgres.WithDatabase("testdb"),
        postgres.WithUsername("test"),
        postgres.WithPassword("test"),
        testcontainers.WithWaitStrategy(wait.ForLog("database system is ready to accept connections")),
    )
    require.NoError(t, err)
    
    connStr, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
    require.NoError(t, err)
    
    db, err := sql.Open("postgres", connStr)
    require.NoError(t, err)
    
    // Применяем миграции
    err = runMigrations(db)
    require.NoError(t, err)
    
    return &TestDatabase{
        Container: postgresContainer,
        DB:        db,
        URL:       connStr,
    }
}

// Cleanup закрывает соединение и останавливает контейнер
func (td *TestDatabase) Cleanup(t *testing.T) {
    td.DB.Close()
    ctx := context.Background()
    err := td.Container.Terminate(ctx)
    require.NoError(t, err)
}

// ClearAllTables очищает все таблицы
func (td *TestDatabase) ClearAllTables(t *testing.T) {
    tables := []string{"comments", "posts", "users"} // В порядке зависимостей
    
    for _, table := range tables {
        _, err := td.DB.Exec(fmt.Sprintf("DELETE FROM %s", table))
        require.NoError(t, err)
        
        // Сбрасываем auto-increment
        _, err = td.DB.Exec(fmt.Sprintf("ALTER SEQUENCE %s_id_seq RESTART WITH 1", table))
        if err != nil {
            // Игнорируем ошибку если sequence не существует
            t.Logf("Warning: Could not reset sequence for table %s: %v", table, err)
        }
    }
}

// TestDataSeeder создает тестовые данные
type TestDataSeeder struct {
    db *sql.DB
}

// NewTestDataSeeder создает новый seeder
func NewTestDataSeeder(db *sql.DB) *TestDataSeeder {
    return &TestDataSeeder{db: db}
}

// SeedUsers создает тестовых пользователей
func (s *TestDataSeeder) SeedUsers(count int) ([]User, error) {
    users := make([]User, count)
    
    for i := 0; i < count; i++ {
        user := User{
            Email:     faker.Email(),
            Name:      faker.Name(),
            Age:       faker.RandomInt(18, 65),
            CreatedAt: time.Now().AddDate(0, 0, -faker.RandomInt(1, 365)),
        }
        
        err := s.db.QueryRow(`
            INSERT INTO users (email, name, age, created_at) 
            VALUES ($1, $2, $3, $4) 
            RETURNING id`,
            user.Email, user.Name, user.Age, user.CreatedAt,
        ).Scan(&user.ID)
        
        if err != nil {
            return nil, err
        }
        
        users[i] = user
    }
    
    return users, nil
}

// SeedPosts создает тестовые посты
func (s *TestDataSeeder) SeedPosts(users []User, postsPerUser int) ([]Post, error) {
    var posts []Post
    
    for _, user := range users {
        for i := 0; i < postsPerUser; i++ {
            post := Post{
                Title:     faker.Sentence(),
                Content:   faker.Paragraph(),
                AuthorID:  user.ID,
                CreatedAt: time.Now().AddDate(0, 0, -faker.RandomInt(1, 180)),
            }
            
            err := s.db.QueryRow(`
                INSERT INTO posts (title, content, author_id, created_at) 
                VALUES ($1, $2, $3, $4) 
                RETURNING id`,
                post.Title, post.Content, post.AuthorID, post.CreatedAt,
            ).Scan(&post.ID)
            
            if err != nil {
                return nil, err
            }
            
            posts = append(posts, post)
        }
    }
    
    return posts, nil
}

// TestHelpers содержит вспомогательные функции для тестов
type TestHelpers struct {
    db *sql.DB
}

// NewTestHelpers создает новый набор хелперов
func NewTestHelpers(db *sql.DB) *TestHelpers {
    return &TestHelpers{db: db}
}

// CreateTestUser создает одного тестового пользователя
func (h *TestHelpers) CreateTestUser(t *testing.T, email, name string) User {
    user := User{
        Email: email,
        Name:  name,
        Age:   25,
    }
    
    err := h.db.QueryRow(`
        INSERT INTO users (email, name, age) 
        VALUES ($1, $2, $3) 
        RETURNING id, created_at`,
        user.Email, user.Name, user.Age,
    ).Scan(&user.ID, &user.CreatedAt)
    
    require.NoError(t, err)
    return user
}

// CreateTestPost создает тестовый пост
func (h *TestHelpers) CreateTestPost(t *testing.T, authorID int, title, content string) Post {
    post := Post{
        Title:    title,
        Content:  content,
        AuthorID: authorID,
    }
    
    err := h.db.QueryRow(`
        INSERT INTO posts (title, content, author_id) 
        VALUES ($1, $2, $3) 
        RETURNING id, created_at`,
        post.Title, post.Content, post.AuthorID,
    ).Scan(&post.ID, &post.CreatedAt)
    
    require.NoError(t, err)
    return post
}

// AssertUserExists проверяет что пользователь существует
func (h *TestHelpers) AssertUserExists(t *testing.T, userID int) {
    var count int
    err := h.db.QueryRow("SELECT COUNT(*) FROM users WHERE id = $1", userID).Scan(&count)
    require.NoError(t, err)
    require.Equal(t, 1, count, "User should exist")
}

// AssertUserNotExists проверяет что пользователь не существует
func (h *TestHelpers) AssertUserNotExists(t *testing.T, userID int) {
    var count int
    err := h.db.QueryRow("SELECT COUNT(*) FROM users WHERE id = $1", userID).Scan(&count)
    require.NoError(t, err)
    require.Equal(t, 0, count, "User should not exist")
}

// GetUserCount возвращает количество пользователей
func (h *TestHelpers) GetUserCount(t *testing.T) int {
    var count int
    err := h.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&count)
    require.NoError(t, err)
    return count
}

// MockServices содержит моки внешних сервисов
type MockServices struct {
    EmailService    *MockEmailService
    PaymentGateway  *MockPaymentGateway
    NotificationSvc *MockNotificationService
}

// NewMockServices создает новый набор моков
func NewMockServices() *MockServices {
    return &MockServices{
        EmailService:    NewMockEmailService(),
        PaymentGateway:  NewMockPaymentGateway(),
        NotificationSvc: NewMockNotificationService(),
    }
}

// MockEmailService мок email сервиса
type MockEmailService struct {
    SentEmails []EmailMessage
    ShouldFail bool
}

type EmailMessage struct {
    To      string
    Subject string
    Body    string
    SentAt  time.Time
}

func NewMockEmailService() *MockEmailService {
    return &MockEmailService{
        SentEmails: make([]EmailMessage, 0),
    }
}

func (m *MockEmailService) SendEmail(to, subject, body string) error {
    if m.ShouldFail {
        return fmt.Errorf("mock email service failure")
    }
    
    email := EmailMessage{
        To:      to,
        Subject: subject,
        Body:    body,
        SentAt:  time.Now(),
    }
    
    m.SentEmails = append(m.SentEmails, email)
    return nil
}

func (m *MockEmailService) GetSentEmailsCount() int {
    return len(m.SentEmails)
}

func (m *MockEmailService) GetLastSentEmail() *EmailMessage {
    if len(m.SentEmails) == 0 {
        return nil
    }
    return &m.SentEmails[len(m.SentEmails)-1]
}

func (m *MockEmailService) Reset() {
    m.SentEmails = make([]EmailMessage, 0)
    m.ShouldFail = false
}

// MockPaymentGateway мок платежного шлюза
type MockPaymentGateway struct {
    Transactions []Transaction
    ShouldFail   bool
}

type Transaction struct {
    ID     string
    Amount float64
    Status string
}

func NewMockPaymentGateway() *MockPaymentGateway {
    return &MockPaymentGateway{
        Transactions: make([]Transaction, 0),
    }
}

func (m *MockPaymentGateway) ProcessPayment(amount float64) (*Transaction, error) {
    if m.ShouldFail {
        return nil, fmt.Errorf("payment processing failed")
    }
    
    transaction := Transaction{
        ID:     fmt.Sprintf("txn_%d", time.Now().Unix()),
        Amount: amount,
        Status: "completed",
    }
    
    m.Transactions = append(m.Transactions, transaction)
    return &transaction, nil
}

func (m *MockPaymentGateway) GetTransactionCount() int {
    return len(m.Transactions)
}

func (m *MockPaymentGateway) Reset() {
    m.Transactions = make([]Transaction, 0)
    m.ShouldFail = false
}

// Пример использования в тестах
func TestExample(t *testing.T) {
    // Настройка тестовой базы данных
    testDB := SetupTestDatabase(t)
    defer testDB.Cleanup(t)
    
    // Создание хелперов и сервисов
    helpers := NewTestHelpers(testDB.DB)
    mockServices := NewMockServices()
    seeder := NewTestDataSeeder(testDB.DB)
    
    // Создание тестовых данных
    user := helpers.CreateTestUser(t, "test@example.com", "Test User")
    post := helpers.CreateTestPost(t, user.ID, "Test Post", "Test content")
    
    // Или создание большого количества данных
    users, err := seeder.SeedUsers(100)
    require.NoError(t, err)
    
    posts, err := seeder.SeedPosts(users[:10], 5) // 50 постов
    require.NoError(t, err)
    
    // Тестирование с моками
    userService := NewUserService(testDB.DB, mockServices.EmailService)
    
    err = userService.RegisterUser("newuser@example.com", "New User")
    require.NoError(t, err)
    
    // Проверка что email был отправлен
    assert.Equal(t, 1, mockServices.EmailService.GetSentEmailsCount())
    
    lastEmail := mockServices.EmailService.GetLastSentEmail()
    assert.Equal(t, "newuser@example.com", lastEmail.To)
    assert.Contains(t, lastEmail.Subject, "Welcome")
    
    // Очистка после теста
    testDB.ClearAllTables(t)
    mockServices.EmailService.Reset()
}

func runMigrations(db *sql.DB) error {
    // Здесь выполняем SQL миграции
    schema := `
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE NOT NULL,
            name VARCHAR(255) NOT NULL,
            age INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE TABLE IF NOT EXISTS posts (
            id SERIAL PRIMARY KEY,
            title VARCHAR(255) NOT NULL,
            content TEXT,
            author_id INTEGER REFERENCES users(id),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE TABLE IF NOT EXISTS comments (
            id SERIAL PRIMARY KEY,
            content TEXT NOT NULL,
            post_id INTEGER REFERENCES posts(id),
            author_id INTEGER REFERENCES users(id),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    `
    
    _, err := db.Exec(schema)
    return err
}

@pytest.fixture
def mock_payment_gateway():
    """Мок платежного шлюза"""
    with patch('app.services.payment.PaymentGateway') as mock:
        mock_instance = Mock()
        mock.return_value = mock_instance
        mock_instance.charge.return_value = {
            "success": True,
            "transaction_id": "txn_123456",
            "amount": 100.00
        }
```

### 📊 Отчетность и мониторинг тестов

**Настройка coverage и отчетов:**
```python
# setup.cfg
[coverage:run]
source = src/
omit = 
    */tests/*
    */venv/*
    */migrations/*
    */settings/*
    */manage.py

[coverage:report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:

[coverage:html]
directory = htmlcov

[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --strict-markers
    --strict-config
    --verbose
    --tb=short
    --cov=src
    --cov-report=term-missing
    --cov-report=html
    --cov-report=xml
    --junit-xml=test-results.xml
markers =
    unit: Unit tests
    integration: Integration tests
    slow: Slow tests
    security: Security tests
    performance: Performance tests
```

**Makefile для автоматизации:**
```makefile
# Makefile
.PHONY: test test-unit test-integration test-performance test-security
.PHONY: coverage lint format type-check clean

# Переменные
PYTHON = poetry run python
PYTEST = poetry run pytest
COVERAGE = poetry run coverage
FLAKE8 = poetry run flake8
BLACK = poetry run black
MYPY = poetry run mypy

# Установка зависимостей
install:
	poetry install --with dev,test

# Все тесты
test: test-unit test-integration

# Юнит тесты
test-unit:
	$(PYTEST) tests/unit/ -v --tb=short

# Интеграционные тесты
test-integration:
	$(PYTEST) tests/integration/ -v --tb=short --maxfail=5

# Тесты производительности
test-performance:
	$(PYTEST) tests/performance/ -v --tb=short -m "not slow"

# Медленные тесты производительности
test-performance-full:
	$(PYTEST) tests/performance/ -v --tb=short

# Тесты безопасности
test-security:
	$(PYTEST) tests/security/ -v --tb=short
	poetry run bandit -r src/
	poetry run safety check

# Быстрые тесты (без медленных)
test-fast:
	$(PYTEST) tests/ -v -m "not slow and not integration"

# Покрытие кода
coverage:
	$(COVERAGE) run -m pytest tests/
	$(COVERAGE) report
	$(COVERAGE) html
	@echo "Coverage report generated in htmlcov/index.html"

# Линтинг
lint:
	$(FLAKE8) src/ tests/
	$(BLACK) --check src/ tests/
	$(MYPY) src/

# Форматирование
format:
	$(BLACK) src/ tests/
	poetry run isort src/ tests/

# Проверка типов
type-check:
	$(MYPY) src/ --strict

# Запуск всех проверок качества
quality: lint type-check test-unit

# Очистка
clean:
	find . -type f -name "*.pyc" -delete
	find . -type d -name "__pycache__" -delete
	find . -type d -name "*.egg-info" -exec rm -rf {} +
	rm -rf .coverage htmlcov/ .pytest_cache/ dist/ build/

# CI пайплайн локально
ci: clean install quality test coverage

# Запуск тестов в Docker
test-docker:
	docker-compose -f docker-compose.test.yml up --build --abort-on-container-exit
	docker-compose -f docker-compose.test.yml down

# Мониторинг тестов в реальном времени
test-watch:
	poetry run ptw tests/ src/ --runner "$(PYTEST) tests/unit/"

# Генерация отчета по flaky тестам
test-flaky:
	$(PYTEST) tests/ --flaky-report=flaky-report.html

# Профилирование тестов
test-profile:
	$(PYTEST) tests/unit/ --profile --profile-svg

# Параллельные тесты
test-parallel:
	$(PYTEST) tests/ -n auto --dist=worksteal
```

---

## 🚀 Модуль 8: Специализированные техники (2-3 недели)

### 🎲 Property-based тестирование

**Философия Property-based Testing:**
```
Обычные тесты:    Для входа X → ожидаем выход Y
Property тесты:   Для ЛЮБОГО входа → должно выполняться свойство Z

Пример:
Обычный:     reverse("hello") == "olleh"
Property:    reverse(reverse(s)) == s  (для любой строки s)
```

**Python с Hypothesis:**
```python
from hypothesis import given, strategies as st, assume, example
from hypothesis.stateful import RuleBasedStateMachine, rule, Bundle, initialize
import pytest

class TestStringFunctions:
    
    @given(s=st.text())
    def test_reverse_is_involution(self, s):
        """Тестируем что двойное обращение строки дает исходную строку"""
        assert reverse(reverse(s)) == s
    
    @given(s=st.text())
    def test_reverse_length_preserved(self, s):
        """Длина строки сохраняется при обращении"""
        assert len(reverse(s)) == len(s)
    
    @given(s1=st.text(), s2=st.text())
    def test_reverse_concatenation_property(self, s1, s2):
        """reverse(s1 + s2) == reverse(s2) + reverse(s1)"""
        assert reverse(s1 + s2) == reverse(s2) + reverse(s1)
    
    @given(lst=st.lists(st.integers()))
    def test_sort_is_idempotent(self, lst):
        """Сортировка идемпотентна"""
        sorted_once = sorted(lst)
        sorted_twice = sorted(sorted_once)
        assert sorted_once == sorted_twice
    
    @given(lst=st.lists(st.integers()))
    def test_sort_preserves_length(self, lst):
        """Сортировка сохраняет длину"""
        assert len(sorted(lst)) == len(lst)
    
    @given(lst=st.lists(st.integers(), min_size=1))
    def test_max_element_in_sorted_list(self, lst):
        """Максимальный элемент в отсортированном списке - последний"""
        sorted_lst = sorted(lst)
        assert max(lst) == sorted_lst[-1]

class TestUserService:
    
    @given(email=st.emails(), name=st.text(min_size=1, max_size=100))
    def test_user_creation_properties(self, email, name):
        """Тестируем свойства создания пользователя"""
        # Исключаем недопустимые имена
        assume(name.strip() != "")
        assume(not any(char in name for char in ['<', '>', '"', "'"]))
        
        user_service = UserService()
        user = user_service.create_user(email, name)
        
        # Свойства которые всегда должны выполняться
        assert user.email == email.lower()  # Email нормализован
        assert user.name == name.strip()    # Имя обрезано
        assert user.id > 0                  # ID положительный
        assert user.created_at is not None  # Дата создания установлена
        assert user.is_active is True       # По умолчанию активный
    
    @given(age=st.integers())
    def test_age_validation_property(self, age):
        """Тестируем валидацию возраста"""
        user_service = UserService()
        
        if 0 <= age <= 150:
            # Валидный возраст должен приниматься
            user = user_service.create_user("test@example.com", "Test", age=age)
            assert user.age == age
        else:
            # Невалидный возраст должен вызывать ошибку
            with pytest.raises(ValueError):
                user_service.create_user("test@example.com", "Test", age=age)
    
    @given(
        data=st.dictionaries(
            keys=st.sampled_from(['name', 'email', 'bio', 'website']),
            values=st.text(max_size=200),
            min_size=1
        )
    )
    def test_user_update_properties(self, data):
        """Тестируем обновление пользователя с произвольными данными"""
        user_service = UserService()
        user = user_service.create_user("test@example.com", "Test User")
        
        original_id = user.id
        original_created_at = user.created_at
        
        updated_user = user_service.update_user(user.id, data)
        
        # Инвариантные свойства
        assert updated_user.id == original_id
        assert updated_user.created_at == original_created_at
        assert updated_user.updated_at >= original_created_at
        
        # Обновленные поля
        for field, value in data.items():
            if hasattr(updated_user, field):
                assert getattr(updated_user, field) == value

# Stateful тестирование
class ShoppingCartStateMachine(RuleBasedStateMachine):
    """Тестируем корзину покупок как state machine"""
    
    def __init__(self):
        super().__init__()
        self.cart = ShoppingCart()
        self.products = Bundle('products')
    
    @initialize()
    def setup(self):
        """Начальное состояние"""
        assert self.cart.is_empty()
        assert self.cart.total() == 0
    
    @rule(target=products, name=st.text(min_size=1, max_size=50), 
          price=st.floats(min_value=0.01, max_value=1000.0))
    def add_product(self, name, price):
        """Добавляем продукт в каталог"""
        product = Product(name=name, price=price)
        return product
    
    @rule(product=products, quantity=st.integers(min_value=1, max_value=10))
    def add_to_cart(self, product, quantity):
        """Добавляем товар в корзину"""
        old_total = self.cart.total()
        old_count = self.cart.item_count()
        
        self.cart.add_item(product, quantity)
        
        # Проверяем инварианты
        assert self.cart.total() >= old_total
        assert self.cart.item_count() >= old_count
        assert not self.cart.is_empty()
    
    @rule(product=products, quantity=st.integers(min_value=1, max_value=5))
    def remove_from_cart(self, product, quantity):
        """Удаляем товар из корзины"""
        if self.cart.has_item(product):
            old_total = self.cart.total()
            old_count = self.cart.item_count()
            
            self.cart.remove_item(product, quantity)
            
            # Проверяем инварианты
            assert self.cart.total() <= old_total
            assert self.cart.item_count() <= old_count
    
    @rule()
    def clear_cart(self):
        """Очищаем корзину"""
        self.cart.clear()
        
        assert self.cart.is_empty()
        assert self.cart.total() == 0
        assert self.cart.item_count() == 0

# Пользовательские стратегии
@st.composite
def user_data(draw):
    """Генерирует валидные данные пользователя"""
    name = draw(st.text(
        alphabet=st.characters(whitelist_categories=['L', 'N', ' ']),
        min_size=2, max_size=50
    ))
    email = draw(st.emails())
    age = draw(st.integers(min_value=13, max_value=120))
    
    return {
        "name": name.strip(),
        "email": email,
        "age": age
    }

@given(user=user_data())
def test_with_custom_user_strategy(user):
    """Тест с пользовательской стратегией"""
    service = UserService()
    created_user = service.create_user(**user)
    
    assert created_user.name == user["name"]
    assert created_user.email == user["email"]
    assert created_user.age == user["age"]

# Настройка примеров
class TestWithExamples:
    
    @given(x=st.integers())
    @example(x=0)  # Всегда проверяем граничный случай
    @example(x=-1)
    @example(x=1)
    def test_absolute_value_properties(self, x):
        """Тестируем свойства модуля числа"""
        abs_x = abs(x)
        
        # Модуль всегда неотрицательный
        assert abs_x >= 0
        
        # |x| = |-x|
        assert abs_x == abs(-x)
        
        # |x|² = x²
        assert abs_x ** 2 == x ** 2

# Настройки Hypothesis
from hypothesis import settings, HealthCheck

@settings(
    max_examples=1000,  # Количество тестовых случаев
    deadline=None,      # Отключаем дедлайн для медленных тестов
    suppress_health_check=[HealthCheck.too_slow]
)
@given(data=st.data())
def test_complex_scenario(data):
    """Сложный тест с настройками"""
    # Генерируем данные внутри теста
    num_users = data.draw(st.integers(min_value=1, max_value=100))
    users = data.draw(st.lists(
        user_data(), 
        min_size=num_users, 
        max_size=num_users,
        unique_by=lambda u: u["email"]
    ))
    
    user_service = UserService()
    created_users = []
    
    for user_data in users:
        created_user = user_service.create_user(**user_data)
        created_users.append(created_user)
    
    # Все пользователи должны быть уникальными по email
    emails = [u.email for u in created_users]
    assert len(emails) == len(set(emails))
    
    # Все ID должны быть уникальными
    ids = [u.id for u in created_users]
    assert len(ids) == len(set(ids))

# Запуск stateful тестов
TestShoppingCart = ShoppingCartStateMachine.TestCase
```

**Go Property-based тестирование с gopter:**
```go
package main

import (
    "testing"
    "github.com/leanovate/gopter"
    "github.com/leanovate/gopter/gen"
    "github.com/leanovate/gopter/prop"
    "github.com/stretchr/testify/assert"
)

func TestStringProperties(t *testing.T) {
    properties := gopter.NewProperties(nil)
    
    // Свойство: reverse(reverse(s)) == s
    properties.Property("reverse is involution", prop.ForAll(
        func(s string) bool {
            return Reverse(Reverse(s)) == s
        },
        gen.AnyString(),
    ))
    
    // Свойство: длина сохраняется при reverse
    properties.Property("reverse preserves length", prop.ForAll(
        func(s string) bool {
            return len(Reverse(s)) == len(s)
        },
        gen.AnyString(),
    ))
    
    // Свойство: reverse(s1 + s2) == reverse(s2) + reverse(s1)  
    properties.Property("reverse concatenation", prop.ForAll(
        func(s1, s2 string) bool {
            return Reverse(s1+s2) == Reverse(s2)+Reverse(s1)
        },
        gen.AnyString(),
        gen.AnyString(),
    ))
    
    properties.TestingRun(t)
}

func TestSortProperties(t *testing.T) {
    properties := gopter.NewProperties(nil)
    
    // Сортировка идемпотентна
    properties.Property("sort is idempotent", prop.ForAll(
        func(slice []int) bool {
            sorted1 := SortInts(slice)
            sorted2 := SortInts(sorted1)
            return slicesEqual(sorted1, sorted2)
        },
        gen.SliceOf(gen.Int()),
    ))
    
    // Длина сохраняется
    properties.Property("sort preserves length", prop.ForAll(
        func(slice []int) bool {
            sorted := SortInts(slice)
            return len(sorted) == len(slice)
        },
        gen.SliceOf(gen.Int()),
    ))
    
    // Результат отсортирован
    properties.Property("result is sorted", prop.ForAll(
        func(slice []int) bool {
            sorted := SortInts(slice)
            return isSorted(sorted)
        },
        gen.SliceOf(gen.Int()),
    ))
    
    properties.TestingRun(t)
}

func TestUserServiceProperties(t *testing.T) {
    properties := gopter.NewProperties(nil)
    
    // Пользовательский генератор для валидных email
    emailGen := gen.RegexMatch(`[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}`)
    nameGen := gen.RegexMatch(`[A-Za-z ]{2,50}`)
    ageGen := gen.IntRange(13, 120)
    
    properties.Property("user creation properties", prop.ForAll(
        func(email, name string, age int) bool {
            service := NewUserService()
            user, err := service.CreateUser(email, name, age)
            
            if err != nil {
                return false
            }
            
            // Проверяем инварианты
            return user.ID > 0 &&
                   user.Email == strings.ToLower(email) &&
                   user.Name == strings.TrimSpace(name) &&
                   user.Age == age &&
                   !user.CreatedAt.IsZero() &&
                   user.IsActive
        },
        emailGen,
        nameGen, 
        ageGen,
    ))
    
    // Валидация возраста
    properties.Property("age validation", prop.ForAll(
        func(age int) bool {
            service := NewUserService()
            _, err := service.CreateUser("test@example.com", "Test User", age)
            
            if age >= 0 && age <= 150 {
                return err == nil
            } else {
                return err != nil
            }
        },
        gen.Int(),
    ))
    
    properties.TestingRun(t)
}

// Stateful тестирование корзины покупок
func TestShoppingCartStateful(t *testing.T) {
    commands := &gopter.Commands{
        NewSystemUnderTest: func(initialState gopter.State) gopter.SystemUnderTest {
            return &ShoppingCartSUT{
                Cart: NewShoppingCart(),
            }
        },
        InitialState: func() gopter.State {
            return &CartState{
                Items: make(map[string]int),
                Total: 0,
            }
        },
        Commands: map[string]gopter.Command{
            "addItem": &AddItemCommand{},
            "removeItem": &RemoveItemCommand{},
            "clear": &ClearCartCommand{},
        },
    }
    
    properties := gopter.NewProperties(nil)
    properties.Property("shopping cart stateful", prop.ForAllCommands(commands))
    properties.TestingRun(t)
}

// Состояние для stateful тестирования
type CartState struct {
    Items map[string]int
    Total float64
}

type ShoppingCartSUT struct {
    Cart *ShoppingCart
}

// Команда добавления товара
type AddItemCommand struct{}

func (cmd *AddItemCommand) Run(sut gopter.SystemUnderTest, state gopter.State) gopter.Result {
    s := state.(*CartState)
    cartSUT := sut.(*ShoppingCartSUT)
    
    product := Product{Name: "test-item", Price: 10.0}
    quantity := 1
    
    // Выполняем команду
    cartSUT.Cart.AddItem(product, quantity)
    
    // Обновляем состояние
    s.Items[product.Name] += quantity
    s.Total += float64(quantity) * product.Price
    
    // Проверяем что реальное состояние совпадает с модельным
    if cartSUT.Cart.Total() != s.Total {
        return &gopter.PropResult{
            Status: gopter.PropFalse,
            Error:  fmt.Errorf("total mismatch: got %f, expected %f", 
                              cartSUT.Cart.Total(), s.Total),
        }
    }
    
    return &gopter.PropResult{Status: gopter.PropTrue}
}

func (cmd *AddItemCommand) Pre(state gopter.State) bool {
    return true // Команда всегда доступна
}

func (cmd *AddItemCommand) Post(state gopter.State, result gopter.Result) *gopter.PropResult {
    return &gopter.PropResult{Status: gopter.PropTrue}
}

func (cmd *AddItemCommand) String() string {
    return "AddItem"
}

// Вспомогательные функции
func slicesEqual(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}

func isSorted(slice []int) bool {
    for i := 1; i < len(slice); i++ {
        if slice[i-1] > slice[i] {
            return false
        }
    }
    return true
}
```

### 🧬 Mutation тестирование

**Концепция Mutation Testing:**
```
Оригинальный код:    if (x > 0) return "positive"
                           ↓
Мутанты:             if (x >= 0) return "positive"  ← Mutant 1
                     if (x < 0) return "positive"   ← Mutant 2  
                     if (x > 1) return "positive"   ← Mutant 3
                           ↓
Качественные тесты должны "убить" все мутанты
```

**Python с mutmut:**
```bash
# Установка
pip install mutmut

# Запуск mutation тестирования
mutmut run

# Просмотр результатов
mutmut results

# Показать конкретный мутант
mutmut show 42

# HTML отчет
mutmut html
```

**Пример кода для mutation тестирования:**
```python
# calculator.py
def add(a, b):
    return a + b  # Мутант: a - b, a * b, a / b

def is_positive(x):
    return x > 0  # Мутант: x >= 0, x < 0, x != 0

def max_of_three(a, b, c):
    if a > b and a > c:  # Мутанты: a >= b, a < b, and → or
        return a
    elif b > c:  # Мутант: b >= c, b < c
        return b
    else:
        return c

def calculate_discount(price, discount_percent):
    if discount_percent < 0 or discount_percent > 100:  # Мутанты: <=, >=, and
        raise ValueError("Invalid discount")
    
    discount = price * (discount_percent / 100)  # Мутанты: -, +, *
    return price - discount  # Мутант: price + discount

# Тесты которые убивают мутантов
class TestCalculator:
    def test_add_positive_numbers(self):
        assert add(2, 3) == 5  # Убивает мутант a - b
    
    def test_add_with_zero(self):
        assert add(5, 0) == 5  # Убивает мутант a * b
        assert add(0, 5) == 5
    
    def test_add_negative_numbers(self):
        assert add(-2, -3) == -5  # Убивает другие мутанты
    
    def test_is_positive_boundary_cases(self):
        assert is_positive(1) is True    # Убивает x != 0
        assert is_positive(0) is False   # Убивает x >= 0  
        assert is_positive(-1) is False  # Убивает x < 0
    
    def test_max_of_three_all_cases(self):
        # Первый элемент максимальный
        assert max_of_three(3, 1, 2) == 3  # Убивает a >= b
        assert max_of_three(3, 3, 2) == 3  # Убивает a > b (граница)
        
        # Второй элемент максимальный  
        assert max_of_three(1, 3, 2) == 3  # Убивает and → or
        assert max_of_three(2, 3, 3) == 3  # Убивает b >= c
        
        # Третий элемент максимальный
        assert max_of_three(1, 2, 3) == 3
        
        # Все равны
        assert max_of_three(2, 2, 2) == 2
    
    def test_calculate_discount_boundary_cases(self):
        # Валидные случаи
        assert calculate_discount(100, 10) == 90
        assert calculate_discount(100, 0) == 100   # Убивает мутант <=
        assert calculate_discount(100, 100) == 0   # Убивает мутант >=
        
        # Невалидные случаи
        with pytest.raises(ValueError):
            calculate_discount(100, -1)    # Убивает мутант <=
        
        with pytest.raises(ValueError): 
            calculate_discount(100, 101)   # Убивает мутант >=
        
        # Проверяем точность вычислений
        assert abs(calculate_discount(100, 25) - 75) < 0.01
```

**Настройка mutmut:**
```python
# setup.cfg
[mutmut]
paths_to_mutate = src/
backup = False
runner = python -m pytest tests/unit/
tests_dir = tests/
cache_only = False

[mutmut:python]
# Исключаем файлы
skip_paths = migrations/,settings/,manage.py

# Исключаем строки с комментариями
skip_lines_with = # pragma: no mutate
```

### 🌪️ Chaos Engineering

**Принципы Chaos Engineering:**
```
1. Гипотеза → Система устойчива к определенному типу сбоев
2. Эксперимент → Вводим контролируемый хаос в продакшн
3. Мониторинг → Отслеживаем поведение системы  
4. Анализ → Система восстановилась или сломалась?
5. Улучшение → Исправляем найденные слабости
```

**Python Chaos Engineering тесты:**
```python
import random
import time
import requests
import threading
from contextlib import contextmanager

class ChaosEngineer:
    """Класс для проведения chaos engineering экспериментов"""
    
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.running = False
    
    @contextmanager 
    def chaos_experiment(self, name):
        """Контекстный менеджер для chaos экспериментов"""
        print(f"Starting chaos experiment: {name}")
        self.running = True
        
        try:
            yield self
        except Exception as e:
            print(f"Chaos experiment failed: {e}")
            raise
        finally:
            self.running = False
            print(f"Chaos experiment completed: {name}")
    
    def simulate_high_cpu_load(self, duration=30):
        """Имитирует высокую нагрузку на CPU"""
        def cpu_stress():
            end_time = time.time() + duration
            while time.time() < end_time and self.running:
                # Создаем нагрузку на CPU
                [i**2 for i in range(10000)]
        
        threads = []
        for _ in range(4):  # 4 потока для нагрузки
            thread = threading.Thread(target=cpu_stress)
            thread.start()
            threads.append(thread)
        
        return threads
    
    def simulate_memory_pressure(self, size_mb=100):
        """Имитирует нехватку памяти"""
        memory_hog = []
        try:
            for _ in range(size_mb):
                # Выделяем по 1MB
                chunk = bytearray(1024 * 1024)
                memory_hog.append(chunk)
                time.sleep(0.1)
        except MemoryError:
            print("Successfully created memory pressure")
        
        return memory_hog
    
    def simulate_network_latency(self, delay_ms=1000):
        """Имитирует задержки сети"""
        import socket
        
        original_connect = socket.socket.connect
        
        def slow_connect(self, address):
            time.sleep(delay_ms / 1000.0)
            return original_connect(self, address)
        
        socket.socket.connect = slow_connect
        return original_connect
    
    def simulate_random_failures(self, failure_rate=0.1):
        """Случайные отказы запросов"""
        original_request = requests.request
        
        def failing_request(*args, **kwargs):
            if random.random() < failure_rate:
                raise requests.ConnectionError("Chaos: Random failure")
            return original_request(*args, **kwargs)
        
        requests.request = failing_request
        return original_request

class TestChaosEngineering:
    
    def test_system_resilience_under_cpu_stress(self):
        """Тестируем устойчивость системы под нагрузкой CPU"""
        chaos = ChaosEngineer()
        
        with chaos.chaos_experiment("CPU Stress Test"):
            # Запускаем нагрузку на CPU
            stress_threads = chaos.simulate_high_cpu_load(duration=30)
            
            # Тестируем что система продолжает отвечать
            start_time = time.time()
            success_count = 0
            total_requests = 0
            
            while time.time() - start_time < 30:
                try:
                    response = requests.get(f"{chaos.base_url}/health", timeout=5)
                    if response.status_code == 200:
                        success_count += 1
                    total_requests += 1
                except requests.RequestException:
                    total_requests += 1
                
                time.sleep(1)
            
            # Ждем завершения стресс-тестов
            for thread in stress_threads:
                thread.join()
            
            # Система должна отвечать на > 80% запросов даже под нагрузкой
            success_rate = success_count / total_requests if total_requests > 0 else 0
            assert success_rate > 0.8, f"Low success rate under CPU stress: {success_rate:.2%}"
    
    def test_system_recovery_after_memory_pressure(self):
        """Тестируем восстановление системы после нехватки памяти"""
        chaos = ChaosEngineer()
        
        with chaos.chaos_experiment("Memory Pressure Test"):
            # Проверяем базовую работоспособность
            response = requests.get(f"{chaos.base_url}/health")
            assert response.status_code == 200
            
            # Создаем нехватку памяти
            memory_hog = chaos.simulate_memory_pressure(size_mb=500)
            
            # Даем системе время для обработки нехватки памяти
            time.sleep(10)
            
            # Освобождаем память
            del memory_hog
            
            # Проверяем что система восстановилась
            time.sleep(5)  # Время на восстановление
            
            recovery_success = 0
            for attempt in range(10):
                try:
                    response = requests.get(f"{chaos.base_url}/health", timeout=10)
                    if response.status_code == 200:
                        recovery_success += 1
                except requests.RequestException:
                    pass
                time.sleep(1)
            
            # Система должна восстановиться
            assert recovery_success >= 8, f"System didn't recover properly: {recovery_success}/10"
    
    def test_graceful_degradation_under_network_issues(self):
        """Тестируем graceful degradation при проблемах с сетью"""
        chaos = ChaosEngineer()
        
        with chaos.chaos_experiment("Network Latency Test"):
            # Сохраняем оригинальную функцию
            original_connect = chaos.simulate_network_latency(delay_ms=2000)
            
            try:
                # Тестируем что система работает, но медленнее
                start_time = time.time()
                response = requests.get(f"{chaos.base_url}/api/users", timeout=30)
                response_time = time.time() - start_time
                
                # Запрос должен выполниться, но дольше обычного
                assert response.status_code == 200
                assert response_time > 2.0  # Учитываем добавленную задержку
                
                # Проверяем что данные корректные несмотря на задержку
                data = response.json()
                assert "users" in data or isinstance(data, list)
                
            finally:
                # Восстанавливаем оригинальную функцию
                import socket
                socket.socket.connect = original_connect
    
    def test_circuit_breaker_behavior(self):
        """Тестируем поведение circuit breaker при случайных сбоях"""
        chaos = ChaosEngineer()
        
        with chaos.chaos_experiment("Random Failures Test"):
            # Имитируем 50% отказов
            original_request = chaos.simulate_random_failures(failure_rate=0.5)
            
            try:
                success_count = 0
                circuit_breaker_activated = False
                
                for attempt in range(20):
                    try:
                        response = requests.get(f"{chaos.base_url}/external-api", timeout=5)
                        if response.status_code == 200:
                            success_count += 1
                        elif response.status_code == 503:  # Service Unavailable
                            circuit_breaker_activated = True
                    except requests.RequestException:
                        # Ожидаемые ошибки из-за chaos
                        pass
                    
                    time.sleep(0.5)
                
                # Circuit breaker должен сработать при высоком проценте ошибок
                assert circuit_breaker_activated, "Circuit breaker should activate under high failure rate"
                
            finally:
                requests.request = original_request
    
    def test_database_connection_pool_exhaustion(self):
        """Тестируем поведение при исчерпании пула соединений с БД"""
        chaos = ChaosEngineer()
        
        def create_long_running_query():
            """Создает долгий запрос к БД"""
            try:
                response = requests.post(f"{chaos.base_url}/admin/long-query", 
                                       json={"duration": 30})
                return response.status_code
            except requests.RequestException:
                return None
        
        with chaos.chaos_experiment("DB Pool Exhaustion"):
            # Запускаем много долгих запросов
            threads = []
            for _ in range(50):  # Больше чем размер пула соединений
                thread = threading.Thread(target=create_long_running_query)
                thread.start()
                threads.append(thread)
                time.sleep(0.1)
            
            # Проверяем что новые запросы корректно обрабатываются
            time.sleep(5)  # Даем время на исчерпание пула
            
            # Быстрый запрос должен либо выполниться, либо вернуть корректную ошибку
            try:
                response = requests.get(f"{chaos.base_url}/health", timeout=10)
                # Либо успех, либо 503 (Service Unavailable)
                assert response.status_code in [200, 503]
                
                if response.status_code == 503:
                    error_data = response.json()
                    assert "database" in error_data.get("message", "").lower()
                    
            except requests.RequestException as e:
                # Timeout тоже допустим при исчерпании пула
                assert "timeout" in str(e).lower()
            
            # Ждем завершения долгих запросов
            for thread in threads:
                thread.join(timeout=1)

# Утилиты для мониторинга во время chaos тестов
class ChaosMonitor:
    """Мониторинг системы во время chaos экспериментов"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.metrics = []
    
    def start_monitoring(self, duration=60):
        """Запускает мониторинг на указанное время"""
        def monitor():
            start_time = time.time()
            while time.time() - start_time < duration:
                metric = self.collect_metrics()
                self.metrics.append(metric)
                time.sleep(1)
        
        thread = threading.Thread(target=monitor)
        thread.daemon = True
        thread.start()
        return thread
    
    def collect_metrics(self):
        """Собирает метрики системы"""
        try:
            start = time.time()
            response = requests.get(f"{self.base_url}/metrics", timeout=5)
            response_time = time.time() - start
            
            if response.status_code == 200:
                data = response.json()
                return {
                    "timestamp": time.time(),
                    "response_time": response_time,
                    "status": "ok",
                    "cpu_usage": data.get("cpu_usage", 0),
                    "memory_usage": data.get("memory_usage", 0),
                    "active_connections": data.get("active_connections", 0)
                }
        except Exception as e:
            return {
                "timestamp": time.time(),
                "status": "error",
                "error": str(e)
            }
    
    def analyze_metrics(self):
        """Анализирует собранные метрики"""
        if not self.metrics:
            return {}
        
        successful_metrics = [m for m in self.metrics if m.get("status") == "ok"]
        error_count = len([m for m in self.metrics if m.get("status") == "error"])
        
        if successful_metrics:
            avg_response_time = sum(m["response_time"] for m in successful_metrics) / len(successful_metrics)
            max_response_time = max(m["response_time"] for m in successful_metrics)
        else:
            avg_response_time = max_response_time = None
        
        return {
            "total_samples": len(self.metrics),
            "successful_samples": len(successful_metrics),
            "error_count": error_count,
            "error_rate": error_count / len(self.metrics),
            "avg_response_time": avg_response_time,
            "max_response_time": max_response_time
        }
```

---

## 🎓 Модуль 9: Продвинутые практики (2-3 недели)

### 🏛️ Архитектура для тестируемости

**Принципы тестируемой архитектуры:**
```
Dependency Injection → Легкое мокирование
Single Responsibility → Фокусированные тесты  
Interface Segregation → Независимые тесты
Hexagonal Architecture → Изоляция бизнес-логики
```

**Python пример Hexagonal Architecture:**
    