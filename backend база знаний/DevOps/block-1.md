# 🎯 DevOps Блок 1: Основы и фундамент
*Глубокое понимание концепций с визуализацией*

---

## 📋 Обзор блока

```
Длительность: 2-3 месяца
Цель: Заложить крепкий фундамент DevOps мышления
Результат: Понимание культуры, уверенная работа с Linux, Git и сетями
```

---

## 🚀 Глава 1.1: DevOps культура и методология

### Что такое DevOps на самом деле?

DevOps - это НЕ просто набор инструментов или должность. Это **культурная философия**, которая разрушает барьеры между командами разработки и операций.

#### Эволюция разработки ПО:

```
Традиционная модель (Waterfall):
    [Планирование] → [Дизайн] → [Разработка] → [Тестирование] → [Деплой] → [Поддержка]
    ↑_______________________________________________________________________________|
    (Обратная связь приходит слишком поздно)

Agile модель:
    [Итерация 1] → [Итерация 2] → [Итерация 3] → ...
    (Быстрые циклы, но проблемы на стыке Dev и Ops)

DevOps модель:
    ┌─────────────────────────────────────────────────────────────┐
    │  [Plan] → [Code] → [Build] → [Test] → [Release] → [Deploy]  │
    │     ↑                                                   ↓    │
    │  [Monitor] ← [Operate] ← [Configure] ← [Package] ← [Stage]   │
    └─────────────────────────────────────────────────────────────┘
    (Непрерывный цикл сотрудничества)
```

### Основные принципы DevOps:

#### 1. **Культура сотрудничества**
```
Традиционно:
    Разработчики: "Работает на моей машине!" 
           ┊
    ═══════╪═══════ (Стена между командами)
           ┊
    Операторы: "Это нестабильный код!"

DevOps:
    Разработчики + Операторы = Единая команда
    • Общие цели
    • Общая ответственность  
    • Общие метрики успеха
```

#### 2. **Автоматизация всего**
Автоматизация - это не просто написание скриптов. Это системный подход:

```
Пирамида автоматизации:
    
         /\
        /  \      ← Культурные изменения
       /____\     
      /      \    ← Процессы и практики
     /________\   
    /          \  ← Инструменты и технологии
   /____________\ 

Важно: Начинаем снизу, но цель - вершина!
```

#### 3. **Измерение и мониторинг**
```
Что нельзя измерить - нельзя улучшить

Четыре ключевые метрики DevOps (DORA):
┌──────────────────┬─────────────────┬──────────────────┐
│ Lead Time        │ Deployment      │ Mean Time to     │
│ (время от коммита│ Frequency       │ Recovery (MTTR)  │
│ до продакшена)   │ (как часто      │ (время           │
│                  │ деплоим)        │ восстановления)  │
├──────────────────┼─────────────────┼──────────────────┤
│ Change Failure   │                 │                  │
│ Rate (процент    │                 │                  │
│ неудачных        │                 │                  │
│ деплоев)         │                 │                  │
└──────────────────┴─────────────────┴──────────────────┘
```

### Lean и устранение потерь (Waste)

DevOps заимствует принципы Lean производства. **8 видов потерь в разработке ПО:**

```
1. Частично выполненная работа
   ┌─────┐ ┌─────┐ ┌─────┐
   │ 50% │ │ 30% │ │ 70% │  ← Незавершенные фичи
   └─────┘ └─────┘ └─────┘

2. Лишние возможности  
   ┌─────────────────────────────────┐
   │ ████████ (используется 20%)     │  ← Переинжиниринг
   └─────────────────────────────────┘

3. Переключение контекста
   Dev A: Проект1 → Проект2 → Проект1 → Проект3
          ↑_____потеря времени на переключение_____↑

4. Ожидание
   [Код готов] → [Ждем ревью] → [Ждем тесты] → [Ждем деплой]
                     ↑             ↑            ↑
                   waste         waste        waste
```

### Практическое применение DevOps культуры:

#### Принцип "You Build It, You Run It" (Amazon)
```
Традиционная модель:
    Разработчик пишет код → Передает Ops → "Не моя проблема"

DevOps модель:
    Разработчик ответственен за полный жизненный цикл:
    ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
    │ Код     │ │ Деплой  │ │ Монитор │ │ Инцидент│
    │         │ │         │ │         │ │ ответ   │
    └─────────┘ └─────────┘ └─────────┘ └─────────┘
```

---

## 🐧 Глава 1.2: Основы Linux и командная строка

### Почему Linux критичен для DevOps?

Linux доминирует в серверной инфраструктуре. **96% из топ-1000 веб-серверов работают на Unix-подобных системах.**

### Архитектура Linux системы:

```
┌─────────────────────────────────────────────────────────┐
│                 Пользователи                            │
├─────────────────────────────────────────────────────────┤
│                Shell (bash, zsh)                        │
├─────────────────────────────────────────────────────────┤
│         Системные утилиты и приложения                  │
├─────────────────────────────────────────────────────────┤
│              Системные вызовы (API)                     │
├─────────────────────────────────────────────────────────┤
│                   Ядро Linux                            │
├─────────────────────────────────────────────────────────┤
│                   Аппаратура                            │
└─────────────────────────────────────────────────────────┘
```

### Файловая система Linux - концептуальное понимание:

```
Корневая файловая система (/):
/
├── bin/     ← Основные исполняемые файлы (ls, cat, bash)
├── etc/     ← Конфигурационные файлы системы
├── home/    ← Домашние директории пользователей
├── var/     ← Переменные данные (логи, временные файлы)
├── usr/     ← Пользовательские программы и библиотеки
├── opt/     ← Опциональное ПО (часто сторонние приложения)
├── tmp/     ← Временные файлы
└── proc/    ← Виртуальная ФС (информация о процессах)
```

#### Права доступа - философия безопасности:

```
Каждый файл имеет три уровня доступа:

┌─────────┬─────────┬─────────┐
│ Owner   │ Group   │ Others  │
│ (u)     │ (g)     │ (o)     │
└─────────┴─────────┴─────────┘

Права для каждого уровня:
r (read)    = 4
w (write)   = 2  
x (execute) = 1

Пример: rwxr-xr-x (755)
├─ rwx (7) = owner может все
├─ r-x (5) = group может читать и выполнять
└─ r-x (5) = others могут читать и выполнять
```

### Процессы и службы - сердце системы:

```
Иерархия процессов:
systemd (PID 1)
├── systemd-logind
├── NetworkManager
├── sshd
│   ├── sshd (пользователь 1)
│   └── sshd (пользователь 2)
└── nginx
    ├── worker process 1
    ├── worker process 2
    └── worker process 3

Каждый процесс имеет:
• PID (Process ID)
• PPID (Parent Process ID)  
• Состояние (running, sleeping, zombie)
• Приоритет (nice value)
• Память и CPU использование
```

### Понимание systemd - современный менеджер служб:

```
systemd управляет:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Services  │    │   Sockets   │    │   Timers    │
│  (.service) │    │  (.socket)  │    │  (.timer)   │
└─────────────┘    └─────────────┘    └─────────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
               ┌─────────────────────┐
               │     systemd         │
               │  (system manager)   │
               └─────────────────────┘

Жизненный цикл службы:
[inactive] → [activating] → [active] → [deactivating] → [inactive]
               ↑              ↓              ↑
            (start)      (running)       (stop)
```

### Bash scripting - автоматизация мышления:

Bash скрипт - это не просто команды, это **декларация намерений**:

```
Принципы хорошего bash скрипта:

1. Идемпотентность - можно запускать многократно
   if [ ! -f "/etc/nginx/nginx.conf.backup" ]; then
       cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup
   fi

2. Fail Fast - останавливаемся при первой ошибке
   set -euo pipefail

3. Логирование - всегда знаем что происходит
   log() { echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >&2; }

4. Переменные окружения для конфигурации
   ENVIRONMENT=${ENVIRONMENT:-development}
```

---

## 🌐 Глава 1.3: Основы сетей и протоколов

### Сетевая модель - фундамент понимания:

```
OSI Model vs TCP/IP в контексте DevOps:

OSI:                    TCP/IP:                 DevOps фокус:
┌─────────────────┐    ┌─────────────────┐    
│ 7. Application  │    │   Application   │ ← HTTP/HTTPS, API
├─────────────────┤    │                 │   DNS, мониторинг
│ 6. Presentation │    │                 │
├─────────────────┤    ├─────────────────┤
│ 5. Session      │    │   Transport     │ ← TCP/UDP, Load balancing
├─────────────────┤    │                 │   Port management
│ 4. Transport    │    │                 │
├─────────────────┤    ├─────────────────┤
│ 3. Network      │    │   Internet      │ ← IP адресация, маршрутизация
├─────────────────┤    │                 │   VPC, subnets
│ 2. Data Link    │    ├─────────────────┤
├─────────────────┤    │   Network       │ ← Физическая инфраструктура
│ 1. Physical     │    │   Access        │   (редко касаемся в DevOps)
└─────────────────┘    └─────────────────┘
```

### TCP/IP - язык интернета:

```
Как работает TCP соединение:

Клиент                              Сервер
   │                                  │
   │──── SYN (я хочу соединиться) ────→│
   │                                  │
   │←─── SYN-ACK (согласен, готов) ───│
   │                                  │
   │──── ACK (отлично, начинаем) ─────→│
   │                                  │
   │════════ Данные ═══════════════════│ ← Здесь HTTP/HTTPS
   │                                  │
   │──── FIN (заканчиваю) ────────────→│
   │                                  │
   │←─── ACK + FIN ───────────────────│
   │                                  │
   │──── ACK ─────────────────────────→│

Каждый пакет имеет:
• Source IP + Port
• Destination IP + Port  
• Sequence number (для упорядочивания)
• Acknowledgment (подтверждение получения)
```

### DNS - телефонная книга интернета:

```
Разрешение имени (example.com → IP):

1. Браузер → Локальный кэш → Не найдено
2. Браузер → Локальный DNS resolver → Не найдено  
3. DNS resolver → Root DNS (.) → "Спроси .com сервер"
4. DNS resolver → .com DNS → "Спроси example.com DNS"
5. DNS resolver → example.com DNS → "IP: 93.184.216.34"
6. Кэширование на каждом уровне

Типы DNS записей:
┌─────────┬────────────────────────────────────────┐
│ A       │ example.com → 93.184.216.34           │
├─────────┼────────────────────────────────────────┤
│ CNAME   │ www.example.com → example.com          │
├─────────┼────────────────────────────────────────┤
│ MX      │ mail.example.com (приоритет 10)       │
├─────────┼────────────────────────────────────────┤
│ TXT     │ Верификация, SPF, DKIM                 │
└─────────┴────────────────────────────────────────┘
```

### Load Balancing - распределение нагрузки:

```
Зачем нужен Load Balancer:

Без Load Balancer:
Клиенты → [Единственный сервер] ← Точка отказа!

С Load Balancer:
                    ┌─[Сервер 1]
Клиенты → [LB] ─────┼─[Сервер 2]  ← Отказоустойчивость
                    └─[Сервер 3]     + Масштабируемость

Алгоритмы распределения:
• Round Robin: 1→2→3→1→2→3...
• Least Connections: направляем на менее загруженный
• Weighted: сервер 1 (вес 3), сервер 2 (вес 1) = 3:1 трафика
• Health Check: проверяем доступность перед отправкой
```

### Reverse Proxy vs Forward Proxy:

```
Forward Proxy (корпоративные сети):
[Клиент] → [Proxy] → [Интернет] → [Сервер]
           ↑
    Скрывает клиента от сервера
    Используется для: фильтрации, кэширования

Reverse Proxy (веб-архитектура):
[Клиент] → [Интернет] → [Reverse Proxy] → [Серверы]
                              ↑
                    Скрывает серверы от клиента
                    Используется для: load balancing, SSL termination
```

### Nginx как Reverse Proxy - концептуальная модель:

```
Поток запроса через Nginx:

1. [Клиент] → HTTPS запрос → [Nginx]
2. [Nginx] → SSL termination → Расшифровка HTTPS
3. [Nginx] → Анализ location блоков → Определение backend
4. [Nginx] → HTTP запрос → [Backend серверы]
5. [Backend] → HTTP ответ → [Nginx]  
6. [Nginx] → Добавление заголовков → [Клиент]

Nginx архитектура:
┌──────────────────────────────────────┐
│ Master Process                       │
│ ├─ Читает конфигурацию               │
│ ├─ Управляет worker'ами              │
│ └─ Обрабатывает сигналы              │
├──────────────────────────────────────┤
│ Worker Processes (event-driven)      │
│ ├─ Обрабатывают клиентские запросы   │
│ ├─ Неблокирующий I/O                 │
│ └─ Один worker = тысячи соединений   │
└──────────────────────────────────────┘
```

---

## 🔄 Глава 1.4: Git и системы контроля версий

### Git - философия распределенных систем:

```
Централизованная vs Распределенная VCS:

Centralised (SVN):
    Developer A ──┐
                  │
    Developer B ──┼── Central Server ← Единая точка отказа
                  │
    Developer C ──┘

Distributed (Git):
    [Repo A] ← → [Central Repo] ← → [Repo B]
       ↑              ↓              ↓
    [Local]       [Remote]       [Local]
       ↓              ↑              ↑  
    [Repo C] ← ← ← ← ← ← ← ← ← ← [Repo D]

Каждый клон - полноценный репозиторий!
```

### Git объектная модель - как Git хранит данные:

```
Git хранит 4 типа объектов:

1. Blob (файл):
   ┌─────────────┐
   │ "Hello\n"   │ ← Содержимое файла
   └─────────────┘
        │
   SHA1: a042c89...

2. Tree (директория):
   ┌─────────────────────────────┐
   │ 100644 hello.txt a042c89... │ ← Ссылки на blobs и trees
   │ 040000 subdir    b7ef123... │
   └─────────────────────────────┘

3. Commit:
   ┌─────────────────────────────┐
   │ tree b7ef123...             │ ← Ссылка на root tree
   │ parent c052ab4...           │ ← Родительский commit
   │ author John <john@ex.com>   │
   │ "Initial commit"            │
   └─────────────────────────────┘

4. Tag:
   ┌─────────────────────────────┐
   │ object c052ab4...           │ ← Ссылка на commit
   │ type commit                 │
   │ tag v1.0                    │
   └─────────────────────────────┘
```

### Branching - ветвление как образ мышления:

```
Ветки в Git - это просто указатели на commits:

master:    A ← B ← C ← D
                  ↑
               feature:  E ← F

HEAD → feature (текущая ветка)

Создание ветки = создание нового указателя
Переключение = перемещение HEAD
Merge = создание commit с двумя родителями

После merge:
master:    A ← B ← C ← D ← G (merge commit)
                  ↑      ↗
               feature:  E ← F
```

### Git Workflow стратегии:

#### 1. **Git Flow - структурированный подход:**
```
master    ──●──────●──────●─── (production releases)
             │      │      │
release   ────●──●──┘      │
             ╱             │
develop   ●──●──●──●──●──●──● (integration branch)
             │  ╲    │    ╱
feature      │   ●───●───●   (feature branches)
             │            
hotfix    ───●───●─────────●── (critical fixes)
```

#### 2. **GitHub Flow - упрощенный подход:**
```
main      ●──●──●──●──●──●──● (всегда готов к деплою)
             │     │     │
feature      ●──●──┘     │
                         │
feature               ●──┘

Принцип: main всегда стабилен, feature ветки короткие
```

#### 3. **GitLab Flow - гибридный подход:**
```
main        ●──●──●──●──●──●
               │  │  │  │
pre-prod       ●──●──●──●──● (staging)
                  │  │  │
production        ●──●──●──● (production)
```

### Merge vs Rebase - философские различия:

```
Merge - сохраняет историю:
    A ← B ← C ← D ← M
        │           ↗
        E ← F ← G ←┘

    git log показывает реальную историю разработки

Rebase - переписывает историю:
    A ← B ← C ← D ← E' ← F' ← G'

    Линейная история, но "ложная" хронология

Когда использовать:
• Merge: публичные ветки, важна история
• Rebase: приватные ветки, чистота истории
```

### Git Hooks - автоматизация workflow:

```
Client-side hooks:
    Working Directory → Staging → Local Repo → Remote Repo
           │               │         │            │
     pre-commit        commit-msg   post-commit  post-receive
           │               │         │            │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │ Проверка    │ │ Валидация   │ │ Уведомления │ │ Деплой      │
    │ стиля кода  │ │ формата     │ │ в Slack     │ │ тестирование│
    │ unit тесты  │ │ сообщения   │ │             │ │             │
    └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘

Типичный pre-commit hook workflow:
1. Lint код (ESLint, Pylint)
2. Проверка форматирования (Prettier, Black)  
3. Запуск быстрых тестов
4. Проверка секретов в коде
5. Валидация commit message
```

---

## 🎯 Практические задания для закрепления

### Задание 1: DevOps культура в действии
```
Сценарий: В компании есть команда разработки (5 человек) и 
          команда администрирования (2 человека). 
          Деплой занимает 3 дня, много ошибок.

Ваша задача:
1. Проанализировать текущие процессы
2. Выявить waste (потери)
3. Предложить DevOps трансформацию
4. Определить метрики для измерения прогресса

Подумайте над:
• Какие барьеры между командами?
• Где происходят задержки?
• Что можно автоматизировать в первую очередь?
• Как изменить культуру?
```

### Задание 2: Linux системное мышление
```
Создайте концептуальную схему:
1. Процесс загрузки веб-приложения
   • systemd → nginx → application → database
   • Покажите зависимости между службами
   • Опишите что происходит при сбое каждого компонента

2. Мониторинг системы
   • Какие метрики важны на каждом уровне?
   • Как они связаны между собой?
   • Где искать причину проблемы?
```

### Задание 3: Сетевая архитектура
```
Спроектируйте сетевую схему для веб-приложения:

Internet → [Load Balancer] → [Web Servers] → [App Servers] → [Database]

Определите:
• Какие порты открыты на каждом уровне?
• Как настроить firewall правила?
• Где разместить SSL сертификаты?
• Как обеспечить высокую доступность?
• Как мониторить каждый компонент?
```

### Задание 4: Git workflow дизайн
```
Для команды из 6 разработчиков спроектируйте Git workflow:

Требования:
• Релизы каждые 2 недели
• Hotfixes должны попадать в продакшен за часы
• Code review обязателен
• Автоматическое тестирование

Опишите:
• Структуру веток
• Процесс feature разработки  
• Процесс релиза
• Процесс hotfix
• Git hooks для автоматизации
```

---

## 📊 Чек-лист завершения Блока 1

### Культура и методология ✅
- [ ] Понимаю разницу между Agile и DevOps
- [ ] Могу объяснить принципы Lean в контексте разработки
- [ ] Знаю 4 ключевые метрики DORA
- [ ] Понимаю концепцию "You Build It, You Run It"

### Linux и командная строка ✅  
- [ ] Понимаю архитектуру Linux системы
- [ ] Разбираюсь в файловой системе и правах доступа
- [ ] Понимаю работу systemd и управление службами
- [ ] Могу писать bash скрипты с учетом best practices

### Сети и протоколы ✅
- [ ] Понимаю TCP/IP стек и его применение в DevOps
- [ ] Разбираюсь в DNS и его роли в инфраструктуре  
- [ ] Понимаю принципы load balancing
- [ ] Знаю разницу между forward и reverse proxy

### Git и VCS ✅
- [ ] Понимаю Git объектную модель
- [ ] Разбираюсь в различных branching стратегиях
- [ ] Понимаю разницу между merge и rebase
- [ ] Могу настроить Git hooks для автоматизации

---

## 🚀 Переход к Блоку 2

После успешного завершения этого блока вы готовы к изучению контейнеризации и оркестрации. Фундамент заложен - теперь строим современную инфраструктуру!

**Следующий блок: Docker и Kubernetes** 🐳

---

*💡 Помните: DevOps - это не набор инструментов, это способ мышления. Каждая технология должна решать бизнес-задачу и улучшать сотрудничество в команде.*