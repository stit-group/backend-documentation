# Справочник ответов: Чистая архитектура и практики проектирования

## 1. SOLID Принципы

### 1.1 Single Responsibility Principle (SRP)

**Принцип:** Класс должен иметь только одну причину для изменения.

**Пример нарушения:**
```csharp
// Нарушение SRP - класс отвечает за бизнес-логику И за отправку email
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    
    public void ChangeEmail(string newEmail)
    {
        Email = newEmail;
        SendEmailNotification(); // Нарушение!
    }
    
    private void SendEmailNotification()
    {
        // Логика отправки email
    }
}
```

**Правильная реализация:**
```csharp
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    
    public void ChangeEmail(string newEmail)
    {
        Email = newEmail;
    }
}

public class EmailNotificationService
{
    public void SendEmailChangeNotification(User user)
    {
        // Логика отправки email
    }
}
```

**Ключевые моменты:**
- Класс может иметь несколько методов, если они служат одной цели
- SRP улучшает тестируемость - легче мокировать отдельные зависимости
- Снижает coupling между компонентами системы

---

### 1.2 Open/Closed Principle (OCP)

**Принцип:** Классы должны быть открыты для расширения, но закрыты для модификации.

**Пример с Strategy pattern:**
```csharp
// Интерфейс для стратегии
public interface IDiscountStrategy
{
    decimal Calculate(decimal amount);
}

// Конкретные стратегии
public class RegularDiscount : IDiscountStrategy
{
    public decimal Calculate(decimal amount) => amount * 0.05m;
}

public class VipDiscount : IDiscountStrategy
{
    public decimal Calculate(decimal amount) => amount * 0.15m;
}

// Контекст - закрыт для модификации, открыт для расширения
public class PriceCalculator
{
    private readonly IDiscountStrategy _discountStrategy;
    
    public PriceCalculator(IDiscountStrategy discountStrategy)
    {
        _discountStrategy = discountStrategy;
    }
    
    public decimal CalculatePrice(decimal basePrice)
    {
        return basePrice - _discountStrategy.Calculate(basePrice);
    }
}
```

**Ключевые моменты:**
- Новые типы скидок добавляются без изменения существующего кода
- Plugin-архитектура - классический пример OCP
- Абстракции должны быть стабильными

---

### 1.3 Liskov Substitution Principle (LSP)

**Принцип:** Объекты подклассов должны быть заменяемыми объектами базового класса без нарушения корректности программы.

**Классический пример нарушения:**
```csharp
// Нарушение LSP
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    
    public int GetArea() => Width * Height;
}

public class Square : Rectangle
{
    public override int Width 
    { 
        get => base.Width; 
        set => base.Width = base.Height = value; // Нарушение!
    }
    
    public override int Height 
    { 
        get => base.Height; 
        set => base.Width = base.Height = value; // Нарушение!
    }
}
```

**Правильная реализация:**
```csharp
public abstract class Shape
{
    public abstract int GetArea();
}

public class Rectangle : Shape
{
    public int Width { get; set; }
    public int Height { get; set; }
    
    public override int GetArea() => Width * Height;
}

public class Square : Shape
{
    public int Side { get; set; }
    
    public override int GetArea() => Side * Side;
}
```

**Ключевые моменты:**
- Поведенческая совместимость важнее структурной
- Подклассы не должны усиливать предусловия или ослаблять постусловия
- LSP критически важен для полиморфизма

---

### 1.4 Interface Segregation Principle (ISP)

**Принцип:** Клиенты не должны зависеть от интерфейсов, которые они не используют.

**Пример нарушения:**
```csharp
// "Толстый" интерфейс - нарушение ISP
public interface IWorker
{
    void Work();
    void Eat();
    void Sleep();
}

public class Robot : IWorker
{
    public void Work() { /* работает */ }
    public void Eat() { throw new NotImplementedException(); } // Проблема!
    public void Sleep() { throw new NotImplementedException(); } // Проблема!
}
```

**Правильная реализация:**
```csharp
public interface IWorkable
{
    void Work();
}

public interface IFeedable
{
    void Eat();
}

public interface ISleepable
{
    void Sleep();
}

public class Human : IWorkable, IFeedable, ISleepable
{
    public void Work() { /* работает */ }
    public void Eat() { /* ест */ }
    public void Sleep() { /* спит */ }
}

public class Robot : IWorkable
{
    public void Work() { /* работает */ }
}
```

**Ключевые моменты:**
- Разделение интерфейсов по ролям клиентов
- Снижается coupling между компонентами
- Применимо к API дизайну - не перегружайте эндпоинты

---

### 1.5 Dependency Inversion Principle (DIP)

**Принцип:** Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.

**Пример нарушения:**
```csharp
// Нарушение DIP - зависимость от конкретной реализации
public class OrderService
{
    private readonly SqlOrderRepository _repository; // Проблема!
    
    public OrderService()
    {
        _repository = new SqlOrderRepository(); // Проблема!
    }
}
```

**Правильная реализация:**
```csharp
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task SaveAsync(Order order);
}

public class OrderService
{
    private readonly IOrderRepository _repository;
    
    public OrderService(IOrderRepository repository)
    {
        _repository = repository;
    }
    
    public async Task ProcessOrder(int orderId)
    {
        var order = await _repository.GetByIdAsync(orderId);
        // Бизнес-логика
        await _repository.SaveAsync(order);
    }
}
```

**Ключевые моменты:**
- DIP ≠ Dependency Injection (DI - техника, DIP - принцип)
- Позволяет легко тестировать и менять реализации
- Инверсия происходит на уровне архитектуры

---

### 1.6 SOLID в комплексе

**Пример комплексного применения:**
```csharp
// SRP - отдельные ответственности
public interface IEmailSender { Task SendAsync(string to, string message); }
public interface ILogger { void Log(string message); }
public interface IOrderValidator { bool Validate(Order order); }

// OCP - расширяемость через абстракции
public interface IOrderProcessor
{
    Task ProcessAsync(Order order);
}

// LSP - корректная иерархия
public abstract class OrderProcessor : IOrderProcessor
{
    public abstract Task ProcessAsync(Order order);
}

// ISP - разделенные интерфейсы
public class OrderService
{
    private readonly IOrderValidator _validator;
    private readonly IOrderProcessor _processor;
    private readonly IEmailSender _emailSender;
    private readonly ILogger _logger;
    
    // DIP - зависимость от абстракций
    public OrderService(
        IOrderValidator validator,
        IOrderProcessor processor,
        IEmailSender emailSender,
        ILogger logger)
    {
        _validator = validator;
        _processor = processor;
        _emailSender = emailSender;
        _logger = logger;
    }
}
```

---

## 2. Clean Architecture

### 2.1 Основы и слои

**Clean Architecture состоит из концентрических кругов:**

1. **Entities** (центр) - бизнес-объекты
2. **Use Cases** - прикладная бизнес-логика
3. **Interface Adapters** - контроллеры, презентеры, гейтвеи
4. **Frameworks & Drivers** - внешние инструменты

**Пример структуры:**
```csharp
// Domain Layer (Entities)
public class Order
{
    public int Id { get; private set; }
    public List<OrderItem> Items { get; private set; } = new();
    public decimal Total => Items.Sum(x => x.Price * x.Quantity);
    
    public void AddItem(Product product, int quantity)
    {
        if (quantity <= 0) throw new ArgumentException("Quantity must be positive");
        Items.Add(new OrderItem(product, quantity));
    }
}

// Application Layer (Use Cases)
public class CreateOrderUseCase
{
    private readonly IOrderRepository _orderRepository;
    private readonly IProductRepository _productRepository;
    
    public CreateOrderUseCase(IOrderRepository orderRepository, IProductRepository productRepository)
    {
        _orderRepository = orderRepository;
        _productRepository = productRepository;
    }
    
    public async Task<int> ExecuteAsync(CreateOrderRequest request)
    {
        var order = new Order();
        
        foreach (var item in request.Items)
        {
            var product = await _productRepository.GetByIdAsync(item.ProductId);
            order.AddItem(product, item.Quantity);
        }
        
        return await _orderRepository.SaveAsync(order);
    }
}
```

**Ключевые отличия от Layered Architecture:**
- Зависимости направлены к центру, а не вниз
- Доменная логика изолирована от внешних деталей
- Тестируемость без внешних зависимостей

---

### 2.2 Dependency Rule

**Правило:** Зависимости могут указывать только внутрь. Внутренние слои не знают о внешних.

**Передача данных между слоями:**
```csharp
// Request/Response объекты для пересечения границ
public class CreateOrderRequest
{
    public List<OrderItemRequest> Items { get; set; }
}

public class OrderItemRequest
{
    public int ProductId { get; set; }
    public int Quantity { get; set; }
}

public class CreateOrderResponse
{
    public int OrderId { get; set; }
    public decimal Total { get; set; }
}

// Use Case
public class CreateOrderUseCase
{
    public async Task<CreateOrderResponse> ExecuteAsync(CreateOrderRequest request)
    {
        // Преобразование внешнего запроса в доменные объекты
        var order = new Order();
        
        // Бизнес-логика
        
        // Преобразование результата в ответ
        return new CreateOrderResponse 
        { 
            OrderId = order.Id, 
            Total = order.Total 
        };
    }
}
```

**Ключевые моменты:**
- Используйте DTO для пересечения границ
- Внутренние слои определяют интерфейсы, внешние их реализуют
- Нарушение правила ведет к tight coupling

---

### 2.3 Entities и Use Cases

**Entities - базовая бизнес-логика:**
```csharp
public class Account
{
    public decimal Balance { get; private set; }
    
    public void Withdraw(decimal amount)
    {
        if (amount <= 0) throw new ArgumentException("Amount must be positive");
        if (Balance < amount) throw new InvalidOperationException("Insufficient funds");
        
        Balance -= amount;
    }
    
    public void Deposit(decimal amount)
    {
        if (amount <= 0) throw new ArgumentException("Amount must be positive");
        Balance += amount;
    }
}
```

**Use Cases - прикладная логика:**
```csharp
public class TransferMoneyUseCase
{
    private readonly IAccountRepository _accountRepository;
    private readonly ITransactionLogger _transactionLogger;
    
    public async Task ExecuteAsync(int fromAccountId, int toAccountId, decimal amount)
    {
        var fromAccount = await _accountRepository.GetByIdAsync(fromAccountId);
        var toAccount = await _accountRepository.GetByIdAsync(toAccountId);
        
        fromAccount.Withdraw(amount); // Доменная логика
        toAccount.Deposit(amount);    // Доменная логика
        
        await _accountRepository.SaveAsync(fromAccount);
        await _accountRepository.SaveAsync(toAccount);
        await _transactionLogger.LogTransferAsync(fromAccountId, toAccountId, amount);
    }
}
```

**Разграничение ответственности:**
- **Entities** - инварианты, базовые правила
- **Use Cases** - оркестрация, workflow, координация

---

### 2.4 Ports & Adapters (Hexagonal Architecture)

**Ports (интерфейсы) - определяются внутри:**
```csharp
// Primary Port (входящий)
public interface IOrderService
{
    Task<int> CreateOrderAsync(CreateOrderRequest request);
}

// Secondary Port (исходящий)
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task<int> SaveAsync(Order order);
}

public interface IEmailNotifier
{
    Task SendOrderConfirmationAsync(int orderId);
}
```

**Adapters (реализации) - во внешних слоях:**
```csharp
// Primary Adapter (Controller)
[ApiController]
public class OrderController : ControllerBase
{
    private readonly IOrderService _orderService;
    
    [HttpPost]
    public async Task<IActionResult> CreateOrder(CreateOrderRequest request)
    {
        var orderId = await _orderService.CreateOrderAsync(request);
        return Ok(new { OrderId = orderId });
    }
}

// Secondary Adapter (Repository)
public class SqlOrderRepository : IOrderRepository
{
    private readonly DbContext _context;
    
    public async Task<Order> GetByIdAsync(int id)
    {
        // EF Core логика
    }
}
```

**Anti-Corruption Layer:**
```csharp
public class PaymentServiceAdapter : IPaymentGateway
{
    private readonly ThirdPartyPaymentClient _client;
    
    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        // Преобразование из нашей модели в модель внешнего сервиса
        var externalRequest = MapToExternalModel(request);
        var externalResponse = await _client.ProcessAsync(externalRequest);
        
        // Преобразование обратно в нашу модель
        return MapFromExternalModel(externalResponse);
    }
}
```

---

### 2.5 Clean Architecture и базы данных

**Размещение компонентов:**
```
Domain Layer (Entities)
├── Order.cs
├── Product.cs

Application Layer (Use Cases)
├── Interfaces/
│   ├── IOrderRepository.cs
│   └── IProductRepository.cs
├── UseCases/
│   └── CreateOrderUseCase.cs

Infrastructure Layer
├── Persistence/
│   ├── OrderRepository.cs
│   ├── ProductRepository.cs
│   └── Mappings/
│       ├── OrderConfiguration.cs
│       └── ProductConfiguration.cs
```

**Mapping между доменом и persistence:**
```csharp
// Domain Entity
public class Order
{
    public int Id { get; private set; }
    public List<OrderItem> Items { get; private set; }
}

// EF Configuration
public class OrderConfiguration : IEntityTypeConfiguration<Order>
{
    public void Configure(EntityTypeBuilder<Order> builder)
    {
        builder.HasKey(o => o.Id);
        
        builder.OwnsMany(o => o.Items, item =>
        {
            item.Property(i => i.ProductId);
            item.Property(i => i.Quantity);
        });
    }
}

// Repository Implementation
public class OrderRepository : IOrderRepository
{
    private readonly AppDbContext _context;
    
    public async Task<Order> GetByIdAsync(int id)
    {
        return await _context.Orders
            .Include(o => o.Items)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
}
```

**Обработка транзакций:**
```csharp
public class CreateOrderUseCase
{
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task<int> ExecuteAsync(CreateOrderRequest request)
    {
        using var transaction = await _unitOfWork.BeginTransactionAsync();
        
        try
        {
            // Создание заказа
            var order = new Order();
            await _unitOfWork.Orders.SaveAsync(order);
            
            // Обновление остатков
            foreach (var item in request.Items)
            {
                var product = await _unitOfWork.Products.GetByIdAsync(item.ProductId);
                product.DecreaseStock(item.Quantity);
                await _unitOfWork.Products.SaveAsync(product);
            }
            
            await transaction.CommitAsync();
            return order.Id;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

---

## 3. Dependency Injection и IoC

### 3.1 Основы DI

**Типы Dependency Injection:**

**Constructor Injection (рекомендуемый):**
```csharp
public class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly IEmailSender _emailSender;
    
    public OrderService(IOrderRepository repository, IEmailSender emailSender)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        _emailSender = emailSender ?? throw new ArgumentNullException(nameof(emailSender));
    }
}
```

**Property Injection:**
```csharp
public class OrderService
{
    public IOrderRepository Repository { get; set; }
    public IEmailSender EmailSender { get; set; }
    
    public void ProcessOrder()
    {
        if (Repository == null) throw new InvalidOperationException("Repository not set");
        // Логика
    }
}
```

**Method Injection:**
```csharp
public class OrderService
{
    public void ProcessOrder(IOrderRepository repository, IEmailSender emailSender)
    {
        // Логика с переданными зависимостями
    }
}
```

**DI vs Service Locator:**
```csharp
// Service Locator (антипаттерн)
public class OrderService
{
    public void ProcessOrder()
    {
        var repository = ServiceLocator.Get<IOrderRepository>(); // Плохо!
        var emailSender = ServiceLocator.Get<IEmailSender>();   // Плохо!
    }
}

// Dependency Injection (правильно)
public class OrderService
{
    private readonly IOrderRepository _repository;
    private readonly IEmailSender _emailSender;
    
    public OrderService(IOrderRepository repository, IEmailSender emailSender)
    {
        _repository = repository;
        _emailSender = emailSender;
    }
}
```

---

### 3.2 Жизненные циклы

**Основные типы lifetime:**

**Singleton:**
```csharp
// Регистрация
services.AddSingleton<IConfigurationService, ConfigurationService>();

// Поведение: один экземпляр на все приложение
public class ConfigurationService : IConfigurationService
{
    private readonly Dictionary<string, string> _cache = new();
    
    public string GetValue(string key)
    {
        return _cache.TryGetValue(key, out var value) ? value : null;
    }
}
```

**Transient:**
```csharp
// Регистрация
services.AddTransient<IEmailSender, EmailSender>();

// Поведение: новый экземпляр каждый раз
public class EmailSender : IEmailSender
{
    public async Task SendAsync(string to, string message)
    {
        // Каждый вызов = новый экземпляр
    }
}
```

**Scoped (в веб-приложениях):**
```csharp
// Регистрация
services.AddScoped<IOrderService, OrderService>();

// Поведение: один экземпляр на HTTP запрос
public class OrderService : IOrderService
{
    private readonly IOrderRepository _repository;
    
    // Один экземпляр в пределах HTTP запроса
}
```

**Captive Dependencies:**
```csharp
// ПРОБЛЕМА: Singleton содержит Scoped зависимость
public class SingletonService // Singleton
{
    private readonly IScopedService _scopedService; // Scoped - будет "захвачен"!
    
    public SingletonService(IScopedService scopedService)
    {
        _scopedService = scopedService; // Ошибка!
    }
}

// РЕШЕНИЕ: Использовать IServiceProvider или фабрику
public class SingletonService
{
    private readonly IServiceProvider _serviceProvider;
    
    public SingletonService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public void DoWork()
    {
        using var scope = _serviceProvider.CreateScope();
        var scopedService = scope.ServiceProvider.GetRequiredService<IScopedService>();
        // Работа с scoped сервисом
    }
}
```

---

### 3.3 Антипаттерны DI

**Constructor Over-injection:**
```csharp
// ПЛОХО: слишком много зависимостей
public class OrderService
{
    public OrderService(
        IOrderRepository repository,
        IProductRepository productRepository,
        ICustomerRepository customerRepository,
        IInventoryService inventoryService,
        IEmailSender emailSender,
        ILogger logger,
        IPricingService pricingService,
        ITaxCalculator taxCalculator,
        IShippingCalculator shippingCalculator,
        IPaymentProcessor paymentProcessor) // 10+ зависимостей!
    {
        // Нарушение SRP!
    }
}

// ХОРОШО: разделение ответственности
public class OrderCreationService
{
    private readonly IOrderRepository _repository;
    private readonly IInventoryService _inventoryService;
    
    public OrderCreationService(IOrderRepository repository, IInventoryService inventoryService)
    {
        _repository = repository;
        _inventoryService = inventoryService;
    }
}

public class OrderNotificationService
{
    private readonly IEmailSender _emailSender;
    private readonly ILogger _logger;
    
    public OrderNotificationService(IEmailSender emailSender, ILogger logger)
    {
        _emailSender = emailSender;
        _logger = logger;
    }
}
```

**Использование контейнера в бизнес-логике:**
```csharp
// ПЛОХО: зависимость от контейнера
public class OrderService
{
    private readonly IServiceProvider _serviceProvider; // Плохо!
    
    public void ProcessOrder(OrderType orderType)
    {
        var processor = orderType switch
        {
            OrderType.Standard => _serviceProvider.GetService<IStandardOrderProcessor>(),
            OrderType.Express => _serviceProvider.GetService<IExpressOrderProcessor>(),
            _ => throw new ArgumentException("Unknown order type")
        };
        
        processor.Process();
    }
}

// ХОРОШО: использование фабрики
public interface IOrderProcessorFactory
{
    IOrderProcessor Create(OrderType orderType);
}

public class OrderService
{
    private readonly IOrderProcessorFactory _processorFactory;
    
    public OrderService(IOrderProcessorFactory processorFactory)
    {
        _processorFactory = processorFactory;
    }
    
    public void ProcessOrder(OrderType orderType)
    {
        var processor = _processorFactory.Create(orderType);
        processor.Process();
    }
}
```

---

### 3.4 DI и тестирование

**Упрощение unit тестирования:**
```csharp
[Test]
public async Task CreateOrder_ShouldSaveOrder_WhenValidRequest()
{
    // Arrange
    var mockRepository = new Mock<IOrderRepository>();
    var mockEmailSender = new Mock<IEmailSender>();
    
    mockRepository.Setup(r => r.SaveAsync(It.IsAny<Order>()))
              .ReturnsAsync(123);
    
    var service = new OrderService(mockRepository.Object, mockEmailSender.Object);
    var request = new CreateOrderRequest { /* тестовые данные */ };
    
    // Act
    var result = await service.CreateOrderAsync(request);
    
    // Assert
    Assert.AreEqual(123, result);
    mockRepository.Verify(r => r.SaveAsync(It.IsAny<Order>()), Times.Once);
    mockEmailSender.Verify(e => e.SendOrderConfirmationAsync(123), Times.Once);
}
```

**Регистрация test doubles:**
```csharp
// В тестовом проекте
public class TestServiceCollection
{
    public static IServiceProvider CreateTestServices()
    {
        var services = new ServiceCollection();
        
        // Регистрация реальных сервисов
        services.AddTransient<IOrderService, OrderService>();
        
        // Замена зависимостей на тестовые
        services.AddSingleton<IOrderRepository, InMemoryOrderRepository>();
        services.AddSingleton<IEmailSender, TestEmailSender>();
        
        return services.BuildServiceProvider();
    }
}

public class InMemoryOrderRepository : IOrderRepository
{
    private readonly List<Order> _orders = new();
    
    public async Task<Order> GetByIdAsync(int id)
    {
        return _orders.FirstOrDefault(o => o.Id == id);
    }
    
    public async Task<int> SaveAsync(Order order)
    {
        order.Id = _orders.Count + 1;
        _orders.Add(order);
        return order.Id;
    }
}
```

---

## 4. Ключевые паттерны проектирования

### 4.1 Repository Pattern

**Правильная реализация Repository:**
```csharp
// Интерфейс репозитория
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task<IEnumerable<Order>> GetByCustomerIdAsync(int customerId);
    Task<int> SaveAsync(Order order);
    Task DeleteAsync(int id);
}

// Реализация
public class OrderRepository : IOrderRepository
{
    private readonly DbContext _context;
    
    public OrderRepository(DbContext context)
    {
        _context = context;
    }
    
    public async Task<Order> GetByIdAsync(int id)
    {
        return await _context.Orders
            .Include(o => o.Items)
            .ThenInclude(i => i.Product)
            .FirstOrDefaultAsync(o => o.Id == id);
    }
    
    public async Task<IEnumerable<Order>> GetByCustomerIdAsync(int customerId)
    {
        return await _context.Orders
            .Where(o => o.CustomerId == customerId)
            .ToListAsync();
    }
}
```

**Generic vs Специфичные репозитории:**
```csharp
// Generic Repository (часто избыточен)
public interface IRepository<T> where T : class
{
    Task<T> GetByIdAsync(int id);
    Task<IEnumerable<T>> GetAllAsync();
    Task SaveAsync(T entity);
    Task DeleteAsync(int id);
}

// Специфичный репозиторий (предпочтительнее)
public interface IOrderRepository
{
    Task<Order> GetByIdAsync(int id);
    Task<IEnumerable<Order>> GetActiveOrdersAsync();
    Task<IEnumerable<Order>> GetOrdersByDateRangeAsync(DateTime from, DateTime to);
    Task<decimal> GetTotalRevenueAsync(int customerId);
}
```

**Почему не стоит возвращать IQueryable:**
```csharp
// ПЛОХО: нарушение инкапсуляции
public interface IOrderRepository
{
    IQueryable<Order> Orders { get; } // Позволяет любые запросы!
}

// ХОРОШО: конкретные методы
public interface IOrderRepository
{
    Task<IEnumerable<Order>> GetOrdersByStatusAsync(OrderStatus status);
    Task<PagedResult<Order>> GetPagedOrdersAsync(int page, int pageSize);
}
```

---

### 4.2 Unit of Work

**Реализация Unit of Work:**
```csharp
public interface IUnitOfWork : IDisposable
{
    IOrderRepository Orders { get; }
    IProductRepository Products { get; }
    ICustomerRepository Customers { get; }
    
    Task<int> SaveChangesAsync();
    Task<IDbTransaction> BeginTransactionAsync();
}

public class UnitOfWork : IUnitOfWork
{
    private readonly DbContext _context;
    private IDbTransaction _transaction;
    
    public IOrderRepository Orders { get; private set; }
    public IProductRepository Products { get; private set; }
    public ICustomerRepository Customers { get; private set; }
    
    public UnitOfWork(DbContext context)
    {
        _context = context;
        Orders = new OrderRepository(context);
        Products = new ProductRepository(context);
        Customers = new CustomerRepository(context);
    }
    
    public async Task<int> SaveChangesAsync()
    {
        return await _context.SaveChangesAsync();
    }
    
    public async Task<IDbTransaction> BeginTransactionAsync()
    {
        _transaction = await _context.Database.BeginTransactionAsync();
        return _transaction;
    }
    
    public void Dispose()
    {
        _transaction?.Dispose();
        _context?.Dispose();
    }
}
```

**Использование в Use Case:**
```csharp
public class TransferProductUseCase
{
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task ExecuteAsync(int productId, int fromWarehouse, int toWarehouse, int quantity)
    {
        using var transaction = await _unitOfWork.BeginTransactionAsync();
        
        try
        {
            var product = await _unitOfWork.Products.GetByIdAsync(productId);
            
            // Уменьшаем остаток на исходном складе
            var fromInventory = await _unitOfWork.Inventory.GetByWarehouseAndProductAsync(fromWarehouse, productId);
            fromInventory.DecreaseQuantity(quantity);
            
            // Увеличиваем остаток на целевом складе
            var toInventory = await _unitOfWork.Inventory.GetByWarehouseAndProductAsync(toWarehouse, productId);
            toInventory.IncreaseQuantity(quantity);
            
            await _unitOfWork.SaveChangesAsync();
            await transaction.CommitAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

---

### 4.3 Strategy Pattern

**Классическая реализация:**
```csharp
public interface IShippingStrategy
{
    decimal CalculateCost(decimal weight, string destination);
    TimeSpan EstimateDeliveryTime(string destination);
}

public class StandardShipping : IShippingStrategy
{
    public decimal CalculateCost(decimal weight, string destination)
    {
        return weight * 2.5m;
    }
    
    public TimeSpan EstimateDeliveryTime(string destination)
    {
        return TimeSpan.FromDays(5);
    }
}

public class ExpressShipping : IShippingStrategy
{
    public decimal CalculateCost(decimal weight, string destination)
    {
        return weight * 8.0m;
    }
    
    public TimeSpan EstimateDeliveryTime(string destination)
    {
        return TimeSpan.FromDays(1);
    }
}
```

**Выбор стратегии во runtime:**
```csharp
public class ShippingCalculator
{
    private readonly IServiceProvider _serviceProvider;
    
    public ShippingCalculator(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public decimal CalculateShippingCost(ShippingType type, decimal weight, string destination)
    {
        var strategy = type switch
        {
            ShippingType.Standard => _serviceProvider.GetService<StandardShipping>(),
            ShippingType.Express => _serviceProvider.GetService<ExpressShipping>(),
            ShippingType.Overnight => _serviceProvider.GetService<OvernightShipping>(),
            _ => throw new ArgumentException($"Unknown shipping type: {type}")
        };
        
        return strategy.CalculateCost(weight, destination);
    }
}
```

**Функциональный подход (альтернатива):**
```csharp
public static class ShippingStrategies
{
    public static readonly Func<decimal, string, decimal> Standard = 
        (weight, destination) => weight * 2.5m;
    
    public static readonly Func<decimal, string, decimal> Express = 
        (weight, destination) => weight * 8.0m;
    
    public static Func<decimal, string, decimal> GetStrategy(ShippingType type)
    {
        return type switch
        {
            ShippingType.Standard => Standard,
            ShippingType.Express => Express,
            _ => throw new ArgumentException($"Unknown shipping type: {type}")
        };
    }
}
```

---

### 4.4 Decorator Pattern

**Реализация декоратора:**
```csharp
public interface IOrderService
{
    Task<int> CreateOrderAsync(CreateOrderRequest request);
}

public class OrderService : IOrderService
{
    private readonly IOrderRepository _repository;
    
    public async Task<int> CreateOrderAsync(CreateOrderRequest request)
    {
        var order = new Order(request.CustomerId);
        // Основная логика создания заказа
        return await _repository.SaveAsync(order);
    }
}

// Декоратор для логирования
public class LoggingOrderServiceDecorator : IOrderService
{
    private readonly IOrderService _orderService;
    private readonly ILogger<LoggingOrderServiceDecorator> _logger;
    
    public LoggingOrderServiceDecorator(IOrderService orderService, ILogger<LoggingOrderServiceDecorator> logger)
    {
        _orderService = orderService;
        _logger = logger;
    }
    
    public async Task<int> CreateOrderAsync(CreateOrderRequest request)
    {
        _logger.LogInformation("Creating order for customer {CustomerId}", request.CustomerId);
        
        try
        {
            var orderId = await _orderService.CreateOrderAsync(request);
            _logger.LogInformation("Order {OrderId} created successfully", orderId);
            return orderId;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create order for customer {CustomerId}", request.CustomerId);
            throw;
        }
    }
}

// Декоратор для кэширования
public class CachingOrderServiceDecorator : IOrderService
{
    private readonly IOrderService _orderService;
    private readonly IMemoryCache _cache;
    
    public async Task<int> CreateOrderAsync(CreateOrderRequest request)
    {
        var cacheKey = $"order_{request.GetHashCode()}";
        
        if (_cache.TryGetValue(cacheKey, out int cachedOrderId))
        {
            return cachedOrderId;
        }
        
        var orderId = await _orderService.CreateOrderAsync(request);
        _cache.Set(cacheKey, orderId, TimeSpan.FromMinutes(5));
        
        return orderId;
    }
}
```

**Регистрация цепочки декораторов:**
```csharp
services.AddTransient<OrderService>();
services.AddTransient<IOrderService>(provider =>
{
    var baseService = provider.GetService<OrderService>();
    var logger = provider.GetService<ILogger<LoggingOrderServiceDecorator>>();
    var cache = provider.GetService<IMemoryCache>();
    
    // Оборачиваем в декораторы
    var loggingDecorator = new LoggingOrderServiceDecorator(baseService, logger);
    var cachingDecorator = new CachingOrderServiceDecorator(loggingDecorator, cache);
    
    return cachingDecorator;
});
```

---

### 4.5 Command Pattern и CQRS

**Классический Command Pattern:**
```csharp
public interface ICommand
{
    Task ExecuteAsync();
}

public class CreateOrderCommand : ICommand
{
    private readonly IOrderRepository _repository;
    private readonly CreateOrderRequest _request;
    
    public CreateOrderCommand(IOrderRepository repository, CreateOrderRequest request)
    {
        _repository = repository;
        _request = request;
    }
    
    public async Task ExecuteAsync()
    {
        var order = new Order(_request.CustomerId);
        // Логика создания заказа
        await _repository.SaveAsync(order);
    }
}
```

**CQRS подход:**
```csharp
// Command (изменение состояния)
public class CreateOrderCommand
{
    public int CustomerId { get; set; }
    public List<OrderItemDto> Items { get; set; }
}

public class CreateOrderCommandHandler
{
    private readonly IOrderRepository _repository;
    private readonly IEventBus _eventBus;
    
    public async Task<int> HandleAsync(CreateOrderCommand command)
    {
        var order = new Order(command.CustomerId);
        
        foreach (var item in command.Items)
        {
            order.AddItem(item.ProductId, item.Quantity);
        }
        
        var orderId = await _repository.SaveAsync(order);
        
        // Публикация события
        await _eventBus.PublishAsync(new OrderCreatedEvent(orderId));
        
        return orderId;
    }
}

// Query (чтение данных)
public class GetOrderQuery
{
    public int OrderId { get; set; }
}

public class GetOrderQueryHandler
{
    private readonly IOrderReadRepository _repository;
    
    public async Task<OrderDto> HandleAsync(GetOrderQuery query)
    {
        return await _repository.GetOrderDtoAsync(query.OrderId);
    }
}
```

**Когда CQRS избыточен:**
- Простые CRUD операции
- Малые проекты без сложной доменной логики
- Когда модель чтения совпадает с моделью записи

---

### 4.6 Factory Patterns

**Factory Method:**
```csharp
public abstract class PaymentProcessorFactory
{
    public abstract IPaymentProcessor CreateProcessor();
    
    public async Task<PaymentResult> ProcessPayment(PaymentRequest request)
    {
        var processor = CreateProcessor();
        return await processor.ProcessAsync(request);
    }
}

public class CreditCardProcessorFactory : PaymentProcessorFactory
{
    public override IPaymentProcessor CreateProcessor()
    {
        return new CreditCardProcessor();
    }
}

public class PayPalProcessorFactory : PaymentProcessorFactory
{
    public override IPaymentProcessor CreateProcessor()
    {
        return new PayPalProcessor();
    }
}
```

**Abstract Factory:**
```csharp
public interface IUIFactory
{
    IButton CreateButton();
    ITextBox CreateTextBox();
    IWindow CreateWindow();
}

public class WindowsUIFactory : IUIFactory
{
    public IButton CreateButton() => new WindowsButton();
    public ITextBox CreateTextBox() => new WindowsTextBox();
    public IWindow CreateWindow() => new WindowsWindow();
}

public class MacUIFactory : IUIFactory
{
    public IButton CreateButton() => new MacButton();
    public ITextBox CreateTextBox() => new MacTextBox();
    public IWindow CreateWindow() => new MacWindow();
}
```

**Builder Pattern (Fluent):**
```csharp
public class EmailBuilder
{
    private string _to;
    private string _subject;
    private string _body;
    private List<string> _attachments = new();
    
    public EmailBuilder To(string to)
    {
        _to = to;
        return this;
    }
    
    public EmailBuilder Subject(string subject)
    {
        _subject = subject;
        return this;
    }
    
    public EmailBuilder Body(string body)
    {
        _body = body;
        return this;
    }
    
    public EmailBuilder Attach(string filePath)
    {
        _attachments.Add(filePath);
        return this;
    }
    
    public Email Build()
    {
        if (string.IsNullOrEmpty(_to)) throw new InvalidOperationException("To address is required");
        if (string.IsNullOrEmpty(_subject)) throw new InvalidOperationException("Subject is required");
        
        return new Email(_to, _subject, _body, _attachments);
    }
}

// Использование
var email = new EmailBuilder()
    .To("user@example.com")
    .Subject("Welcome!")
    .Body("Welcome to our service")
    .Attach("welcome.pdf")
    .Build();
```

**Factory с DI:**
```csharp
public interface IPaymentProcessorFactory
{
    IPaymentProcessor Create(PaymentType type);
}

public class PaymentProcessorFactory : IPaymentProcessorFactory
{
    private readonly IServiceProvider _serviceProvider;
    
    public PaymentProcessorFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    public IPaymentProcessor Create(PaymentType type)
    {
        return type switch
        {
            PaymentType.CreditCard => _serviceProvider.GetService<CreditCardProcessor>(),
            PaymentType.PayPal => _serviceProvider.GetService<PayPalProcessor>(),
            PaymentType.BankTransfer => _serviceProvider.GetService<BankTransferProcessor>(),
            _ => throw new ArgumentException($"Unknown payment type: {type}")
        };
    }
}
```

---

## 5. Domain-Driven Design

### 5.1 Анемичная vs Богатая доменная модель

**Анемичная модель (антипаттерн):**
```csharp
// Только данные, нет поведения
public class Order
{
    public int Id { get; set; }
    public int CustomerId { get; set; }
    public DateTime OrderDate { get; set; }
    public List<OrderItem> Items { get; set; } = new();
    public decimal Total { get; set; }
    public OrderStatus Status { get; set; }
}

// Логика в сервисах
public class OrderService
{
    public void AddItem(Order order, int productId, int quantity, decimal price)
    {
        var item = new OrderItem 
        { 
            ProductId = productId, 
            Quantity = quantity, 
            Price = price 
        };
        order.Items.Add(item);
        
        // Пересчет общей суммы
        order.Total = order.Items.Sum(i => i.Quantity * i.Price);
    }
    
    public void CompleteOrder(Order order)
    {
        if (order.Items.Count == 0) 
            throw new InvalidOperationException("Cannot complete empty order");
        
        order.Status = OrderStatus.Completed;
        order.OrderDate = DateTime.UtcNow;
    }
}
```

**Богатая доменная модель:**
```csharp
public class Order
{
    private readonly List<OrderItem> _items = new();
    
    public int Id { get; private set; }
    public int CustomerId { get; private set; }
    public DateTime OrderDate { get; private set; }
    public IReadOnlyList<OrderItem> Items => _items.AsReadOnly();
    public decimal Total => _items.Sum(i => i.Subtotal);
    public OrderStatus Status { get; private set; }
    
    public Order(int customerId)
    {
        if (customerId <= 0) throw new ArgumentException("Customer ID must be positive", nameof(customerId));
        
        CustomerId = customerId;
        Status = OrderStatus.Draft;
        OrderDate = DateTime.UtcNow;
    }
    
    public void AddItem(int productId, int quantity, decimal unitPrice)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify completed order");
        
        if (quantity <= 0) throw new ArgumentException("Quantity must be positive", nameof(quantity));
        if (unitPrice < 0) throw new ArgumentException("Price cannot be negative", nameof(unitPrice));
        
        var existingItem = _items.FirstOrDefault(i => i.ProductId == productId);
        if (existingItem != null)
        {
            existingItem.IncreaseQuantity(quantity);
        }
        else
        {
            _items.Add(new OrderItem(productId, quantity, unitPrice));
        }
    }
    
    public void RemoveItem(int productId)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify completed order");
        
        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            _items.Remove(item);
        }
    }
    
    public void Complete()
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Order is already completed");
        
        if (_items.Count == 0)
            throw new InvalidOperationException("Cannot complete empty order");
        
        Status = OrderStatus.Completed;
    }
}

public class OrderItem
{
    public int ProductId { get; private set; }
    public int Quantity { get; private set; }
    public decimal UnitPrice { get; private set; }
    public decimal Subtotal => Quantity * UnitPrice;
    
    public OrderItem(int productId, int quantity, decimal unitPrice)
    {
        if (productId <= 0) throw new ArgumentException("Product ID must be positive");
        if (quantity <= 0) throw new ArgumentException("Quantity must be positive");
        if (unitPrice < 0) throw new ArgumentException("Price cannot be negative");
        
        ProductId = productId;
        Quantity = quantity;
        UnitPrice = unitPrice;
    }
    
    public void IncreaseQuantity(int additionalQuantity)
    {
        if (additionalQuantity <= 0) throw new ArgumentException("Additional quantity must be positive");
        Quantity += additionalQuantity;
    }
}
```

**Ubiquitous Language:**
- Использовать термины предметной области в коде
- Избегать технических терминов в доменных объектах
- Код должен "читаться" как описание бизнес-процессов

---

### 5.2 Entities vs Value Objects

**Entity (имеет идентичность):**
```csharp
public class Customer : Entity
{
    public string Name { get; private set; }
    public Email Email { get; private set; }
    public Address ShippingAddress { get; private set; }
    
    public Customer(string name, Email email)
    {
        if (string.IsNullOrWhiteSpace(name)) 
            throw new ArgumentException("Name cannot be empty");
        
        Name = name;
        Email = email ?? throw new ArgumentNullException(nameof(email));
    }
    
    public void ChangeEmail(Email newEmail)
    {
        Email = newEmail ?? throw new ArgumentNullException(nameof(newEmail));
        // Возможно, нужно отправить уведомление
    }
    
    public void UpdateShippingAddress(Address address)
    {
        ShippingAddress = address ?? throw new ArgumentNullException(nameof(address));
    }
}

public abstract class Entity
{
    public int Id { get; protected set; }
    
    public override bool Equals(object obj)
    {
        if (obj is not Entity other || other.GetType() != GetType())
            return false;
        
        return Id == other.Id;
    }
    
    public override int GetHashCode() => Id.GetHashCode();
}
```

**Value Object (определяется значениями):**
```csharp
public class Email : ValueObject
{
    public string Value { get; private set; }
    
    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Email cannot be empty");
        
        if (!IsValidEmail(value))
            throw new ArgumentException("Invalid email format");
        
        Value = value.ToLowerInvariant();
    }
    
    private static bool IsValidEmail(string email)
    {
        return Regex.IsMatch(email, @"^[^@\s]+@[^@\s]+\.[^@\s]+$");
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }
    
    public override string ToString() => Value;
}

public class Address : ValueObject
{
    public string Street { get; private set; }
    public string City { get; private set; }
    public string PostalCode { get; private set; }
    public string Country { get; private set; }
    
    public Address(string street, string city, string postalCode, string country)
    {
        Street = street ?? throw new ArgumentNullException(nameof(street));
        City = city ?? throw new ArgumentNullException(nameof(city));
        PostalCode = postalCode ?? throw new ArgumentNullException(nameof(postalCode));
        Country = country ?? throw new ArgumentNullException(nameof(country));
    }
    
    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Street;
        yield return City;
        yield return PostalCode;
        yield return Country;
    }
}

public abstract class ValueObject
{
    protected abstract IEnumerable<object> GetEqualityComponents();
    
    public override bool Equals(object obj)
    {
        if (obj == null || obj.GetType() != GetType())
            return false;
        
        var other = (ValueObject)obj;
        return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
    }
    
    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Select(x => x?.GetHashCode() ?? 0)
            .Aggregate((x, y) => x ^ y);
    }
}
```

**Критерии выбора:**
- **Entity**: имеет жизненный цикл, может изменяться, важна идентичность
- **Value Object**: неизменяемый, определяется значениями, можно заменять

---

### 5.3 Aggregates

**Определение границ агрегата:**
```csharp
// Агрегат Order с корнем Order
public class Order : AggregateRoot
{
    private readonly List<OrderItem> _items = new();
    private readonly List<IDomainEvent> _domainEvents = new();
    
    public int CustomerId { get; private set; }
    public Money Total { get; private set; }
    public OrderStatus Status { get; private set; }
    public IReadOnlyList<OrderItem> Items => _items.AsReadOnly();
    
    public Order(int customerId)
    {
        CustomerId = customerId;
        Status = OrderStatus.Draft;
        Total = Money.Zero();
        
        AddDomainEvent(new OrderCreatedEvent(Id, customerId));
    }
    
    public void AddItem(Product product, int quantity)
    {
        // Инвариант: нельзя добавлять товары в завершенный заказ
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot add items to completed order");
        
        var existingItem = _items.FirstOrDefault(i => i.ProductId == product.Id);
        if (existingItem != null)
        {
            existingItem.IncreaseQuantity(quantity);
        }
        else
        {
            _items.Add(new OrderItem(product.Id, quantity, product.Price));
        }
        
        RecalculateTotal();
        AddDomainEvent(new OrderItemAddedEvent(Id, product.Id, quantity));
    }
    
    public void Complete()
    {
        // Инвариант: нельзя завершить пустой заказ
        if (_items.Count == 0)
            throw new InvalidOperationException("Cannot complete empty order");
        
        // Инвариант: минимальная сумма заказа
        if (Total.Amount < 10)
            throw new InvalidOperationException("Order total must be at least $10");
        
        Status = OrderStatus.Completed;
        AddDomainEvent(new OrderCompletedEvent(Id, Total));
    }
    
    private void RecalculateTotal()
    {
        var totalAmount = _items.Sum(i => i.Subtotal.Amount);
        Total = new Money(totalAmount);
    }
    
    public IReadOnlyList<IDomainEvent> GetDomainEvents() => _domainEvents.AsReadOnly();
    
    public void ClearDomainEvents() => _domainEvents.Clear();
    
    private void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }
}

// OrderItem является частью агрегата Order
public class OrderItem : Entity
{
    public int ProductId { get; private set; }
    public int Quantity { get; private set; }
    public Money UnitPrice { get; private set; }
    public Money Subtotal => new Money(Quantity * UnitPrice.Amount);
    
    internal OrderItem(int productId, int quantity, Money unitPrice)
    {
        ProductId = productId;
        Quantity = quantity;
        UnitPrice = unitPrice;
    }
    
    internal void IncreaseQuantity(int additionalQuantity)
    {
        Quantity += additionalQuantity;
    }
}
```

**Ссылки между агрегатами по ID:**
```csharp
public class Order : AggregateRoot
{
    public int CustomerId { get; private set; } // Ссылка по ID, не объект Customer
    public int? ShippingAddressId { get; private set; } // Ссылка по ID
    
    // НЕ так: public Customer Customer { get; set; }
    // НЕ так: public Address ShippingAddress { get; set; }
}

// Для получения связанных данных используем сервисы или read-модели
public class OrderDetailsQueryHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly ICustomerRepository _customerRepository;
    
    public async Task<OrderDetailsDto> GetOrderDetailsAsync(int orderId)
    {
        var order = await _orderRepository.GetByIdAsync(orderId);
        var customer = await _customerRepository.GetByIdAsync(order.CustomerId);
        
        return new OrderDetailsDto
        {
            OrderId = order.Id,
            CustomerName = customer.Name,
            Total = order.Total,
            Items = order.Items.Select(MapToDto).ToList()
        };
    }
}
```

---

### 5.4 Domain Events

**Определение Domain Events:**
```csharp
public interface IDomainEvent
{
    DateTime OccurredOn { get; }
}

public class OrderCreatedEvent : IDomainEvent
{
    public int OrderId { get; }
    public int CustomerId { get; }
    public DateTime OccurredOn { get; }
    
    public OrderCreatedEvent(int orderId, int customerId)
    {
        OrderId = orderId;
        CustomerId = customerId;
        OccurredOn = DateTime.UtcNow;
    }
}

public class OrderCompletedEvent : IDomainEvent
{
    public int OrderId { get; }
    public Money Total { get; }
    public DateTime OccurredOn { get; }
    
    public OrderCompletedEvent(int orderId, Money total)
    {
        OrderId = orderId;
        Total = total;
        OccurredOn = DateTime.UtcNow;
    }
}
```

**Обработка событий:**
```csharp
public interface IDomainEventHandler<T> where T : IDomainEvent
{
    Task HandleAsync(T domainEvent);
}

public class OrderCompletedEventHandler : IDomainEventHandler<OrderCompletedEvent>
{
    private readonly IEmailSender _emailSender;
    private readonly ICustomerRepository _customerRepository;
    
    public async Task HandleAsync(OrderCompletedEvent domainEvent)
    {
        var customer = await _customerRepository.GetByIdAsync(domainEvent.CustomerId);
        
        await _emailSender.SendAsync(
            customer.Email.Value,
            "Order Confirmation",
            $"Your order #{domainEvent.OrderId} has been completed. Total: ${domainEvent.Total.Amount}"
        );
    }
}

// Диспетчер событий
public class DomainEventDispatcher
{
    private readonly IServiceProvider _serviceProvider;
    
    public async Task DispatchAsync<T>(T domainEvent) where T : IDomainEvent
    {
        var handlers = _serviceProvider.GetServices<IDomainEventHandler<T>>();
        
        foreach (var handler in handlers)
        {
            await handler.HandleAsync(domainEvent);
        }
    }
}
```

**Публикация событий при сохранении:**
```csharp
public class OrderRepository : IOrderRepository
{
    private readonly DbContext _context;
    private readonly IDomainEventDispatcher _eventDispatcher;
    
    public async Task<int> SaveAsync(Order order)
    {
        _context.Orders.Add(order);
        await _context.SaveChangesAsync();
        
        // Публикация событий после успешного сохранения
        var events = order.GetDomainEvents();
        order.ClearDomainEvents();
        
        foreach (var domainEvent in events)
        {
            await _eventDispatcher.DispatchAsync(domainEvent);
        }
        
        return order.Id;
    }
}
```

**Domain Events vs Integration Events:**
- **Domain Events**: внутри bounded context, синхронные/асинхронные
- **Integration Events**: между bounded contexts, обычно асинхронные через message bus

---

## 6. Практические аспекты

### 6.1 Тестирование архитектуры

**Пирамида тестирования в Clean Architecture:**
```csharp
// Unit тесты для доменной логики
[Test]
public void Order_AddItem_ShouldIncreaseTotal()
{
    // Arrange
    var order = new Order(customerId: 1);
    var product = new Product(1, "Test Product", new Money(10));
    
    // Act
    order.AddItem(product, quantity: 2);
    
    // Assert
    Assert.AreEqual(20, order.Total.Amount);
    Assert.AreEqual(1, order.Items.Count);
}

// Unit тесты для Use Cases
[Test]
public async Task CreateOrderUseCase_ShouldCreateOrder_WhenValidRequest()
{
    // Arrange
    var mockOrderRepo = new Mock<IOrderRepository>();
    var mockProductRepo = new Mock<IProductRepository>();
    
    var product = new Product(1, "Test", new Money(10));
    mockProductRepo.Setup(r => r.GetByIdAsync(1)).ReturnsAsync(product);
    mockOrderRepo.Setup(r => r.SaveAsync(It.IsAny<Order>())).ReturnsAsync(123);
    
    var useCase = new CreateOrderUseCase(mockOrderRepo.Object, mockProductRepo.Object);
    var request = new CreateOrderRequest 
    { 
        CustomerId = 1, 
        Items = new[] { new OrderItemRequest { ProductId = 1, Quantity = 2 } }
    };
    
    // Act
    var result = await useCase.ExecuteAsync(request);
    
    // Assert
    Assert.AreEqual(123, result);
    mockOrderRepo.Verify(r => r.SaveAsync(It.IsAny<Order>()), Times.Once);
}
```

**Integration тесты:**
```csharp
[Test]
public async Task CreateOrder_EndToEnd_ShouldCreateOrderAndSendEmail()
{
    // Arrange
    var factory = new WebApplicationFactory<Program>();
    var client = factory.CreateClient();
    
    var request = new CreateOrderRequest
    {
        CustomerId = 1,
        Items = new[] { new OrderItemRequest { ProductId = 1, Quantity = 2 } }
    };
    
    // Act
    var response = await client.PostAsJsonAsync("/api/orders", request);
    
    // Assert
    response.EnsureSuccessStatusCode();
    var content = await response.Content.ReadAsStringAsync();
    var result = JsonSerializer.Deserialize<CreateOrderResponse>(content);
    
    Assert.IsTrue(result.OrderId > 0);
    
    // Проверяем, что заказ действительно создан в БД
    using var scope = factory.Services.CreateScope();
    var orderRepo = scope.ServiceProvider.GetService<IOrderRepository>();
    var order = await orderRepo.GetByIdAsync(result.OrderId);
    Assert.IsNotNull(order);
}
```

**Architecture Tests (ArchUnit-style):**
```csharp
[Test]
public void Domain_ShouldNotDependOn_Infrastructure()
{
    var domainAssembly = typeof(Order).Assembly;
    var infrastructureAssembly = typeof(OrderRepository).Assembly;
    
    var domainTypes = domainAssembly.GetTypes();
    
    foreach (var type in domainTypes)
    {
        var dependencies = type.GetReferencedAssemblies();
        Assert.IsFalse(dependencies.Any(a => a.FullName.Contains("Infrastructure")),
            $"Domain type {type.Name} should not reference Infrastructure");
    }
}

[Test]
public void UseCase_ShouldOnlyDependOn_DomainAndApplicationInterfaces()
{
    var useCaseType = typeof(CreateOrderUseCase);
    var dependencies = useCaseType.GetConstructorDependencies();
    
    foreach (var dependency in dependencies)
    {
        Assert.IsTrue(dependency.IsInterface, 
            $"UseCase {useCaseType.Name} should only depend on interfaces, but depends on {dependency.Name}");
        
        Assert.IsFalse(dependency.Assembly.FullName.Contains("Infrastructure"),
            $"UseCase should not directly depend on Infrastructure types");
    }
}
```

---

### 6.2 Выявление технического долга

**Architectural Smells и их обнаружение:**
```csharp
// 1. God Class (слишком много ответственности)
public class OrderManager // 500+ строк кода
{
    public void CreateOrder() { /* 50 строк */ }
    public void ValidateOrder() { /* 30 строк */ }
    public void CalculateShipping() { /* 40 строк */ }
    public void ProcessPayment() { /* 60 строк */ }
    public void SendNotifications() { /* 35 строк */ }
    public void UpdateInventory() { /* 45 строк */ }
    public void GenerateInvoice() { /* 55 строк */ }
    // ... еще 20 методов
}

// Решение: разделение по принципу SRP
public class OrderCreationService { /* только создание заказов */ }
public class OrderValidationService { /* только валидация */ }
public class ShippingCalculator { /* только расчет доставки */ }
public class PaymentProcessor { /* только платежи */ }
```

**Метрики для измерения архитектурного долга:**
```csharp
// Инструмент для анализа coupling
public class CouplingAnalyzer
{
    public CouplingMetrics AnalyzeAssembly(Assembly assembly)
    {
        var types = assembly.GetTypes();
        var metrics = new CouplingMetrics();
        
        foreach (var type in types)
        {
            // Afferent Coupling (Ca) - кто зависит от этого типа
            metrics.AfferentCoupling[type] = CountIncomingDependencies(type, types);
            
            // Efferent Coupling (Ce) - от кого зависит этот тип
            metrics.EfferentCoupling[type] = CountOutgoingDependencies(type);
            
            // Instability (I) = Ce / (Ca + Ce)
            var ca = metrics.AfferentCoupling[type];
            var ce = metrics.EfferentCoupling[type];
            metrics.Instability[type] = ca + ce == 0 ? 0 : (double)ce / (ca + ce);
        }
        
        return metrics;
    }
    
    private int CountIncomingDependencies(Type target, Type[] allTypes)
    {
        return allTypes.Count(type => 
            type != target && 
            type.GetDependencies().Contains(target));
    }
    
    private int CountOutgoingDependencies(Type type)
    {
        return type.GetDependencies().Count();
    }
}

// Обнаружение циклических зависимостей
public class CyclicDependencyDetector
{
    public List<string> DetectCycles(Assembly assembly)
    {
        var graph = BuildDependencyGraph(assembly);
        var cycles = new List<string>();
        var visited = new HashSet<string>();
        var recursionStack = new HashSet<string>();
        
        foreach (var node in graph.Keys)
        {
            if (!visited.Contains(node))
            {
                DetectCyclesDFS(node, graph, visited, recursionStack, cycles, new List<string>());
            }
        }
        
        return cycles;
    }
}
```

**Автоматизированное обнаружение проблем:**
```csharp
[Test]
public void Architecture_ShouldNotHave_CyclicDependencies()
{
    var assembly = typeof(OrderService).Assembly;
    var detector = new CyclicDependencyDetector();
    var cycles = detector.DetectCycles(assembly);
    
    Assert.IsEmpty(cycles, $"Found cyclic dependencies: {string.Join(", ", cycles)}");
}

[Test]
public void Classes_ShouldNotExceed_ComplexityThreshold()
{
    var assembly = typeof(OrderService).Assembly;
    var analyzer = new ComplexityAnalyzer();
    
    foreach (var type in assembly.GetTypes())
    {
        var complexity = analyzer.CalculateCyclomaticComplexity(type);
        Assert.LessOrEqual(complexity, 10, 
            $"Class {type.Name} has cyclomatic complexity {complexity}, should be <= 10");
    }
}
```

---

### 6.3 Стратегии рефакторинга

**Strangler Fig Pattern:**
```csharp
// Старая система
public class LegacyOrderProcessor
{
    public void ProcessOrder(LegacyOrder order)
    {
        // Старая логика с множеством проблем
        // 1000+ строк спагетти-кода
    }
}

// Новая система постепенно замещает старую
public interface IOrderProcessor
{
    Task ProcessOrderAsync(Order order);
}

public class ModernOrderProcessor : IOrderProcessor
{
    public async Task ProcessOrderAsync(Order order)
    {
        // Новая чистая архитектура
    }
}

// Прокси-класс для постепенного перехода
public class OrderProcessorFacade : IOrderProcessor
{
    private readonly LegacyOrderProcessor _legacyProcessor;
    private readonly ModernOrderProcessor _modernProcessor;
    private readonly IFeatureToggle _featureToggle;
    
    public async Task ProcessOrderAsync(Order order)
    {
        // Постепенный переход по feature flag или другим критериям
        if (_featureToggle.IsEnabled("UseModernProcessor") || 
            ShouldUseModernProcessor(order))
        {
            await _modernProcessor.ProcessOrderAsync(order);
        }
        else
        {
            var legacyOrder = ConvertToLegacyFormat(order);
            _legacyProcessor.ProcessOrder(legacyOrder);
        }
    }
    
    private bool ShouldUseModernProcessor(Order order)
    {
        // Критерии для использования новой системы
        return order.CustomerId > 1000 || // Новые клиенты
               order.Total.Amount < 100;   // Простые заказы
    }
}
```

**Incremental рефакторинг:**
```csharp
// Шаг 1: Выделение интерфейса из legacy кода
public interface IInventoryService
{
    bool IsAvailable(int productId, int quantity);
    void ReserveItems(int productId, int quantity);
}

// Шаг 2: Обертка вокруг legacy кода
public class LegacyInventoryServiceWrapper : IInventoryService
{
    private readonly LegacyInventorySystem _legacySystem;
    
    public bool IsAvailable(int productId, int quantity)
    {
        // Адаптация к legacy API
        var legacyProduct = _legacySystem.GetProductById(productId);
        return legacyProduct.StockLevel >= quantity;
    }
    
    public void ReserveItems(int productId, int quantity)
    {
        _legacySystem.UpdateStock(productId, -quantity);
    }
}

// Шаг 3: Постепенная замена на новую реализацию
public class ModernInventoryService : IInventoryService
{
    private readonly IInventoryRepository _repository;
    
    public async Task<bool> IsAvailableAsync(int productId, int quantity)
    {
        var inventory = await _repository.GetByProductIdAsync(productId);
        return inventory.AvailableQuantity >= quantity;
    }
    
    public async Task ReserveItemsAsync(int productId, int quantity)
    {
        var inventory = await _repository.GetByProductIdAsync(productId);
        inventory.ReserveQuantity(quantity);
        await _repository.SaveAsync(inventory);
    }
}

// Шаг 4: Переходной период с настраиваемым роутингом
public class HybridInventoryService : IInventoryService
{
    private readonly LegacyInventoryServiceWrapper _legacyService;
    private readonly ModernInventoryService _modernService;
    private readonly IConfiguration _config;
    
    public async Task<bool> IsAvailableAsync(int productId, int quantity)
    {
        var migrationThreshold = _config.GetValue<int>("InventoryMigrationThreshold");
        
        if (productId > migrationThreshold)
        {
            return await _modernService.IsAvailableAsync(productId, quantity);
        }
        else
        {
            return _legacyService.IsAvailable(productId, quantity);
        }
    }
}
```

**Branch by Abstraction:**
```csharp
// Абстракция для разных реализаций
public interface IPaymentGateway
{
    Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request);
}

// Старая реализация
public class OldPaymentGateway : IPaymentGateway
{
    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        // Старая логика
    }
}

// Новая реализация
public class NewPaymentGateway : IPaymentGateway
{
    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        // Новая улучшенная логика
    }
}

// Фабрика для выбора реализации
public class PaymentGatewayFactory
{
    public IPaymentGateway CreateGateway(string version)
    {
        return version switch
        {
            "v1" => new OldPaymentGateway(),
            "v2" => new NewPaymentGateway(),
            _ => throw new ArgumentException($"Unknown version: {version}")
        };
    }
}
```

---

### 6.4 Legacy код

**Characterization Tests:**
```csharp
// Документируем поведение legacy кода перед рефакторингом
[Test]
public void LegacyOrderCalculator_CharacterizationTest()
{
    var calculator = new LegacyOrderCalculator();
    
    // Тест текущего поведения (может быть странным, но это реальность)
    var result1 = calculator.CalculateTotal(100, 0.1m, "STANDARD");
    Assert.AreEqual(115.5m, result1); // Почему 115.5? Неясно, но так работает
    
    var result2 = calculator.CalculateTotal(0, 0.1m, "EXPRESS");
    Assert.AreEqual(5.0m, result2); // Минимальная комиссия?
    
    var result3 = calculator.CalculateTotal(-10, 0.1m, "STANDARD");
    Assert.AreEqual(0, result3); // Отрицательные суммы обнуляются
    
    // Эти тесты зафиксируют текущее поведение
    // Теперь можно безопасно рефакторить
}

// После понимания поведения создаем новую реализацию
public class ModernOrderCalculator
{
    private readonly Dictionary<string, decimal> _shippingRates = new()
    {
        ["STANDARD"] = 5.0m,
        ["EXPRESS"] = 15.0m
    };
    
    public decimal CalculateTotal(decimal baseAmount, decimal taxRate, string shippingType)
    {
        if (baseAmount < 0) baseAmount = 0; // Документированное поведение
        
        var tax = baseAmount * taxRate;
        var shipping = _shippingRates.GetValueOrDefault(shippingType, 5.0m);
        
        return baseAmount + tax + shipping;
    }
}
```

**Выделение доменной логики из legacy монолита:**
```csharp
// Legacy монолит
public class LegacyOrderSystem
{
    public void ProcessOrder(DataRow orderData)
    {
        // 500 строк смешанной логики:
        // - валидация данных
        // - бизнес-правила
        // - обращения к БД
        // - отправка email
        // - логирование
        // - вызовы внешних API
    }
}

// Шаг 1: Выделяем доменную логику
public class OrderDomainService
{
    public OrderValidationResult ValidateOrder(OrderData data)
    {
        // Чистая бизнес-логика без побочных эффектов
        var errors = new List<string>();
        
        if (data.Items.Count == 0)
            errors.Add("Order must contain at least one item");
        
        if (data.Total < 0)
            errors.Add("Order total cannot be negative");
        
        return new OrderValidationResult(errors);
    }
    
    public decimal CalculateShipping(OrderData data)
    {
        // Изолированная логика расчета доставки
        return data.Weight * 2.5m + (data.IsExpress ? 10m : 0m);
    }
}

// Шаг 2: Создаем адаптер для legacy системы
public class LegacyOrderAdapter
{
    private readonly LegacyOrderSystem _legacySystem;
    private readonly OrderDomainService _domainService;
    
    public void ProcessOrderWithDomainLogic(DataRow orderData)
    {
        // Преобразуем legacy данные в доменную модель
        var domainData = ConvertFromLegacyFormat(orderData);
        
        // Используем новую доменную логику
        var validation = _domainService.ValidateOrder(domainData);
        if (!validation.IsValid)
        {
            throw new ValidationException(validation.Errors);
        }
        
        var shipping = _domainService.CalculateShipping(domainData);
        
        // Обновляем legacy данные результатами
        orderData["ShippingCost"] = shipping;
        
        // Вызываем legacy систему для остальной обработки
        _legacySystem.ProcessOrder(orderData);
    }
}
```

**Безопасный рефакторинг с минимальным риском:**
```csharp
// Принцип: одно изменение за раз
public class SafeRefactoringExample
{
    // Было: все в одном методе
    public void ProcessOrder_Before(int orderId)
    {
        var order = GetOrderFromDatabase(orderId);
        
        if (order.Status != "PENDING")
            throw new InvalidOperationException("Order is not pending");
        
        var total = 0m;
        foreach (var item in order.Items)
        {
            total += item.Quantity * item.Price;
        }
        
        if (total < 10)
            throw new InvalidOperationException("Minimum order is $10");
        
        order.Status = "PROCESSING";
        SaveOrderToDatabase(order);
        SendEmailNotification(order.CustomerEmail, "Order is being processed");
    }
    
    // Шаг 1: Выделение валидации (Extract Method)
    public void ProcessOrder_Step1(int orderId)
    {
        var order = GetOrderFromDatabase(orderId);
        
        ValidateOrderForProcessing(order); // Извлекли метод
        
        var total = CalculateOrderTotal(order); // Извлекли метод
        
        if (total < 10)
            throw new InvalidOperationException("Minimum order is $10");
        
        order.Status = "PROCESSING";
        SaveOrderToDatabase(order);
        SendEmailNotification(order.CustomerEmail, "Order is being processed");
    }
    
    // Шаг 2: Выделение в отдельный класс (Extract Class)
    public void ProcessOrder_Step2(int orderId)
    {
        var order = GetOrderFromDatabase(orderId);
        
        var validator = new OrderValidator();
        validator.ValidateForProcessing(order);
        
        var calculator = new OrderCalculator();
        var total = calculator.CalculateTotal(order);
        
        if (total < 10)
            throw new InvalidOperationException("Minimum order is $10");
        
        order.Status = "PROCESSING";
        SaveOrderToDatabase(order);
        SendEmailNotification(order.CustomerEmail, "Order is being processed");
    }
    
    // Шаг 3: Внедрение зависимостей (Dependency Injection)
    private readonly IOrderValidator _validator;
    private readonly IOrderCalculator _calculator;
    private readonly IOrderRepository _repository;
    private readonly IEmailService _emailService;
    
    public void ProcessOrder_Final(int orderId)
    {
        var order = await _repository.GetByIdAsync(orderId);
        
        _validator.ValidateForProcessing(order);
        
        var total = _calculator.CalculateTotal(order);
        if (total < 10)
            throw new InvalidOperationException("Minimum order is $10");
        
        order.Status = "PROCESSING";
        await _repository.SaveAsync(order);
        await _emailService.SendAsync(order.CustomerEmail, "Order is being processed");
    }
}
```

---

### 6.5 Performance и архитектура

**Влияние архитектурных абстракций на производительность:**
```csharp
// Измерение накладных расходов DI
[Benchmark]
public class DIPerformanceBenchmark
{
    private readonly IServiceProvider _serviceProvider;
    private readonly OrderService _directInstance;
    
    [Benchmark(Baseline = true)]
    public void DirectInstantiation()
    {
        var repository = new OrderRepository();
        var emailSender = new EmailSender();
        var service = new OrderService(repository, emailSender);
        service.ProcessOrder(123);
    }
    
    [Benchmark]
    public void DIContainer()
    {
        var service = _serviceProvider.GetService<IOrderService>();
        service.ProcessOrder(123);
    }
    
    [Benchmark]
    public void SingletonFromDI()
    {
        // Singleton должен быть быстрее
        var service = _serviceProvider.GetService<ISingletonOrderService>();
        service.ProcessOrder(123);
    }
}

// Результаты показывают накладные расходы < 1% для большинства случаев
```

**Оптимизация без нарушения принципов:**
```csharp
// Кэширование на уровне Use Case
public class GetOrderUseCase
{
    private readonly IOrderRepository _repository;
    private readonly IMemoryCache _cache;
    
    public async Task<OrderDto> ExecuteAsync(int orderId)
    {
        var cacheKey = $"order_{orderId}";
        
        if (_cache.TryGetValue(cacheKey, out OrderDto cachedOrder))
        {
            return cachedOrder;
        }
        
        var order = await _repository.GetByIdAsync(orderId);
        var dto = MapToDto(order);
        
        _cache.Set(cacheKey, dto, TimeSpan.FromMinutes(5));
        return dto;
    }
}

// Batch операции для снижения накладных расходов
public class BatchOrderProcessor
{
    private readonly IOrderRepository _repository;
    
    public async Task ProcessOrdersBatchAsync(IEnumerable<int> orderIds)
    {
        // Получаем все заказы одним запросом
        var orders = await _repository.GetByIdsAsync(orderIds);
        
        // Группируем операции
        var ordersToUpdate = new List<Order>();
        var emailsToSend = new List<EmailMessage>();
        
        foreach (var order in orders)
        {
            // Доменная логика остается чистой
            order.Process();
            ordersToUpdate.Add(order);
            
            emailsToSend.Add(new EmailMessage(
                order.CustomerEmail, 
                "Order processed"));
        }
        
        // Batch операции для производительности
        await _repository.SaveManyAsync(ordersToUpdate);
        await _emailService.SendBatchAsync(emailsToSend);
    }
}
```

**Когда можно пожертвовать принципами:**
```csharp
// Критический путь с высокой нагрузкой
public class HighPerformanceOrderCalculator
{
    // Нарушаем DIP для производительности в критическом месте
    private readonly SqlConnection _directConnection; // Прямое подключение к БД
    
    public async Task<decimal> CalculatePriceAsync(int productId, int quantity)
    {
        // Прямой SQL запрос вместо Repository для скорости
        const string sql = "SELECT Price FROM Products WHERE Id = @id";
        using var command = new SqlCommand(sql, _directConnection);
        command.Parameters.AddWithValue("@id", productId);
        
        var price = (decimal)await command.ExecuteScalarAsync();
        return price * quantity;
    }
}

// ВАЖНО: Документируем компромисс
// TODO: Рефакторинг когда производительность перестанет быть критичной
// Измеренное улучшение: с 50ms до 5ms на запрос
// Альтернатива: кэширование в Repository слое
```

**Мониторинг производительности архитектуры:**
```csharp
public class PerformanceMonitoringDecorator<T> : IOrderService
{
    private readonly IOrderService _orderService;
    private readonly IMetrics _metrics;
    
    public async Task<int> CreateOrderAsync(CreateOrderRequest request)
    {
        using var timer = _metrics.Measure.Timer.Time("order_creation");
        
        try
        {
            var result = await _orderService.CreateOrderAsync(request);
            _metrics.Measure.Counter.Increment("orders_created_success");
            return result;
        }
        catch (Exception)
        {
            _metrics.Measure.Counter.Increment("orders_created_failure");
            throw;
        }
    }
}

// Автоматическое обнаружение проблем производительности
public class PerformanceAnalyzer
{
    public void AnalyzeMethodPerformance(Type serviceType)
    {
        foreach (var method in serviceType.GetMethods())
        {
            var complexity = CalculateComplexity(method);
            var dependencies = CountDependencies(method);
            
            if (complexity > 10 && dependencies > 5)
            {
                Console.WriteLine($"Warning: Method {method.Name} has high complexity " +
                                $"({complexity}) and many dependencies ({dependencies})");
            }
        }
    }
}
```

---

## Заключение

### Ключевые принципы успешного применения

1. **Прагматичность над догматизмом**
   - Принципы - это инструменты, а не законы
   - Контекст определяет выбор архитектурных решений
   - Измеряйте влияние архитектурных решений

2. **Эволюционная архитектура**
   - Начинайте просто, усложняйте по необходимости
   - Рефакторинг - это постоянный процесс
   - Тестирование обеспечивает безопасность изменений

3. **Баланс между качеством и скоростью**
   - Не все код должен быть идеальным с первого раза
   - Техничсекий долг - инструмент, а не проблема
   - Инвестируйте в архитектуру там, где это критично

4. **Непрерывное обучение**
   - Архитектурные решения должны документироваться
   - Ретроспективы помогают улучшать архитектурные практики
   - Делитесь знаниями в команде

### Практические рекомендации

- **Начинайте с модульной архитектуры**, даже если не используете полноценную Clean Architecture
- **Инвестируйте в автоматизированное тестирование** - это основа для безопасного рефакторинга
- **Используйте архитектурные тесты** для контроля соблюдения принципов
- **Мониторьте техническую задолженность** и планируйте время на ее устранение
- **Документируйте архитектурные решения** и их обоснования

Помните: хорошая архитектура - это не та, которая соблюдает все принципы, а та, которая решает бизнес-задачи с приемлемыми затратами на разработку и поддержку.