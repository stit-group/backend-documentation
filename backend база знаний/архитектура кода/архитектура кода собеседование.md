# Компактное техническое интервью: Чистая архитектура и практики проектирования

## Описание
Сфокусированное интервью для оценки знаний backend разработчика в области архитектуры, SOLID принципов и современных практик проектирования.

**Структура:** 30 основных вопросов + 90 углубляющих вопросов (3 к каждому основному)  
**Время проведения:** 1-1.5 часа  
**Уровень:** Middle/Senior Backend Developer

---

## 1. SOLID Принципы (6 вопросов)

### 1.1 Single Responsibility Principle
**Основной вопрос:** Объясните SRP и покажите на примере класс, который его нарушает.

**Углубляющие вопросы:**
1. Как SRP влияет на тестируемость кода?
2. Может ли класс иметь несколько методов и соответствовать SRP?
3. В каких случаях нарушение SRP оправданно?

### 1.2 Open/Closed Principle
**Основной вопрос:** Как Strategy pattern помогает соблюдать OCP? Приведите пример.

**Углубляющие вопросы:**
1. Что такое "точки расширения" в архитектуре?
2. Как plugin-архитектура реализует OCP?
3. Может ли чрезмерное следование OCP навредить простоте?

### 1.3 Liskov Substitution Principle
**Основной вопрос:** Объясните LSP на классическом примере с прямоугольником и квадратом.

**Углубляющие вопросы:**
1. Что такое "поведенческая совместимость"?
2. Как LSP связан с контрактным программированием?
3. Какие проблемы создает нарушение LSP в runtime?

### 1.4 Interface Segregation Principle
**Основной вопрос:** Покажите рефакторинг "толстого" интерфейса согласно ISP.

**Углубляющие вопросы:**
1. Что такое "interface pollution"?
2. Как ISP связан с cohesion и coupling?
3. Применим ли ISP к REST API дизайну?

### 1.5 Dependency Inversion Principle
**Основной вопрос:** В чем разница между DIP и Dependency Injection? Покажите на коде.

**Углубляющие вопросы:**
1. Как DIP влияет на архитектуру слоев приложения?
2. Как DIP помогает в юнит-тестировании?
3. Какие антипаттерны возникают при неправильном применении DIP?

### 1.6 SOLID в комплексе
**Основной вопрос:** Приведите пример совместного применения нескольких SOLID принципов.

**Углубляющие вопросы:**
1. Могут ли SOLID принципы противоречить друг другу?
2. Как балансировать между SOLID и производительностью?
3. Какие метрики помогают оценить соблюдение SOLID?

---

## 2. Clean Architecture (5 вопросов)

### 2.1 Основы и слои
**Основной вопрос:** Объясните концепцию Clean Architecture и назначение каждого слоя.

**Углубляющие вопросы:**
1. В чем разница между Clean Architecture и Layered Architecture?
2. Почему доменный слой должен быть в центре?
3. Где размещать валидацию данных?

### 2.2 Dependency Rule
**Основной вопрос:** Объясните правило зависимостей. Как передавать данные между слоями?

**Углубляющие вопросы:**
1. Что происходит при нарушении Dependency Rule?
2. Как обрабатывать исключения из внешних слоев?
3. Какие инструменты помогают контролировать зависимости?

### 2.3 Entities и Use Cases
**Основной вопрос:** В чем разница между entities и use cases? Как определить их границы?

**Углубляющие вопросы:**
1. Должны ли entities содержать бизнес-логику?
2. Могут ли use cases вызывать другие use cases?
3. Как тестировать entities и use cases изолированно?

### 2.4 Ports & Adapters
**Основной вопрос:** Как реализовать паттерн Ports & Adapters в Clean Architecture?

**Углубляющие вопросы:**
1. В чем разница между primary и secondary adapters?
2. Что такое anti-corruption layer?
3. Как тестировать адаптеры?

### 2.5 Clean Architecture и базы данных
**Основной вопрос:** Где размещать Repository и ORM в Clean Architecture?

**Углубляющие вопросы:**
1. Должны ли entities знать о схеме БД?
2. Где выполнять mapping между доменными объектами и DTO?
3. Как обрабатывать транзакции в архитектуре?

---

## 3. Dependency Injection и IoC (4 вопроса)

### 3.1 Основы DI
**Основной вопрос:** Объясните DI и разницу между constructor, setter и interface injection.

**Углубляющие вопросы:**
1. В чем разница между DI и Service Locator?
2. Что такое Inversion of Control?
3. Можно ли использовать DI без контейнера?

### 3.2 Жизненные циклы
**Основной вопрос:** Объясните Singleton, Transient и Scoped lifetimes.

**Углубляющие вопросы:**
1. Как Scoped lifetime работает в веб-приложениях?
2. Что такое Captive Dependencies?
3. Как обрабатывать disposable зависимости?

### 3.3 Антипаттерны DI
**Основной вопрос:** Какие основные антипаттерны DI и как их избежать?

**Углубляющие вопросы:**
1. Что такое Constructor Over-injection?
2. Почему опасно использовать контейнер в бизнес-логике?
3. Как избежать скрытых зависимостей?

### 3.4 DI и тестирование
**Основной вопрос:** Как DI упрощает unit тестирование?

**Углубляющие вопросы:**
1. Нужен ли отдельный контейнер для тестов?
2. Как мокировать зависимости в DI?
3. Что такое test doubles и как их регистрировать?

---

## 4. Ключевые паттерны проектирования (6 вопросов)

### 4.1 Repository Pattern
**Основной вопрос:** Как правильно реализовать Repository pattern?

**Углубляющие вопросы:**
1. Generic repository или специфичные репозитории?
2. Стоит ли Repository возвращать IQueryable?
3. Как интегрировать Repository с ORM?

### 4.2 Unit of Work
**Основной вопрос:** Что такое Unit of Work и как он решает проблемы транзакционности?

**Углубляющие вопросы:**
1. Как UoW интегрируется с Repository?
2. Как обрабатывать nested Unit of Work?
3. Что происходит при откате транзакции?

### 4.3 Strategy Pattern
**Основной вопрос:** Как Strategy pattern поддерживает принцип Open/Closed?

**Углубляющие вопросы:**
1. Как выбирать стратегию во runtime?
2. В чем разница между Strategy и State patterns?
3. Как Strategy работает с функциональным программированием?

### 4.4 Decorator Pattern
**Основной вопрос:** Когда Decorator предпочтительнее наследования?

**Углубляющие вопросы:**
1. Как избежать explosion декораторов?
2. Как Decorator работает с DI?
3. Как тестировать цепочки декораторов?

### 4.5 Command Pattern и CQRS
**Основной вопрос:** Как Command pattern эволюционировал в CQRS?

**Углубляющие вопросы:**
1. В чем разница между Command pattern и CQRS?
2. Что такое Command Handler?
3. Когда CQRS избыточен?

### 4.6 Factory Patterns
**Основной вопрос:** Когда использовать Factory Method vs Abstract Factory vs Builder?

**Углубляющие вопросы:**
1. Как совместить Factory с Dependency Injection?
2. Что такое fluent builder?
3. Как создавать объекты с runtime параметрами через DI?

---

## 5. Domain-Driven Design (4 вопроса)

### 5.1 Основы DDD
**Основной вопрос:** В чем разница между анемичной и богатой доменной моделью?

**Углубляющие вопросы:**
1. Что такое ubiquitous language?
2. Подходит ли DDD для всех приложений?
3. Как DDD соотносится с Clean Architecture?

### 5.2 Entities vs Value Objects
**Основной вопрос:** Как принимать решение между Entity и Value Object?

**Углубляющие вопросы:**
1. Может ли Value Object содержать поведение?
2. Как обеспечить immutability Value Objects?
3. Должны ли Value Objects знать о persistence?

### 5.3 Aggregates
**Основной вопрос:** Как определить корень агрегата и его границы?

**Углубляющие вопросы:**
1. Может ли агрегат ссылаться на другие агрегаты по ID?
2. Что такое invariants и как их поддерживать?
3. Как размер агрегата влияет на производительность?

### 5.4 Domain Events
**Основной вопрос:** Как правильно проектировать и обрабатывать Domain Events?

**Углубляющие вопросы:**
1. Когда генерировать события: при изменении или сохранении?
2. В чем разница между Domain и Integration Events?
3. Как обеспечить consistency при обработке событий?

---

## 6. Практические аспекты (5 вопросов)

### 6.1 Тестирование архитектуры
**Основной вопрос:** Как организовать тестирование в многослойной архитектуре?

**Углубляющие вопросы:**
1. Что тестировать на unit, а что на integration уровне?
2. Что такое architecture tests?
3. Как тестировать Use Cases без внешних зависимостей?

### 6.2 Выявление технического долга
**Основной вопрос:** Как выявлять архитектурный технический долг?

**Углубляющие вопросы:**
1. Что такое architectural smells?
2. Какие метрики помогают измерить архитектурный долг?
3. Как приоритизировать рефакторинг?

### 6.3 Стратегии рефакторинга
**Основной вопрос:** Какие стратегии рефакторинга архитектуры существуют?

**Углубляющие вопросы:**
1. Что такое Strangler Fig pattern?
2. В чем разница между Big Bang и incremental рефакторингом?
3. Как рефакторить с минимальным риском?

### 6.4 Legacy код
**Основной вопрос:** Как работать с legacy кодом, нарушающим архитектурные принципы?

**Углубляющие вопросы:**
1. Что такое characterization tests?
2. Как выделить доменную логику из legacy монолита?
3. Стоит ли переписывать legacy систему с нуля?

### 6.5 Performance и архитектура
**Основной вопрос:** Как балансировать между чистотой архитектуры и производительностью?

**Углубляющие вопросы:**
1. Создают ли архитектурные абстракции критичные накладные расходы?
2. Когда стоит пожертвовать принципами ради производительности?
3. Как измерить влияние архитектурных решений на performance?

---

## Критерии оценки

### Распределение по уровням:

**Middle (50-70% правильных ответов):**
- Понимание основ SOLID и Clean Architecture
- Знание ключевых паттернов проектирования
- Способность применять DI
- Базовое понимание DDD

**Senior (70-85% правильных ответов):**
- Глубокое понимание всех концепций
- Знание trade-offs и альтернатив
- Опыт рефакторинга и работы с legacy
- Понимание тестирования архитектуры

**Lead/Архитектор (85%+ правильных ответов):**
- Экспертное знание всех тем
- Способность адаптировать принципы под задачи
- Системное понимание архитектурных решений
- Опыт принятия архитектурных решений

---

## Рекомендации по проведению

1. **Выберите 12-15 основных вопросов** в зависимости от уровня позиции
2. **Начните с основ** (SOLID) и переходите к сложным темам
3. **Просите примеры** из реального опыта кандидата
4. **Оценивайте объяснения** - способность упростить сложное
5. **Обращайте внимание на trade-offs** - понимание компромиссов
6. **Проверяйте практический опыт** - не только теорию

## Ключевые индикаторы качества ответов

✅ **Хорошие признаки:**
- Приводит конкретные примеры из опыта
- Объясняет когда принципы НЕ стоит применять
- Понимает trade-offs и альтернативы
- Может объяснить сложное простыми словами

❌ **Красные флаги:**
- Только теоретические знания без практики
- Догматичное следование принципам
- Неспособность объяснить "почему"
- Незнание альтернативных подходов