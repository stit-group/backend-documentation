# Архитектура Backend: От новичка до эксперта

---

## Введение: Почему архитектура важна?

> **История:** В 1968 году проект IBM OS/360 превратился в кошмар. Фредерик Брукс позже напишет "Мифический человеко-месяц", где опишет, как отсутствие архитектурного мышления привело к провалу проекта стоимостью $5 млрд.

### Что такое архитектура?

Архитектура — это **искусство принятия решений**, которые сложно изменить потом.

```
Плохая архитектура:        Хорошая архитектура:
    [Код] ←→ [База]           [API] ← [Logic] → [Data]
       ↕                         ↑       ↓
    [UI] ←→ [Auth]            [Auth]   [Cache]
```

**Ключевая идея:** Архитектура определяет, как легко добавлять новые фичи через год.

### Историческая эволюция подходов:

```
1960s: Monolithic Programs
[Input] → [BigProgram] → [Output]

1970s: Structured Programming  
[Input] → [Module1] → [Module2] → [Output]

1980s: Object-Oriented Design
[Objects] ←→ [Objects] ←→ [Objects]

1990s: Layered Architecture
[UI] → [Business] → [Data]

2000s: Service-Oriented Architecture
[Service1] ←→ [Service2] ←→ [Service3]

2010s+: Microservices & Event-Driven
[Service] → [Events] → [Service]
     ↓                    ↓
  [Queue]              [Queue]
```

### Архитектурные антипаттерны и их последствия:

```
Big Ball of Mud:
[Everything] ←→ [Everything]
Результат: Каждое изменение ломает что-то еще

God Object:
[GodClass]
├── doEverything()
├── handleAllLogic()
└── manageAllData()
Результат: Невозможно изменить без риска

Spaghetti Code:
[Class1] ←→ [Class2] ←→ [Class3]
   ↕          ↕          ↕
[Class4] ←→ [Class5] ←→ [Class6]
Результат: Никто не понимает зависимости
```

---

## Модуль 1: Фундаментальные принципы

### Глава 1.1: От хаоса к порядку

**Эволюция мышления разработчика:**

```
Стадия 1: "Главное — работает"
[Input] → [BigFunction] → [Output]

Стадия 2: "Надо разделить на функции"  
[Input] → [Func1] → [Func2] → [Output]

Стадия 3: "Архитектурное мышление"
[Input] → [Validation] → [Business] → [Storage] → [Output]
          ─────────────────────────────────────────
          Слои с четкой ответственностью
```

### Качественные атрибуты системы

> **Метафора:** Архитектура как фундамент дома. Можно поменять обои (UI), но нельзя легко перенести несущие стены (архитектуру).

**Функциональные требования vs Качественные атрибуты:**

```
Функциональные (что система делает):
- Регистрация пользователей
- Обработка платежей  
- Отправка уведомлений

Качественные (как система это делает):
- Performance: < 200ms response time
- Availability: 99.9% uptime
- Security: защита от SQL injection
- Scalability: 10,000 concurrent users
- Maintainability: новая фича за 2 дня
```

**The Big Six качественных атрибутов:**

```
Performance ←────────→ Resource Usage
    ↑                        ↑
    │      Trade-offs         │
    ↓                        ↓
Security ←────────→ Usability
    ↑                        ↑
    │                        │
    ↓                        ↓
Maintainability ←──→ Scalability
```

### Архитектурные компромиссы (Trade-offs)

```
Быстрая разработка ←────────→ Качественный код
      ↑                           ↑
   Монолит                   Микросервисы
      ↓                           ↓
 Простота деплоя ←────────→ Гибкость масштабирования

Consistency ←────────→ Availability
     ↑                      ↑
 ACID DB              Eventually Consistent
     ↓                      ↓
Strong Guarantees ←──→ High Performance
```

**Золотое правило:** Нет универсально "лучших" решений, есть подходящие для контекста.

### Принципы архитектурных решений:

> **История:** Дейкстра в 1972 сказал: "Простота — это предпосылка надежности". Этот принцип до сих пор актуален.

```
1. KISS (Keep It Simple, Stupid)
   Simple Solution ──→ Easy to understand ──→ Less bugs

2. YAGNI (You Aren't Gonna Need It)  
   Current Needs ──→ Simple Design ──→ Easy to extend

3. DRY (Don't Repeat Yourself)
   Single Source of Truth ──→ Centralized Changes ──→ Consistency

4. Principle of Least Surprise
   Expected Behavior ──→ Intuitive Design ──→ Maintainability
```

### Глава 1.2: SOLID на архитектурном уровне

> **История:** Роберт Мартин сформулировал SOLID принципы в 2000-х, но их корни уходят к работам Дэвида Парнаса 1970-х о модульности.

#### Single Responsibility Principle (SRP)

**Эволюция понимания SRP:**

```
Уровень 1 - Функции:
function processOrder() {
  validateOrder();
  calculateTotal();
  saveToDatabase();
  sendEmail();
}

Уровень 2 - Классы:
class OrderProcessor {
  process() { /* only processing */ }
}
class OrderValidator {
  validate() { /* only validation */ }
}

Уровень 3 - Модули:
[OrderModule] - только бизнес-логика заказов
[NotificationModule] - только уведомления  
[PaymentModule] - только платежи
```

**На уровне модулей:**
```
❌ Плохо - модуль с множественной ответственностью:
[UserModule]
├── validate() ── причина изменения: новые правила валидации
├── save() ──── причина изменения: смена БД
├── sendEmail() ── причина изменения: новый email провайдер
└── generateReport() ── причина изменения: новый формат отчета

✅ Хорошо - один модуль, одна ответственность:
[UserService] ────────→ [EmailService]
     ↓                        ↑
[ValidationService] ──→ [ReportService]
     ↓
[UserRepository]
```

**Практический принцип:** Один модуль = одна причина для изменений.

#### Open/Closed Principle (OCP)

**Эволюция расширяемости:**

```
Уровень 1 - Модификация существующего кода:
class PaymentProcessor {
  process(type, amount) {
    if (type === 'credit') { /* logic */ }
    if (type === 'paypal') { /* logic */ }
    // Добавление нового типа = модификация класса
  }
}

Уровень 2 - Расширение через наследование:
abstract class PaymentProcessor {
  abstract process(amount);
}

class CreditCardProcessor extends PaymentProcessor {
  process(amount) { /* implementation */ }
}

Уровень 3 - Архитектурный уровень:
[PaymentService] ──→ [IPaymentProvider]
                           ↑
                    ┌──────┼──────┐
                    │      │      │
           [CreditCard] [PayPal] [Stripe]
```

#### Liskov Substitution Principle (LSP)

**Архитектурные нарушения LSP:**

```
❌ Нарушение на архитектурном уровне:
interface Storage {
  save(data): void;
  delete(id): void;
}

class ReadOnlyStorage implements Storage {
  save(data) { throw new Error("Read-only!"); }
  delete(id) { throw new Error("Read-only!"); }
}

✅ Правильное разделение:
interface ReadableStorage {
  get(id): Data;
}

interface WritableStorage extends ReadableStorage {
  save(data): void;
  delete(id): void;
}
```

#### Interface Segregation Principle (ISP)

**От толстых интерфейсов к тонким:**

```
❌ Толстый интерфейс:
interface UserService {
  // Для аутентификации
  authenticate(credentials);
  
  // Для профиля  
  updateProfile(data);
  getProfile(id);
  
  // Для уведомлений
  sendNotification(message);
  getNotificationPrefs(id);
}

✅ Разделенные интерфейсы:
interface AuthService {
  authenticate(credentials);
}

interface ProfileService {  
  updateProfile(data);
  getProfile(id);
}

interface NotificationService {
  sendNotification(message);
  getNotificationPrefs(id);
}
```

#### Dependency Inversion Principle (DIP)

**Эволюция понимания зависимостей:**
```
Уровень 1 (новичок) - прямые зависимости:
[Controller] → [MySQLDatabase]

Уровень 2 (продвинутый) - через сервисы:
[Controller] → [Service] → [Repository] → [MySQLDatabase]

Уровень 3 (архитектор) - инверсия зависимостей:
[Controller] → [UseCase] → [IRepository] ← [Repository]
                              ↑              ↓
                         [Interface]    [MySQLDatabase]

Уровень 4 (enterprise) - полная инверсия:
[Domain] ← [Application] ← [Infrastructure]
   ↑           ↑               ↑
[Entities] [UseCases]    [DB, Web, etc.]
```

**Практический пример инверсии:**

```javascript
// ❌ Нарушение DIP
class OrderService {
  constructor() {
    this.db = new MySQLDatabase(); // прямая зависимость
    this.email = new SmtpEmail();  // прямая зависимость
  }
}

// ✅ Соблюдение DIP  
class OrderService {
  constructor(repository, notificationService) {
    this.repository = repository;           // зависимость на абстракцию
    this.notifications = notificationService; // зависимость на абстракцию
  }
}
```

### Глава 1.3: Связанность и сцепление

> **Метафора:** Хорошая архитектура как хорошо спроектированный город — районы независимы, но связаны понятными дорогами.

#### Типы coupling (связанности):

```
Content Coupling (самый плохой):
ModuleA читает/изменяет внутренние данные ModuleB
[ModuleA] ──→ [ModuleB.internalData]

Common Coupling:
Модули используют глобальные переменные
[ModuleA] ──→ [GlobalState] ←── [ModuleB]

Control Coupling:
ModuleA контролирует поведение ModuleB через флаги
[ModuleA] ──flag──→ [ModuleB]

Data Coupling (лучший):
Модули обмениваются только необходимыми данными
[ModuleA] ──data──→ [ModuleB]
```

#### Измеряем качество архитектуры:

```
Низкое сцепление (Low Coupling):
[ModuleA] ──interface──→ [ModuleB]

Высокое сцепление (High Coupling):
[ModuleA] ←──→ [ModuleB]
    ↕           ↕
[ModuleC] ←──→ [ModuleD]

Измерение coupling:
- Afferent Coupling (Ca): кто зависит от модуля
- Efferent Coupling (Ce): от кого зависит модуль
- Instability (I) = Ce / (Ca + Ce)
```

#### Типы cohesion (сцепленности):

```
Functional Cohesion (лучший):
Все элементы работают для одной задачи
[calculateTax] ├── getTaxRate()
               ├── applyExemptions()  
               └── computeFinalTax()

Sequential Cohesion:
Выход одного элемента = вход следующего
[processOrder] ├── validateOrder()
               ├── calculateTotal()
               └── saveOrder()

Coincidental Cohesion (худший):
Элементы просто собраны вместе
[utilities] ├── formatDate()
            ├── sendEmail()
            └── calculateTax()
```

#### Закон Деметера на архитектурном уровне:

```
❌ Нарушение:
service.getUser().getProfile().getSettings().update()

class OrderController {
  processOrder(orderId) {
    const order = this.orderService.getOrder(orderId);
    order.getCustomer().getPaymentMethod().charge(order.getTotal());
  }
}

✅ Соблюдение:
service.updateUserSettings(userId, settings)

class OrderController {
  processOrder(orderId) {
    this.orderService.processPayment(orderId);
  }
}
```

### Глава 1.4: Архитектурные принципы высокого уровня

#### Принцип единственной абстракции:

```
❌ Смешение уровней абстракции:
class OrderService {
  processOrder(orderData) {
    // Высокий уровень
    if (!this.isValidOrder(orderData)) return false;
    
    // Низкий уровень  
    const sql = "INSERT INTO orders (data) VALUES (?)";
    this.db.execute(sql, [orderData]);
    
    // Средний уровень
    this.emailService.sendConfirmation(orderData.email);
  }
}

✅ Единый уровень абстракции:
class OrderService {
  processOrder(orderData) {
    this.validateOrder(orderData);
    this.saveOrder(orderData);  
    this.sendConfirmation(orderData);
  }
}
```

#### Принцип стабильных зависимостей:

```
Зависимости должны указывать в сторону стабильности:

Unstable ──→ Stable
[WebController] ──→ [BusinessLogic] ──→ [CoreEntities]
     ↑                   ↑                    ↑
  Часто меняется    Редко меняется      Очень стабильно

Антипаттерн:
[CoreEntity] ──→ [WebFramework]
  (стабильное зависит от нестабильного)
```

#### Принцип абстрактности и стабильности:

```
                   Абстрактность
                        ↑
                        │
Зона боли          Main Sequence      Зона полезности
(Abstract &        (оптимальная       (Concrete & 
 Unstable)          зона)              Stable)
    │                   │                   │
    └───────────────────┼───────────────────┘
                        │
                 Зона бесполезности
                (Abstract & Stable, но не используется)
```

---

## Модуль 2: Слоистая архитектура

### Глава 2.1: История слоев

> **История:** Концепция слоев пришла из сетевых протоколов (OSI Model, 1984). Каждый слой решает свои задачи и предоставляет сервисы верхнему слою.

#### Эволюция от спагетти к слоям:

```
1960s - Mainframe, один большой процесс:
[Input] ──→ [Processing] ──→ [Output]

1970s - Структурное программирование:
[Input] ──→ [Module1] ──→ [Module2] ──→ [Output]

1980s - Клиент-сервер:
[Client] ←──→ [Server]
             ├── Logic
             └── Database

1990s - Трехслойная архитектура:
[Presentation]
     ↓
[Business Logic]  
     ↓
[Data Access]

2000s - N-tier архитектура:
[UI] ──→ [Web Server] ──→ [App Server] ──→ [DB Server]

2010s+ - Современный подход:
[API Layer]
     ↓
[Application Layer]
     ↓  
[Domain Layer]
     ↓
[Infrastructure Layer]
```

### Классическая трехслойная архитектура:

```
┌─────────────────────────────────┐
│        Presentation Layer       │ ← HTTP, JSON, валидация запросов
├─────────────────────────────────┤
│        Business Logic Layer     │ ← Бизнес-правила, вычисления
├─────────────────────────────────┤  
│        Data Access Layer        │ ← SQL, ORM, кэширование
└─────────────────────────────────┘

Правило: Слой может обращаться только к слою ниже
```

### Проблемы классических слоев:

```
Проблема 1 - Transitive Dependencies:
[UI] ──→ [Business] ──→ [Data]
          │
          └──→ [Database Schema]
Изменение схемы БД влияет на UI!

Проблема 2 - Anemic Domain Model:
[Business Layer]
├── getUser() { return dataLayer.getUser(); }
├── saveUser() { dataLayer.saveUser(user); }
└── deleteUser() { dataLayer.deleteUser(id); }
(Слой становится простой прослойкой)

Проблема 3 - Tight Coupling:
Business Layer знает о деталях Data Layer
```

### Правило зависимостей в слоях:

```
Допустимо:           Недопустимо:
[Layer 1]           [Layer 1] ←──┐
    ↓                   ↓        │
[Layer 2]           [Layer 2] ──→┘
    ↓                   ↓
[Layer 3]           [Layer 3]

Bypass тоже недопустим:
[Layer 1] ──────┐
    ↓           ↓
[Layer 2]   [Layer 3]
```

### Глава 2.2: Clean Architecture

> **История:** Роберт Мартин представил Clean Architecture в 2012, объединив идеи Hexagonal Architecture (Alistair Cockburn, 2005) и Onion Architecture (Jeffrey Palermo, 2008).

#### Проблемы традиционной архитектуры:

```
Традиционная архитектура:
[UI] ──→ [Business] ──→ [Database]

Проблемы:
1. Business Logic зависит от Database
2. Сложно тестировать без БД
3. Сложно поменять БД
4. Бизнес-логика "размазана" по слоям
```

#### Концентрические круги зависимостей:

```
        ┌─────────────────────────────────────┐
        │     Frameworks & Drivers (Blue)    │ ← Web, DB, External APIs
        │  ┌─────────────────────────────────┐ │
        │  │  Interface Adapters (Green)     │ │ ← Controllers, Presenters
        │  │ ┌─────────────────────────────┐ │ │
        │  │ │     Use Cases (Red)         │ │ │ ← Application Business Rules
        │  │ │ ┌─────────────────────────┐ │ │ │
        │  │ │ │    Entities (Yellow)    │ │ │ │ ← Enterprise Business Rules
        │  │ │ └─────────────────────────┘ │ │ │
        │  │ └─────────────────────────────┘ │ │
        │  └─────────────────────────────────┘ │
        └─────────────────────────────────────┘
        
Зависимости направлены ВНУТРЬ - к бизнес-логике
```

#### Детальная структура Clean Architecture:

```
Entities (Центр):
├── User { id, email, rules }
├── Order { items, total, validate() }
└── Product { price, availability }

Use Cases (Приложение):
├── RegisterUser
├── ProcessOrder  
├── UpdateInventory
└── GenerateReport

Interface Adapters:
├── Controllers (HTTP → Use Cases)
├── Presenters (Use Cases → JSON)
├── Repositories (Use Cases → Data)
└── Gateways (Use Cases → External)

Frameworks & Drivers:
├── Web Framework (Express, FastAPI)
├── Database (PostgreSQL, MongoDB)
├── External APIs (Payment, Email)
└── UI (React, Mobile App)
```

#### Практический пример:

```javascript
// ❌ Традиционный подход
class UserController {
  async createUser(req, res) {
    const db = new MySQLDatabase();
    const user = await db.users.insert(req.body);
    res.json(user);
  }
}

// ✅ Clean Architecture  
class UserController {
  constructor(createUserUseCase) {
    this.createUser = createUserUseCase;
  }
  
  async create(req, res) {
    try {
      const userData = req.body;
      const user = await this.createUser.execute(userData);
      res.json({ success: true, user });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
}

class CreateUserUseCase {
  constructor(userRepository, emailService) {
    this.users = userRepository;
    this.email = emailService;
  }
  
  async execute(userData) {
    const user = new User(userData);
    user.validate();
    
    const savedUser = await this.users.save(user);
    await this.email.sendWelcome(savedUser.email);
    
    return savedUser;
  }
}
```

### Dependency Rule в действии:

```
Source Code Dependencies vs Control Flow:

Control Flow:
[Controller] ──calls──→ [UseCase] ──calls──→ [Repository]

Source Code Dependencies:
[Controller] ──imports──→ [UseCase] ──imports──→ [IRepository]
                                                    ↑
                                           [Repository] implements
                                                    
Зависимости указывают ВНУТРЬ, независимо от направления вызовов
```

### Глава 2.3: Hexagonal Architecture (Ports & Adapters)

> **Метафора:** Приложение как крепость с воротами (ports). Внешний мир общается через ворота, но не знает, что происходит внутри.

#### История возникновения:

> **Предыстория:** Алистер Коберн в 2005 году устал от проблем традиционной слоистой архитектуры, где бизнес-логика зависела от UI и БД.

```
Проблема традиционной архитектуры:
[UI] ──→ [Application] ──→ [Database]
         │
         └──→ [External APIs]

Если меняется БД или внешний API, ломается приложение!
```

#### Hexagonal (шестиугольная) структура:

```
                External World
                      │
              ┌───────▼───────┐
              │    Adapter    │ ← HTTP Controller
              └───────┬───────┘
                      │ Port (Interface)
              ┌───────▼───────┐
              │               │
         ┌────┤  Application  ├────┐
         │    │     Core      │    │
         │    │               │    │
         │    └───────┬───────┘    │
         │            │ Port       │
   ┌─────▼─────┐ ┌───▼───┐  ┌─────▼─────┐
   │  Database │ │  API  │  │   Email   │
   │  Adapter  │ │Adapter│  │  Adapter  │
   └───────────┘ └───────┘  └───────────┘
```

#### Ports vs Adapters:

```
Port (Интерфейс):
interface UserRepository {
  save(user: User): Promise<User>;
  findById(id: string): Promise<User>;
  findByEmail(email: string): Promise<User>;
}

Adapter (Реализация):
class MySQLUserRepository implements UserRepository {
  async save(user: User): Promise<User> {
    // MySQL-специфичная логика
  }
  
  async findById(id: string): Promise<User> {
    // MySQL-специфичная логика  
  }
}

class MongoUserRepository implements UserRepository {
  async save(user: User): Promise<User> {
    // MongoDB-специфичная логика
  }
}
```

#### Типы портов:

```
Primary Ports (Driving/Inbound):
Приложение предоставляет сервисы внешнему миру
[External] ──→ [Port] ──→ [Application]
Примеры: HTTP API, GraphQL, CLI

Secondary Ports (Driven/Outbound):  
Приложение использует внешние сервисы
[Application] ──→ [Port] ──→ [External]
Примеры: Database, Email, Payment API
```

**Ключевые преимущества:**
- Бизнес-логика не зависит от внешних систем
- Легко тестировать (mock'и для адаптеров)
- Гибкость в выборе технологий
- Изоляция от изменений внешних систем

#### Практический пример тестирования:

```javascript
// Тестирование без внешних зависимостей
class MockUserRepository {
  constructor() {
    this.users = new Map();
  }
  
  async save(user) {
    this.users.set(user.id, user);
    return user;
  }
  
  async findByEmail(email) {
    return Array.from(this.users.values())
      .find(user => user.email === email);
  }
}

// Тест Use Case без реальной БД
test('should create user successfully', async () => {
  const mockRepo = new MockUserRepository();
  const useCase = new CreateUserUseCase(mockRepo);
  
  const user = await useCase.execute({
    email: 'test@example.com',
    name: 'Test User'
  });
  
  expect(user.email).toBe('test@example.com');
});
```

### Глава 2.4: Onion Architecture

> **История:** Джеффри Палермо представил Onion Architecture в 2008 как попытку решить проблемы N-tier архитектуры.

#### Слои луковицы:

```
       ┌─────────────────────────┐
       │    Infrastructure       │ ← Frameworks, DB, External APIs
       │ ┌─────────────────────┐ │
       │ │  Application Core   │ │ ← Services, Use Cases
       │ │ ┌─────────────────┐ │ │
       │ │ │ Domain Services │ │ │ ← Domain Logic
       │ │ │ ┌─────────────┐ │ │ │
       │ │ │ │   Domain    │ │ │ │ ← Entities, Value Objects
       │ │ │ │   Model     │ │ │ │
       │ │ │ └─────────────┘ │ │ │
       │ │ └─────────────────┘ │ │
       │ └─────────────────────┘ │
       └─────────────────────────┘

Зависимости направлены К ЦЕНТРУ
```

#### Отличия от традиционной архитектуры:

```
Traditional N-Tier:
[UI] → [Business] → [Data] → [Database]
    (зависимости направлены "вниз")

Onion Architecture:
[Infrastructure] → [Application] → [Domain] ← [Services]
    (все зависимости направлены к домену)
```

---

## Модуль 3: Domain-Driven Design

### Глава 3.1: Философия DDD

> **История:** Эрик Эванс ввел DDD в 2003 году, заметив, что технические решения часто не отражают бизнес-реальность. Он работал консультантом и видел, как проекты проваливались из-за разрыва между бизнесом и кодом.

#### Проблема традиционного подхода:

```
Как думают разработчики:
[User] ─ has ─→ [Order] ─ contains ─→ [Product]
  │                │                     │
  ├─ id            ├─ id                 ├─ id  
  ├─ name          ├─ userId             ├─ name
  ├─ email         ├─ productIds         ├─ price
  └─ createdAt     └─ total              └─ stock

Как думает бизнес:
[Customer] ─ places ─→ [Order] ─ for ─→ [Product]
     │                   │                 │
     ├─ creditRating     ├─ orderDate      ├─ availability
     ├─ purchaseHistory  ├─ deliveryDate   ├─ category
     ├─ preferences      ├─ status         ├─ supplier
     └─ loyaltyLevel     └─ paymentStatus  └─ seasonality
```

#### От технического к доменному мышлению:

```
Technical Model:            Domain Model:
[UserTable]                [Customer] 
├── user_id                ├── customerId
├── first_name             ├── fullName  
├── last_name              ├── contactInfo
├── email                  ├── creditRating
├── phone                  ├── purchaseHistory
├── created_at             ├── loyaltyStatus
└── updated_at             └── preferences
                          
[OrderTable]               [Order]
├── order_id               ├── orderNumber
├── user_id                ├── orderDate
├── total_amount           ├── lineItems[]
├── order_date             ├── deliveryAddress
├── status                 ├── billingAddress
└── created_at             └── orderStatus

Техническая модель отвечает на "как хранить"
Доменная модель отвечает на "что означает"
```

### Стратегические паттерны DDD:

#### Ubiquitous Language (Единый язык):

```
❌ Технический жаргон:
"Когда user создает order с items, мы валидируем inventory 
и обновляем stock, затем создаем payment record"

✅ Доменный язык:
"Когда Customer размещает Order с товарами, мы проверяем 
Availability и резервируем Products, затем инициируем Payment"

Код отражает доменный язык:
class Customer {
  placeOrder(orderItems) { /* */ }
}

class Product {
  checkAvailability() { /* */ }
  reserve(quantity) { /* */ }
}
```

#### Bounded Context (Ограниченный контекст):

> **Метафора:** Как в разных отделах компании слово "клиент" может означать разное — в продажах это потенциальный покупатель, в поддержке — человек с проблемой.

```
Sales Context:              Support Context:
[Lead]                     [Ticket]
├── contactInfo            ├── issueDescription  
├── interests              ├── priority
├── probability            ├── category
└── assignedSalesman       └── assignedAgent
     ↓                           ↓
[Customer]                 [Customer]  
├── purchaseHistory        ├── supportHistory
├── creditLimit            ├── satisfactionRating
├── preferredPayment       ├── preferredContact
└── salesRepresentative    └── supportTier

Один Customer - разные модели в разных контекстах!
```

#### Context Map (Карта контекстов):

```
┌─────────────┐    Shared Kernel    ┌─────────────┐
│   Sales     │←─────────────────→│  Marketing  │
│  Context    │                    │   Context   │
└─────────────┘                    └─────────────┘
      ↓                                    ↓
 Customer/Conformist               Anticorruption Layer
      ↓                                    ↓
┌─────────────┐    Partnership     ┌─────────────┐
│   Billing   │←─────────────────→│   Support   │
│  Context    │                    │   Context   │
└─────────────┘                    └─────────────┘
```

### Глава 3.2: Tactical Patterns DDD

#### Entity vs Value Object:

```
Entity (имеет идентичность):
class Customer {
  constructor(customerId) {
    this.customerId = customerId;  // Уникальный ID
    this.email = email;           // Может измениться
    this.address = address;       // Может измениться
  }
  
  // Два Customer равны, если у них одинаковый ID
  equals(other) {
    return this.customerId === other.customerId;
  }
  
  changeEmail(newEmail) {
    this.email = newEmail; // Изменение разрешено
  }
}

Value Object (определяется значением):
class Money {
  constructor(amount, currency) {
    this.amount = amount;         // Неизменяемый
    this.currency = currency;     // Неизменяемый
  }
  
  // Два Money равны, если равны amount и currency
  equals(other) {
    return this.amount === other.amount && 
           this.currency === other.currency;
  }
  
  add(other) {
    if (this.currency !== other.currency) {
      throw new Error('Currency mismatch');
    }
    return new Money(this.amount + other.amount, this.currency);
  }
}
```

#### Когда использовать Entity vs Value Object:

```
Entity используем когда:
- Объект имеет уникальную идентичность
- Изменения объекта важны для бизнеса
- Объект имеет жизненный цикл
- Нужно отслеживать объект во времени

Примеры: User, Order, Account, Subscription

Value Object используем когда:
- Важно значение, а не идентичность
- Объект неизменяемый (immutable)
- Можно свободно копировать и передавать
- Описывает характеристику другого объекта

Примеры: Money, Address, DateRange, Color
```

#### Aggregate — граница консистентности:

```
Aggregate Root: [Order]
                  ├── [OrderItem] ← не может существовать без Order
                  ├── [OrderItem] ← не может быть изменен напрямую
                  └── [Discount]  ← управляется только через Order
                      
Правила Aggregate:
1. Внешние объекты могут ссылаться только на Aggregate Root
2. Изменения внутри Aggregate атомарны
3. Один Repository на Aggregate
4. Aggregate должен быть маленьким

❌ Плохо:
orderItemRepository.updateQuantity(itemId, newQuantity);

✅ Хорошо:
order = orderRepository.findById(orderId);
order.updateItemQuantity(itemId, newQuantity);
orderRepository.save(order);
```

#### Правила проектирования Aggregates:

```
Размер Aggregate:
┌─────────────────────────────────────┐
│ Small Aggregate (Рекомендуется)     │
│ [Order]                             │
│   ├── OrderItem                     │
│   ├── OrderItem                     │
│   └── ShippingInfo                  │
└─────────────────────────────────────┘

vs

┌─────────────────────────────────────┐
│ Large Aggregate (Проблематично)     │
│ [Customer]                          │
│   ├── PersonalInfo                  │
│   ├── Address                       │
│   ├── Orders[]                      │
│   │   ├── OrderItems[]              │
│   │   └── Payments[]                │
│   ├── SupportTickets[]              │
│   └── Preferences                   │
└─────────────────────────────────────┘

Проблемы больших Aggregates:
- Конфликты при параллельном доступе
- Медленная загрузка
- Сложная логика валидации
```

### Domain Services:

```
Когда логика не принадлежит конкретной Entity:

❌ Неправильно - логика в Entity:
class Order {
  calculateShipping(customer, shippingRules, geolocation) {
    // Сложная логика расчета доставки
    // Order не должен знать о геолокации!
  }
}

✅ Правильно - Domain Service:
class ShippingCalculator {
  calculate(order, customer, destination) {
    // Специализированная логика расчета
    // Использует знания о географии, тарифах, и т.д.
  }
}

class Order {
  calculateTotal(shippingCalculator, destination) {
    const shippingCost = shippingCalculator.calculate(this, this.customer, destination);
    return this.itemsTotal + shippingCost;
  }
}
```

### Repository Pattern в DDD:

```
Repository - коллекция Aggregates в памяти:

interface OrderRepository {
  // Работа с Aggregate целиком
  findById(orderId: OrderId): Order;
  findByCustomer(customerId: CustomerId): Order[];
  save(order: Order): void;
  remove(order: Order): void;
  
  // Бизнес-ориентированные запросы
  findPendingOrders(): Order[];
  findOrdersRequiringShipping(): Order[];
}

❌ Не Repository паттерн:
interface OrderDataAccess {
  getOrderData(id);
  getOrderItems(orderId);  
  updateOrderStatus(id, status);
  insertOrderItem(orderItem);
}

Repository скрывает детали хранения и предоставляет 
интерфейс в терминах домена
```

---

## Модуль 4: Архитектурные паттерны для backend систем

### Глава 4.1: CQRS (Command Query Responsibility Segregation)

> **История:** Грег Янг популяризировал CQRS в 2010, основываясь на принципе CQS Бертрана Мейера (1988). Мейер заметил, что методы должны либо изменять состояние (команды), либо возвращать данные (запросы), но не то и другое.

#### Принцип CQS (Command Query Separation):

```
❌ Нарушение CQS:
class User {
  // Возвращает данные И изменяет состояние
  String updateEmailAndGetOldEmail(String newEmail) {
    String oldEmail = this.email;
    this.email = newEmail;      // изменение
    this.lastUpdated = now();   // изменение
    return oldEmail;            // запрос
  }
}

✅ Соблюдение CQS:
class User {
  // Только запрос
  String getEmail() {
    return this.email;
  }
  
  // Только команда
  void updateEmail(String newEmail) {
    this.email = newEmail;
    this.lastUpdated = now();
  }
}
```

#### Эволюция от простого к сложному:

```
Традиционный CRUD:
[Client] ←→ [API] ←→ [Service] ←→ [Database]
             ↕              ↕
        Commands &      Read & Write
         Queries        same model

Простой CQRS:
[Client] ──Write──→ [CommandAPI] ──→ [WriteService] ──→ [Database]
   ↑                                                        │
   └────Read──── [QueryAPI] ←─── [ReadService] ←────────────┘

Продвинутый CQRS:
[Client] ──Write──→ [CommandAPI] ──→ [WriteService] ──→ [WriteDB]
   ↑                                       │
   │                                   [Events]
   │                                       ↓
   └────Read──── [QueryAPI] ←── [ReadService] ←── [ReadDB]
                                       ↑
                               [Event Handlers]
```

#### Зачем разделять команды и запросы?

```
Проблемы единой модели:
1. Конфликтующие требования:
   Write: Нормализация, целостность, валидация
   Read: Денормализация, производительность, агрегации

2. Разная нагрузка:
   Write: 10% запросов, высокая важность консистентности
   Read: 90% запросов, требования к производительности

3. Разные паттерны доступа:
   Write: Одна запись за раз, транзакционность
   Read: Много записей, сложные JOIN'ы, аналитика
```

#### Типы CQRS:

```
CQRS Level 1 - Разделение на уровне кода:
class UserService {
  // Commands
  createUser(userData) { /* */ }
  updateUser(userId, data) { /* */ }
  
  // Queries  
  getUser(userId) { /* */ }
  getUsersByRole(role) { /* */ }
}

CQRS Level 2 - Разные модели:
class UserCommandModel {
  id, email, hashedPassword, permissions
}

class UserQueryModel {  
  id, fullName, email, lastLoginDate, isActive
}

CQRS Level 3 - Разные хранилища:
Commands → [NormalizedDB] → Events → [DenormalizedDB] ← Queries
```

#### Практический пример:

```javascript
// Command Model - для изменений
class CreateOrderCommand {
  constructor(customerId, items, shippingAddress) {
    this.customerId = customerId;
    this.items = items;
    this.shippingAddress = shippingAddress;
  }
}

class OrderCommandHandler {
  async handle(command) {
    const order = new Order(command.customerId);
    command.items.forEach(item => order.addItem(item));
    order.setShippingAddress(command.shippingAddress);
    
    await this.orderRepository.save(order);
    await this.eventBus.publish(new OrderCreated(order));
  }
}

// Query Model - для чтения
class OrderSummaryQuery {
  customerId: string;
  dateFrom: Date;
  dateTo: Date;
}

class OrderQueryHandler {
  async handle(query) {
    return await this.readDatabase.query(`
      SELECT o.id, o.total, o.status, c.name as customerName
      FROM order_summaries o
      JOIN customer_summaries c ON o.customer_id = c.id  
      WHERE o.customer_id = ? AND o.date BETWEEN ? AND ?
    `, [query.customerId, query.dateFrom, query.dateTo]);
  }
}
```

#### Когда использовать CQRS:

```
✅ Подходит для:                    ❌ Излишне для:
- Сложные бизнес-правила           - Простые CRUD операции
- Разные модели чтения/записи      - Команды совпадают с запросами
- Высокая нагрузка на чтение       - Маленькая команда (< 5 человек)
- Необходимость аналитики          - Быстрый MVP
- Разные SLA для чтения/записи     - Простые отчеты
- Eventual Consistency приемлема   - Строгая консистентность критична
```

### Глава 4.2: Event Sourcing

> **Метафора:** Как банковская выписка — вместо хранения текущего баланса храним все операции. Текущий баланс восстанавливается проигрыванием всех операций.

#### История и мотивация:

> **Предыстория:** Мартин Фаулер впервые описал Event Sourcing в 2005. Идея пришла из финансовой индустрии, где аудит операций критически важен.

```
Традиционное хранение состояния (State Store):
User: { id: 123, balance: 1000, status: 'active', lastLogin: '2023-01-15' }

Проблемы:
- Потеря истории изменений
- Сложно восстановить состояние на конкретную дату
- Невозможно понять, почему состояние такое
- Сложно отладить временные баги

Event Sourcing (Event Store):
Events: [
  { timestamp: '2023-01-01', type: 'UserRegistered', userId: 123, email: 'user@example.com' },
  { timestamp: '2023-01-02', type: 'BalanceAdded', userId: 123, amount: 1000, source: 'initial' },
  { timestamp: '2023-01-10', type: 'PurchaseMade', userId: 123, amount: 250, productId: 456 },
  { timestamp: '2023-01-15', type: 'UserLoggedIn', userId: 123, ipAddress: '192.168.1.1' }
]

Current State = apply(events) = { balance: 750, status: 'active', lastLogin: '2023-01-15' }
```

#### Ключевые концепции Event Sourcing:

```
Event (Событие):
- Неизменяемое (immutable)
- Описывает что произошло в прошлом
- Содержит все данные, необходимые для воспроизведения

Event Stream (Поток событий):
User-123: [UserCreated] → [EmailChanged] → [PasswordReset] → [LoginAttempted]

Projection (Проекция):
События → Применить → Текущее состояние
События → Применить → Отчет по продажам  
События → Применить → Аудитный лог
```

#### Event Store структура:

```
Event Store Table:
┌─────────────┬──────────────┬─────────┬──────────────┬─────────────────┐
│ StreamId    │ Version      │ Type    │ Data         │ Timestamp       │
├─────────────┼──────────────┼─────────┼──────────────┼─────────────────┤
│ user-123    │ 1            │ Created │ {email:...}  │ 2023-01-01 10:00│
│ user-123    │ 2            │ Updated │ {name:...}   │ 2023-01-02 11:30│
│ order-456   │ 1            │ Placed  │ {items:...}  │ 2023-01-03 14:15│
│ user-123    │ 3            │ Deleted │ {}           │ 2023-01-04 09:45│
└─────────────┴──────────────┴─────────┴──────────────┴─────────────────┘

Где:
- StreamId: идентификатор агрегата
- Version: порядковый номер события (для concurrency control)
- Type: тип события
- Data: JSON с данными события
```

#### Восстановление состояния (Rehydration):

```javascript
class UserAggregate {
  constructor() {
    this.id = null;
    this.email = null;
    this.isActive = false;
    this.version = 0;
  }
  
  // Применение событий для восстановления состояния
  apply(event) {
    switch(event.type) {
      case 'UserCreated':
        this.id = event.data.userId;
        this.email = event.data.email;
        this.isActive = true;
        break;
        
      case 'EmailChanged':
        this.email = event.data.newEmail;
        break;
        
      case 'UserDeactivated':
        this.isActive = false;
        break;
    }
    this.version = event.version;
  }
  
  // Восстановление из потока событий
  static fromEvents(events) {
    const user = new UserAggregate();
    events.forEach(event => user.apply(event));
    return user;
  }
}
```

#### Projections (Проекции):

```
События → Разные проекции для разных целей:

Current State Projection:
Events → UserSnapshot: { id, email, isActive, lastSeen }

Analytics Projection:  
Events → UserStats: { registrationsToday, activeUsers, churnRate }

Audit Projection:
Events → AuditLog: { timestamp, userId, action, changes }

Report Projection:
Events → SalesReport: { dailySales, topProducts, revenue }

Каждая проекция оптимизирована для конкретного use case
```

#### Преимущества и недостатки:

```
✅ Преимущества:
- Полная история изменений
- Аудит "из коробки"  
- Debugging временных багов
- Естественные проекции
- Возможность replay событий
- Temporal Queries (состояние на дату)

❌ Недостатки:
- Сложность запросов
- Больше места на диске  
- Сложность миграций
- Eventual consistency
- Learning curve для команды
- Необходимость снапшотов для производительности
```

#### Снапшоты (Snapshots):

```
Проблема: Восстановление состояния из 10,000 событий медленно

Решение: Периодические снапшоты
┌─────────────────────────────────────────────────────────┐
│ Events: 1→2→3→...→1000→[SNAPSHOT]→1001→1002→...→1050    │
└─────────────────────────────────────────────────────────┘

Восстановление:
1. Загрузить последний снапшот (событие 1000)
2. Применить события после снапшота (1001-1050)
3. Получить текущее состояние

class SnapshotStore {
  async saveSnapshot(streamId, version, state) {
    await this.db.upsert('snapshots', {
      streamId, version, state, timestamp: new Date()
    });
  }
  
  async getLatestSnapshot(streamId) {
    return await this.db.findLatest('snapshots', { streamId });
  }
}
```

### Глава 4.3: Microservices Architecture

> **История:** Термин ввел Джеймс Льюис в 2011. Но идеи восходят к Unix Philosophy (1970s): "Do one thing and do it well". Netflix стал пионером в применении микросервисов в production (2009-2012).

#### Эволюция масштабирования:

```
Single Process (1960s):
┌─────────────────────────────────────┐
│   [Input] → [Process] → [Output]    │
└─────────────────────────────────────┘

Monolith (1980s-2000s):
┌─────────────────────────────────────┐
│   [UI] → [Business Logic] → [DB]    │
└─────────────────────────────────────┘

Modular Monolith (2000s):
┌─────────────────────────────────────┐
│ [UserModule]    [OrderModule]       │
│ [ProductModule] [PaymentModule]     │  
│           [SharedDatabase]          │
└─────────────────────────────────────┘

Service-Oriented Architecture (2000s):
[WebService] ←→ [WebService] ←→ [WebService]
      ↓              ↓              ↓
   [Database]    [Database]    [Database]

Microservices (2010s+):
[UserService] ──HTTP/gRPC──→ [OrderService]
     ↓                           ↓
  [UserDB]                   [OrderDB]
     ↑                           ↑
[Event Bus] ←──────────────────────┘
```

#### Характеристики микросервисов:

```
Размер сервиса:
"Размер команды, которая может его поддерживать" (Amazon's Two Pizza Rule)

┌─────────────────────────┐
│  User Service (5-7 чел) │
│  ├── Authentication     │
│  ├── Profile Management │
│  ├── Preferences        │
│  └── User Analytics     │
└─────────────────────────┘

vs

┌─────────────────────────┐  
│ Order Service (3-5 чел) │
│  ├── Order Processing   │
│  ├── Order History      │
│  └── Order Validation   │
└─────────────────────────┘
```

#### Conway's Law в действии:

```
Организационная структура:
Team A ─── Team B        
  │          │               
Team C ─── Team D        

Отражается в архитектуре:
Service A ←→ Service B
     │          │
Service C ←→ Service D

"Организации проектируют системы, которые копируют 
структуру коммуникации этих организаций"
```

#### Декомпозиция монолита:

```
Стратегия 1 - По бизнес-возможностям:
Монолит → [UserManagement] + [OrderProcessing] + [Inventory] + [Billing]

Стратегия 2 - По данным:
Монолит → [CustomerData] + [ProductData] + [OrderData] + [AnalyticsData]

Стратегия 3 - По типу нагрузки:
Монолит → [ReadHeavyService] + [WriteHeavyService] + [CPUIntensiveService]

Стратегия 4 - Strangler Fig:
Монолит ←→ [NewService] (постепенная миграция функциональности)
```

#### Паттерны коммуникации микросервисов:

```
Synchronous Communication:
[ServiceA] ──HTTP/gRPC──→ [ServiceB] ──HTTP/gRPC──→ [ServiceC]
    ↑                                                   │
    └─────────── wait for response ───────────────────────┘

Asynchronous Communication:
[ServiceA] ──event──→ [MessageBus] ──→ [ServiceB]
                         │        ──→ [ServiceC]
                         │        ──→ [ServiceD]
                   (independent processing)

Hybrid Approach:
[ServiceA] ──command──→ [ServiceB] (sync)
    │                      │
    └──event──→ [Bus] ←──event── (async)
                 │
                 └──→ [ServiceC] (async notification)
```

#### Database per Service:

```
❌ Shared Database Anti-pattern:
[UserService] ──→ [SharedDB] ←── [OrderService]
                     ↑
               [PaymentService]

Проблемы:
- Tight coupling через схему БД
- Сложно изменять схему  
- Нет изоляции данных
- Single point of failure

✅ Database per Service:
[UserService] ──→ [UserDB]
[OrderService] ──→ [OrderDB]  
[PaymentService] ──→ [PaymentDB]

Преимущества:
- Loose coupling
- Технологическое разнообразие
- Независимые изменения схемы
- Изоляция проблем
```

#### Распределенные транзакции - Saga Pattern:

```
Проблема: Как обеспечить консистентность между сервисами?

Choreography-based Saga:
[OrderService] ──OrderCreated──→ [EventBus]
                                     │
                    ┌────────────────┼────────────────┐
                    ↓                ↓                ↓
            [PaymentService]  [InventoryService]  [ShippingService]
                    │                │                │
                    ├─PaymentFailed──┼─OutOfStock─────┼─ShippingFailed
                    ↓                ↓                ↓
               [EventBus] ←──────────────────────────────
                    │
            CompensatingActions
                    ↓
        [OrderCancelled, RefundIssued, InventoryRestored]

Orchestration-based Saga:
[SagaOrchestrator]
├── Step 1: CreateOrder → [OrderService]
├── Step 2: ProcessPayment → [PaymentService]  
├── Step 3: ReserveInventory → [InventoryService]
├── Step 4: ScheduleShipping → [ShippingService]
└── Compensation: Rollback on any failure
```

### Глава 4.4: Event-Driven Architecture

> **Метафора:** Как новостная лента в соцсетях — события происходят, заинтересованные подписчики реагируют. Издатель не знает, кто подписан, подписчики не знают друг о друге.

#### Эволюция интеграции систем:

```
File Transfer (1960s):
[SystemA] ──file──→ [SharedStorage] ←──file── [SystemB]

Database Sharing (1980s):
[SystemA] ──→ [SharedDB] ←── [SystemB]

Remote Procedure Calls (1990s):
[SystemA] ──RPC call──→ [SystemB]

Message Queues (2000s):
[SystemA] ──message──→ [Queue] ──→ [SystemB]

Event Streaming (2010s+):
[SystemA] ──events──→ [EventStream] ──→ [SystemB]
                          │        ──→ [SystemC]
                          │        ──→ [SystemD]
```

#### Типы событий:

```
Domain Events (бизнес-события):
- CustomerRegistered
- OrderPlaced  
- PaymentProcessed
- ProductOutOfStock

Integration Events (технические события):
- UserDataSynced
- EmailSent
- CacheInvalidated
- DatabaseMigrated

System Events (системные события):
- ServiceStarted
- ServiceStopped
- ErrorOccurred
- PerformanceThresholdExceeded
```

#### Паттерны обработки событий:

```
Event Notification:
[Publisher] ──minimal event──→ [Subscriber]
                                   │
                                   └──queries for details──→ [Publisher]

Event-Carried State Transfer:
[Publisher] ──full state in event──→ [Subscriber]
                                         │
                                    stores locally

Event Sourcing:
[Publisher] ──append-only events──→ [EventStore] ──→ [Subscribers]
                                         │
                                    single source of truth
```

#### Event Bus vs Message Queue:

```
Message Queue (точка-к-точке):
[Producer] ──→ [Queue] ──→ [Consumer]
               ↓ ↓ ↓
          (messages consumed once)

Event Bus (pub/sub):
[Publisher] ──→ [EventBus] ──→ [Subscriber1]
                    │      ──→ [Subscriber2]  
                    │      ──→ [Subscriber3]
              (event delivered to all)

Event Stream (append-only log):
[Producer] ──→ [EventLog] ←── [Consumer1] (reads from offset)
               ├─Event1    [Consumer2] (reads from different offset)
               ├─Event2    [Consumer3] (can replay from any point)
               ├─Event3
               └─Event4
```

#### Choreography vs Orchestration:

```
Choreography (хореография):
Каждый сервис знает, как реагировать на события

OrderPlaced → [PaymentService] → PaymentProcessed → [InventoryService] 
                                                  → InventoryReserved 
                                                  → [ShippingService]
                                                  → ShippingScheduled

Преимущества: Loose coupling, высокая автономность
Недостатки: Сложно отследить flow, нет центрального контроля

Orchestration (оркестрация):  
Центральный сервис управляет процессом

[ProcessOrderSaga] ──→ [PaymentService]
        ↓              ↓
   [InventoryService] ←─PaymentSuccess
        ↓
   [ShippingService] ←─InventoryReserved

Преимущества: Центральный контроль, легко отследить
Недостатки: Tight coupling, orchestrator может стать bottleneck
```

#### Обработка ошибок в Event-Driven Architecture:

```
Dead Letter Queue:
[EventProcessor] ──failed processing──→ [DeadLetterQueue]
                                            │
                                    ┌───────┼───────┐
                                    ↓       ↓       ↓
                              [Manual]  [Retry]  [Alert]
                             [Review] [Service] [Admin]

Retry Patterns:
┌─────────────────────────────────────────────────────────┐
│ Event Processing Attempts:                              │
│ Attempt 1: immediate                                    │
│ Attempt 2: +1 second (exponential backoff)             │
│ Attempt 3: +2 seconds                                  │
│ Attempt 4: +4 seconds                                  │
│ Attempt 5: +8 seconds                                  │
│ → Dead Letter Queue                                     │
└─────────────────────────────────────────────────────────┘

Circuit Breaker for Event Processing:
[EventProcessor] ──→ [DownstreamService]
      ↑                      │
      │                   failures
      │                      ↓
   [Circuit] ──────────→ [OPEN] (stop processing)
   [Breaker]                 │
      ↑                   timeout
      │                      ↓
   [HALF-OPEN] ←─────────→ [CLOSED] (resume processing)
```

#### Практический пример Event-Driven Order Processing:

```javascript
// Event Definitions
class OrderPlaced {
  constructor(orderId, customerId, items, total) {
    this.orderId = orderId;
    this.customerId = customerId;
    this.items = items;
    this.total = total;
    this.timestamp = new Date();
  }
}

class PaymentProcessed {
  constructor(orderId, paymentId, amount) {
    this.orderId = orderId;
    this.paymentId = paymentId;
    this.amount = amount;
    this.timestamp = new Date();
  }
}

// Event Handlers
class PaymentService {
  async handleOrderPlaced(event) {
    try {
      const payment = await this.processPayment(
        event.customerId, 
        event.total
      );
      
      await this.eventBus.publish(
        new PaymentProcessed(event.orderId, payment.id, event.total)
      );
    } catch (error) {
      await this.eventBus.publish(
        new PaymentFailed(event.orderId, error.message)
      );
    }
  }
}

class InventoryService {
  async handlePaymentProcessed(event) {
    const order = await this.getOrderDetails(event.orderId);
    
    for (const item of order.items) {
      await this.reserveItem(item.productId, item.quantity);
    }
    
    await this.eventBus.publish(
      new InventoryReserved(event.orderId, order.items)
    );
  }
}
```

---

## Модуль 5: Данные и производительность

### Глава 5.1: Data Architecture Patterns

> **История:** Паттерн Repository появился в книге Эванса "Domain-Driven Design" (2003), но корни уходят к DAO pattern из J2EE (1999). Active Record популяризовал Ruby on Rails (2004).

#### Эволюция доступа к данным:

```
1970s - Прямой SQL:
function getUser(id) {
  return execute("SELECT * FROM users WHERE id = " + id);
}

1990s - Stored Procedures:
function getUser(id) {
  return callProcedure("sp_get_user", [id]);
}

1999 - Data Access Objects (DAO):
class UserDAO {
  getUser(id) { /* SQL logic */ }
  saveUser(user) { /* SQL logic */ }
  deleteUser(id) { /* SQL logic */ }
}

2004 - Active Record (Rails):
user = User.find(123);
user.name = "New Name";
user.save();

2010s+ - Repository Pattern:
interface UserRepository {
  findById(id): User
  save(user): void
}
```

#### Active Record vs Data Mapper vs Repository:

```
Active Record (Rails-style):
class User extends ActiveRecord {
  // Domain logic mixed with persistence
  save() { /* writes to DB */ }
  validate() { /* business rules */ }
  
  static findByEmail(email) { /* queries DB */ }
}

Проблемы:
- Tight coupling между domain и persistence
- Сложно тестировать без БД
- Нарушение Single Responsibility

Data Mapper (технически-ориентированный):
class UserMapper {
  insert(user): void
  update(user): void  
  delete(id): void
  selectById(id): UserData
  selectByEmail(email): UserData[]
}

Проблемы:
- Слишком технический подход
- Не отражает бизнес-операции
- CRUD-мышление

Repository (доменно-ориентированный):
interface UserRepository {
  // Бизнес-ориентированные методы
  findActiveCustomers(): Customer[]
  findCustomersWithOutstandingOrders(): Customer[]
  findTopCustomersByRevenue(limit: number): Customer[]
  
  // Базовые операции
  findById(id): Customer
  save(customer): void
}

Преимущества:
- Бизнес-ориентированный интерфейс
- Скрывает детали persistence
- Легко тестировать (mock repository)
- Инкапсулирует сложные запросы
```

#### Unit of Work Pattern:

```
Проблема: Как управлять изменениями множественных объектов?

❌ Без Unit of Work:
customerRepository.save(customer);
orderRepository.save(order);  
paymentRepository.save(payment);
// Что если одна операция failed?

✅ С Unit of Work:
class UnitOfWork {
  constructor() {
    this.newObjects = [];
    this.dirtyObjects = [];  
    this.removedObjects = [];
  }
  
  registerNew(object) {
    this.newObjects.push(object);
  }
  
  registerDirty(object) {
    this.dirtyObjects.push(object);
  }
  
  commit() {
    // Все изменения в одной транзакции
    this.db.beginTransaction();
    try {
      this.insertNew();
      this.updateDirty();
      this.deleteRemoved();
      this.db.commit();
    } catch (error) {
      this.db.rollback();
      throw error;
    }
  }
}

// Использование
const uow = new UnitOfWork();
uow.registerNew(customer);
uow.registerDirty(order);
uow.commit(); // Атомарная операция
```

#### Database per Service Pattern:

```
Монолитная БД:
[UserService] ──→ [MonolithDB]
[OrderService] ──→     │
[PaymentService] ──→   │
[InventoryService] ──→ │

Проблемы:
- Shared schema coupling
- Scaling bottleneck  
- Single point of failure
- Technology lock-in

Database per Service:
[UserService] ──→ [PostgreSQL] (relational data)
[OrderService] ──→ [PostgreSQL] (transactional)
[PaymentService] ──→ [PostgreSQL] (ACID compliance)
[InventoryService] ──→ [MongoDB] (product catalog)
[AnalyticsService] ──→ [ClickHouse] (time-series)
[SearchService] ──→ [Elasticsearch] (full-text search)

Преимущества:
- Technology diversity
- Independent scaling
- Fault isolation
- Team autonomy
```

#### Polyglot Persistence:

```
Выбор БД под задачу:

Relational (PostgreSQL, MySQL):
- ACID transactions
- Complex queries
- Structured data
- Reporting

Document (MongoDB, CouchDB):  
- Semi-structured data
- Rapid development
- Horizontal scaling
- Content management

Key-Value (Redis, DynamoDB):
- Simple data model
- High performance
- Caching
- Session storage

Graph (Neo4j, Amazon Neptune):
- Connected data
- Recommendations  
- Social networks
- Fraud detection

Time-Series (InfluxDB, TimescaleDB):
- Metrics and logs
- IoT data
- Monitoring
- Analytics

Search (Elasticsearch, Solr):
- Full-text search
- Complex filtering
- Faceted navigation
- Log analysis
```

### Глава 5.2: Caching Architecture

> **Метафора:** Кэш как записная книжка — часто используемую информацию держим под рукой, редкую ищем в архиве.

#### Иерархия кэширования:

```
Browser Cache (1-60 seconds)
      ↓ (miss)
CDN Cache (1-60 minutes)  
      ↓ (miss)
Load Balancer Cache (30 seconds)
      ↓ (miss)
Application Cache (5-30 minutes)
      ↓ (miss)
Database Query Cache (15-60 minutes)
      ↓ (miss)
Database Buffer Pool
      ↓ (miss)
Disk Storage

Каждый уровень оптимизирован для своих задач:
- Browser: персонализация, статические ресурсы
- CDN: географическое распределение
- Application: бизнес-логика, вычисления
- Database: индексы, план запросов
```

#### Стратегии кэширования:

```
Cache-Aside (Lazy Loading):
[App] ──1.check──→ [Cache] ──2.miss──→ [App] ──3.query──→ [DB]
  ↑                                      │                 │
  └──6.return── [Cache] ←──5.store──── [App] ←──4.data─────┘

Write-Through:
[App] ──1.write──→ [Cache] ──2.write──→ [DB]
  ↑                   │                  │
  └──4.confirm───── [Cache] ←──3.ack─────┘

Write-Behind (Write-Back):
[App] ──1.write──→ [Cache] ──3.async write──→ [DB]
  ↑                   │
  └──2.immediate──────┘
     confirm

Write-Around:
[App] ──write──→ [DB] (bypassing cache)
  │              
  └──read──→ [Cache] ──miss──→ [DB]
```

#### Кэширование в микросервисах:

```
Local Cache (per service):
[Service1] ← [LocalCache1]
[Service2] ← [LocalCache2]  
[Service3] ← [LocalCache3]

Проблемы:
- Inconsistency между сервисами
- Duplication данных
- Сложность invalidation

Distributed Cache (shared):
[Service1] ──→ [Redis Cluster] ←── [Service2]
                     ↑
               [Service3]

Преимущества:
- Consistency
- Shared data
- Centralized invalidation

Недостатки:
- Network latency
- Single point of failure
- Additional complexity
```

#### Cache Invalidation Strategies:

```
Time-Based (TTL):
[Cache] ── expires after 5 minutes ──→ [Removed]

Event-Based:
[DataChanged] ──event──→ [CacheInvalidator] ──→ [Cache.remove()]

Version-Based:
[Data v1] ──→ [Cache: key="user:123:v1"]
[Data v2] ──→ [Cache: key="user:123:v2"] (v1 becomes stale)

Tag-Based:
[Cache] ──tags: ["user:123", "orders"]──
[Event: user updated] ──→ invalidate all with tag "user:123"

Manual:
[Admin] ──→ [Cache.clear("pattern:*")] ──→ [Cache]
```

#### Практический пример многоуровневого кэширования:

```javascript
class MultiLevelCache {
  constructor() {
    this.l1Cache = new Map(); // In-memory (fast, small)
    this.l2Cache = new RedisClient(); // Distributed (medium, larger)
    this.database = new Database(); // Persistent (slow, unlimited)
  }
  
  async get(key) {
    // Level 1: In-memory cache
    if (this.l1Cache.has(key)) {
      return this.l1Cache.get(key);
    }
    
    // Level 2: Distributed cache
    const l2Value = await this.l2Cache.get(key);
    if (l2Value) {
      this.l1Cache.set(key, l2Value); // Populate L1
      return l2Value;
    }
    
    // Level 3: Database
    const dbValue = await this.database.get(key);
    if (dbValue) {
      this.l1Cache.set(key, dbValue); // Populate L1
      await this.l2Cache.set(key, dbValue, 3600); // Populate L2
      return dbValue;
    }
    
    return null;
  }
  
  async set(key, value) {
    // Write-through to all levels
    this.l1Cache.set(key, value);
    await this.l2Cache.set(key, value, 3600);
    await this.database.set(key, value);
  }
  
  async invalidate(key) {
    this.l1Cache.delete(key);
    await this.l2Cache.del(key);
    // Database value remains (source of truth)
  }
}
```

#### Cache Stampede и его решения:

```
Проблема Cache Stampede:
[Cache expires] → [Multiple requests] → [All hit DB simultaneously]
                     │    │    │
                     ↓    ↓    ↓
                 [DB Overload]

Решение 1 - Lock-based:
[Request1] ──gets lock──→ [Rebuilds cache]
[Request2] ──waits──→ [Gets fresh cache]
[Request3] ──waits──→ [Gets fresh cache]

Решение 2 - Probabilistic Early Expiration:
expires_at = base_expiry - random(0, early_expiry_window)
// Requests expire at slightly different times

Решение 3 - Background Refresh:
[Cache] ──soft TTL (5 min)──→ [Trigger background refresh]
        ──hard TTL (10 min)──→ [Actually expire]

class ProbabilisticCache {
  async get(key) {
    const item = await this.cache.get(key);
    if (!item) return null;
    
    const timeLeft = item.expiry - Date.now();
    const refreshProbability = 1 - (timeLeft / item.ttl);
    
    if (Math.random() < refreshProbability) {
      // Trigger background refresh
      this.backgroundRefresh(key);
    }
    
    return item.value;
  }
}
```

### Глава 5.3: Performance Architecture

> **Принцип:** "Преждевременная оптимизация — корень всех зол" (Дональд Кнут). Но архитектурные решения для производительности нужно принимать заранее.

#### Измерение производительности:

```
Response Time Components:
┌─────────────────────────────────────────────────────────┐
│ [User Request] ──→ [Network] ──→ [Load Balancer]        │
│      ↓                              ↓                   │
│ [Application Processing] ──→ [Database Query]           │
│      ↓                              ↓                   │
│ [Business Logic] ──→ [External API Call]                │
│      ↓                              ↓                   │
│ [Response Building] ──→ [Network] ──→ [User]            │
└─────────────────────────────────────────────────────────┘

Total Response Time = Network + Processing + Database + External + ...

Key Metrics:
- Latency: время отклика на один запрос
- Throughput: количество запросов в секунду  
- Concurrent Users: одновременные пользователи
- Resource Utilization: CPU, Memory, Disk, Network
```

#### Масштабирование — вертикальное vs горизонтальное:

```
Vertical Scaling (Scale Up):
Server v1: [2 CPU, 4GB RAM] ──→ Server v2: [16 CPU, 64GB RAM]
                ↓                              ↓
            1000 RPS                       4000 RPS

Преимущества:
- Простота (нет изменений в коде)
- Нет сетевых задержек
- ACID транзакции

Недостатки:  
- Предел масштабирования
- Single point of failure
- Высокая стоимость high-end hardware

Horizontal Scaling (Scale Out):
[Server1] ←──→ [Load Balancer] ←──→ [Server2]
   1000 RPS         ↕                1000 RPS  
                [Server3]
                 1000 RPS
                 
Total: 3000 RPS

Преимущества:
- Почти неограниченное масштабирование
- Fault tolerance
- Cost effective (commodity hardware)

Недостатки:
- Сложность архитектуры
- Сетевые задержки
- Eventual consistency
```

#### Load Balancing Strategies:

```
Round Robin:
Request 1 → Server A
Request 2 → Server B  
Request 3 → Server C
Request 4 → Server A (cycle)

Weighted Round Robin:
Server A (weight: 3) gets 3 requests
Server B (weight: 2) gets 2 requests
Server C (weight: 1) gets 1 request

Least Connections:
Server A: 10 active connections
Server B: 5 active connections  ← next request goes here
Server C: 8 active connections

Response Time Based:
Server A: avg 200ms
Server B: avg 150ms ← next request goes here
Server C: avg 300ms

Consistent Hashing (for stateful services):
Hash(request) → Server mapping
Same request always goes to same server
```

#### Database Scaling Patterns:

```
Read Replicas:
[Master DB] ──replication──→ [Replica 1]
    ↑                           ↓
  Writes                      Reads
    ↑                           ↓  
[App] ──────reads──────→ [Replica 2]

Connection Pooling:
[App Instances] ──→ [Connection Pool] ──→ [Database]
    ├─ Instance 1        ├─ Conn 1           │
    ├─ Instance 2        ├─ Conn 2           │
    └─ Instance N        └─ Conn M           │
                         (M << N)

Database Sharding:
[App] ──→ [Shard Router]
             ├── [Shard 1: users A-M] 
             ├── [Shard 2: users N-Z]
             └── [Shard 3: analytics data]

Sharding Strategies:
1. Range-based: user_id 1-1000 → Shard1
2. Hash-based: hash(user_id) % shard_count
3. Directory-based: lookup table for routing
```

#### Практический пример sharding:

```javascript
class ShardedUserRepository {
  constructor(shards) {
    this.shards = shards; // Array of database connections
  }
  
  getShardForUser(userId) {
    // Consistent hashing
    const hash = this.hashFunction(userId);
    const shardIndex = hash % this.shards.length;
    return this.shards[shardIndex];
  }
  
  async findById(userId) {
    const shard = this.getShardForUser(userId);
    return await shard.query(
      'SELECT * FROM users WHERE id = ?', 
      [userId]
    );
  }
  
  async save(user) {
    const shard = this.getShardForUser(user.id);
    return await shard.query(
      'INSERT INTO users (id, email, name) VALUES (?, ?, ?)',
      [user.id, user.email, user.name]
    );
  }
  
  // Cross-shard queries are challenging!
  async findByEmail(email) {
    // Need to query all shards :(
    const promises = this.shards.map(shard => 
      shard.query('SELECT * FROM users WHERE email = ?', [email])
    );
    
    const results = await Promise.all(promises);
    return results.flat().find(user => user !== null);
  }
}
```

#### Асинхронная обработка:

```
Synchronous Processing:
[Request] → [Validate] → [Process] → [Save] → [Email] → [Response]
            (100ms)     (2000ms)   (200ms)  (1000ms)
            
Total: 3300ms response time

Asynchronous Processing:
[Request] → [Validate] → [Queue Job] → [Response]
            (100ms)       (10ms)        
                            ↓
                      [Background Worker]
                      [Process] → [Save] → [Email]
                      (2000ms)   (200ms)  (1000ms)

Response time: 110ms
Total processing: still 3300ms, but user doesn't wait
```

#### Queue Architecture для async processing:

```
Simple Queue:
[Producer] → [Queue] → [Consumer]

Work Queue with multiple workers:
[Producer] → [Queue] ← [Worker 1]
                ↑   ← [Worker 2]  
                ↑   ← [Worker 3]

Priority Queue:
[Producer] → [High Priority Queue] ← [Worker 1]
          → [Low Priority Queue]  ← [Worker 2]

Dead Letter Queue:
[Queue] → [Worker] → [Failed] → [Dead Letter Queue]
                                      ↓
                               [Manual Review]

class JobProcessor {
  async processJob(job) {
    try {
      await this.executeJob(job);
      await this.markCompleted(job.id);
    } catch (error) {
      job.retryCount++;
      
      if (job.retryCount < MAX_RETRIES) {
        await this.requeueWithDelay(job);
      } else {
        await this.sendToDeadLetterQueue(job, error);
      }
    }
  }
}
```

#### CDN и статический контент:

```
Without CDN:
[User in Tokyo] ──8000km──→ [Server in US] (500ms latency)

With CDN:
[User in Tokyo] ──50km──→ [CDN Edge in Tokyo] (20ms latency)
                              ↓ (cache miss)
                         [CDN Origin in US] (initial load only)

CDN Strategy:
Static Assets (CSS, JS, Images):
- Cache-Control: max-age=31536000 (1 year)
- Versioned URLs: /assets/main.v123.css

Dynamic API Responses:
- Cache-Control: max-age=300 (5 minutes)
- Vary: Authorization (per-user caching)

Personalized Content:
- Edge Side Includes (ESI)
- Cache fragments, personalize at edge
```

---

## Модуль 6: Архитектурная оценка и эволюция

### Глава 6.1: Architecture Assessment

> **Принцип:** "You can't manage what you don't measure" — Питер Друкер. Но что измерять в архитектуре?

#### Архитектурные метрики:

```
Code Quality Metrics:
┌─────────────────────────────────────────────────────────┐
│ Coupling Metrics:                                       │
│ - Afferent Coupling (Ca): кто зависит от модуля        │
│ - Efferent Coupling (Ce): от кого зависит модуль       │  
│ - Instability (I): Ce / (Ca + Ce)                      │
│ - Distance from Main Sequence: |A + I - 1|             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Cohesion Metrics:                                       │
│ - Lines of Code per Class (< 200 ideal)                │
│ - Number of Methods per Class (< 20 ideal)             │
│ - Cyclomatic Complexity (< 10 per method)              │
│ - Depth of Inheritance Tree (< 5 levels)               │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Dependency Metrics:                                     │
│ - Number of Dependencies per Module                     │
│ - Circular Dependencies (should be 0)                  │
│ - Dependency Inversion Ratio                           │
│ - Package Principles Violations                        │
└─────────────────────────────────────────────────────────┘
```

#### Архитектурная матрица зависимостей:

```
Dependency Structure Matrix (DSM):
        A  B  C  D  E
     A [■] X  .  .  .
     B [■][■] X  .  .  
     C [■] . [■] X  .
     D  .  . [■][■] X
     E [■] .  . [■][■]

Где:
■ - модуль зависит сам от себя (диагональ)
X - зависимость между модулями
. - нет зависимости

Проблемы:
- Выше диагонали = циклические зависимости
- Слишком много X = high coupling
- Кластеры X = tight cohesion groups
```

#### Architecture Decision Records (ADR):

```
ADR-001: Choice of Database Technology
Status: Accepted
Date: 2023-01-15
Participants: Tech Lead, Senior Engineers, Product Owner

Context:
We need to choose a primary database for our e-commerce platform.
Requirements:
- ACID transactions for order processing
- Support for complex queries (reports)
- Horizontal scaling capability
- Team expertise availability

Options Considered:
1. PostgreSQL
   Pros: ACID, SQL, team knows it, good tooling
   Cons: Vertical scaling limitations

2. MongoDB  
   Pros: Horizontal scaling, flexible schema
   Cons: Limited transaction support, learning curve

3. Amazon DynamoDB
   Pros: Managed service, automatic scaling
   Cons: Vendor lock-in, limited query flexibility

Decision:
Use PostgreSQL as primary database with read replicas for scaling.
Plan to evaluate sharding strategies as we approach scale limits.

Consequences:
+ Team can be productive immediately
+ Strong consistency guarantees
+ Rich ecosystem of tools
- Will need to plan for scaling challenges
- Limited NoSQL flexibility
```

#### Technical Debt Assessment:

```
Technical Debt Quadrant (Martin Fowler):

         Reckless          |         Prudent
                          |
    "We don't have       |   "We must ship now and
     time for design"    |    deal with consequences"
    ─────────────────────┼─────────────────────────
    "What's layering?"   |   "Now we know how we
                         |    should have done it"
      Inadvertent        |        Deliberate

Debt Metrics:
- Code Coverage < 70%
- Cyclomatic Complexity > 10
- Duplicated Code > 3%
- Technical Debt Ratio > 5%
- Bug Fix Time > Issue Creation Time
- Time to Add New Feature (trending up)

class TechnicalDebtAssessment {
  calculateDebtRatio() {
    const remediation = this.getRemediationCost();
    const development = this.getDevelopmentCost();
    return (remediation / (remediation + development)) * 100;
  }
  
  identifyHotspots() {
    return this.modules
      .filter(m => m.changeFrequency > 0.1) // Changes often
      .filter(m => m.complexity > 15)       // High complexity
      .filter(m => m.bugCount > 5);         // Many bugs
  }
}
```

#### Architecture Fitness Functions:

```
Automated Architecture Tests:

// Dependency Rules Test
test('Domain layer should not depend on Infrastructure', () => {
  const domainPackages = analyzePackages('./src/domain');
  const infrastructureDependencies = domainPackages
    .flatMap(pkg => pkg.dependencies)
    .filter(dep => dep.startsWith('infrastructure'));
    
  expect(infrastructureDependencies).toHaveLength(0);
});

// Performance Constraints
test('API response time should be under 200ms', async () => {
  const start = Date.now();
  await apiClient.get('/users/123');
  const duration = Date.now() - start;
  
  expect(duration).toBeLessThan(200);
});

// Security Rules
test('Sensitive data should not be logged', () => {
  const logFiles = readLogFiles();
  const sensitivePatterns = [
    /password/i,
    /credit.*card/i,
    /ssn/i,
    /api.*key/i
  ];
  
  logFiles.forEach(log => {
    sensitivePatterns.forEach(pattern => {
      expect(log).not.toMatch(pattern);
    });
  });
});
```

### Глава 6.2: Refactoring Architecture

#### Принципы безопасного рефакторинга:

```
Refactoring vs Rewriting:

Refactoring (small, safe steps):
[Monolith] → [Monolith + NewService] → [Monolith + NewService] → [Services]
             (extract one module)      (extract another)         (complete)

Big Bang Rewrite (risky):
[OldSystem] → [6 months development] → [NewSystem]
                                      (high risk of failure)

Incremental Approach Success Rate: 85%
Big Bang Approach Success Rate: 15%
```

#### Strangler Fig Pattern:

> **Метафора:** Как дерево-душитель постепенно охватывает и заменяет старое дерево, не убивая его сразу.

```
Phase 1 - Intercept:
[Requests] → [Proxy] → [Legacy System]
                ↓
           [New Service] (handles 10% of traffic)

Phase 2 - Migrate:  
[Requests] → [Proxy] → [Legacy System] (70% traffic)
                ↓
           [New Service] (30% traffic)

Phase 3 - Eliminate:
[Requests] → [Proxy] → [New Service] (90% traffic)
                ↓
           [Legacy System] (10% traffic)

Phase 4 - Complete:
[Requests] → [New Service] (100% traffic)
           [Legacy System] (retired)

class StranglerFigProxy {
  route(request) {
    if (this.shouldRouteToNewService(request)) {
      return this.newService.handle(request);
    } else {
      return this.legacySystem.handle(request);
    }
  }
  
  shouldRouteToNewService(request) {
    // Route based on feature flags, user segments, etc.
    return this.featureFlag.isEnabled('new-service', request.userId);
  }
}
```

#### Database Migration Strategies:

```
Parallel Change Pattern:
Step 1 - Expand:
[App] → [OldTable] + [NewTable]
        (dual writes)

Step 2 - Migrate:  
[DataMigration] copies OldTable → NewTable
[App] reads from NewTable, writes to both

Step 3 - Contract:
[App] → [NewTable] only
[OldTable] deleted

Branch by Abstraction:
[Client] → [Abstraction] → [OldImplementation]
                    ↓
              [NewImplementation]

Gradually flip flag:
if (useNewImplementation) {
  return newService.handle(request);
} else {
  return oldService.handle(request);
}
```

#### Feature Toggles в архитектурных изменениях:

```
Types of Feature Toggles:

Release Toggles (temporary):
- Hide incomplete features
- Dark launches  
- Progressive rollouts

Experiment Toggles (temporary):
- A/B testing
- Canary releases
- Performance comparisons

Ops Toggles (long-lived):
- Circuit breakers
- Graceful degradation
- Load shedding

Permission Toggles (long-lived):
- Premium features
- Beta access
- Admin functionality

class FeatureToggleService {
  isEnabled(toggleName, context) {
    const toggle = this.getToggle(toggleName);
    
    switch(toggle.type) {
      case 'percentage':
        return this.hash(context.userId) < toggle.percentage;
        
      case 'user-list':
        return toggle.users.includes(context.userId);
        
      case 'ring':
        return toggle.rings.includes(context.userRing);
        
      default:
        return toggle.defaultValue;
    }
  }
}
```

#### Blue-Green Deployment для архитектурных обновлений:

```
Blue-Green Architecture Migration:

Current State (Blue):
[LoadBalancer] → [BlueEnvironment]
                 ├── [OldArchitecture]
                 ├── [MonolithDB]
                 └── [LegacyServices]

Preparation (Green):
[LoadBalancer] → [BlueEnvironment]
                 
[GreenEnvironment] (parallel)
├── [NewArchitecture]  
├── [MicroservicesDB]
└── [ModernServices]

Switch:
[LoadBalancer] → [GreenEnvironment]

[BlueEnvironment] (kept for rollback)

Rollback (if needed):
[LoadBalancer] → [BlueEnvironment]
```

### Глава 6.3: Evolution Architecture

#### Принципы эволюционной архитектуры:

```
Traditional Architecture:
Big Upfront Design → Implementation → Maintenance

Evolutionary Architecture:
┌─ Guided Incremental Change ─→ Feedback ─┐
│                                          │
└─ Architecture Fitness Functions ←────────┘

Key Principles:
1. Incremental change over big bang
2. Fitness functions guide evolution  
3. Last responsible moment decisions
4. Appropriate coupling (not zero coupling)
```

#### Hexagonal Architecture Evolution:

```
Evolution Stage 1 - Monolithic Hexagon:
        [WebAdapter]
             │
    [ApplicationCore]
             │
       [DBAdapter]

Evolution Stage 2 - Service Hexagons:
[WebAdapter] → [UserService] ← [DBAdapter]
[WebAdapter] → [OrderService] ← [DBAdapter]

Evolution Stage 3 - Event-Driven Hexagons:
[WebAdapter] → [UserService] → [EventBus] → [OrderService]
                     ↓                          ↓
              [UserDBAdapter]              [OrderDBAdapter]

Evolution Stage 4 - Distributed Hexagons:
[Region1: UserService] ←─── EventStream ───→ [Region2: UserService]
[Region1: OrderService] ←── EventStream ───→ [Region2: OrderService]
```

#### Microservices Evolution Path:

```
Monolith → Modular Monolith → Services:

Stage 1 - Identify Bounded Contexts:
[Monolith]
├── UserModule (high cohesion)
├── OrderModule (high cohesion)  
├── PaymentModule (high cohesion)
└── ReportModule (cross-cutting)

Stage 2 - Extract Low-Risk Services:
[Monolith] + [NotificationService] (stateless, low coupling)
         + [ReportingService] (read-only, eventual consistency OK)

Stage 3 - Extract Core Business Services:
[Monolith] + [UserService] + [OrderService] + [PaymentService]

Stage 4 - Break Down Remaining Monolith:
[APIGateway] → [UserService]
             → [OrderService]  
             → [PaymentService]
             → [InventoryService]
             → [ShippingService]

Service Extraction Priority:
1. Stateless services (lowest risk)
2. Read-only services  
3. Services with clear boundaries
4. Services with different scaling needs
5. Core business services (highest value)
```

### Глава 6.4: Architecture Documentation

#### C4 Model — Контекст, Контейнеры, Компоненты, Код:

```
Level 1 - System Context (Zoom Out):
[Customer] ──uses──→ [E-commerce System] ──→ [Payment Gateway]
                           │                      ↑
                           ↓                      │
                    [Email Service] ──────────────┘
                           │
                           ↓
                      [Admin User]

Level 2 - Container Diagram (Zoom In):
┌─────────── E-commerce System ───────────┐
│ [Web App] ←→ [API Gateway] ←→ [Database] │
│     ↓             ↓              ↑      │
│ [Mobile App] [Background Jobs]   │      │
└─────────────────────────────────┼──────┘
                                  ↓
                            [External APIs]

Level 3 - Component Diagram (Zoom In API Gateway):
┌─────────── API Gateway ──────────────┐
│ [UserController] ──→ [UserService]   │
│ [OrderController] ──→ [OrderService] │  
│ [PaymentController] ──→ [PaymentService] │
│         ↓                   ↓        │
│    [UserRepository] [OrderRepository]│
└──────────────────────────────────────┘

Level 4 - Code Diagram (Class/Sequence diagrams):
class UserController {
  constructor(userService) {}
  async getUser(id) {}
  async createUser(data) {}
}
```

#### Architecture Decision Process:

```
Decision Framework (TOGAF ADM):

1. Architecture Vision:
   "What are we trying to achieve?"
   
2. Business Architecture:  
   "What business capabilities do we need?"
   
3. Information Systems Architecture:
   "What data and applications support these capabilities?"
   
4. Technology Architecture:
   "What technology stack enables this?"
   
5. Opportunities & Solutions:
   "What are our options and their trade-offs?"
   
6. Migration Planning:
   "How do we get from current state to target state?"
   
7. Implementation Governance:
   "How do we ensure architecture compliance?"
   
8. Architecture Change Management:
   "How do we evolve the architecture?"
```

#### Documentation Strategies:

```
Living Documentation (Code as Documentation):
// Architecture tests document constraints
test('Services should not directly call each other', () => {
  const violations = findDirectServiceCalls();
  expect(violations).toHaveLength(0);
});

// API documentation from code
/**
 * @swagger
 * /users/{id}:
 *   get:
 *     summary: Get user by ID
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 */

Documentation as Code:
// Architecture decision records in Git
docs/
├── adr/
│   ├── 001-database-choice.md
│   ├── 002-microservices-strategy.md
│   └── 003-caching-approach.md
├── diagrams/
│   ├── context-diagram.puml
│   └── container-diagram.puml
└── runbooks/
    ├── incident-response.md
    └── deployment-guide.md

Architecture Characteristics Documentation:
┌─────────────────────────────────────────────────────────┐
│ Quality Attribute: Performance                          │
│ Measure: Response time < 200ms for 95% of requests     │
│ Current: 180ms average, 320ms 95th percentile          │
│ Target: 150ms average, 200ms 95th percentile           │
│ Architecture Support:                                   │
│ - Caching layer (Redis)                                │
│ - Database read replicas                               │
│ - CDN for static assets                                │
│ - Asynchronous processing for heavy operations         │
└─────────────────────────────────────────────────────────┘
```

#### Knowledge Sharing Strategies:

```
Architecture Guild Model:
[Chapter Leads] ──→ [Architecture Guild] ←── [Senior Engineers]
     │                     │                        │
     ↓                     ↓                        ↓
[Team A]              [Standards &              [Team B]
[Team C]               Guidelines]              [Team D]

Architecture Review Process:
┌─ Proposal ─→ Review ─→ Decision ─→ Implementation ─┐
│                │                                    │
└─ Feedback ←─ Monitor ←─ Document ←─ Communicate ←──┘

Types of Architecture Reviews:
1. Pre-Project Reviews (before major initiatives)
2. Mid-Project Reviews (architecture compliance)  
3. Post-Project Reviews (lessons learned)
4. Periodic Reviews (architecture health checks)

Architecture Mentorship:
Senior Architect ──mentors──→ Junior Developer
       │                           │
       ├─ Design Reviews            ├─ Shadow Architecture
       ├─ Code Reviews              ├─ Pair Programming  
       ├─ Architecture Katas        ├─ Tech Talks
       └─ Career Development        └─ Conference Attendance
```

---

## Заключение: Путь архитектора

### Уровни архитектурного мышления:

```
Junior Developer (Tactical):
"Как заставить код работать?"
[Problem] → [Code] → [Solution]

Focus: Syntax, algorithms, immediate bugs

Senior Developer (Design):  
"Как написать хороший код?"
[Problem] → [Design] → [Code] → [Solution]

Focus: Patterns, principles, maintainability

Software Architect (Strategic):
"Как создать систему, которая будет развиваться?"
[Context] → [Constraints] → [Architecture] → [Evolution]

Focus: Quality attributes, trade-offs, long-term vision

Enterprise Architect (Business):
"Как технологии поддерживают бизнес-цели?"
[Business Strategy] → [Technology Strategy] → [Implementation]

Focus: Business alignment, portfolio management, standards
```

### Эволюция архитектурного мышления:

```
Stage 1 - Code-Centric:
"Если это работает, значит архитектура хорошая"
Metrics: Lines of code, features delivered

Stage 2 - Design-Centric:
"Если код чистый, значит архитектура хорошая"  
Metrics: Code quality, design patterns usage

Stage 3 - Quality-Centric:
"Если система соответствует требованиям, архитектура хорошая"
Metrics: Performance, availability, maintainability

Stage 4 - Business-Centric:
"Если архитектура поддерживает бизнес-цели, она хорошая"
Metrics: Time to market, business agility, cost efficiency

Stage 5 - Ecosystem-Centric:
"Если архитектура адаптируется к изменениям, она хорошая"
Metrics: Evolutionary fitness, ecosystem health
```

### Принципы архитектурного мышления:

```
1. Контекст превыше всего:
   Нет универсальных решений, есть подходящие для ситуации
   
2. Компромиссы неизбежны:
   Каждое решение что-то улучшает и что-то ухудшает
   
3. Простота как цель:
   Сложность должна быть обоснована бизнес-ценностью
   
4. Эволюция, не революция:
   Большие изменения через серию маленьких шагов
   
5. Измеряй и проверяй:
   Architecture fitness functions > Architecture astronauts
   
6. Коммуникация критична:
   Лучшая архитектура бесполезна, если команда её не понимает
   
7. Учись постоянно:
   Технологии меняются, принципы остаются
```

### Карьерная траектория архитектора:

```
Архитектурные роли:

Technical Lead:
├── Team architecture decisions
├── Code review and mentoring  
├── Technical debt management
└── Technology choices for team

Solution Architect:
├── Multi-team system design
├── Integration architecture
├── Technology strategy
└── Stakeholder communication

Enterprise Architect:
├── Organization-wide standards
├── Technology portfolio management
├── Business-IT alignment  
└── Strategic planning

Domain Architect:
├── Deep domain expertise
├── Domain-specific patterns
├── Industry knowledge
└── Business process optimization

Cloud Architect:
├── Cloud-native architectures  
├── Multi-cloud strategies
├── Cloud migration planning
└── Cost optimization

Security Architect:
├── Security by design
├── Threat modeling
├── Compliance frameworks
└── Risk assessment
```

### Развитие архитектурных навыков:

```
Technical Skills (30%):
- Programming languages & frameworks
- Databases & data modeling
- Cloud platforms & infrastructure  
- DevOps & CI/CD
- Performance optimization

Design Skills (40%):
- Design patterns & principles
- System design & modeling
- API design
- Distributed systems concepts
- Architecture patterns

Soft Skills (30%):
- Communication & presentation
- Leadership & influence
- Business understanding
- Stakeholder management
- Decision making under uncertainty

Learning Path:
Year 1-2: Master technical fundamentals
Year 3-5: Learn design patterns and principles  
Year 6-8: Practice system design and trade-offs
Year 9+: Develop business acumen and leadership
```

### Архитектурные антипаттерны, которых стоит избегать:

```
Architecture Astronaut:
"Создаёт сложные решения для простых проблем"
Cure: Focus on business value, not technical elegance

Big Ball of Mud:
"Архитектура отсутствует, всё связано со всем"
Cure: Gradual refactoring, clear boundaries

Golden Hammer:
"Использует одно решение для всех проблем"
Cure: Learn diverse approaches, question assumptions

Resume Driven Development:
"Выбирает технологии для резюме, не для проекта"
Cure: Business-first thinking, technology-second

Analysis Paralysis:
"Бесконечно планирует, никогда не начинает"
Cure: MVP mindset, iterate and improve

NIH (Not Invented Here):
"Переизобретает велосипед вместо использования готовых решений"
Cure: Build vs buy analysis, focus on core competencies
```

### Дальнейший путь обучения:

```
Книги (Foundational):
├── "Clean Architecture" - Robert Martin
├── "Building Microservices" - Sam Newman  
├── "Designing Data-Intensive Applications" - Martin Kleppmann
├── "Software Architecture in Practice" - Bass, Clements, Kazman
└── "Enterprise Integration Patterns" - Hohpe, Woolf

Практика:
├── Architecture Katas (архитектурные упражнения)
├── Open Source проекты (анализ архитектуры)
├── System Design интервью
├── Tech talks и конференции
└── Менторство других разработчиков

Сообщества:
├── Software Architecture Monday (Mark Richards)
├── Architecture & Design InfoQ
├── C4 Model Community  
├── DDD Community
└── Local Software Architecture meetups

Специализации:
├── Cloud Architecture (AWS, Azure, GCP)
├── Data Architecture (Big Data, Analytics)
├── Security Architecture (Zero Trust, DevSecOps)
├── Mobile Architecture (React Native, Flutter)
└── AI/ML Architecture (MLOps, Model Serving)
```

### Финальные мысли:

```
Архитектура как искусство:
"Архитектура — это искусство делать сложное простым,
 а не простое сложным."

Архитектура как ремесло:
"Хорошая архитектура — результат тысяч маленьких решений,
 принятых правильно."

Архитектура как эволюция:
"Лучшие архитектуры растут, а не проектируются."

Архитектура как коммуникация:
"Архитектура — это не о коде, это о людях."
```

---

**Помни:** Архитектура — это не о том, чтобы предсказать будущее. Это о том, чтобы создать систему, которая сможет адаптироваться к непредсказуемому будущему.

**Удачи в вашем архитектурном путешествии! 🚀**

---

## Приложения

### Глоссарий архитектурных терминов

```
Abstraction - Скрытие сложности за простым интерфейсом
Aggregate - Кластер объектов, обрабатываемых как единое целое
Bounded Context - Граница, в которой модель имеет конкретное значение
Cohesion - Степень связанности элементов внутри модуля
Coupling - Степень зависимости между модулями
Domain Model - Модель, отражающая понимание предметной области
Event Sourcing - Хранение состояния как последовательность событий
Idempotency - Свойство операции давать одинаковый результат при повторении
Microservice - Небольшой, независимо развёртываемый сервис
Repository - Инкапсуляция логики доступа к данным
Saga - Паттерн управления длительными бизнес-транзакциями
```

### Чек-лист архитектурного ревью

```
Business Alignment:
☐ Архитектура поддерживает бизнес-цели
☐ Учтены ограничения времени и бюджета
☐ Определены приоритеты качественных атрибутов

Technical Quality:
☐ Ясные архитектурные границы
☐ Подходящие паттерны для решаемых проблем  
☐ Управляемые зависимости
☐ Планы тестирования и мониторинга

Risk Management:
☐ Определены архитектурные риски
☐ Есть планы митигации рисков
☐ Учтены нефункциональные требования
☐ Продуман план эволюции

Documentation:
☐ ADR для ключевых решений
☐ Диаграммы C4 актуальны
☐ Runbooks для операционных задач
☐ Знания переданы команде
```