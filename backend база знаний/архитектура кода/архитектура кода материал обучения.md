# Архитектура Backend: От новичка до эксперта

---

## Блок 1: Основы архитектурного мышления

### Глава 1: Что такое архитектура?

**Архитектура — это искусство принятия решений**, которые сложно изменить потом.

> **История:** В 1968 году проект IBM OS/360 превратился в кошмар. Фредерик Брукс позже напишет "Мифический человеко-месяц", где опишет, как отсутствие архитектурного мышления привело к провалу проекта стоимостью $5 млрд.

```
Плохая архитектура:        Хорошая архитектура:
    [Код] ←→ [База]           [API] ← [Logic] → [Data]
       ↕                         ↑       ↓
    [UI] ←→ [Auth]            [Auth]   [Cache]
```

**Ключевая идея:** Архитектура определяет, как легко добавлять новые фичи через год.

#### Архитектурные антипаттерны:

```
Big Ball of Mud:
[Everything] ←→ [Everything]
Результат: Каждое изменение ломает что-то еще

God Object:
[GodClass]
├── doEverything()
├── handleAllLogic()
└── manageAllData()
Результат: Невозможно изменить без риска

Spaghetti Code:
[Class1] ←→ [Class2] ←→ [Class3]
   ↕          ↕          ↕
[Class4] ←→ [Class5] ←→ [Class6]
Результат: Никто не понимает зависимости
```

### Глава 2: Качественные атрибуты системы

> **Метафора:** Архитектура как фундамент дома. Можно поменять обои (UI), но нельзя легко перенести несущие стены (архитектуру).

**Функциональные требования vs Качественные атрибуты:**

```
Функциональные (что система делает):
- Регистрация пользователей
- Обработка платежей  
- Отправка уведомлений

Качественные (как система это делает):
- Performance: < 200ms response time
- Availability: 99.9% uptime
- Security: защита от SQL injection
- Scalability: 10,000 concurrent users
- Maintainability: новая фича за 2 дня
```

**The Big Six качественных атрибутов:**

```
Performance ←────────→ Resource Usage
    ↑                        ↑
    │      Trade-offs         │
    ↓                        ↓
Security ←────────→ Usability
    ↑                        ↑
    │                        │
    ↓                        ↓
Maintainability ←──→ Scalability
```

**Золотое правило:** Нет универсально "лучших" решений, есть подходящие для контекста.

### Глава 3: SOLID принципы на архитектурном уровне

> **История:** Роберт Мартин сформулировал SOLID принципы в 2000-х, но их корни уходят к работам Дэвида Парнаса 1970-х о модульности.

#### Single Responsibility Principle (SRP)

```python
# ❌ Плохо - модуль с множественной ответственностью
class UserModule:
    def validate_user(self): pass  # причина изменения: новые правила валидации
    def save_user(self): pass      # причина изменения: смена БД
    def send_email(self): pass     # причина изменения: новый email провайдер
    def generate_report(self): pass # причина изменения: новый формат отчета

# ✅ Хорошо - один модуль, одна ответственность
class UserService:
    def __init__(self, email_service, report_service):
        self.email_service = email_service
        self.report_service = report_service
```

#### Dependency Inversion Principle (DIP)

```python
# ❌ Нарушение DIP
class OrderService:
    def __init__(self):
        self.db = MySQLDatabase()  # прямая зависимость
        self.email = SmtpEmail()   # прямая зависимость

# ✅ Соблюдение DIP  
class OrderService:
    def __init__(self, repository, notification_service):
        self.repository = repository           # зависимость на абстракцию
        self.notifications = notification_service # зависимость на абстракцию
```

### Глава 4: Связанность и сцепление

> **Метафора:** Хорошая архитектура как хорошо спроектированный город — районы независимы, но связаны понятными дорогами.

#### Типы coupling (связанности):

```
Content Coupling (самый плохой):
ModuleA читает/изменяет внутренние данные ModuleB

Common Coupling:
Модули используют глобальные переменные

Control Coupling:
ModuleA контролирует поведение ModuleB через флаги

Data Coupling (лучший):
Модули обмениваются только необходимыми данными
```

#### Закон Деметера на архитектурном уровне:

```python
# ❌ Нарушение
class OrderController:
    def process_order(self, order_id):
        order = self.order_service.get_order(order_id)
        order.get_customer().get_payment_method().charge(order.get_total())

# ✅ Соблюдение
class OrderController:
    def process_order(self, order_id):
        self.order_service.process_payment(order_id)
```

---

## Блок 2: Слоистая архитектура

### Глава 5: История и эволюция слоев

> **История:** Концепция слоев пришла из сетевых протоколов (OSI Model, 1984). Каждый слой решает свои задачи и предоставляет сервисы верхнему слою.

#### Эволюция архитектурных подходов:

```
1960s: Monolithic Programs
[Input] → [BigProgram] → [Output]

1970s: Structured Programming  
[Input] → [Module1] → [Module2] → [Output]

1980s: Object-Oriented Design
[Objects] ←→ [Objects] ←→ [Objects]

1990s: Layered Architecture
[UI] → [Business] → [Data]

2000s: Service-Oriented Architecture
[Service1] ←→ [Service2] ←→ [Service3]

2010s+: Microservices & Event-Driven
[Service] → [Events] → [Service]
     ↓                    ↓
  [Queue]              [Queue]
```

### Глава 6: Clean Architecture

> **История:** Роберт Мартин представил Clean Architecture в 2012, объединив идеи Hexagonal Architecture (Alistair Cockburn, 2005) и Onion Architecture (Jeffrey Palermo, 2008).

#### Концентрические круги зависимостей:

```
        ┌─────────────────────────────────────┐
        │     Frameworks & Drivers (Blue)    │ ← Web, DB, External APIs
        │  ┌─────────────────────────────────┐ │
        │  │  Interface Adapters (Green)     │ │ ← Controllers, Presenters
        │  │ ┌─────────────────────────────┐ │ │
        │  │ │     Use Cases (Red)         │ │ │ ← Application Business Rules
        │  │ │ ┌─────────────────────────┐ │ │ │
        │  │ │ │    Entities (Yellow)    │ │ │ │ ← Enterprise Business Rules
        │  │ │ └─────────────────────────┘ │ │ │
        │  │ └─────────────────────────────┘ │ │
        │  └─────────────────────────────────┘ │
        └─────────────────────────────────────┘
        
Зависимости направлены ВНУТРЬ - к бизнес-логике
```

#### Практический пример:

```python
# Clean Architecture  
class UserController:
    def __init__(self, create_user_use_case):
        self.create_user = create_user_use_case
    
    async def create(self, request):
        try:
            user_data = request.json
            user = await self.create_user.execute(user_data)
            return {"success": True, "user": user}
        except Exception as error:
            return {"error": str(error)}, 400

class CreateUserUseCase:
    def __init__(self, user_repository, email_service):
        self.users = user_repository
        self.email = email_service
    
    async def execute(self, user_data):
        user = User(user_data)
        user.validate()
        
        saved_user = await self.users.save(user)
        await self.email.send_welcome(saved_user.email)
        
        return saved_user
```

### Глава 7: Hexagonal Architecture (Ports & Adapters)

> **Метафора:** Приложение как крепость с воротами (ports). Внешний мир общается через ворота, но не знает, что происходит внутри.

#### Hexagonal структура:

```
                External World
                      │
              ┌───────▼───────┐
              │    Adapter    │ ← HTTP Controller
              └───────┬───────┘
                      │ Port (Interface)
              ┌───────▼───────┐
              │               │
         ┌────┤  Application  ├────┐
         │    │     Core      │    │
         │    │               │    │
         │    └───────┬───────┘    │
         │            │ Port       │
   ┌─────▼─────┐ ┌───▼───┐  ┌─────▼─────┐
   │  Database │ │  API  │  │   Email   │
   │  Adapter  │ │Adapter│  │  Adapter  │
   └───────────┘ └───────┘  └───────────┘
```

#### Ports vs Adapters:

```python
# Port (Интерфейс)
from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    async def save(self, user):
        pass
    
    @abstractmethod
    async def find_by_id(self, user_id):
        pass

# Adapter (Реализация)
class PostgreSQLUserRepository(UserRepository):
    async def save(self, user):
        # PostgreSQL-специфичная логика
        pass
    
    async def find_by_id(self, user_id):
        # PostgreSQL-специфичная логика  
        pass

class MongoUserRepository(UserRepository):
    async def save(self, user):
        # MongoDB-специфичная логика
        pass
```

---

## Блок 3: Domain-Driven Design

### Глава 8: Философия DDD

> **История:** Эрик Эванс ввел DDD в 2003 году, заметив, что технические решения часто не отражают бизнес-реальность.

#### От технического к доменному мышлению:

```
Technical Model:            Domain Model:
[UserTable]                [Customer] 
├── user_id                ├── customerId
├── first_name             ├── fullName  
├── last_name              ├── contactInfo
├── email                  ├── creditRating
├── phone                  ├── purchaseHistory
├── created_at             ├── loyaltyStatus
└── updated_at             └── preferences

Техническая модель отвечает на "как хранить"
Доменная модель отвечает на "что означает"
```

#### Ubiquitous Language (Единый язык):

```python
# ❌ Технический жаргон
class OrderService:
    def create_order(self, user_id, items):
        # Validate inventory and update stock
        pass

# ✅ Доменный язык
class Customer:
    def place_order(self, order_items):
        # Check availability and reserve products
        pass

class Product:
    def check_availability(self):
        pass
    
    def reserve(self, quantity):
        pass
```

#### Bounded Context (Ограниченный контекст):

```
Sales Context:              Support Context:
[Lead]                     [Ticket]
├── contactInfo            ├── issueDescription  
├── interests              ├── priority
├── probability            ├── category
└── assignedSalesman       └── assignedAgent
     ↓                           ↓
[Customer]                 [Customer]  
├── purchaseHistory        ├── supportHistory
├── creditLimit            ├── satisfactionRating
├── preferredPayment       ├── preferredContact
└── salesRepresentative    └── supportTier

Один Customer - разные модели в разных контекстах!
```

### Глава 9: Tactical Patterns DDD

#### Entity vs Value Object:

```python
# Entity (имеет идентичность)
class Customer:
    def __init__(self, customer_id, email):
        self.customer_id = customer_id  # Уникальный ID
        self.email = email             # Может измениться
    
    def __eq__(self, other):
        return self.customer_id == other.customer_id
    
    def change_email(self, new_email):
        self.email = new_email

# Value Object (определяется значением)
class Money:
    def __init__(self, amount, currency):
        self._amount = amount       # Неизменяемый
        self._currency = currency   # Неизменяемый
    
    def __eq__(self, other):
        return (self._amount == other._amount and 
                self._currency == other._currency)
    
    def add(self, other):
        if self._currency != other._currency:
            raise ValueError('Currency mismatch')
        return Money(self._amount + other._amount, self._currency)
```

#### Aggregate — граница консистентности:

```python
class Order:  # Aggregate Root
    def __init__(self, customer_id):
        self.id = generate_id()
        self.customer_id = customer_id
        self._items = []  # Внутренние entities
        self._status = OrderStatus.DRAFT
    
    def add_item(self, product_id, quantity, price):
        # Бизнес-правила применяются через Aggregate Root
        if self._status != OrderStatus.DRAFT:
            raise ValueError("Cannot modify confirmed order")
        
        item = OrderItem(product_id, quantity, price)
        self._items.append(item)
    
    def confirm(self):
        if not self._items:
            raise ValueError("Cannot confirm empty order")
        self._status = OrderStatus.CONFIRMED

# ❌ Плохо: прямое изменение item
# order_item_repository.update_quantity(item_id, new_quantity)

# ✅ Хорошо: через Aggregate Root
order = order_repository.find_by_id(order_id)
order.update_item_quantity(item_id, new_quantity)
order_repository.save(order)
```

---

## Блок 4: Архитектурные паттерны

### Глава 10: CQRS (Command Query Responsibility Segregation)

> **История:** Грег Янг популяризировал CQRS в 2010, основываясь на принципе CQS Бертрана Мейера (1988).

#### Принцип CQS:

```python
# ❌ Нарушение CQS
class User:
    def update_email_and_get_old_email(self, new_email):
        old_email = self.email
        self.email = new_email      # изменение
        self.last_updated = now()   # изменение
        return old_email            # запрос

# ✅ Соблюдение CQS
class User:
    def get_email(self):  # Только запрос
        return self.email
    
    def update_email(self, new_email):  # Только команда
        self.email = new_email
        self.last_updated = now()
```

#### Эволюция CQRS:

```
Простой CQRS:
[Client] ──Write──→ [CommandAPI] ──→ [WriteService] ──→ [Database]
   ↑                                                        │
   └────Read──── [QueryAPI] ←─── [ReadService] ←────────────┘

Продвинутый CQRS:
[Client] ──Write──→ [CommandAPI] ──→ [WriteService] ──→ [WriteDB]
   ↑                                       │
   │                                   [Events]
   │                                       ↓
   └────Read──── [QueryAPI] ←── [ReadService] ←── [ReadDB]
                                       ↑
                               [Event Handlers]
```

#### Практический пример:

```python
# Command Model
class CreateOrderCommand:
    def __init__(self, customer_id, items, shipping_address):
        self.customer_id = customer_id
        self.items = items
        self.shipping_address = shipping_address

class OrderCommandHandler:
    def __init__(self, order_repository, event_bus):
        self.order_repository = order_repository
        self.event_bus = event_bus
    
    async def handle(self, command):
        order = Order(command.customer_id)
        for item in command.items:
            order.add_item(item)
        order.set_shipping_address(command.shipping_address)
        
        await self.order_repository.save(order)
        await self.event_bus.publish(OrderCreated(order))

# Query Model
class OrderSummaryQuery:
    def __init__(self, customer_id, date_from, date_to):
        self.customer_id = customer_id
        self.date_from = date_from
        self.date_to = date_to

class OrderQueryHandler:
    def __init__(self, read_database):
        self.read_database = read_database
    
    async def handle(self, query):
        return await self.read_database.query(
            "SELECT o.id, o.total, o.status, c.name as customerName "
            "FROM order_summaries o "
            "JOIN customer_summaries c ON o.customer_id = c.id "
            "WHERE o.customer_id = ? AND o.date BETWEEN ? AND ?",
            [query.customer_id, query.date_from, query.date_to]
        )
```

### Глава 11: Event Sourcing

> **Метафора:** Как банковская выписка — вместо хранения текущего баланса храним все операции. Текущий баланс восстанавливается проигрыванием всех операций.

#### Традиционное хранение vs Event Sourcing:

```
Традиционное хранение (State Store):
User: { id: 123, balance: 1000, status: 'active', lastLogin: '2023-01-15' }

Event Sourcing (Event Store):
Events: [
  { timestamp: '2023-01-01', type: 'UserRegistered', userId: 123, email: 'user@example.com' },
  { timestamp: '2023-01-02', type: 'BalanceAdded', userId: 123, amount: 1000, source: 'initial' },
  { timestamp: '2023-01-10', type: 'PurchaseMade', userId: 123, amount: 250, productId: 456 },
  { timestamp: '2023-01-15', type: 'UserLoggedIn', userId: 123, ipAddress: '192.168.1.1' }
]

Current State = apply(events) = { balance: 750, status: 'active', lastLogin: '2023-01-15' }
```

#### Восстановление состояния:

```python
class UserAggregate:
    def __init__(self):
        self.id = None
        self.email = None
        self.is_active = False
        self.version = 0
    
    def apply(self, event):
        if event.type == 'UserCreated':
            self.id = event.data['userId']
            self.email = event.data['email']
            self.is_active = True
        elif event.type == 'EmailChanged':
            self.email = event.data['newEmail']
        elif event.type == 'UserDeactivated':
            self.is_active = False
        
        self.version = event.version
    
    @classmethod
    def from_events(cls, events):
        user = cls()
        for event in events:
            user.apply(event)
        return user
```

### Глава 12: Microservices Architecture

> **История:** Термин ввел Джеймс Льюис в 2011. Netflix стал пионером в применении микросервисов в production (2009-2012).

#### Эволюция масштабирования:

```
Monolith (1980s-2000s):
┌─────────────────────────────────────┐
│   [UI] → [Business Logic] → [DB]    │
└─────────────────────────────────────┘

Microservices (2010s+):
[UserService] ──HTTP/gRPC──→ [OrderService]
     ↓                           ↓
  [UserDB]                   [OrderDB]
     ↑                           ↑
[Event Bus] ←──────────────────────┘
```

#### Database per Service:

```python
# Проблема Shared Database
class UserService:
    def __init__(self):
        self.db = shared_database  # Tight coupling

class OrderService:
    def __init__(self):
        self.db = shared_database  # Same database!

# Решение: Database per Service
class UserService:
    def __init__(self):
        self.db = postgresql_user_db  # Собственная БД

class OrderService:
    def __init__(self):
        self.db = postgresql_order_db  # Своя БД

class AnalyticsService:
    def __init__(self):
        self.db = clickhouse_analytics_db  # Оптимизированная для аналитики
```

#### Saga Pattern для распределенных транзакций:

```python
# Choreography-based Saga
class PaymentService:
    async def handle_order_created(self, event):
        try:
            payment = await self.process_payment(event.customer_id, event.total)
            await self.event_bus.publish(PaymentProcessed(event.order_id, payment.id))
        except Exception as error:
            await self.event_bus.publish(PaymentFailed(event.order_id, str(error)))

class InventoryService:
    async def handle_payment_processed(self, event):
        order = await self.get_order_details(event.order_id)
        
        for item in order.items:
            await self.reserve_item(item.product_id, item.quantity)
        
        await self.event_bus.publish(InventoryReserved(event.order_id, order.items))
```

### Глава 13: Event-Driven Architecture

> **Метафора:** Как новостная лента в соцсетях — события происходят, заинтересованные подписчики реагируют. Издатель не знает, кто подписан.

#### Типы событий:

```
Domain Events (бизнес-события):
- CustomerRegistered
- OrderPlaced  
- PaymentProcessed
- ProductOutOfStock

Integration Events (технические события):
- UserDataSynced
- EmailSent
- CacheInvalidated
- DatabaseMigrated
```

#### Паттерны обработки событий:

```
Event Notification:
[Publisher] ──minimal event──→ [Subscriber]
                                   │
                                   └──queries for details──→ [Publisher]

Event-Carried State Transfer:
[Publisher] ──full state in event──→ [Subscriber]
                                         │
                                    stores locally
```

#### Choreography vs Orchestration:

```python
# Choreography (хореография)
class PaymentService:
    async def handle_order_placed(self, event):
        # Каждый сервис знает, как реагировать
        await self.process_payment(event.order_id)
        await self.event_bus.publish(PaymentProcessed(event.order_id))

# Orchestration (оркестрация)  
class ProcessOrderSaga:
    async def handle(self, order_id):
        # Центральный контроль процесса
        await self.payment_service.process_payment(order_id)
        await self.inventory_service.reserve_items(order_id)
        await self.shipping_service.schedule_delivery(order_id)
```

---

## Блок 5: Данные и производительность

### Глава 14: Data Architecture Patterns

#### Repository Pattern:

```python
# Active Record (проблематичный подход)
class User:
    def save(self):  # Domain logic mixed with persistence
        # writes to DB
        pass
    
    @staticmethod
    def find_by_email(email):  # queries DB
        pass

# Repository Pattern (правильный подход)
from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    async def find_active_customers(self):
        pass
    
    @abstractmethod
    async def find_customers_with_outstanding_orders(self):
        pass
    
    @abstractmethod
    async def save(self, customer):
        pass

class PostgreSQLUserRepository(UserRepository):
    async def find_active_customers(self):
        return await self.db.query(
            "SELECT * FROM customers WHERE status = 'active'"
        )
```

#### Unit of Work Pattern:

```python
class UnitOfWork:
    def __init__(self):
        self.new_objects = []
        self.dirty_objects = []  
        self.removed_objects = []
    
    def register_new(self, obj):
        self.new_objects.append(obj)
    
    def register_dirty(self, obj):
        self.dirty_objects.append(obj)
    
    async def commit(self):
        async with self.db.transaction():
            try:
                await self._insert_new()
                await self._update_dirty()
                await self._delete_removed()
            except Exception:
                raise

# Использование
uow = UnitOfWork()
uow.register_new(customer)
uow.register_dirty(order)
await uow.commit()  # Атомарная операция
```

### Глава 15: Caching Architecture

> **Метафора:** Кэш как записная книжка — часто используемую информацию держим под рукой.

#### Иерархия кэширования:

```
Browser Cache (1-60 seconds)
      ↓ (miss)
CDN Cache (1-60 minutes)  
      ↓ (miss)
Application Cache (5-30 minutes)
      ↓ (miss)
Database Query Cache (15-60 minutes)
      ↓ (miss)
Disk Storage
```

#### Стратегии кэширования:

```python
class CacheService:
    async def get_user(self, user_id):
        # Cache-Aside (Lazy Loading)
        cached_user = await self.cache.get(f"user:{user_id}")
        if cached_user:
            return cached_user
        
        user = await self.database.get_user(user_id)
        if user:
            await self.cache.set(f"user:{user_id}", user, ttl=3600)
        return user
    
    async def update_user(self, user):
        # Write-Through
        await self.cache.set(f"user:{user.id}", user, ttl=3600)
        await self.database.save_user(user)
```

#### Cache Stampede решение:

```python
import asyncio
from typing import Dict

class ProbabilisticCache:
    def __init__(self):
        self._locks: Dict[str, asyncio.Lock] = {}
    
    async def get(self, key):
        item = await self.cache.get(key)
        if not item:
            return None
        
        time_left = item['expiry'] - time.time()
        refresh_probability = 1 - (time_left / item['ttl'])
        
        if random.random() < refresh_probability:
            # Trigger background refresh
            asyncio.create_task(self._background_refresh(key))
        
        return item['value']
    
    async def _background_refresh(self, key):
        if key not in self._locks:
            self._locks[key] = asyncio.Lock()
        
        async with self._locks[key]:
            # Only one coroutine refreshes the cache
            fresh_value = await self._fetch_from_source(key)
            await self.cache.set(key, fresh_value)
```

### Глава 16: Performance Architecture

#### Масштабирование:

```
Vertical Scaling (Scale Up):
Server v1: [2 CPU, 4GB RAM] ──→ Server v2: [16 CPU, 64GB RAM]

Horizontal Scaling (Scale Out):
[Server1] ←──→ [Load Balancer] ←──→ [Server2]
   1000 RPS         ↕                1000 RPS  
                [Server3]
                 1000 RPS
Total: 3000 RPS
```

#### Database Sharding:

```python
import hashlib

class ShardedUserRepository:
    def __init__(self, shards):
        self.shards = shards  # Array of database connections
    
    def _get_shard_for_user(self, user_id):
        # Consistent hashing
        hash_value = int(hashlib.md5(str(user_id).encode()).hexdigest(), 16)
        shard_index = hash_value % len(self.shards)
        return self.shards[shard_index]
    
    async def find_by_id(self, user_id):
        shard = self._get_shard_for_user(user_id)
        return await shard.query(
            'SELECT * FROM users WHERE id = ?', 
            [user_id]
        )
    
    async def save(self, user):
        shard = self._get_shard_for_user(user.id)
        return await shard.query(
            'INSERT INTO users (id, email, name) VALUES (?, ?, ?)',
            [user.id, user.email, user.name]
        )
```

#### Асинхронная обработка:

```python
import asyncio
from enum import Enum

class JobStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"

class JobProcessor:
    def __init__(self, max_retries=3):
        self.max_retries = max_retries
    
    async def process_job(self, job):
        try:
            await self._execute_job(job)
            await self._mark_completed(job.id)
        except Exception as error:
            job.retry_count += 1
            
            if job.retry_count < self.max_retries:
                await self._requeue_with_delay(job)
            else:
                await self._send_to_dead_letter_queue(job, error)
```

---

## Блок 6: Архитектурная эволюция

### Глава 17: Architecture Assessment

#### Архитектурные метрики:

```
Code Quality Metrics:
- Coupling Metrics: Afferent Coupling (Ca), Efferent Coupling (Ce)
- Cohesion Metrics: Lines of Code per Class (< 200), Methods per Class (< 20)
- Dependency Metrics: Circular Dependencies (should be 0)

Technical Debt Metrics:
- Code Coverage < 70%
- Cyclomatic Complexity > 10
- Duplicated Code > 3%
- Bug Fix Time > Issue Creation Time
```

#### Architecture Decision Records (ADR):

```markdown
# ADR-001: Choice of Database Technology

**Status:** Accepted
**Date:** 2023-01-15

## Context
We need to choose a primary database for our e-commerce platform.
Requirements:
- ACID transactions for order processing
- Support for complex queries (reports)
- Team expertise availability

## Decision
Use PostgreSQL as primary database with read replicas for scaling.

## Consequences
+ Team can be productive immediately
+ Strong consistency guarantees
- Will need to plan for scaling challenges
```

#### Fitness Functions:

```python
def test_domain_independence():
    """Domain layer should not depend on Infrastructure"""
    domain_packages = analyze_packages('./src/domain')
    infrastructure_deps = [
        dep for pkg in domain_packages 
        for dep in pkg.dependencies 
        if dep.startswith('infrastructure')
    ]
    assert len(infrastructure_deps) == 0

async def test_api_performance():
    """API response time should be under 200ms"""
    start = time.time()
    await api_client.get('/users/123')
    duration = (time.time() - start) * 1000
    assert duration < 200
```

### Глава 18: Architecture Refactoring

#### Strangler Fig Pattern:

```python
class StranglerFigProxy:
    def __init__(self, legacy_service, new_service, feature_flags):
        self.legacy_service = legacy_service
        self.new_service = new_service
        self.feature_flags = feature_flags
    
    async def route_request(self, request):
        if self._should_route_to_new_service(request):
            return await self.new_service.handle(request)
        else:
            return await self.legacy_service.handle(request)
    
    def _should_route_to_new_service(self, request):
        return self.feature_flags.is_enabled('new-service', request.user_id)
```

#### Database Migration - Parallel Change:

```python
class DualWriteUserRepository:
    def __init__(self, old_repo, new_repo):
        self.old_repo = old_repo
        self.new_repo = new_repo
    
    async def save(self, user):
        # Dual writes during migration
        await self.old_repo.save(user)
        try:
            await self.new_repo.save(user)
        except Exception as e:
            # Log but don't fail - new system is not critical yet
            logger.warning(f"New repo write failed: {e}")
    
    async def find_by_id(self, user_id):
        # Read from new system, fallback to old
        try:
            user = await self.new_repo.find_by_id(user_id)
            if user:
                return user
        except Exception:
            pass
        
        return await self.old_repo.find_by_id(user_id)
```

### Глава 19: Evolution Architecture

#### Microservices Evolution Path:

```
Stage 1 - Identify Bounded Contexts:
[Monolith]
├── UserModule (high cohesion)
├── OrderModule (high cohesion)  
├── PaymentModule (high cohesion)
└── ReportModule (cross-cutting)

Stage 2 - Extract Low-Risk Services:
[Monolith] + [NotificationService] (stateless)
         + [ReportingService] (read-only)

Stage 3 - Extract Core Business Services:
[Monolith] + [UserService] + [OrderService] + [PaymentService]

Stage 4 - Break Down Remaining Monolith:
[APIGateway] → [UserService]
             → [OrderService]  
             → [PaymentService]
             → [InventoryService]
```

#### Service Extraction Priority:

```python
class ServiceExtractionStrategy:
    def prioritize_services(self, modules):
        """Prioritize modules for extraction based on risk/value"""
        scored_modules = []
        
        for module in modules:
            score = 0
            
            # Low risk factors (increase score)
            if module.is_stateless():
                score += 10
            if module.has_clear_boundaries():
                score += 8
            if module.is_read_only():
                score += 6
            
            # High value factors (increase score)  
            if module.has_different_scaling_needs():
                score += 8
            if module.enables_team_autonomy():
                score += 6
            
            # High risk factors (decrease score)
            if module.has_complex_dependencies():
                score -= 5
            if module.shares_data_extensively():
                score -= 8
            
            scored_modules.append((module, score))
        
        return sorted(scored_modules, key=lambda x: x[1], reverse=True)
```

### Глава 20: Architecture Documentation

#### C4 Model:

```
Level 1 - System Context:
[Customer] ──uses──→ [E-commerce System] ──→ [Payment Gateway]

Level 2 - Container Diagram:
┌─────────── E-commerce System ───────────┐
│ [Web App] ←→ [API Gateway] ←→ [Database] │
│     ↓             ↓              ↑      │
│ [Mobile App] [Background Jobs]   │      │
└─────────────────────────────────┼──────┘

Level 3 - Component Diagram:
┌─────────── API Gateway ──────────────┐
│ [UserController] ──→ [UserService]   │
│ [OrderController] ──→ [OrderService] │  
│         ↓                   ↓        │
│    [UserRepository] [OrderRepository]│
└──────────────────────────────────────┘
```

#### Living Documentation:

```python
def test_service_isolation():
    """Services should not directly call each other"""
    violations = find_direct_service_calls()
    assert len(violations) == 0, f"Found direct calls: {violations}"

def test_dependency_direction():
    """Dependencies should point toward domain core"""
    violations = find_inward_dependencies()
    assert len(violations) == 0, f"Found outward dependencies: {violations}"

class ArchitectureDocumentation:
    """
    Architecture characteristics documentation
    
    Quality Attribute: Performance
    Measure: Response time < 200ms for 95% of requests
    Current: 180ms average, 320ms 95th percentile
    Target: 150ms average, 200ms 95th percentile
    
    Architecture Support:
    - Caching layer (Redis)
    - Database read replicas
    - CDN for static assets
    - Asynchronous processing for heavy operations
    """
    pass
```

---

## Заключение: Путь архитектора

### Уровни архитектурного мышления:

```
Junior Developer (Tactical):
"Как заставить код работать?"
Focus: Syntax, algorithms, immediate bugs

Senior Developer (Design):  
"Как написать хороший код?"
Focus: Patterns, principles, maintainability

Software Architect (Strategic):
"Как создать систему, которая будет развиваться?"
Focus: Quality attributes, trade-offs, long-term vision

Enterprise Architect (Business):
"Как технологии поддерживают бизнес-цели?"
Focus: Business alignment, portfolio management
```

### Принципы архитектурного мышления:

1. **Контекст превыше всего:** Нет универсальных решений, есть подходящие для ситуации
2. **Компромиссы неизбежны:** Каждое решение что-то улучшает и что-то ухудшает
3. **Простота как цель:** Сложность должна быть обоснована бизнес-ценностью
4. **Эволюция, не революция:** Большие изменения через серию маленьких шагов
5. **Измеряй и проверяй:** Architecture fitness functions > Architecture astronauts
6. **Коммуникация критична:** Лучшая архитектура бесполезна, если команда её не понимает
7. **Учись постоянно:** Технологии меняются, принципы остаются

### Развитие архитектурных навыков:

```
Technical Skills (30%):
- Programming languages & frameworks
- Databases & data modeling
- Cloud platforms & infrastructure  
- Performance optimization

Design Skills (40%):
- Design patterns & principles
- System design & modeling
- API design
- Architecture patterns

Soft Skills (30%):
- Communication & presentation
- Leadership & influence
- Business understanding
- Decision making under uncertainty
```

### Архитектурные антипаттерны:

```python
# Architecture Astronaut
class OverEngineeredSolution:
    """Создаёт сложные решения для простых проблем"""
    pass

# Big Ball of Mud  
class NoArchitecture:
    """Архитектура отсутствует, всё связано со всем"""
    pass

# Golden Hammer
class OneToolForEverything:
    """Использует одно решение для всех проблем"""
    pass

# Resume Driven Development
class TechnologyShowoff:
    """Выбирает технологии для резюме, не для проекта"""
    pass
```

**Помни:** Архитектура — это не о том, чтобы предсказать будущее. Это о том, чтобы создать систему, которая сможет адаптироваться к непредсказуемому будущему.

---

## Дальнейшее обучение

### Рекомендуемые книги:
- "Clean Architecture" - Robert Martin
- "Building Microservices" - Sam Newman  
- "Designing Data-Intensive Applications" - Martin Kleppmann
- "Software Architecture in Practice" - Bass, Clements, Kazman

### Практика:
- Architecture Katas (архитектурные упражнения)
- Open Source проекты (анализ архитектуры)
- System Design интервью
- Менторство других разработчиков

### Специализации:
- Cloud Architecture (AWS, Azure, GCP)
- Data Architecture (Big Data, Analytics)
- Security Architecture (Zero Trust, DevSecOps)
- AI/ML Architecture (MLOps, Model Serving)

**Удачи в вашем архитектурном путешествии! 🚀**