# Блок 6: Производительность и безопасность Linux

**⏱️ Продолжительность:** 2-3 месяца  
**🎯 Цель:** Оптимизировать системы и обеспечить высокий уровень безопасности

---

## 🎯 Введение в блок

На этом этапе вы переходите от администрирования к экспертному уровню управления Linux-системами. Производительность и безопасность - это два краеугольных камня, на которых строится надежная IT-инфраструктура. 

**Философия блока:**
- Проактивный подход к мониторингу и оптимизации
- Глубокое понимание "узких мест" системы
- Многоуровневая модель безопасности
- Планирование на случай аварийных ситуаций

---

## 6.1 Тюнинг производительности системы

### Концепция системной производительности

Производительность Linux-системы - это баланс между четырьмя основными ресурсами:

```
    ┌─────────────────────────────────────┐
    │          СИСТЕМНЫЕ РЕСУРСЫ          │
    └─────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
    ┌───▼───┐       ┌───▼───┐       ┌───▼───┐
    │  CPU  │       │Memory │       │  I/O  │
    │Процес-│       │Память │       │Диски/ │
    │сор    │       │       │       │Сеть   │
    └───┬───┘       └───┬───┘       └───┬───┘
        │               │               │
        └───────────────┼───────────────┘
                        │
               ┌────────▼────────┐
               │   ПРИЛОЖЕНИЯ    │
               │   Пользователи  │
               └─────────────────┘
```

### Методология анализа производительности

**Принцип "USE Method" (Utilization, Saturation, Errors):**

```
Для каждого ресурса проверяем:
┌─────────────────────────────────────────┐
│ UTILIZATION (Использование)             │
│ ├─ Сколько времени ресурс занят?        │
│ └─ Цель: <70% для комфортной работы     │
├─────────────────────────────────────────┤
│ SATURATION (Насыщение)                  │
│ ├─ Есть ли очередь к ресурсу?           │
│ └─ Показатель: длина очереди, время     │
├─────────────────────────────────────────┤
│ ERRORS (Ошибки)                         │
│ ├─ Возникают ли ошибки при работе?      │
│ └─ Типы: timeout, retry, corruption     │
└─────────────────────────────────────────┘
```

### Анализ CPU производительности

**Архитектура современного процессора:**

```
┌─────────────────────────────────────────────────┐
│                    CPU                          │
├─────────────────────────────────────────────────┤
│  Core 1    │  Core 2    │  Core 3    │  Core 4  │
│  ┌─────┐   │  ┌─────┐   │  ┌─────┐   │  ┌─────┐ │
│  │ HT1 │   │  │ HT1 │   │  │ HT1 │   │  │ HT1 │ │
│  │ HT2 │   │  │ HT2 │   │  │ HT2 │   │  │ HT2 │ │
│  └─────┘   │  └─────┘   │  └─────┘   │  └─────┘ │
├─────────────────────────────────────────────────┤
│              L3 Cache (Shared)                  │
├─────────────────────────────────────────────────┤
│                Memory Controller                │
└─────────────────────────────────────────────────┘
```

**Типы нагрузки CPU:**
- **User Time** - выполнение пользовательских процессов
- **System Time** - работа ядра (системные вызовы, драйверы)
- **I/O Wait** - простой в ожидании операций ввода-вывода
- **Steal Time** - время "украденное" гипервизором (в виртуализации)

**Признаки проблем с CPU:**
- Load Average > количества CPU cores
- Высокий %sys (много системных вызовов)
- Высокий %iowait (медленные диски)

### Оптимизация памяти

**Иерархия памяти Linux:**

```
┌─────────────────────────────────────────┐
│           ИЕРАРХИЯ ПАМЯТИ               │
├─────────────────────────────────────────┤
│ L1 Cache      │ ~32KB    │ ~1 нс       │
│ L2 Cache      │ ~256KB   │ ~3 нс       │  
│ L3 Cache      │ ~8MB     │ ~12 нс      │
│ RAM           │ ~16GB    │ ~60 нс      │
│ SSD           │ ~500GB   │ ~100 мкс    │
│ HDD           │ ~2TB     │ ~10 мс      │
├─────────────────────────────────────────┤
│           ВИРТУАЛЬНАЯ ПАМЯТЬ            │
├─────────────────────────────────────────┤
│ Virtual Memory → Physical Memory        │
│      ↓                                  │
│ Page Tables (4KB страницы)              │
│      ↓                                  │
│ Swap (когда RAM заканчивается)          │
└─────────────────────────────────────────┘
```

**Управление памятью в Linux:**

```
┌─────────────┬─────────────┬─────────────┐
│    FREE     │   BUFFERS   │   CACHED    │
├─────────────┼─────────────┼─────────────┤
│ Свободная   │ Буферы для  │ Кэш файлов  │
│ память      │ блочных     │ и метаданных│
│             │ устройств   │             │
└─────────────┴─────────────┴─────────────┘
                     │
            ┌────────▼────────┐
            │   AVAILABLE     │
            │ (FREE+BUFFERS+  │
            │ RECLAIMABLE)    │
            └─────────────────┘
```

**Механизм OOM (Out of Memory) Killer:**

```
Нехватка памяти → OOM Killer активируется
        ↓
Анализ процессов по OOM Score:
- Размер используемой памяти
- Важность процесса (nice level)
- Время работы процесса
        ↓
Выбор "жертвы" → SIGKILL → Освобождение памяти
```

### Оптимизация дисковой подсистемы

**Архитектура дисковой подсистемы:**

```
┌─────────────────────────────────────────────────┐
│                APPLICATION                      │
├─────────────────────────────────────────────────┤
│                VFS (Virtual File System)        │
├─────────────────────────────────────────────────┤
│   ext4    │    xfs     │   btrfs   │   zfs     │
├─────────────────────────────────────────────────┤
│              Block Layer                        │
│  ┌─────────────────────────────────────────┐    │
│  │        I/O Schedulers                   │    │
│  │  CFQ  │  Deadline  │  NOOP  │  BFQ     │    │
│  └─────────────────────────────────────────┘    │
├─────────────────────────────────────────────────┤
│              Device Drivers                     │
├─────────────────────────────────────────────────┤
│   SATA   │   NVMe    │   SCSI    │   MD/LVM   │
└─────────────────────────────────────────────────┘
```

**Типы I/O операций:**

```
RANDOM I/O vs SEQUENTIAL I/O

Random (случайный доступ):
┌─────┬─────┬─────┬─────┬─────┐
│  3  │  1  │  5  │  2  │  4  │  ← Порядок чтения
└─────┴─────┴─────┴─────┴─────┘
  Медленно для HDD, быстро для SSD

Sequential (последовательный):
┌─────┬─────┬─────┬─────┬─────┐
│  1  │  2  │  3  │  4  │  5  │  ← Порядок чтения
└─────┴─────┴─────┴─────┴─────┘
  Быстро для всех типов дисков
```

**I/O Schedulers (планировщики ввода-вывода):**

- **CFQ (Complete Fair Queuing)** - справедливое распределение между процессами
- **Deadline** - минимизация задержек, гарантия выполнения в срок
- **NOOP** - простая FIFO очередь (идеален для SSD)
- **BFQ (Budget Fair Queuing)** - низкие задержки для интерактивных приложений

### Сетевая подсистема

**Стек сетевых протоколов:**

```
┌─────────────────────────────────────────┐
│         APPLICATION LAYER               │
│    HTTP, FTP, SSH, DNS, SMTP...         │
├─────────────────────────────────────────┤
│         TRANSPORT LAYER                 │
│          TCP, UDP, SCTP                 │
├─────────────────────────────────────────┤
│         NETWORK LAYER                   │
│        IP, ICMP, IGMP                   │
├─────────────────────────────────────────┤
│         DATA LINK LAYER                 │
│        Ethernet, WiFi                   │
├─────────────────────────────────────────┤
│         PHYSICAL LAYER                  │
│     Кабели, радиоволны                  │
└─────────────────────────────────────────┘
```

**Путь сетевого пакета в Linux:**

```
Сетевая карта → DMA → Ring Buffer → Soft IRQ
        ↓
Network Stack (netfilter hooks)
        ↓
Socket Buffer → Application
```

---

## 6.2 Анализ логов и troubleshooting

### Философия troubleshooting

**Методология решения проблем:**

```
┌─────────────────────────────────────────┐
│            ПРОБЛЕМА                     │
├─────────────────────────────────────────┤
│ 1. СБОР ИНФОРМАЦИИ                      │
│    ├─ Симптомы                          │
│    ├─ Время возникновения               │
│    ├─ Частота повторения                │
│    └─ Затронутые компоненты             │
├─────────────────────────────────────────┤
│ 2. ГИПОТЕЗЫ                             │
│    ├─ Возможные причины                 │
│    ├─ Приоритизация по вероятности      │
│    └─ План проверки                     │
├─────────────────────────────────────────┤
│ 3. ТЕСТИРОВАНИЕ                         │
│    ├─ Проверка гипотез                  │
│    ├─ Исключение ложных путей           │
│    └─ Сбор дополнительных данных        │
├─────────────────────────────────────────┤
│ 4. РЕШЕНИЕ                              │
│    ├─ Применение исправления            │
│    ├─ Проверка результата               │
│    └─ Документирование                  │
└─────────────────────────────────────────┘
```

### Система логирования в Linux

**Архитектура логирования:**

```
┌─────────────────────────────────────────────────┐
│                ПРИЛОЖЕНИЯ                       │
├─────────────────────────────────────────────────┤
│           Библиотеки логирования                │
│     syslog(), journal API, custom               │
├─────────────────────────────────────────────────┤
│              СИСТЕМЫ СБОРА                      │
│  ┌─────────────────┬─────────────────────────┐   │
│  │    rsyslog      │      systemd-journal   │   │
│  │   (традиц.)     │      (современный)     │   │
│  └─────────────────┴─────────────────────────┘   │
├─────────────────────────────────────────────────┤
│               ХРАНИЛИЩА                         │
│  /var/log/messages   │  /var/log/journal/...    │
│  /var/log/secure     │  binary format           │
│  /var/log/maillog    │  indexed, compressed     │
└─────────────────────────────────────────────────┘
```

**Уровни важности логов (syslog):**

```
┌─────────┬─────────────┬─────────────────────────┐
│ Уровень │ Код         │ Описание                │
├─────────┼─────────────┼─────────────────────────┤
│ emerg   │ 0          │ Система неработоспособна│
│ alert   │ 1          │ Требуется срочное вмеш. │
│ crit    │ 2          │ Критические ошибки      │
│ err     │ 3          │ Ошибки                  │
│ warning │ 4          │ Предупреждения          │
│ notice  │ 5          │ Нормальные, но важные   │
│ info    │ 6          │ Информационные          │
│ debug   │ 7          │ Отладочные сообщения    │
└─────────┴─────────────┴─────────────────────────┘
```

### systemd Journal

**Преимущества journald:**

```
┌─────────────────────────────────────────────────┐
│              JOURNALD vs SYSLOG                 │
├─────────────────────────────────────────────────┤
│ СТРУКТУРИРОВАННОСТЬ                             │
│ ├─ Бинарный формат с индексами                  │
│ ├─ Метаданные: PID, UID, время, приоритет      │
│ └─ Быстрый поиск и фильтрация                   │
├─────────────────────────────────────────────────┤
│ ИНТЕГРАЦИЯ                                      │
│ ├─ Прямая связь с systemd сервисами             │
│ ├─ Автоматическая ротация                       │
│ └─ Контроль целостности                         │
├─────────────────────────────────────────────────┤
│ БЕЗОПАСНОСТЬ                                    │
│ ├─ Защита от подделки логов                     │
│ ├─ Контроль доступа                             │
│ └─ Шифрование (опционально)                     │
└─────────────────────────────────────────────────┘
```

**Структура записи в journal:**

```
┌─────────────────────────────────────────────────┐
│                JOURNAL ENTRY                    │
├─────────────────────────────────────────────────┤
│ TIMESTAMP: 2024-01-15 14:30:25.123456          │
│ HOSTNAME: web-server-01                         │
│ SYSLOG_IDENTIFIER: nginx                        │
│ PID: 1234                                       │
│ UID: 33 (www-data)                              │
│ MESSAGE: 192.168.1.100 GET /api/users 200      │
│ PRIORITY: 6 (info)                              │
│ SYSTEMD_UNIT: nginx.service                     │
│ CODE_FILE: /usr/src/nginx/http_log.c            │
│ CODE_LINE: 425                                  │
└─────────────────────────────────────────────────┘
```

### Ротация логов

**Проблема роста логов:**

```
Без ротации:
┌─────────────────────────────────────────┐
│ /var/log/messages                       │
│ Size: 50MB → 500MB → 5GB → 50GB...      │
│ Результат: Переполнение диска           │
└─────────────────────────────────────────┘

С ротацией:
┌─────────────────────────────────────────┐
│ messages      ← Текущий (10MB)          │
│ messages.1    ← Вчерашний (сжат)        │
│ messages.2    ← Позавчерашний (сжат)    │
│ messages.3    ← 3 дня назад (сжат)      │
│ ...удаляются старые файлы               │
└─────────────────────────────────────────┘
```

**Стратегии ротации:**
- **По размеру** - когда файл достигает определенного размера
- **По времени** - ежедневно, еженедельно, ежемесячно
- **По количеству** - сколько старых файлов хранить
- **Сжатие** - gzip для экономии места

---

## 6.3 Сетевая безопасность

### Концепция Defense in Depth

**Многоуровневая защита:**

```
┌─────────────────────────────────────────────────┐
│                 ИНТЕРНЕТ                        │
├─────────────────────────────────────────────────┤
│ Уровень 1: ISP и внешние фильтры               │
├─────────────────────────────────────────────────┤
│ Уровень 2: Периметр (Router/Firewall)          │
├─────────────────────────────────────────────────┤
│ Уровень 3: DMZ (демилитаризованная зона)       │
├─────────────────────────────────────────────────┤
│ Уровень 4: Внутренняя сеть                      │
├─────────────────────────────────────────────────┤
│ Уровень 5: Host-based защита                    │
├─────────────────────────────────────────────────┤
│ Уровень 6: Приложения и данные                  │
└─────────────────────────────────────────────────┘
```

### Архитектура iptables

**Структура netfilter/iptables:**

```
┌─────────────────────────────────────────────────┐
│               NETFILTER HOOKS                   │
├─────────────────────────────────────────────────┤
│                                                 │
│  PREROUTING → ROUTING → FORWARD → POSTROUTING   │
│       │        DECISION    │           │        │
│       │                    │           │        │
│       ▼                    ▼           ▼        │
│   nat table            filter      nat table    │
│   mangle table         table       mangle table │
│                                                 │
│                        │                       │
│                        ▼                       │
│                   LOCAL INPUT                   │
│                        │                       │
│                        ▼                       │
│                  LOCAL PROCESS                  │
│                        │                       │
│                        ▼                       │
│                   LOCAL OUTPUT                  │
│                        │                       │
│                   nat table                     │
│                   filter table                  │
│                   mangle table                  │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Таблицы и цепочки iptables:**

```
┌─────────────────────────────────────────────────┐
│                    TABLES                       │
├─────────────────────────────────────────────────┤
│ FILTER (по умолчанию)                           │
│ ├─ INPUT: входящие пакеты                       │
│ ├─ FORWARD: транзитные пакеты                   │
│ └─ OUTPUT: исходящие пакеты                     │
├─────────────────────────────────────────────────┤
│ NAT (трансляция адресов)                        │
│ ├─ PREROUTING: изменение входящих               │
│ ├─ OUTPUT: изменение локальных исходящих        │
│ └─ POSTROUTING: изменение всех исходящих        │
├─────────────────────────────────────────────────┤
│ MANGLE (изменение заголовков)                   │
│ ├─ Изменение TOS, TTL                           │
│ └─ Маркировка пакетов                           │
├─────────────────────────────────────────────────┤
│ RAW (отключение connection tracking)            │
│ └─ Обход conntrack для производительности       │
└─────────────────────────────────────────────────┘
```

### Современные угрозы и защита

**Типы атак и методы защиты:**

```
┌─────────────────────────────────────────────────┐
│                 DDoS АТАКИ                      │
├─────────────────────────────────────────────────┤
│ Volumetric Attacks:                             │
│ ├─ UDP/ICMP flood                               │
│ ├─ Amplification (DNS, NTP)                     │
│ └─ Защита: Rate limiting, GeoIP фильтры         │
├─────────────────────────────────────────────────┤
│ Protocol Attacks:                               │
│ ├─ SYN flood, ACK flood                         │
│ ├─ Ping of Death                                │
│ └─ Защита: SYN cookies, connection limits       │
├─────────────────────────────────────────────────┤
│ Application Layer:                              │
│ ├─ HTTP flood, Slowloris                        │
│ ├─ Cache poisoning                              │
│ └─ Защита: WAF, Application-level filtering     │
└─────────────────────────────────────────────────┘
```

**Принципы построения правил firewall:**

```
Принцип "Default Deny":
┌─────────────────────────────────────────┐
│ 1. Запретить ВСЁ по умолчанию           │
│ 2. Разрешить только необходимое         │
│ 3. Логировать отклоненные соединения    │
│ 4. Регулярно пересматривать правила     │
└─────────────────────────────────────────┘

Структура правил:
┌─────────────────────────────────────────┐
│ ПОЛИТИКИ ПО УМОЛЧАНИЮ (DROP/REJECT)     │
├─────────────────────────────────────────┤
│ ANTI-SPOOFING ПРАВИЛА                   │
├─────────────────────────────────────────┤
│ ESTABLISHED/RELATED СОЕДИНЕНИЯ          │
├─────────────────────────────────────────┤
│ РАЗРЕШЕННЫЕ ВХОДЯЩИЕ СОЕДИНЕНИЯ         │
├─────────────────────────────────────────┤
│ РАЗРЕШЕННЫЕ ИСХОДЯЩИЕ СОЕДИНЕНИЯ        │
├─────────────────────────────────────────┤
│ ЛОГИРОВАНИЕ И ОТКЛОНЕНИЕ                │
└─────────────────────────────────────────┘
```

---

## 6.4 Системная безопасность

### Модель безопасности Linux

**Классическая модель DAC (Discretionary Access Control):**

```
┌─────────────────────────────────────────────────┐
│              СУБЪЕКТ → ОБЪЕКТ                   │
├─────────────────────────────────────────────────┤
│                                                 │
│  ПОЛЬЗОВАТЕЛЬ ────────→ ФАЙЛ/КАТАЛОГ            │
│       │                    │                   │
│       │                    ├─ Owner (rwx)      │
│   UID/GID ←────────────────├─ Group (rwx)      │
│   Primary/               │ └─ Other (rwx)      │
│   Secondary Groups       │                     │
│                         │                     │
│                         ▼                     │
│                   ПРАВА ДОСТУПА:               │
│                   r = read (4)                 │
│                   w = write (2)                │
│                   x = execute (1)              │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Ограничения классической модели:**
- Владелец имеет полный контроль
- Нет центрального управления политиками
- Сложно контролировать информационные потоки
- Уязвимо к атакам повышения привилегий

### SELinux (Security-Enhanced Linux)

**Архитектура SELinux:**

```
┌─────────────────────────────────────────────────┐
│             ПРИЛОЖЕНИЕ                          │
├─────────────────────────────────────────────────┤
│             СИСТЕМНЫЙ ВЫЗОВ                     │
├─────────────────────────────────────────────────┤
│   ┌─────────────────────────────────────────┐   │
│   │         LINUX KERNEL                    │   │
│   │  ┌───────────────┬─────────────────┐    │   │
│   │  │ LSM Framework │   SELinux       │    │   │
│   │  │               │   Security      │    │   │
│   │  │               │   Server        │    │   │
│   │  └───────────────┴─────────────────┘    │   │
│   └─────────────────────────────────────────┘   │
├─────────────────────────────────────────────────┤
│               РЕЗУЛЬТАТ                         │
│         ALLOW / DENY + AUDIT                    │
└─────────────────────────────────────────────────┘
```

**Концепции SELinux:**

```
┌─────────────────────────────────────────────────┐
│              SECURITY CONTEXT                  │
├─────────────────────────────────────────────────┤
│                                                 │
│  USER : ROLE : TYPE : LEVEL                     │
│    │      │      │       │                     │
│    │      │      │       └─ MLS/MCS уровень    │
│    │      │      └─ Основной атрибут           │
│    │      └─ Роль (какие типы доступны)        │
│    └─ SELinux пользователь                     │
│                                                 │
│  Пример:                                        │
│  unconfined_u:unconfined_r:unconfined_t:s0      │
│                                                 │
├─────────────────────────────────────────────────┤
│                ТИПЫ ДОМЕНОВ                     │
├─────────────────────────────────────────────────┤
│                                                 │
│  httpd_t ──────→ httpd_config_t                 │
│     │                   │                       │
│     │            (файлы конфигурации)           │
│     │                                           │
│     └─────────→ httpd_log_t                     │
│                       │                         │
│               (лог файлы)                       │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Режимы работы SELinux:**

```
┌─────────────────────────────────────────────────┐
│                  РЕЖИМЫ                         │
├─────────────────────────────────────────────────┤
│ ENFORCING                                       │
│ ├─ Политики применяются принудительно           │
│ ├─ Нарушения блокируются                        │
│ └─ Все действия логируются                      │
├─────────────────────────────────────────────────┤
│ PERMISSIVE                                      │
│ ├─ Политики НЕ применяются                      │
│ ├─ Нарушения разрешаются                        │
│ └─ Логируются как "would be denied"             │
├─────────────────────────────────────────────────┤
│ DISABLED                                        │
│ ├─ SELinux полностью отключен                   │
│ ├─ Никаких проверок                             │
│ └─ Требует перезагрузки для изменения           │
└─────────────────────────────────────────────────┘
```

### Управление сертификатами SSL/TLS

**Инфраструктура открытых ключей (PKI):**

```
┌─────────────────────────────────────────────────┐
│              ROOT CA                            │
│         (Корневой центр)                        │
│              │                                  │
│         [Root Cert]                             │
│              │                                  │
│    ┌─────────┴─────────┐                        │
│    │                   │                        │
│ INTERMEDIATE CA    INTERMEDIATE CA               │
│    │                   │                        │
│ [Int Cert]         [Int Cert]                   │
│    │                   │                        │
│    ├─ [Server Cert]    ├─ [Server Cert]         │
│    ├─ [Client Cert]    ├─ [Client Cert]         │
│    └─ [Code Sign]      └─ [Email Cert]          │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Жизненный цикл сертификата:**

```
┌─────────────────────────────────────────────────┐
│           ЖИЗНЕННЫЙ ЦИКЛ                        │
├─────────────────────────────────────────────────┤
│ 1. ГЕНЕРАЦИЯ КЛЮЧЕВОЙ ПАРЫ                      │
│    ├─ Приватный ключ (хранится секретно)        │
│    └─ Публичный ключ (включается в CSR)         │
├─────────────────────────────────────────────────┤
│ 2. СОЗДАНИЕ CSR (Certificate Signing Request)   │
│    ├─ Данные организации (DN)                   │
│    ├─ Доменные имена (SAN)                      │
│    └─ Публичный ключ                            │
├─────────────────────────────────────────────────┤
│ 3. ВАЛИДАЦИЯ И ПОДПИСАНИЕ                       │
│    ├─ Проверка права на домен                   │
│    ├─ Проверка организации (EV)                 │
│    └─ Выпуск сертификата                        │
├─────────────────────────────────────────────────┤
│ 4. УСТАНОВКА И НАСТРОЙКА                        │
│    ├─ Настройка веб-сервера                     │
│    ├─ Цепочка сертификатов                      │
│    └─ Настройка автообновления                  │
├─────────────────────────────────────────────────┤
│ 5. МОНИТОРИНГ И ОБНОВЛЕНИЕ                      │
│    ├─ Отслеживание срока действия               │
│    ├─ Автоматическое обновление                 │
│    └─ Отзыв при компрометации                   │
└─────────────────────────────────────────────────┘
```

---

## 6.5 Резервное копирование и восстановление

### Стратегия 3-2-1

**Правило 3-2-1:**

```
┌─────────────────────────────────────────────────┐
│               ПРАВИЛО 3-2-1                     │
├─────────────────────────────────────────────────┤
│                                                 │
│  3 ── Три копии данных                          │
│   │   ├─ Оригинал (рабочие данные)              │
│   │   ├─ Локальная копия                        │
│   │   └─ Удаленная копия                        │
│   │                                             │
│   ▼                                             │
│  2 ── На двух разных типах носителей            │
│   │   ├─ HDD + SSD                              │
│   │   ├─ Локальный + облачный                   │
│   │   └─ Разные производители                   │
│   │                                             │
│   ▼                                             │
│  1 ── Одна копия находится offsite              │
│       ├─ Другое здание                          │
│       ├─ Другой город                           │
│       └─ Облачное хранилище                     │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Типы резервного копирования

**Стратегии резервного копирования:**

```
┌─────────────────────────────────────────────────┐
│              ТИПЫ BACKUP                        │
├─────────────────────────────────────────────────┤
│                                                 │
│ FULL BACKUP (Полное)                            │
│ ├─ Все данные полностью                         │
│ ├─ Долго выполняется                            │
│ ├─ Много места на диске                         │
│ └─ Быстрое восстановление                       │
│                                                 │
│ INCREMENTAL (Инкрементальное)                   │
│ ├─ Только изменения с последнего backup         │
│ ├─ Быстрое выполнение                           │
│ ├─ Мало места                                   │
│ └─ Медленное восстановление (нужны все звенья)  │
│                                                 │
│ DIFFERENTIAL (Дифференциальное)                 │
│ ├─ Изменения с последнего FULL backup           │
│ ├─ Среднее время выполнения                     │
│ ├─ Среднее количество места                     │
│ └─ Среднее время восстановления                 │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Пример расписания backup:**

```
┌───┬───┬───┬───┬───┬───┬───┐
│ВС │ПН │ВТ │СР │ЧТ │ПТ │СБ │
├───┼───┼───┼───┼───┼───┼───┤
│ F │ I │ I │ I │ I │ I │ D │  ← Неделя 1
│ F │ I │ I │ I │ I │ I │ D │  ← Неделя 2  
│ F │ I │ I │ I │ I │ I │ D │  ← Неделя 3
│ F │ I │ I │ I │ I │ I │ D │  ← Неделя 4
└───┴───┴───┴───┴───┴───┴───┘

F = Full backup
I = Incremental backup  
D = Differential backup

Хранение:
- Full: 4 недели
- Incremental: 1 неделя
- Differential: 2 недели
```

### LVM Snapshots

**Концепция снапшотов:**

```
┌─────────────────────────────────────────────────┐
│              LVM SNAPSHOT                       │
├─────────────────────────────────────────────────┤
│                                                 │
│ ОРИГИНАЛЬНЫЙ VOLUME                             │
│ ┌─────────────────────────────────────────────┐ │
│ │ Block 1 │ Block 2 │ Block 3 │ Block 4     │ │
│ └─────────────────────────────────────────────┘ │
│           │                                     │
│           │ Создание snapshot                   │
│           ▼                                     │
│ SNAPSHOT VOLUME                                 │
│ ┌─────────────────────────────────────────────┐ │
│ │ Changed │ Changed │ Original│ Original    │ │
│ │ Block 1 │ Block 3 │ Block 2 │ Block 4     │ │
│ └─────────────────────────────────────────────┘ │
│                                                 │
│ Copy-on-Write механизм:                         │
│ 1. При изменении блока в оригинале              │
│ 2. Старое содержимое копируется в snapshot      │
│ 3. Новые данные записываются в оригинал         │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Преимущества LVM snapshots:**
- Мгновенное создание точки восстановления
- Консистентность данных на момент создания
- Возможность backup'а "живой" файловой системы
- Минимальное использование дискового пространства

---

## 6.6 Высокая доступность

### Концепция High Availability

**Уровни доступности:**

```
┌─────────────────────────────────────────────────┐
│            УРОВНИ ДОСТУПНОСТИ                   │
├─────────────────────────────────────────────────┤
│ 99%      ── 3.65 дней простоя в год             │
│ 99.9%    ── 8.76 часов простоя в год            │
│ 99.99%   ── 52.56 минут простоя в год           │
│ 99.999%  ── 5.26 минут простоя в год            │
│ 99.9999% ── 31.5 секунд простоя в год           │
├─────────────────────────────────────────────────┤
│         КОМПОНЕНТЫ ДОСТУПНОСТИ                  │
├─────────────────────────────────────────────────┤
│ Надежность    ── Как долго работает без сбоев   │
│ Готовность    ── Как быстро восстанавливается   │
│ Обслуживание  ── Как легко поддерживать         │
│ Производ-ть   ── Насколько быстро работает      │
└─────────────────────────────────────────────────┘
```

### Архитектура кластера

**Активно-пассивная конфигурация:**

```
┌─────────────────────────────────────────────────┐
│           ACTIVE-PASSIVE CLUSTER                │
├─────────────────────────────────────────────────┤
│                                                 │
│    ┌─────────────┐         ┌─────────────┐      │
│    │   NODE 1    │         │   NODE 2    │      │
│    │  (ACTIVE)   │◄──────► │ (STANDBY)   │      │
│    │             │         │             │      │
│    │ ┌─────────┐ │         │ ┌─────────┐ │      │
│    │ │  APP    │ │         │ │   APP   │ │      │
│    │ │RUNNING  │ │         │ │STOPPED  │ │      │
│    │ └─────────┘ │         │ └─────────┘ │      │
│    └─────────────┘         └─────────────┘      │
│            │                       │            │
│            │    HEARTBEAT           │            │
│            │ ◄─────────────────────► │            │
│            │                       │            │
│            ▼                       ▼            │
│    ┌─────────────────────────────────────────┐   │
│    │         SHARED STORAGE                  │   │
│    │     (SAN, NAS, DRBD)                    │   │
│    └─────────────────────────────────────────┘   │
│                                                 │
│ При сбое Node 1:                                │
│ 1. Node 2 обнаруживает отсутствие heartbeat     │
│ 2. Захватывает shared storage                   │
│ 3. Запускает приложение                         │
│ 4. Принимает IP адрес сервиса                   │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Активно-активная конфигурация:**

```
┌─────────────────────────────────────────────────┐
│           ACTIVE-ACTIVE CLUSTER                 │
├─────────────────────────────────────────────────┤
│                                                 │
│    ┌─────────────┐         ┌─────────────┐      │
│    │   NODE 1    │         │   NODE 2    │      │
│    │  (ACTIVE)   │◄──────► │  (ACTIVE)   │      │
│    │             │         │             │      │
│    │ ┌─────────┐ │         │ ┌─────────┐ │      │
│    │ │  APP A  │ │         │ │  APP B  │ │      │
│    │ │RUNNING  │ │         │ │RUNNING  │ │      │
│    │ └─────────┘ │         │ └─────────┘ │      │
│    └─────────────┘         └─────────────┘      │
│            │                       │            │
│            ▼                       ▼            │
│     ┌─────────────────────────────────────┐     │
│     │          LOAD BALANCER              │     │
│     │     (распределение нагрузки)        │     │
│     └─────────────────────────────────────┘     │
│                        │                        │
│                        ▼                        │
│              ┌─────────────────┐                 │
│              │     CLIENTS     │                 │
│              └─────────────────┘                 │
│                                                 │
│ Преимущества:                                   │
│ - Использование ресурсов обеих нод              │
│ - Лучшая производительность                     │
│ - Более сложная настройка                       │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Load Balancing

**Алгоритмы балансировки нагрузки:**

```
┌─────────────────────────────────────────────────┐
│          АЛГОРИТМЫ LOAD BALANCING               │
├─────────────────────────────────────────────────┤
│                                                 │
│ ROUND ROBIN                                     │
│ ├─ Запросы по очереди на каждый сервер          │
│ ├─ Простота реализации                          │
│ └─ Подходит для серверов одинаковой мощности    │
│                                                 │
│ WEIGHTED ROUND ROBIN                            │
│ ├─ Учитывает вес каждого сервера                │
│ ├─ Более мощные получают больше запросов        │
│ └─ Статическое распределение                    │
│                                                 │
│ LEAST CONNECTIONS                               │
│ ├─ Направляет на сервер с наименьшими связями   │
│ ├─ Динамическое распределение                   │
│ └─ Подходит для длительных соединений           │
│                                                 │
│ IP HASH                                         │
│ ├─ Хеш от IP клиента определяет сервер          │
│ ├─ Сохраняет привязку клиента к серверу         │
│ └─ Полезно для сессионных приложений            │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Disaster Recovery

**Планирование восстановления после аварий:**

```
┌─────────────────────────────────────────────────┐
│              DISASTER RECOVERY                  │
├─────────────────────────────────────────────────┤
│                                                 │
│ RTO (Recovery Time Objective)                   │
│ ├─ Максимальное время простоя                   │
│ ├─ Как быстро должны восстановиться             │
│ └─ Влияет на архитектуру и затраты              │
│                                                 │
│ RPO (Recovery Point Objective)                  │
│ ├─ Максимальная потеря данных                   │
│ ├─ Как часто делать backup                      │
│ └─ Влияет на частоту репликации                 │
│                                                 │
│ MTBF (Mean Time Between Failures)               │
│ ├─ Средняя наработка на отказ                   │
│ ├─ Показатель надежности                        │
│ └─ Используется для планирования                │
│                                                 │
│ MTTR (Mean Time To Repair)                      │
│ ├─ Среднее время восстановления                 │
│ ├─ Включает обнаружение + исправление           │
│ └─ Цель для улучшения процессов                 │
│                                                 │
└─────────────────────────────────────────────────┘
```

**Стратегии DR:**

```
┌─────────────────────────────────────────────────┐
│             DR СТРАТЕГИИ                        │
├─────────────────────────────────────────────────┤
│                                                 │
│ COLD SITE (Холодная площадка)                   │
│ ├─ Помещение + базовая инфраструктура           │
│ ├─ Низкая стоимость                             │
│ ├─ RTO: дни/недели                              │
│ └─ Подходит для некритичных систем              │
│                                                 │
│ WARM SITE (Теплая площадка)                     │
│ ├─ Частично настроенное оборудование            │
│ ├─ Средняя стоимость                            │
│ ├─ RTO: часы/дни                                │
│ └─ Компромисс между ценой и скоростью           │
│                                                 │
│ HOT SITE (Горячая площадка)                     │
│ ├─ Полностью готовая к работе площадка          │
│ ├─ Высокая стоимость                            │
│ ├─ RTO: минуты/часы                             │
│ └─ Для критически важных систем                 │
│                                                 │
│ CLOUD DR                                        │
│ ├─ Использование облачных провайдеров           │
│ ├─ Гибкие затраты (pay-as-you-use)             │
│ ├─ Быстрое масштабирование                      │
│ └─ Географическая распределенность              │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

## 🎯 Заключение блока

### Ключевые навыки после изучения блока

После освоения этого блока вы будете обладать экспертными знаниями в области:

**Производительность:**
- Системный анализ узких мест производительности
- Оптимизация CPU, памяти, дисковой и сетевой подсистем
- Тюнинг ядра Linux и файловых систем
- Профилирование и мониторинг приложений

**Безопасность:**
- Многоуровневая защита Linux-систем
- Настройка сетевых экранов и систем обнаружения вторжений
- Управление SSL/TLS сертификатами
- Работа с SELinux и системами принудительного контроля доступа

**Надежность:**
- Проектирование отказоустойчивых систем
- Стратегии резервного копирования и восстановления
- Построение высокодоступных кластеров
- Планирование аварийного восстановления

### Практические результаты

К концу изучения блока вы сможете:
- Диагностировать и устранять сложные проблемы производительности
- Проектировать и внедрять комплексные системы безопасности
- Обеспечивать 99.9%+ доступность критических сервисов
- Восстанавливать системы после серьезных аварий
- Создавать документацию по эксплуатации и аварийному восстановлению

### Переход к следующему блоку

Этот блок завершает техническую подготовку системного администратора Linux. В следующем блоке (Специализация и экспертиза) вы сможете:
- Выбрать направление для углубленной специализации
- Подготовиться к получению профессиональных сертификаций
- Развить навыки технического лидерства
- Стать признанным экспертом в выбранной области

**Помните:** Безопасность и производительность - это не разовые задачи, а непрерывные процессы, требующие постоянного внимания и совершенствования. Успех в этой области приходит через практику, анализ реальных инцидентов и постоянное обучение новым технологиям и методам.