# 📚 Блок 1: Основы языка и синтаксис

**⏱️ Длительность:** 2-3 месяца  
**🎯 Цель:** Освоить базовый синтаксис и фундаментальные концепции Go

---

## 1.1 Знакомство с Go

### История и философия языка

Go (или Golang) был создан в Google в 2007 году тремя выдающимися программистами: Робертом Гризмером, Робом Пайком и Кеном Томпсоном. Язык появился из необходимости решить проблемы, с которыми сталкивались разработчики Google при работе с большими системами.

#### Основные принципы Go:

```
Простота ────────────────── Читаемость кода
    │                           │
    │                           │
    ▼                           ▼
Быстрая компиляция ────── Эффективность выполнения
    │                           │
    │                           │
    ▼                           ▼
Встроенная конкурентность ── Надежность
```

**Философия Go можно выразить тремя словами:**
- **Простота** - минимум синтаксических конструкций
- **Ясность** - код должен быть понятен любому разработчику
- **Эффективность** - как времени разработки, так и выполнения

#### Почему Go особенный?

```
Традиционные языки:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Простота  │    │  Скорость   │    │Конкурентность│
│   (Python)  │    │    (C++)    │    │   (Erlang)  │
└─────────────┘    └─────────────┘    └─────────────┘

Go объединяет все три:
┌─────────────────────────────────────────────────────┐
│              Go Language                            │
│  ┌─────────┐  ┌─────────┐  ┌─────────────────┐     │
│  │Простота │  │ Скорость│  │  Конкурентность │     │
│  └─────────┘  └─────────┘  └─────────────────┘     │
└─────────────────────────────────────────────────────┘
```

### Установка Go и настройка окружения

Go следует принципу "Convention over Configuration" - соглашения важнее конфигурации.

#### Структура Go окружения:

```
GOPATH (исторически, до Go 1.11)
├── bin/          # Исполняемые файлы
├── pkg/          # Скомпилированные пакеты
└── src/          # Исходный код
    └── github.com/
        └── username/
            └── project/

Go Modules (современный подход, с Go 1.11+)
project-name/
├── go.mod        # Определение модуля
├── go.sum        # Контрольные суммы зависимостей
├── main.go       # Точка входа
└── internal/     # Внутренние пакеты
```

### Первая программа "Hello, World!"

Каждая Go программа начинается с объявления пакета. Пакет `main` особенный - он говорит компилятору, что это исполняемая программа, а не библиотека.

#### Анатомия Go программы:

```
package main ←─────────── Объявление пакета
     │
     ▼
import "fmt" ←─────────── Импорт зависимостей
     │
     ▼
func main() { ←────────── Точка входа
    fmt.Println("Hello, World!")
} ←────────────────────── Тело функции
```

**Важные концепции:**
- `package main` - обязательно для исполняемых программ
- `func main()` - функция, с которой начинается выполнение
- `fmt.Println` - функция для вывода с новой строкой

### Команды go

Go поставляется с мощным набором команд для разработки:

```
Go Toolchain
├── go run ────────── Компиляция и запуск "на лету"
├── go build ──────── Компиляция в исполняемый файл
├── go test ───────── Запуск тестов
├── go fmt ────────── Автоматическое форматирование
├── go vet ────────── Статический анализ кода
├── go mod ────────── Управление модулями
└── go get ────────── Загрузка зависимостей
```

---

## 1.2 Базовый синтаксис

### Переменные и константы

В Go есть несколько способов объявления переменных, каждый с своей областью применения.

#### Способы объявления переменных:

```
Полное объявление:
var name string = "John"
 │   │     │       │
 │   │     │       └── Значение
 │   │     └────────── Тип
 │   └──────────────── Имя переменной
 └──────────────────── Ключевое слово

Объявление с выводом типа:
var name = "John"  // Go сам определит тип string

Краткое объявление (только внутри функций):
name := "John"     // Самый популярный способ
```

#### Нулевые значения (Zero Values):

Go инициализирует все переменные нулевыми значениями, что делает код более предсказуемым:

```
Тип          │ Нулевое значение
─────────────┼─────────────────
int          │ 0
float64      │ 0.0
string       │ "" (пустая строка)
bool         │ false
pointer      │ nil
slice        │ nil
map          │ nil
channel      │ nil
interface    │ nil
```

#### Константы:

```
Объявление констант:
const Pi = 3.14159
const (
    StatusOK = 200
    StatusNotFound = 404
    StatusError = 500
)

Типизированные vs нетипизированные:
const typedPi float64 = 3.14159   // Типизированная
const untypedPi = 3.14159         // Нетипизированная (более гибкая)
```

### Базовые типы данных

Go имеет богатую систему типов, построенную на принципах простоты и эффективности.

#### Числовые типы:

```
Целые числа:
┌──────────────────────────────────────────┐
│  Знаковые    │  Беззнаковые  │ Размер   │
├──────────────┼───────────────┼──────────┤
│  int8        │  uint8        │ 8 бит    │
│  int16       │  uint16       │ 16 бит   │
│  int32       │  uint32       │ 32 бита  │
│  int64       │  uint64       │ 64 бита  │
│  int         │  uint         │ Зависит  │
│              │  uintptr      │ от архит.│
└──────────────┴───────────────┴──────────┘

Вещественные числа:
┌──────────────────────────────────────────┐
│  Тип         │  Точность     │ Размер   │
├──────────────┼───────────────┼──────────┤
│  float32     │  ~7 знаков    │ 32 бита  │
│  float64     │  ~15 знаков   │ 64 бита  │
└──────────────┴───────────────┴──────────┘
```

#### Строки и булевы значения:

```
string ────────── UTF-8 по умолчанию
  │               Неизменяемые (immutable)
  │               Могут содержать любые байты
  └─── "Hello, 世界"

bool ──────────── true или false
  │               Нулевое значение: false
  └─── Результат сравнений и логических операций
```

### Операторы

#### Арифметические операторы:

```
Математические операции:
┌─────────┬─────────┬────────────────────┐
│ Оператор│ Пример  │ Описание           │
├─────────┼─────────┼────────────────────┤
│    +    │  5 + 3  │ Сложение           │
│    -    │  5 - 3  │ Вычитание          │
│    *    │  5 * 3  │ Умножение          │
│    /    │  5 / 3  │ Деление            │
│    %    │  5 % 3  │ Остаток от деления │
└─────────┴─────────┴────────────────────┘

Специальные операторы:
++  ────── Инкремент (только постфиксный)
--  ────── Декремент (только постфиксный)
```

#### Операторы сравнения:

```
Сравнение значений:
┌─────────┬─────────┬────────────────┐
│ Оператор│ Пример  │ Результат      │
├─────────┼─────────┼────────────────┤
│   ==    │ 5 == 5  │ true           │
│   !=    │ 5 != 3  │ true           │
│   <     │ 3 < 5   │ true           │
│   <=    │ 5 <= 5  │ true           │
│   >     │ 5 > 3   │ true           │
│   >=    │ 5 >= 5  │ true           │
└─────────┴─────────┴────────────────┘
```

#### Логические операторы:

```
Булева алгебра:
┌─────────┬──────────────┬─────────────┐
│ Оператор│ Название     │ Пример      │
├─────────┼──────────────┼─────────────┤
│   &&    │ Логическое И │ true && false = false │
│   ||    │ Логическое ИЛИ │ true || false = true │
│   !     │ Логическое НЕ │ !true = false │
└─────────┴──────────────┴─────────────┘

Короткое замыкание:
a && b ─── Если a = false, b не вычисляется
a || b ─── Если a = true, b не вычисляется
```

### Область видимости переменных

Go использует блочную область видимости с четкими правилами:

```
Уровни области видимости:

Глобальный уровень (package level):
┌─────────────────────────────────────┐
│ package main                        │
│                                     │
│ var globalVar = "Видна везде"       │
│                                     │
│ Уровень функции:                    │
│ ┌─────────────────────────────────┐ │
│ │ func example() {                │ │
│ │     var funcVar = "В функции"   │ │
│ │                                 │ │
│ │     Уровень блока:              │ │
│ │     ┌─────────────────────────┐ │ │
│ │     │ if condition {          │ │ │
│ │     │     var blockVar = "Блок" │ │ │
│ │     │ }                       │ │ │
│ │     └─────────────────────────┘ │ │
│ │ }                               │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

**Правила области видимости:**
- Переменные доступны только в блоке, где объявлены
- Внутренние блоки могут "затенять" внешние переменные
- Переменные с заглавной буквы экспортируются из пакета

---

## 1.3 Структуры управления

### Условные операторы

Go упростил условные конструкции, оставив только самое необходимое.

#### Оператор if:

```
Базовый синтаксис:
if condition {
    // выполняется, если condition == true
}

Расширенный синтаксис:
if initialization; condition {
    // initialization выполняется один раз
    // condition проверяется
}

Пример потока выполнения:
┌─── if x > 0 ────┐
│                 │
▼                 ▼
true            false
│                 │
▼                 ▼
Выполнить       Пропустить
код блока       блок
```

#### Оператор if-else:

```
Ветвление логики:
if condition {
    // Путь A
} else {
    // Путь B
}

Множественные условия:
if condition1 {
    // Путь A
} else if condition2 {
    // Путь B
} else {
    // Путь C (по умолчанию)
}

Диаграмма выполнения:
    condition1?
    ┌───┴───┐
  true    false
    │       │
    ▼       ▼
   Путь A  condition2?
           ┌───┴───┐
         true    false
           │       │
           ▼       ▼
         Путь B  Путь C
```

#### Оператор switch:

```
Switch в Go более мощный, чем в других языках:

Базовый switch:
switch variable {
case value1:
    // код
case value2:
    // код
default:
    // код по умолчанию
}

Switch без переменной (как if-else):
switch {
case condition1:
    // код
case condition2:
    // код
default:
    // код
}

Особенности Go switch:
┌────────────────────────────────────┐
│ • Автоматический break             │
│ • Можно несколько значений в case  │
│ • Не нужны константы в case        │
│ • Type switch для интерфейсов      │
└────────────────────────────────────┘
```

### Циклы

В Go есть только один тип цикла - `for`, но он очень гибкий.

#### Формы цикла for:

```
1. Классический цикл:
for initialization; condition; post {
    // тело цикла
}

2. Цикл-условие (как while):
for condition {
    // тело цикла
}

3. Бесконечный цикл:
for {
    // бесконечное выполнение
    if someCondition {
        break
    }
}

4. Range цикл (для коллекций):
for index, value := range collection {
    // обход коллекции
}
```

#### Поток выполнения цикла:

```
Классический for цикл:
┌─── initialization ───┐
│                      │
▼                      │
┌─── condition? ───────┤
│        │             │
│      true            │
│        │             │
│        ▼             │
│   тело цикла         │
│        │             │
│        ▼             │
│     post ────────────┘
│        │
│      false
│        │
▼        ▼
  выход из цикла
```

#### Range цикл:

```
Range работает с различными типами:

Массивы и срезы:
for i, v := range []int{1, 2, 3} {
    // i - индекс, v - значение
}

Строки (по рунам):
for i, r := range "Hello" {
    // i - позиция байта, r - руна
}

Карты:
for k, v := range map[string]int{"a": 1} {
    // k - ключ, v - значение
}

Каналы:
for v := range channel {
    // v - значение из канала
}
```

### Операторы break, continue, goto

```
Операторы управления потоком:

break ────────── Выход из цикла или switch
    │
    ▼
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // Выход когда i == 5
    }
}

continue ────── Переход к следующей итерации
    │
    ▼
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue  // Пропуск четных чисел
    }
    // Обработка только нечетных
}

goto ─────────── Переход к метке (редко используется)
    │
    ▼
goto cleanup
// ...код...
cleanup:
    // код очистки
```

**Важные принципы:**
- `break` и `continue` работают только с циклами
- `goto` может нарушить структуру кода - используйте осторожно
- В Go нет операторов `while` и `do-while` - используйте `for`

---

## 1.4 Функции

Функции в Go - это граждане первого класса. Они могут присваиваться переменным, передаваться как параметры и возвращаться как значения.

### Объявление и вызов функций

#### Анатомия функции:

```
func functionName(parameters) returnType {
    // тело функции
    return value
}

Разбор по частям:
┌─── func ───┐  ┌─ parameters ─┐  ┌ returnType ┐
│            │  │              │  │           │
▼            ▼  ▼              ▼  ▼           ▼
func  calculateSum(a int, b int)  int         {
    return a + b
}
```

#### Типы функций:

```
1. Функция без параметров и возвращаемого значения:
func sayHello() {
    fmt.Println("Hello!")
}

2. Функция с параметрами:
func greet(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

3. Функция с возвращаемым значением:
func add(a, b int) int {
    return a + b
}

4. Функция с несколькими параметрами одного типа:
func calculate(a, b, c int) int {
    return a + b + c
}
```

### Множественные возвращаемые значения

Одна из уникальных особенностей Go - функции могут возвращать несколько значений.

#### Паттерн возврата значения и ошибки:

```
Типичная Go функция:
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}

Использование:
result, err := divide(10, 2)
if err != nil {
    // обработка ошибки
    return
}
// использование result
```

#### Диаграмма обработки ошибок:

```
Вызов функции
      │
      ▼
┌─ Функция выполнилась? ─┐
│                        │
▼                        ▼
Успешно                Ошибка
│                        │
▼                        ▼
result, nil            0, error
│                        │
▼                        ▼
Продолжить            Обработать
выполнение            ошибку
```

### Именованные возвращаемые значения

Go позволяет именовать возвращаемые значения, что делает код более читаемым.

```
Без именованных значений:
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}

С именованными значениями:
func divide(a, b float64) (result float64, err error) {
    if b == 0 {
        err = errors.New("деление на ноль")
        return  // "голый" return
    }
    result = a / b
    return
}

Преимущества именованных возвращаемых значений:
┌────────────────────────────────────────┐
│ • Самодокументируемый код              │
│ • Автоматическая инициализация нулевыми│
│   значениями                           │
│ • Возможность "голого" return          │
│ • Лучшая читаемость в сложных функциях │
└────────────────────────────────────────┘
```

### Вариативные функции

Функции могут принимать переменное количество параметров.

```
Объявление вариативной функции:
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

Использование:
result1 := sum(1, 2, 3)        // 6
result2 := sum(1, 2, 3, 4, 5)  // 15
result3 := sum()               // 0

Передача среза:
nums := []int{1, 2, 3, 4}
result := sum(nums...)  // Распаковка среза
```

#### Внутреннее устройство:

```
numbers ...int внутри функции становится []int

Вызов sum(1, 2, 3):
┌─────────────────────────────────┐
│ numbers = []int{1, 2, 3}        │
│                                 │
│ for _, num := range numbers {   │
│     total += num                │
│ }                               │
└─────────────────────────────────┘
```

### Анонимные функции и замыкания

Go поддерживает функции как значения первого класса.

#### Анонимные функции:

```
Объявление и немедленный вызов:
result := func(a, b int) int {
    return a + b
}(5, 3)  // result = 8

Присваивание переменной:
add := func(a, b int) int {
    return a + b
}
result := add(5, 3)  // result = 8
```

#### Замыкания:

```
Замыкание "захватывает" переменные из внешней области видимости:

func makeCounter() func() int {
    count := 0
    return func() int {
        count++  // захват переменной count
        return count
    }
}

Использование:
counter1 := makeCounter()
counter2 := makeCounter()

fmt.Println(counter1())  // 1
fmt.Println(counter1())  // 2
fmt.Println(counter2())  // 1 (независимый счетчик)
```

#### Диаграмма замыкания:

```
Внешняя функция makeCounter():
┌─────────────────────────────────────┐
│ count := 0                          │
│                                     │
│ Внутренняя функция:                 │
│ ┌─────────────────────────────────┐ │
│ │ func() int {                    │ │
│ │     count++  ← захват count     │ │
│ │     return count                │ │
│ │ }                               │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

**Ключевые концепции функций:**
- Функции - значения первого класса
- Множественные возвращаемые значения - идиоматичный способ обработки ошибок
- Вариативные функции обеспечивают гибкость API
- Замыкания позволяют создавать функции с состоянием

---

## 1.5 Массивы и срезы

### Массивы: объявление и использование

Массивы в Go имеют фиксированный размер, который является частью их типа.

#### Концепция массива:

```
Массив - это последовательность элементов одного типа:

┌───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │  ← Индексы
├───┼───┼───┼───┼───┤
│10 │20 │30 │40 │50 │  ← Значения
└───┴───┴───┴───┴───┘
  ↑               ↑
len=5           cap=5

Объявление массивов:
var arr1 [5]int                    // [0 0 0 0 0]
var arr2 = [5]int{1, 2, 3, 4, 5}   // [1 2 3 4 5]
var arr3 = [...]int{1, 2, 3}       // [1 2 3] (размер автоматически)
```

#### Особенности массивов:

```
Размер - часть типа:
┌─────────────────────────────────────┐
│ [3]int и [4]int - РАЗНЫЕ типы       │
│                                     │
│ var a [3]int                        │
│ var b [4]int                        │
│ // a = b  ← ОШИБКА компиляции       │
└─────────────────────────────────────┘

Массивы - значения:
┌─────────────────────────────────────┐
│ При присваивании копируются         │
│                                     │
│ a := [3]int{1, 2, 3}                │
│ b := a  // b получает КОПИЮ a       │
│ b[0] = 10                           │
│ // a остается [1, 2, 3]             │
└─────────────────────────────────────┘
```

### Срезы: создание, операции, внутреннее устройство

Срезы - это динамические массивы, более гибкие и часто используемые.

#### Внутреннее устройство среза:

```
Срез состоит из трех компонентов:
┌─────────────────────────────────────┐
│ Структура среза:                    │
│                                     │
│ ┌─────────┐                         │
│ │ pointer │ ──────┐                 │
│ ├─────────┤       │                 │
│ │ length  │       │ Базовый массив: │
│ ├─────────┤       ▼                 │
│ │capacity │ ┌───┬───┬───┬───┬───┐   │
│ └─────────┘ │ 1 │ 2 │ 3 │ 4 │ 5 │   │
│             └───┴───┴───┴───┴───┘   │
│               ↑─ len=3 ─↑           │
│               ↑──── cap=5 ────↑     │
└─────────────────────────────────────┘
```

#### Создание срезов:

```
Способы создания срезов:

1. Литерал среза:
s1 := []int{1, 2, 3, 4, 5}

2. Из массива:
arr := [5]int{1, 2, 3, 4, 5}
s2 := arr[1:4]  // [2, 3, 4]

3. Функция make:
s3 := make([]int, 3)     // len=3, cap=3, [0, 0, 0]
s4 := make([]int, 3, 5)  // len=3, cap=5, [0, 0, 0]

4. Нулевой срез:
var s5 []int  // nil срез, len=0, cap=0
```

#### Операции среза (slicing):

```
Синтаксис: slice[start:end:capacity]

Исходный срез: [1, 2, 3, 4, 5]
                0  1  2  3  4  ← индексы

s[1:4]    → [2, 3, 4]       // с 1 по 3 включительно
s[:3]     → [1, 2, 3]       // с начала до 2 включительно  
s[2:]     → [3, 4, 5]       // с 2 до конца
s[:]      → [1, 2, 3, 4, 5] // полная копия ссылки

Расширенный синтаксис:
s[1:3:4]  → срез с start=1, end=3, capacity=4-1=3
```

### Функции make, append, copy

#### Функция make:

```
make создает срезы с определенными параметрами:

make([]T, length)           // capacity = length
make([]T, length, capacity) // явное указание capacity

Диаграмма памяти:
make([]int, 3, 5):
┌─────────┐     ┌───┬───┬───┬───┬───┐
│ pointer │────▶│ 0 │ 0 │ 0 │   │   │
├─────────┤     └───┴───┴───┴───┴───┘
│ len: 3  │           ↑─len─↑
├─────────┤           ↑──cap──↑
│ cap: 5  │
└─────────┘
```

#### Функция append:

```
append добавляет элементы в конец среза:

s := []int{1, 2, 3}
s = append(s, 4)        // [1, 2, 3, 4]
s = append(s, 5, 6, 7)  // [1, 2, 3, 4, 5, 6, 7]

Поведение при превышении capacity:
┌─────────────────────────────────────┐
│ Если len + новые элементы > cap:    │
│                                     │
│ 1. Создается новый массив           │
│ 2. Копируются старые элементы       │
│ 3. Добавляются новые элементы       │
│ 4. Capacity увеличивается (обычно×2)│
└─────────────────────────────────────┘

Пример роста capacity:
cap=2 → cap=4 → cap=8 → cap=16 → ...
```

#### Функция copy:

```
copy копирует элементы между срезами:

src := []int{1, 2, 3, 4, 5}
dst := make([]int, 3)
n := copy(dst, src)  // n=3, dst=[1, 2, 3]

Правила copy:
┌─────────────────────────────────────┐
│ • Копирует min(len(dst), len(src))  │
│ • Возвращает количество скопированных│
│ • Срезы могут перекрываться         │
│ • Безопасно для копирования в себя  │
└─────────────────────────────────────┘

Перекрывающиеся срезы:
s := []int{1, 2, 3, 4, 5}
copy(s[2:], s[1:])  // [1, 2, 2, 3, 4]
```

### Многомерные массивы и срезы

#### Двумерные массивы:

```
Объявление многомерного массива:
var matrix [3][4]int  // 3 строки, 4 столбца

Инициализация:
matrix := [3][4]int{
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
}

Визуализация:
     Col 0  Col 1  Col 2  Col 3
   ┌─────┬─────┬─────┬─────┐
Row 0│  1  │  2  │  3  │  4  │
   ├─────┼─────┼─────┼─────┤
Row 1│  5  │  6  │  7  │  8  │
   ├─────┼─────┼─────┼─────┤
Row 2│  9  │ 10  │ 11  │ 12  │
   └─────┴─────┴─────┴─────┘
```

#### Двумерные срезы:

```
Срез срезов:
matrix := [][]int{
    {1, 2, 3},
    {4, 5},
    {6, 7, 8, 9},
}

Внутреннее устройство:
┌─────────┐     ┌─────────┐
│ matrix  │────▶│ slice 0 │────▶ [1, 2, 3]
└─────────┘     ├─────────┤
                │ slice 1 │────▶ [4, 5]
                ├─────────┤
                │ slice 2 │────▶ [6, 7, 8, 9]
                └─────────┘

Создание "правильной" матрицы:
rows, cols := 3, 4
matrix := make([][]int, rows)
for i := range matrix {
    matrix[i] = make([]int, cols)
}
```

**Важные концепции массивов и срезов:**
- Массивы имеют фиксированный размер и копируются по значению
- Срезы - это ссылки на базовый массив с динамическим размером
- `append` может вызвать перевыделение памяти
- `copy` безопасно для перекрывающихся срезов
- Многомерные структуры данных строятся из одномерных

---

## 1.6 Карты (maps)

Карты в Go - это хеш-таблицы, предоставляющие быстрый доступ к данным по ключу.

### Создание и инициализация карт

#### Концепция карты:

```
Карта связывает ключи со значениями:

┌─────────────────────────────────────┐
│        Карта map[string]int         │
│                                     │
│ "apple"  ──────────────▶ 5          │
│ "banana" ──────────────▶ 3          │
│ "orange" ──────────────▶ 8          │
│                                     │
│ ключ (string) ───▶ значение (int)   │
└─────────────────────────────────────┘
```

#### Способы создания карт:

```
1. Объявление с инициализацией:
fruits := map[string]int{
    "apple":  5,
    "banana": 3,
    "orange": 8,
}

2. Создание пустой карты:
var m1 map[string]int           // nil карта (только чтение)
m2 := make(map[string]int)      // пустая карта (можно записывать)
m3 := map[string]int{}          // пустая карта

3. Создание с начальной емкостью:
m4 := make(map[string]int, 10)  // подсказка о размере
```

#### Нулевое значение карты:

```
Жизненный цикл карты:
┌─────────────────────────────────────┐
│ var m map[string]int                │
│ ┌─────────────────────────────────┐ │
│ │ m == nil                        │ │
│ │ len(m) == 0                     │ │
│ │ m["key"] возвращает нулевое     │ │
│ │ значение                        │ │
│ │ m["key"] = value → ПАНИКА!      │ │
│ └─────────────────────────────────┘ │
│                                     │
│ m = make(map[string]int)            │
│ ┌─────────────────────────────────┐ │
│ │ m != nil                        │ │
│ │ len(m) == 0                     │ │
│ │ m["key"] = value → OK           │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### Добавление, изменение, удаление элементов

#### Основные операции:

```
m := make(map[string]int)

Добавление/изменение:
m["apple"] = 5      // Добавление нового элемента
m["apple"] = 10     // Изменение существующего

Чтение:
value := m["apple"] // Получение значения
                   // Если ключа нет, возвращается нулевое значение

Удаление:
delete(m, "apple")  // Удаление элемента
delete(m, "missing") // Безопасно удалять несуществующий ключ

Получение длины:
length := len(m)    // Количество пар ключ-значение
```

### Проверка существования ключа

Go предоставляет элегантный способ проверки существования ключа:

```
Синтаксис двойного присваивания:
value, exists := m["key"]

┌─────────────────────────────────────┐
│ value  ─ значение по ключу          │
│ exists ─ true если ключ существует, │
│          false если нет             │
└─────────────────────────────────────┘

Паттерны использования:

1. Проверка с использованием значения:
if value, exists := m["key"]; exists {
    fmt.Printf("Значение: %d\n", value)
} else {
    fmt.Println("Ключ не найден")
}

2. Проверка только существования:
if _, exists := m["key"]; exists {
    fmt.Println("Ключ существует")
}

3. Проверка отсутствия:
if _, exists := m["key"]; !exists {
    m["key"] = defaultValue
}
```

### Итерация по картам

#### Range цикл для карт:

```
m := map[string]int{
    "apple":  5,
    "banana": 3,
    "orange": 8,
}

Итерация по ключам и значениям:
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

Только ключи:
for key := range m {
    fmt.Printf("Ключ: %s\n", key)
}

Только значения:
for _, value := range m {
    fmt.Printf("Значение: %d\n", value)
}
```

#### Важные особенности итерации:

```
Порядок итерации СЛУЧАЙНЫЙ:
┌─────────────────────────────────────┐
│ Каждый запуск программы может       │
│ выдать разный порядок ключей        │
│                                     │
│ Запуск 1: apple, banana, orange     │
│ Запуск 2: orange, apple, banana     │
│ Запуск 3: banana, orange, apple     │
└─────────────────────────────────────┘

Для стабильного порядка:
keys := make([]string, 0, len(m))
for key := range m {
    keys = append(keys, key)
}
sort.Strings(keys)

for _, key := range keys {
    fmt.Printf("%s: %d\n", key, m[key])
}
```

#### Безопасная модификация во время итерации:

```
Безопасные операции во время range:
┌─────────────────────────────────────┐
│ ✅ Добавление новых элементов       │
│ ✅ Изменение существующих значений  │
│ ✅ Удаление ТЕКУЩЕГО элемента       │
│ ❌ Удаление других элементов        │
└─────────────────────────────────────┘

Безопасное удаление:
toDelete := []string{}
for key, value := range m {
    if value < 5 {
        toDelete = append(toDelete, key)
    }
}
for _, key := range toDelete {
    delete(m, key)
}
```

#### Сравнение карт:

```
Карты нельзя сравнивать напрямую:
┌─────────────────────────────────────┐
│ m1 := map[string]int{"a": 1}        │
│ m2 := map[string]int{"a": 1}        │
│ // m1 == m2  ← ОШИБКА компиляции    │
└─────────────────────────────────────┘

Можно сравнивать только с nil:
var m map[string]int
if m == nil {
    fmt.Println("Карта не инициализирована")
}

Функция для сравнения карт:
func mapsEqual(m1, m2 map[string]int) bool {
    if len(m1) != len(m2) {
        return false
    }
    for key, value := range m1 {
        if m2[key] != value {
            return false
        }
    }
    return true
}
```

**Ключевые концепции карт:**
- Карты - это ссылочные типы
- Нулевое значение карты - `nil`
- Порядок итерации случайный
- Ключи должны быть сравнимыми типами
- Операции с картами не являются потокобезопасными

---

## 1.7 Строки и руны

### Работа со строками

Строки в Go имеют особое устройство, связанное с поддержкой Unicode.

#### Внутреннее представление строк:

```
Строка в Go - это неизменяемый срез байт:

"Hello" представляется как:
┌───┬───┬───┬───┬───┐
│'H'│'e'│'l'│'l'│'o'│
├───┼───┼───┼───┼───┤
│72 │101│108│108│111│ ← ASCII коды
└───┴───┴───┴───┴───┘
 0   1   2   3   4  ← Индексы байт

len("Hello") = 5 байт
```

#### Основные операции со строками:

```
s := "Hello, World!"

Длина строки (в байтах):
length := len(s)  // 13

Доступ к байту по индексу:
b := s[0]  // 72 ('H')

Срез строки:
substr := s[7:12]  // "World"
substr := s[:5]    // "Hello"
substr := s[7:]    // "World!"

Конкатенация:
greeting := "Hello, " + "World!"
```

#### Неизменяемость строк:

```
Строки неизменяемы:
┌─────────────────────────────────────┐
│ s := "Hello"                        │
│ // s[0] = 'h'  ← ОШИБКА компиляции  │
│                                     │
│ Для изменения нужно создать новую:  │
│ s = "h" + s[1:]  // "hello"         │
└─────────────────────────────────────┘

Эффективное построение строк:
var builder strings.Builder
builder.WriteString("Hello")
builder.WriteString(", ")
builder.WriteString("World!")
result := builder.String()  // "Hello, World!"
```

### UTF-8 и руны

Go использует UTF-8 кодировку по умолчанию, что усложняет работу с Unicode символами.

#### Концепция руны:

```
Руна (rune) = символ Unicode = int32

"Hello, 世界" анализ:
┌─────────────────────────────────────┐
│ Байты:   H  e  l  l  o  ,     世  界│
│ Позиции: 0  1  2  3  4  5  6  7-9 10-12│
│ Руны:    H  e  l  l  o  ,     世   界│
│ Индексы: 0  1  2  3  4  5  6   7    8 │
└─────────────────────────────────────┘

len("Hello, 世界") = 13 байт
utf8.RuneCountInString("Hello, 世界") = 9 рун
```

#### Итерация по строке:

```
s := "Hello, 世界"

По байтам:
for i := 0; i < len(s); i++ {
    fmt.Printf("%d: %c\n", i, s[i])
}
// Проблема: многобайтовые символы разбиваются

По рунам (правильный способ):
for i, r := range s {
    fmt.Printf("%d: %c\n", i, r)
}
// i - позиция байта начала руны
// r - сама руна (int32)

Только руны:
for _, r := range s {
    fmt.Printf("%c ", r)
}
```

#### Преобразование между строками и рунами:

```
Строка в срез рун:
s := "Hello, 世界"
runes := []rune(s)
fmt.Println(len(runes))  // 9

Срез рун в строку:
runes[0] = 'h'  // Изменяем первую руну
newS := string(runes)  // "hello, 世界"

Отдельная руна в строку:
r := '世'
s := string(r)  // "世"
```

### Пакет strings

Пакет `strings` предоставляет множество функций для работы со строками.

#### Основные функции поиска и проверки:

```
s := "Hello, World!"

Проверка содержания:
strings.Contains(s, "World")     // true
strings.HasPrefix(s, "Hello")    // true
strings.HasSuffix(s, "!")        // true

Поиск подстроки:
strings.Index(s, "World")        // 7
strings.LastIndex(s, "l")        // 10
strings.Count(s, "l")            // 3

Регистр:
strings.ToLower(s)               // "hello, world!"
strings.ToUpper(s)               // "HELLO, WORLD!"
strings.Title(s)                 // "Hello, World!"
```

#### Функции разделения и объединения:

```
Разделение строк:
csv := "apple,banana,orange"
fruits := strings.Split(csv, ",")
// []string{"apple", "banana", "orange"}

fields := strings.Fields("  hello   world  ")
// []string{"hello", "world"}

Объединение строк:
fruits := []string{"apple", "banana", "orange"}
result := strings.Join(fruits, " and ")
// "apple and banana and orange"
```

#### Функции замены и обрезки:

```
s := "  Hello, World!  "

Замена:
strings.Replace(s, "World", "Go", 1)    // "  Hello, Go!  "
strings.ReplaceAll(s, "l", "L")         // "  HeLLo, WorLd!  "

Обрезка:
strings.TrimSpace(s)                    // "Hello, World!"
strings.Trim(s, " !")                   // "Hello, World"
strings.TrimPrefix(s, "  Hello")        // ", World!  "
strings.TrimSuffix(s, "!  ")            // "  Hello, World"
```

### Форматирование строк

#### Пакет fmt для форматирования:

```
Основные глаголы форматирования:
┌─────────┬─────────────────────────────┐
│ Глагол  │ Описание                    │
├─────────┼─────────────────────────────┤
│   %v    │ Значение в формате по умолч.│
│   %+v   │ Значение с именами полей    │
│   %#v   │ Go-синтаксис значения       │
│   %T    │ Тип значения                │
│   %t    │ Булево значение             │
│   %d    │ Десятичное целое            │
│   %b    │ Двоичное представление      │
│   %o    │ Восьмеричное                │
│   %x    │ Шестнадцатеричное (нижний)  │
│   %X    │ Шестнадцатеричное (верхний) │
│   %f    │ Вещественное число          │
│   %e    │ Научная нотация (нижний)    │
│   %E    │ Научная нотация (верхний)   │
│   %g    │ %e или %f (компактнее)      │
│   %s    │ Строка                      │
│   %q    │ Строка в кавычках           │
│   %p    │ Указатель                   │
└─────────┴─────────────────────────────┘
```

#### Примеры форматирования:

```
name := "Go"
version := 1.21
active := true

Основное форматирование:
fmt.Sprintf("Language: %s", name)           // "Language: Go"
fmt.Sprintf("Version: %.2f", version)       // "Version: 1.21"
fmt.Sprintf("Active: %t", active)           // "Active: true"

Ширина и выравнивание:
fmt.Sprintf("%-10s|", name)                 // "Go        |"
fmt.Sprintf("%10s|", name)                  // "        Go|"
fmt.Sprintf("%010d", 42)                    // "0000000042"

Индексированные аргументы:
fmt.Sprintf("%[2]s %[1]s", "World", "Hello") // "Hello World"
```

#### Строковые литералы:

```
Различные способы создания строк:

Обычная строка:
s1 := "Hello\nWorld"  // Интерпретирует escape-последовательности

Сырая строка (raw string):
s2 := `Hello\nWorld`  // Буквально сохраняет все символы
s3 := `Многострочная
       строка
       с отступами`

Сравнение:
fmt.Println(s1)  // Hello
                 // World
fmt.Println(s2)  // Hello\nWorld
```

**Ключевые концепции строк и рун:**
- Строки в Go - это UTF-8 последовательности байт
- Руны представляют Unicode символы
- Итерация `range` автоматически декодирует UTF-8
- Строки неизменяемы - изменения создают новые строки
- Пакет `strings` предоставляет богатый набор функций

---

## 🏆 Итоговые знания Блока 1

После изучения первого блока вы должны:

### Понимать концепции:
- **Философию Go** - простота, ясность, эффективность
- **Систему типов** - статическая типизация с выводом типов
- **Управление памятью** - автоматическое управление с GC
- **Область видимости** - блочная видимость и правила экспорта

### Владеть синтаксисом:
- **Объявление переменных** - var, := и их применение
- **Функции** - включая множественные возвращаемые значения
- **Структуры управления** - if, switch, for и их варианты
- **Коллекции** - массивы, срезы и карты

### Применять на практике:
- **Написание простых программ** с четкой структурой
- **Работу с данными** различных типов
- **Обработку ошибок** идиоматичным способом
- **Использование стандартной библиотеки** для базовых операций

### Следовать соглашениям:
- **Стиль кода Go** - gofmt, именование, комментарии
- **Идиомы языка** - использование `range`, обработка ошибок
- **Организация кода** - пакеты, импорты, структура проекта

---

## 📝 Практические задания для Блока 1

### 1. Калькулятор с базовыми операциями
Создайте программу-калькулятор, которая:
- Принимает два числа и операцию от пользователя
- Выполняет арифметические операции (+, -, *, /, %)
- Обрабатывает ошибки (деление на ноль)
- Возвращает результат с соответствующим сообщением

### 2. Программа для работы с текстовыми файлами
Разработайте утилиту, которая:
- Читает текстовый файл
- Подсчитывает количество строк, слов и символов
- Находит самое длинное и самое короткое слово
- Создает статистику по частоте символов

### 3. Игра "Угадай число"
Реализуйте игру, где:
- Программа загадывает случайное число от 1 до 100
- Пользователь пытается угадать число
- Программа дает подсказки "больше" или "меньше"
- Ведется счет попыток
- В конце показывается статистика

### 4. Конвертер единиц измерения
Создайте программу-конвертер, которая:
- Конвертирует между различными единицами (длина, вес, температура)
- Использует карты для хранения коэффициентов
- Имеет удобный интерфейс выбора операций
- Проверяет корректность ввода

---

Этот блок закладывает фундамент для изучения более сложных концепций Go. Убедитесь, что вы комфортно чувствуете себя со всеми представленными концепциями, прежде чем переходить к следующему блоку!