# Go Ğ´Ğ»Ñ Backend Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ°: ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ñ€ÑƒĞºĞ¾Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ Ğ½ÑƒĞ»Ñ Ğ´Ğ¾ ÑĞºÑĞ¿ĞµÑ€Ñ‚Ğ°

> **Ğ¦ĞµĞ»ÑŒ ĞºÑƒÑ€ÑĞ°:** ĞŸÑ€Ğ¾Ğ¹Ñ‚Ğ¸ Ğ¿ÑƒÑ‚ÑŒ Ğ¾Ñ‚ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ³Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ° Ğ´Ğ¾ ÑƒĞ²ĞµÑ€ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Go backend Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ° Ğ·Ğ° 3-4 Ğ¼ĞµÑÑÑ†Ğ°

## ğŸ¯ Ğ—Ğ°Ñ‡ĞµĞ¼ Ğ¸Ğ·ÑƒÑ‡Ğ°Ñ‚ÑŒ Go Ğ´Ğ»Ñ backend?

### Ğ”Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°: Go vs Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ ÑĞ·Ñ‹ĞºĞ¸ Ğ´Ğ»Ñ backend

```
Performance & Concurrency Comparison
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Language â”‚ Performance â”‚ Concurrency â”‚ Memory â”‚ Learning â”‚   â”‚
â”‚          â”‚    (1-10)   â”‚   (1-10)    â”‚ Usage  â”‚  Curve   â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Go       â”‚      9      â”‚      10     â”‚  Low   â”‚  Easy    â”‚ âœ… â”‚
â”‚ Node.js  â”‚      6      â”‚       7     â”‚ Medium â”‚  Easy    â”‚   â”‚
â”‚ Python   â”‚      4      â”‚       5     â”‚  High  â”‚  Easy    â”‚   â”‚
â”‚ Java     â”‚      8      â”‚       8     â”‚  High  â”‚  Hard    â”‚   â”‚
â”‚ C++      â”‚     10      â”‚       6     â”‚  Low   â”‚  Hard    â”‚   â”‚
â”‚ Rust     â”‚     10      â”‚       9     â”‚  Low   â”‚  Hard    â”‚   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Go Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹

```
Go Program Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Go Binary                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   main()    â”‚  â”‚ Goroutines  â”‚  â”‚   Memory    â”‚          â”‚
â”‚  â”‚  Package    â”‚  â”‚   Manager   â”‚  â”‚   Manager   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Standard   â”‚  â”‚   Custom    â”‚  â”‚  External   â”‚          â”‚
â”‚  â”‚  Library    â”‚  â”‚  Packages   â”‚  â”‚ Dependenciesâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Go Runtime                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Scheduler   â”‚  â”‚     GC      â”‚  â”‚  Network    â”‚          â”‚
â”‚  â”‚ (M:N model) â”‚  â”‚ (Concurrent)â”‚  â”‚   Poller    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Go Ñ€ĞµÑˆĞ°ĞµÑ‚ Ğ³Ğ»Ğ°Ğ²Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ backend Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸:**
- **ğŸš€ Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ** - ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ² Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´, Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ±ĞµĞ· VM
- **âš¡ ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ñ‚Ğ° Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ°** - Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ Ğ¸ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ¸Ğ· ĞºĞ¾Ñ€Ğ¾Ğ±ĞºĞ¸  
- **â±ï¸ Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ** - Ğ¼Ğ³Ğ½Ğ¾Ğ²ĞµĞ½Ğ½Ğ°Ñ ÑĞ±Ğ¾Ñ€ĞºĞ° Ğ´Ğ°Ğ¶Ğµ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¾Ğ² (ÑĞµĞºÑƒĞ½Ğ´Ñ‹ vs Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹)
- **ğŸ“š ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ°Ñ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ°Ñ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºĞ°** - HTTP-ÑĞµÑ€Ğ²ĞµÑ€, JSON, Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ‘Ğ” Ğ±ĞµĞ· Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
- **ğŸ›¡ï¸ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ** - Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ² runtime, Ğ»ÑƒÑ‡ÑˆĞµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ
- **ğŸ”§ ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ğ´ĞµĞ¿Ğ»Ğ¾Ğ¹** - Ğ¾Ğ´Ğ¸Ğ½ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ±ĞµĞ· Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹

---

## ğŸ“š Ğ­Ñ‚Ğ°Ğ¿ 1: ĞÑĞ½Ğ¾Ğ²Ñ‹ ÑĞ·Ñ‹ĞºĞ° Go (2-3 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

### ĞĞµĞ´ĞµĞ»Ñ 1: Ğ¡Ğ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ Ğ¸ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸

#### ğŸ”§ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ

```bash
# ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸
go version

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
mkdir my-backend-app
cd my-backend-app
go mod init github.com/username/my-backend-app

# Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°
my-backend-app/
â”œâ”€â”€ go.mod                 # ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ Ğ¸ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
â”œâ”€â”€ go.sum                 # Ğ¥ĞµÑˆĞ¸ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
â”œâ”€â”€ main.go               # Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ°
â”œâ”€â”€ internal/             # ĞŸÑ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ‹Ğµ Ğ¿Ğ°ĞºĞµÑ‚Ñ‹ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
â”‚   â”œâ”€â”€ handlers/         # HTTP Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸
â”‚   â”œâ”€â”€ services/         # Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
â”‚   â””â”€â”€ repository/       # Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
â”œâ”€â”€ pkg/                  # ĞŸÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¿Ğ°ĞºĞµÑ‚Ñ‹
â””â”€â”€ cmd/                  # Ğ˜ÑĞ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
```

#### ğŸ“¦ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¿Ğ°ĞºĞµÑ‚Ğ¾Ğ² Go

```
Package System Visualization
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Go Module                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   package   â”‚  â”‚   package   â”‚  â”‚   package   â”‚          â”‚
â”‚  â”‚    main     â”‚  â”‚   handlers  â”‚  â”‚   models    â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ func main() â”‚  â”‚ func Handle â”‚  â”‚ type User   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                â”‚                â”‚                â”‚
â”‚         â–¼                â–¼                â–¼                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚               Exported Functions/Types                  â”‚ â”‚
â”‚  â”‚              (Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‚ÑÑ Ñ Ğ·Ğ°Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ¹)                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
// main.go - Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
package main

import (
    "fmt"
    "log"
    "net/http"
    
    // Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ°ĞºĞµÑ‚Ñ‹
    "github.com/username/my-backend-app/internal/handlers"
    "github.com/username/my-backend-app/internal/services"
    
    // Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
    "github.com/gorilla/mux"
)

func main() {
    // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞµÑ€Ğ²Ğ¸ÑĞ¾Ğ²
    userService := services.NewUserService()
    userHandler := handlers.NewUserHandler(userService)
    
    // ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ğ°
    router := mux.NewRouter()
    router.HandleFunc("/users", userHandler.GetUsers).Methods("GET")
    
    fmt.Println("ğŸš€ Backend server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", router))
}
```

**ğŸ’¡ ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ:** ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ¿Ñ€Ğ¸Ğ½Ğ°Ğ´Ğ»ĞµĞ¶Ğ¸Ñ‚ Ğ¿Ğ°ĞºĞµÑ‚Ñƒ. `main` - ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ°ĞºĞµÑ‚ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼.

#### ğŸ”¢ ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¸ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚Ğ¸Ğ¿Ğ¾Ğ² Go

```
Go Type System
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Basic Types                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Numbers   â”‚  â”‚   Strings   â”‚  â”‚   Boolean   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ int, int64  â”‚  â”‚   string    â”‚  â”‚    bool     â”‚          â”‚
â”‚  â”‚ float64     â”‚  â”‚   rune      â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ uint        â”‚  â”‚   byte      â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Composite Types                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Arrays    â”‚  â”‚   Slices    â”‚  â”‚    Maps     â”‚          â”‚
â”‚  â”‚ [5]int      â”‚  â”‚   []int     â”‚  â”‚ map[string] â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚    int      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Structs   â”‚  â”‚ Interfaces  â”‚  â”‚  Channels   â”‚          â”‚
â”‚  â”‚ type User   â”‚  â”‚ type Reader â”‚  â”‚  chan int   â”‚          â”‚
â”‚  â”‚   struct    â”‚  â”‚ interface   â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "time"
)

// Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ (Ğ»ÑƒÑ‡ÑˆĞ°Ñ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ° - Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸)
const (
    APIVersion = "v1"
    MaxRetries = 3
    TimeoutSeconds = 30
)

func demonstrateTypes() {
    // ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ´Ğ»Ñ backend Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
    var userID int64 = 12345678901234567  // int64 Ğ´Ğ»Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… ID
    var accountBalance float64 = 1234.56   // float64 Ğ´Ğ»Ñ Ğ´ĞµĞ½ĞµĞ¶Ğ½Ñ‹Ñ… ÑÑƒĞ¼Ğ¼
    var isActive bool = true               // bool Ğ´Ğ»Ñ Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ²
    var userName string = "john_doe"       // string Ğ´Ğ»Ñ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    
    // ĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ğµ (Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ±)
    email := "john@example.com"
    createdAt := time.Now()
    
    // ĞÑƒĞ»ĞµĞ²Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº)
    var uninitializedString string    // ""
    var uninitializedInt int         // 0
    var uninitializedBool bool       // false
    var uninitializedPointer *string // nil
    
    fmt.Printf("User: %d, %s, %s, Balance: %.2f, Active: %v\n", 
        userID, userName, email, accountBalance, isActive)
    fmt.Printf("Created: %v\n", createdAt)
    fmt.Printf("Zero values: '%s', %d, %v, %v\n", 
        uninitializedString, uninitializedInt, uninitializedBool, uninitializedPointer)
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ñ‚Ğ¸Ğ¿Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ API
type APIUser struct {
    ID        int64     `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    Balance   float64   `json:"balance"`
    IsActive  bool      `json:"is_active"`
    CreatedAt time.Time `json:"created_at"`
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ°:** Ğ¡Ñ‚Ñ€Ğ¾Ğ³Ğ°Ñ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ¾ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ½Ğ¸ĞºĞ°ÑÑ‚ Ğ² Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ°Ñ… Ğ¿Ñ€Ğ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ Ñ API Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸.

#### ğŸ”„ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‰Ğ¸Ğµ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸

### Ğ”Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ

```
Control Flow in Go
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Conditional Logic                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              if condition {                                 â”‚
â”‚                  // code                                    â”‚
â”‚              } else if condition2 {                         â”‚
â”‚                  // code                                    â”‚
â”‚              } else {                                       â”‚
â”‚                  // code                                    â”‚
â”‚              }                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Switch Logic                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              switch value {                                 â”‚
â”‚              case "GET":                                    â”‚
â”‚                  // handle GET                             â”‚
â”‚              case "POST":                                   â”‚
â”‚                  // handle POST                            â”‚
â”‚              default:                                       â”‚
â”‚                  // handle others                          â”‚
â”‚              }                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Loops                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              for i := 0; i < len(items); i++ {             â”‚
â”‚                  // index-based loop                       â”‚
â”‚              }                                              â”‚
â”‚                                                             â”‚
â”‚              for index, value := range items {             â”‚
â”‚                  // range-based loop                       â”‚
â”‚              }                                              â”‚
â”‚                                                             â”‚
â”‚              for condition {                                â”‚
â”‚                  // while-like loop                        â”‚
â”‚              }                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
)

// Ğ£ÑĞ»Ğ¾Ğ²Ğ½Ñ‹Ğµ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ğ¸ Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğµ HTTP Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ°
func handleHTTPMethod(method string) string {
    // if-else Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ‹Ñ… ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğ¹
    if method == "" {
        return "Method not specified"
    }
    
    // switch Ğ´Ğ»Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° (Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ¾ Ğ´Ğ»Ñ HTTP Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²)
    switch strings.ToUpper(method) {
    case "GET":
        return "Reading data"
    case "POST":
        return "Creating data"
    case "PUT":
        return "Updating data"
    case "DELETE":
        return "Deleting data"
    case "PATCH":
        return "Partially updating data"
    default:
        return "Unsupported method"
    }
}

// Ğ¦Ğ¸ĞºĞ»Ñ‹ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ĞºĞ¾Ğ»Ğ»ĞµĞºÑ†Ğ¸Ğ¹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
func processUsers() {
    users := []string{"alice@example.com", "bob@example.com", "charlie@example.com"}
    
    // ĞšĞ»Ğ°ÑÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ†Ğ¸ĞºĞ» for (Ñ€ĞµĞ´ĞºĞ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ)
    fmt.Println("Classic for loop:")
    for i := 0; i < len(users); i++ {
        fmt.Printf("User %d: %s\n", i+1, users[i])
    }
    
    // Range Ñ†Ğ¸ĞºĞ» (Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ±)
    fmt.Println("\nRange loop:")
    for index, email := range users {
        fmt.Printf("Index %d: %s\n", index, email)
    }
    
    // Range Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸ÑĞ¼ (ĞºĞ¾Ğ³Ğ´Ğ° Ğ¸Ğ½Ğ´ĞµĞºÑ Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½)
    fmt.Println("\nValues only:")
    for _, email := range users {
        if strings.Contains(email, "@example.com") {
            fmt.Printf("Valid email: %s\n", email)
        }
    }
    
    // "Ğ‘ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹" Ñ†Ğ¸ĞºĞ» Ñ ÑƒÑĞ»Ğ¾Ğ²Ğ¸ĞµĞ¼ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ°
    counter := 0
    for {
        counter++
        if counter > 3 {
            break
        }
        fmt.Printf("Processing batch %d\n", counter)
    }
}

// ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ HTTP Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¾Ğ²
func validateHeaders(headers http.Header) []string {
    var errors []string
    
    requiredHeaders := []string{"Content-Type", "Authorization"}
    
    for _, header := range requiredHeaders {
        if value := headers.Get(header); value == "" {
            errors = append(errors, fmt.Sprintf("Missing required header: %s", header))
        }
    }
    
    return errors
}
```

**ğŸ’¡ ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ:** Ğ’ Go Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ‚Ğ¸Ğ¿ Ñ†Ğ¸ĞºĞ»Ğ° `for`, Ğ½Ğ¾ Ğ¾Ğ½ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ°Ñ…. Range Ñ†Ğ¸ĞºĞ» - Ğ¸Ğ´Ğ¸Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¾ÑĞ¾Ğ± Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸.

#### âš¡ Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ² Go

```
Error Handling Philosophy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Go Error Model                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚   Happy Path    â”‚    â”‚   Error Path    â”‚               â”‚
â”‚   â”‚                 â”‚    â”‚                 â”‚               â”‚
â”‚   â”‚ Normal Return   â”‚    â”‚ Error Return    â”‚               â”‚
â”‚   â”‚ (value, nil)    â”‚    â”‚ (zero, error)   â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                        â”‚                       â”‚
â”‚           â–¼                        â–¼                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚  Continue       â”‚    â”‚  Handle Error   â”‚               â”‚
â”‚   â”‚  Execution      â”‚    â”‚  - Log          â”‚               â”‚
â”‚   â”‚                 â”‚    â”‚  - Retry        â”‚               â”‚
â”‚   â”‚                 â”‚    â”‚  - Return       â”‚               â”‚
â”‚   â”‚                 â”‚    â”‚  - Panic        â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Explicit > Implicit                            â”‚
â”‚         "Errors are values" - Rob Pike                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "errors"
    "fmt"
    "log"
    "regexp"
    "strings"
    "time"
)

// ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ¹ Ğ´Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ¸
type ValidationError struct {
    Field   string
    Value   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field '%s': %s", e.Field, e.Message)
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼ (Ğ¸Ğ´Ğ¸Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ Go)
func validateEmail(email string) (bool, error) {
    if email == "" {
        return false, ValidationError{
            Field:   "email",
            Value:   email,
            Message: "email cannot be empty",
        }
    }
    
    // ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° email
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return false, ValidationError{
            Field:   "email",
            Value:   email,
            Message: "invalid email format",
        }
    }
    
    return true, nil
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼Ğ¸ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸ÑĞ¼Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
func processUserRegistration(email, password string) error {
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° email
    if valid, err := validateEmail(email); err != nil {
        // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
        return fmt.Errorf("email validation failed: %w", err)
    } else if !valid {
        return errors.New("email validation failed for unknown reason")
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ
    if len(password) < 8 {
        return ValidationError{
            Field:   "password",
            Value:   "***",
            Message: "password must be at least 8 characters",
        }
    }
    
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ² Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    if err := saveUserToDB(email, password); err != nil {
        // ĞĞ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ°
        return fmt.Errorf("failed to save user to database: %w", err)
    }
    
    log.Printf("User successfully registered: %s", email)
    return nil
}

// Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ‘Ğ”
func saveUserToDB(email, password string) error {
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ ÑĞµÑ‚ĞµĞ²Ğ¾Ğ¹ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ¸
    time.Sleep(10 * time.Millisecond)
    
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ‘Ğ” (10% Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ)
    if strings.Contains(email, "error") {
        return errors.New("database connection failed")
    }
    
    return nil
}

// Ğ Ğ°Ğ·Ğ½Ñ‹Ğµ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº
func demonstrateErrorHandling() {
    testEmails := []string{
        "valid@example.com",
        "",
        "invalid-email",
        "error@example.com", // Ğ¢Ñ€Ğ¸Ğ³Ğ³ĞµÑ€Ğ¸Ñ‚ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ Ğ‘Ğ”
    }
    
    for _, email := range testEmails {
        fmt.Printf("\n--- Processing: %s ---\n", email)
        
        err := processUserRegistration(email, "password123")
        if err != nil {
            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ‚Ğ¸Ğ¿Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
            var validationErr ValidationError
            if errors.As(err, &validationErr) {
                fmt.Printf("âŒ Validation Error: %s\n", validationErr.Message)
            } else {
                fmt.Printf("âŒ System Error: %v\n", err)
            }
        } else {
            fmt.Println("âœ… User registered successfully")
        }
    }
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ² Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ°
func getUser(id int64) (*User, error) {
    if id <= 0 {
        return nil, errors.New("invalid user ID")
    }
    
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    return &User{ID: id, Email: "user@example.com"}, nil
}

func getUserCount() (int, error) {
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ¿Ğ¾Ğ´ÑÑ‡ĞµÑ‚Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    return 42, nil
}

func deleteUser(id int64) error {
    if id <= 0 {
        return errors.New("invalid user ID")
    }
    
    // Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ñ
    return nil
}

type User struct {
    ID    int64  `json:"id"`
    Email string `json:"email"`
    Name  string `json:"name"`
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ°:** Ğ¯Ğ²Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ² Go Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ½ĞµĞ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ ÑĞµÑ€Ğ²ĞµÑ€Ğ° Ğ¸ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ñ‹Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹.

**ğŸ’¡ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹:**
- ĞÑˆĞ¸Ğ±ĞºĞ¸ - ÑÑ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ, Ğ½Ğµ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
- Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ ÑĞ²Ğ½Ğ¾
- ĞĞ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ°
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ¹ Ğ´Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ¸

---

### ĞĞµĞ´ĞµĞ»Ñ 2: Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸

#### ğŸ“‹ Ğ¡Ğ»Ğ°Ğ¹ÑÑ‹ - Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¼Ğ°ÑÑĞ¸Ğ²Ñ‹

### Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ĞµĞµ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ ÑĞ»Ğ°Ğ¹ÑĞ¾Ğ²

```
Slice Internal Structure
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Slice Header                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Pointer   â”‚  â”‚   Length    â”‚  â”‚  Capacity   â”‚          â”‚
â”‚  â”‚      â”‚      â”‚  â”‚     3       â”‚  â”‚     5       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           Underlying Array                              â”‚ â”‚
â”‚  â”‚  [0]  â”‚  [1]  â”‚  [2]  â”‚  [3]  â”‚  [4]  â”‚ ...           â”‚ â”‚
â”‚  â”‚ "Go"  â”‚ "is"  â”‚ "fun" â”‚  nil  â”‚  nil  â”‚               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â–²               â–²                                   â”‚
â”‚      Used part      Unused capacity                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "strings"
)

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ÑĞ¾ ÑĞ»Ğ°Ğ¹ÑĞ°Ğ¼Ğ¸ Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğµ backend
func demonstrateSlices() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ»Ğ°Ğ¹ÑĞ¾Ğ² Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼Ğ¸ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ°Ğ¼Ğ¸
    
    // 1. Ğ›Ğ¸Ñ‚ĞµÑ€Ğ°Ğ» ÑĞ»Ğ°Ğ¹ÑĞ°
    supportedMethods := []string{"GET", "POST", "PUT", "DELETE"}
    fmt.Printf("Supported HTTP methods: %v\n", supportedMethods)
    fmt.Printf("Length: %d, Capacity: %d\n", len(supportedMethods), cap(supportedMethods))
    
    // 2. Make Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ (ĞºĞ¾Ğ³Ğ´Ğ° Ğ·Ğ½Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€)
    userIDs := make([]int64, 0, 100) // length=0, capacity=100
    fmt.Printf("User IDs: %v, len=%d, cap=%d\n", userIDs, len(userIDs), cap(userIDs))
    
    // 3. Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
    userIDs = append(userIDs, 1001, 1002, 1003)
    fmt.Printf("After append: %v, len=%d, cap=%d\n", userIDs, len(userIDs), cap(userIDs))
    
    // 4. Ğ¡Ñ€ĞµĞ·Ñ‹ (slicing)
    recentUsers := userIDs[1:3] // ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ñ Ğ¸Ğ½Ğ´ĞµĞºÑĞ° 1 Ğ´Ğ¾ 3 (Ğ½Ğµ Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ 3)
    fmt.Printf("Recent users: %v\n", recentUsers)
    
    // 5. ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ»Ğ°Ğ¹ÑĞ¾Ğ² (Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ñ Ğ½ĞµĞ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹)
    originalTags := []string{"backend", "go", "api"}
    copiedTags := make([]string, len(originalTags))
    copy(copiedTags, originalTags)
    
    copiedTags[0] = "frontend" // Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ
    fmt.Printf("Original: %v\n", originalTags)
    fmt.Printf("Copied: %v\n", copiedTags)
}

// ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ»Ğ°Ğ¹ÑĞ¾Ğ² Ğ² backend
type APIResponse struct {
    Data    []interface{} `json:"data"`
    Meta    ResponseMeta  `json:"meta"`
    Errors  []string      `json:"errors,omitempty"`
}

type ResponseMeta struct {
    Total  int `json:"total"`
    Page   int `json:"page"`
    Limit  int `json:"limit"`
}

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
func paginateUsers(users []User, page, limit int) ([]User, ResponseMeta) {
    total := len(users)
    start := (page - 1) * limit
    end := start + limit
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†
    if start >= total {
        return []User{}, ResponseMeta{Total: total, Page: page, Limit: limit}
    }
    
    if end > total {
        end = total
    }
    
    paginatedUsers := users[start:end]
    meta := ResponseMeta{
        Total: total,
        Page:  page,
        Limit: limit,
    }
    
    return paginatedUsers, meta
}

// Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
func filterActiveUsers(users []User) []User {
    var activeUsers []User
    
    for _, user := range users {
        if user.IsActive {
            activeUsers = append(activeUsers, user)
        }
    }
    
    return activeUsers
}

// Bulk Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
func validateEmails(emails []string) ([]string, []string) {
    var validEmails []string
    var invalidEmails []string
    
    for _, email := range emails {
        if strings.Contains(email, "@") && strings.Contains(email, ".") {
            validEmails = append(validEmails, email)
        } else {
            invalidEmails = append(invalidEmails, email)
        }
    }
    
    return validEmails, invalidEmails
}

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ ÑĞ»Ğ°Ğ¹ÑĞ¾Ğ²
func demonstrateSlicePerformance() {
    // ĞŸÑ€ĞµĞ´Ğ²Ğ°Ñ€Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ğ»ÑƒÑ‡ÑˆĞµĞ¹ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
    userIDs := make([]int64, 0, 1000) // Ğ—Ğ°Ñ€Ğ°Ğ½ĞµĞµ Ğ²Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ Ğ½Ğ° 1000 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
    
    for i := int64(1); i <= 1000; i++ {
        userIDs = append(userIDs, i)
    }
    
    fmt.Printf("Generated %d user IDs efficiently\n", len(userIDs))
}

type User struct {
    ID       int64  `json:"id"`
    Email    string `json:"email"`
    Name     string `json:"name"`
    IsActive bool   `json:"is_active"`
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ°:**
- **ĞŸĞ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ** - ÑĞ»Ğ°Ğ¹ÑÑ‹ Ğ¸Ğ´ĞµĞ°Ğ»ÑŒĞ½Ñ‹ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ±Ğ¸ĞµĞ½Ğ¸Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… Ğ½Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ² Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ** - Ğ»ĞµĞ³ĞºĞ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ´Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **Bulk Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸** - Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¼Ğ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²Ğ° ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² Ğ·Ğ° Ñ€Ğ°Ğ·
- **API responses** - Ğ³Ğ¸Ğ±ĞºĞ¸Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ JSON

#### ğŸ—‚ï¸ ĞšĞ°Ñ€Ñ‚Ñ‹ - key-value Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° ĞºĞ°Ñ€Ñ‚ Ğ² Go

```
Map Internal Structure (Hash Table)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Hash Table                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Key       â”‚    Hash     â”‚    Bucket    â”‚    Value       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ "user:123"    â”‚ hash("...") â”‚ bucket[0]    â”‚ User{...}      â”‚
â”‚ "user:456"    â”‚ hash("...") â”‚ bucket[1]    â”‚ User{...}      â”‚
â”‚ "session:abc" â”‚ hash("...") â”‚ bucket[2]    â”‚ Session{...}   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Collision Handling                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Bucket    â”‚    â”‚   Bucket    â”‚    â”‚   Bucket    â”‚      â”‚
â”‚  â”‚  [Entry1]   â”‚    â”‚  [Entry1]   â”‚    â”‚  [Entry1]   â”‚      â”‚
â”‚  â”‚  [Entry2]   â”‚    â”‚      â”‚      â”‚    â”‚             â”‚      â”‚
â”‚  â”‚      â”‚      â”‚    â”‚      â–¼      â”‚    â”‚             â”‚      â”‚
â”‚  â”‚   Overflow  â”‚    â”‚   Next      â”‚    â”‚             â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ ĞºĞ°Ñ€Ñ‚ Ğ² backend
func demonstrateMaps() {
    // 1. ĞšÑÑˆ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ (ÑĞ°Ğ¼Ğ¾Ğµ Ñ‡Ğ°ÑÑ‚Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ)
    userCache := make(map[string]*User)
    
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ² ĞºÑÑˆ
    userCache["user:123"] = &User{ID: 123, Email: "john@example.com", Name: "John"}
    userCache["user:456"] = &User{ID: 456, Email: "jane@example.com", Name: "Jane"}
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ (ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ²Ğ°Ğ¶Ğ½Ğ¾!)
    if user, exists := userCache["user:123"]; exists {
        fmt.Printf("Found in cache: %s\n", user.Name)
    } else {
        fmt.Println("User not found in cache")
    }
    
    // Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· ĞºÑÑˆĞ°
    delete(userCache, "user:456")
    
    // 2. Ğ¡Ñ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¸ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
    requestCounts := make(map[string]int)
    endpoints := []string{"/users", "/posts", "/users", "/comments", "/users"}
    
    for _, endpoint := range endpoints {
        requestCounts[endpoint]++
    }
    
    fmt.Println("Request statistics:")
    for endpoint, count := range requestCounts {
        fmt.Printf("%s: %d requests\n", endpoint, count)
    }
    
    // 3. ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    config := map[string]interface{}{
        "database_url":    "postgres://localhost:5432/myapp",
        "redis_url":       "redis://localhost:6379",
        "max_connections": 100,
        "debug_mode":      true,
        "allowed_origins": []string{"localhost:3000", "myapp.com"},
    }
    
    if dbURL, ok := config["database_url"].(string); ok {
        fmt.Printf("Database URL: %s\n", dbURL)
    }
}

// Thread-safe ĞºÑÑˆ Ñ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ¼
type SafeCache struct {
    mu    sync.RWMutex
    cache map[string]*User
}

func NewSafeCache() *SafeCache {
    return &SafeCache{
        cache: make(map[string]*User),
    }
}

func (c *SafeCache) Set(key string, user *User) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.cache[key] = user
}

func (c *SafeCache) Get(key string) (*User, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    user, exists := c.cache[key]
    return user, exists
}

func (c *SafeCache) Delete(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.cache, key)
}

func (c *SafeCache) Size() int {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return len(c.cache)
}

// ĞšÑÑˆ Ñ TTL (Time To Live)
type CacheEntry struct {
    User      *User
    ExpiresAt time.Time
}

type TTLCache struct {
    mu      sync.RWMutex
    entries map[string]*CacheEntry
}

func NewTTLCache() *TTLCache {
    cache := &TTLCache{
        entries: make(map[string]*CacheEntry),
    }
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñƒ Ğ´Ğ»Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¸ Ğ¸ÑÑ‚ĞµĞºÑˆĞ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹
    go cache.cleanup()
    
    return cache
}

func (c *TTLCache) Set(key string, user *User, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.entries[key] = &CacheEntry{
        User:      user,
        ExpiresAt: time.Now().Add(ttl),
    }
}

func (c *TTLCache) Get(key string) (*User, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    entry, exists := c.entries[key]
    if !exists {
        return nil, false
    }
    
    if time.Now().After(entry.ExpiresAt) {
        return nil, false
    }
    
    return entry.User, true
}

func (c *TTLCache) cleanup() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        c.mu.Lock()
        for key, entry := range c.entries {
            if time.Now().After(entry.ExpiresAt) {
                delete(c.entries, key)
            }
        }
        c.mu.Unlock()
    }
}

// Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ ĞºĞ°Ñ€Ñ‚
func groupUsersByDomain(users []User) map[string][]User {
    groups := make(map[string][]User)
    
    for _, user := range users {
        // Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ¾Ğ¼ĞµĞ½ Ğ¸Ğ· email
        parts := strings.Split(user.Email, "@")
        if len(parts) == 2 {
            domain := parts[1]
            groups[domain] = append(groups[domain], user)
        }
    }
    
    return groups
}

// Ğ˜Ğ½Ğ´ĞµĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ¸ÑĞºĞ°
type UserIndex struct {
    byID    map[int64]*User
    byEmail map[string]*User
    byName  map[string][]*User // Ğ˜Ğ¼ĞµĞ½Ğ° Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑ‚ÑŒÑÑ
}

func NewUserIndex() *UserIndex {
    return &UserIndex{
        byID:    make(map[int64]*User),
        byEmail: make(map[string]*User),
        byName:  make(map[string][]*User),
    }
}

func (idx *UserIndex) AddUser(user *User) {
    idx.byID[user.ID] = user
    idx.byEmail[user.Email] = user
    idx.byName[user.Name] = append(idx.byName[user.Name], user)
}

func (idx *UserIndex) FindByID(id int64) *User {
    return idx.byID[id]
}

func (idx *UserIndex) FindByEmail(email string) *User {
    return idx.byEmail[email]
}

func (idx *UserIndex) FindByName(name string) []*User {
    return idx.byName[name]
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ°:**
- **ĞšÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** - Ğ¼Ğ³Ğ½Ğ¾Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ğ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼
- **Ğ˜Ğ½Ğ´ĞµĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** - Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼ Ğ¿Ğ¾Ğ»ÑĞ¼
- **ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ** - Ğ³Ğ¸Ğ±ĞºĞ¾Ğµ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
- **Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°** - Ğ¿Ğ¾Ğ´ÑÑ‡ĞµÑ‚ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹ Ğ¸ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº

#### ğŸ—ï¸ Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ - Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ² Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ

```
Struct Usage in Application Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Domain Models                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    User     â”‚  â”‚    Post     â”‚  â”‚   Comment   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ - ID        â”‚  â”‚ - ID        â”‚  â”‚ - ID        â”‚          â”‚
â”‚  â”‚ - Email     â”‚  â”‚ - Title     â”‚  â”‚ - Content   â”‚          â”‚
â”‚  â”‚ - Name      â”‚  â”‚ - Content   â”‚  â”‚ - UserID    â”‚          â”‚
â”‚  â”‚ - CreatedAt â”‚  â”‚ - UserID    â”‚  â”‚ - PostID    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Data Transfer Objects                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ UserRequest â”‚  â”‚UserResponse â”‚  â”‚  ErrorDTO   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ - Email     â”‚  â”‚ - ID        â”‚  â”‚ - Code      â”‚          â”‚
â”‚  â”‚ - Name      â”‚  â”‚ - Email     â”‚  â”‚ - Message   â”‚          â”‚
â”‚  â”‚ - Password  â”‚  â”‚ - Name      â”‚  â”‚ - Details   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Configuration Structs                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ DatabaseCfg â”‚  â”‚  ServerCfg  â”‚  â”‚  RedisCfg   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ - Host      â”‚  â”‚ - Port      â”‚  â”‚ - URL       â”‚          â”‚
â”‚  â”‚ - Port      â”‚  â”‚ - Host      â”‚  â”‚ - Password  â”‚          â”‚
â”‚  â”‚ - Database  â”‚  â”‚ - ReadTimeoutâ”‚ â”‚ - Database  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "encoding/json"
    "fmt"
    "time"
    "database/sql/driver"
    "strings"
)

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… ÑÑƒÑ‰Ğ½Ğ¾ÑÑ‚ĞµĞ¹
type BaseModel struct {
    ID        int64     `json:"id" db:"id"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ - Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ
type User struct {
    BaseModel
    Email     string    `json:"email" db:"email" validate:"required,email"`
    Name      string    `json:"name" db:"name" validate:"required,min=2,max=50"`
    Password  string    `json:"-" db:"password_hash"` // "-" ÑĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»Ğµ Ğ² JSON
    IsActive  bool      `json:"is_active" db:"is_active"`
    Role      UserRole  `json:"role" db:"role"`
    Profile   *Profile  `json:"profile,omitempty"` // Pointer Ğ´Ğ»Ñ optional Ğ¿Ğ¾Ğ»Ñ
}

// Enum Ğ´Ğ»Ñ Ñ€Ğ¾Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
type UserRole string

const (
    RoleUser  UserRole = "user"
    RoleAdmin UserRole = "admin"
    RoleMod   UserRole = "moderator"
)

// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ° Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ‘Ğ”
func (r UserRole) Value() (driver.Value, error) {
    return string(r), nil
}

func (r *UserRole) Scan(value interface{}) error {
    if value == nil {
        *r = RoleUser
        return nil
    }
    if s, ok := value.(string); ok {
        *r = UserRole(s)
        return nil
    }
    return fmt.Errorf("cannot scan %T into UserRole", value)
}

// ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°)
type Profile struct {
    UserID   int64  `json:"user_id" db:"user_id"`
    Avatar   string `json:"avatar" db:"avatar"`
    Bio      string `json:"bio" db:"bio"`
    Website  string `json:"website" db:"website"`
    Location string `json:"location" db:"location"`
}

// ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ´Ğ»Ñ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸
func (u *User) IsValid() bool {
    return u.Email != "" && u.Name != "" && len(u.Name) >= 2
}

func (u *User) CanModerate() bool {
    return u.Role == RoleAdmin || u.Role == RoleMod
}

func (u *User) GetDisplayName() string {
    if u.Name != "" {
        return u.Name
    }
    return strings.Split(u.Email, "@")[0]
}

// DTO Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
type CreateUserRequest struct {
    Email    string `json:"email" validate:"required,email"`
    Name     string `json:"name" validate:"required,min=2,max=50"`
    Password string `json:"password" validate:"required,min=8"`
}

// DTO Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° API
type UserResponse struct {
    ID        int64     `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    IsActive  bool      `json:"is_active"`
    Role      UserRole  `json:"role"`
    CreatedAt time.Time `json:"created_at"`
    Profile   *Profile  `json:"profile,omitempty"`
}

// ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¼Ğ¾Ğ´ĞµĞ»ÑĞ¼Ğ¸
func (u *User) ToResponse() UserResponse {
    return UserResponse{
        ID:        u.ID,
        Email:     u.Email,
        Name:      u.Name,
        IsActive:  u.IsActive,
        Role:      u.Role,
        CreatedAt: u.CreatedAt,
        Profile:   u.Profile,
    }
}

func (req *CreateUserRequest) ToUser() *User {
    return &User{
        BaseModel: BaseModel{
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
        Email:    req.Email,
        Name:     req.Name,
        Password: req.Password, // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ñ…ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        IsActive: true,
        Role:     RoleUser,
    }
}

// Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
type PaginatedResponse struct {
    Data       interface{}    `json:"data"`
    Pagination PaginationMeta `json:"pagination"`
}

type PaginationMeta struct {
    Page       int `json:"page"`
    Limit      int `json:"limit"`
    Total      int `json:"total"`
    TotalPages int `json:"total_pages"`
    HasNext    bool `json:"has_next"`
    HasPrev    bool `json:"has_prev"`
}

func NewPaginatedResponse(data interface{}, page, limit, total int) PaginatedResponse {
    totalPages := (total + limit - 1) / limit
    
    return PaginatedResponse{
        Data: data,
        Pagination: PaginationMeta{
            Page:       page,
            Limit:      limit,
            Total:      total,
            TotalPages: totalPages,
            HasNext:    page < totalPages,
            HasPrev:    page > 1,
        },
    }
}

// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
type Config struct {
    Server   ServerConfig   `json:"server"`
    Database DatabaseConfig `json:"database"`
    Redis    RedisConfig    `json:"redis"`
    JWT      JWTConfig      `json:"jwt"`
    Email    EmailConfig    `json:"email"`
}

type ServerConfig struct {
    Host         string        `json:"host" env:"SERVER_HOST" default:"localhost"`
    Port         int           `json:"port" env:"SERVER_PORT" default:"8080"`
    ReadTimeout  time.Duration `json:"read_timeout" env:"SERVER_READ_TIMEOUT" default:"30s"`
    WriteTimeout time.Duration `json:"write_timeout" env:"SERVER_WRITE_TIMEOUT" default:"30s"`
    IdleTimeout  time.Duration `json:"idle_timeout" env:"SERVER_IDLE_TIMEOUT" default:"60s"`
}

type DatabaseConfig struct {
    Host         string `json:"host" env:"DB_HOST" default:"localhost"`
    Port         int    `json:"port" env:"DB_PORT" default:"5432"`
    User         string `json:"user" env:"DB_USER" default:"postgres"`
    Password     string `json:"-" env:"DB_PASSWORD"`
    Name         string `json:"name" env:"DB_NAME" default:"myapp"`
    SSLMode      string `json:"ssl_mode" env:"DB_SSL_MODE" default:"disable"`
    MaxOpenConns int    `json:"max_open_conns" env:"DB_MAX_OPEN_CONNS" default:"25"`
    MaxIdleConns int    `json:"max_idle_conns" env:"DB_MAX_IDLE_CONNS" default:"5"`
}

func (db DatabaseConfig) DSN() string {
    return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        db.Host, db.Port, db.User, db.Password, db.Name, db.SSLMode)
}

type RedisConfig struct {
    URL      string `json:"url" env:"REDIS_URL" default:"redis://localhost:6379"`
    Password string `json:"-" env:"REDIS_PASSWORD"`
    Database int    `json:"database" env:"REDIS_DB" default:"0"`
}

type JWTConfig struct {
    Secret         string        `json:"-" env:"JWT_SECRET"`
    AccessExpiry   time.Duration `json:"access_expiry" env:"JWT_ACCESS_EXPIRY" default:"15m"`
    RefreshExpiry  time.Duration `json:"refresh_expiry" env:"JWT_REFRESH_EXPIRY" default:"7d"`
    Issuer         string        `json:"issuer" env:"JWT_ISSUER" default:"myapp"`
}

type EmailConfig struct {
    Host     string `json:"host" env:"EMAIL_HOST"`
    Port     int    `json:"port" env:"EMAIL_PORT" default:"587"`
    Username string `json:"username" env:"EMAIL_USERNAME"`
    Password string `json:"-" env:"EMAIL_PASSWORD"`
    From     string `json:"from" env:"EMAIL_FROM"`
}

// Embedded ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
type Timestamped struct {
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

type SoftDeleted struct {
    DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ embedded ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€
type Post struct {
    ID       int64  `json:"id" db:"id"`
    Title    string `json:"title" db:"title"`
    Content  string `json:"content" db:"content"`
    UserID   int64  `json:"user_id" db:"user_id"`
    Status   string `json:"status" db:"status"`
    
    Timestamped  // Ğ’ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»Ñ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
    SoftDeleted  // Ğ’ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ soft delete
}

func (p *Post) IsPublished() bool {
    return p.Status == "published" && p.DeletedAt == nil
}

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ÑĞ¾ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°Ğ¼Ğ¸
func demonstrateStructs() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user := &User{
        BaseModel: BaseModel{
            ID:        1,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
        Email:    "john@example.com",
        Name:     "John Doe",
        IsActive: true,
        Role:     RoleUser,
        Profile: &Profile{
            Bio:      "Backend developer",
            Location: "San Francisco",
        },
    }
    
    // Ğ¡ĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ² JSON
    jsonData, _ := json.MarshalIndent(user, "", "  ")
    fmt.Printf("User JSON:\n%s\n", jsonData)
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
    fmt.Printf("Display name: %s\n", user.GetDisplayName())
    fmt.Printf("Can moderate: %v\n", user.CanModerate())
    fmt.Printf("Is valid: %v\n", user.IsValid())
    
    // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ² DTO
    response := user.ToResponse()
    responseJSON, _ := json.MarshalIndent(response, "", "  ")
    fmt.Printf("Response JSON:\n%s\n", responseJSON)
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ°:**
- **Ğ¢Ğ¸Ğ¿Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ** - Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ½Ğ° ÑÑ‚Ğ°Ğ¿Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ğ¸
- **JSON Ñ‚ĞµĞ³Ğ¸** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ ÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ/Ğ´ĞµÑĞµÑ€Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ API
- **Database Ñ‚ĞµĞ³Ğ¸** - Ğ¼Ğ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ğ½Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ‘Ğ”
- **Validation Ñ‚ĞµĞ³Ğ¸** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ²Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **ĞœĞµÑ‚Ğ¾Ğ´Ñ‹** - Ğ¸Ğ½ĞºĞ°Ğ¿ÑÑƒĞ»ÑÑ†Ğ¸Ñ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸

#### ğŸ¯ Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒÑ

### ĞŸĞ°Ğ¼ÑÑ‚ÑŒ Ğ² Go: Stack vs Heap

```
Memory Management in Go
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Stack                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   func1()   â”‚  â”‚   func2()   â”‚  â”‚   func3()   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ local vars  â”‚  â”‚ local vars  â”‚  â”‚ local vars  â”‚          â”‚
â”‚  â”‚ parameters  â”‚  â”‚ parameters  â”‚  â”‚ parameters  â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â–²               â–²               â–²                  â”‚
â”‚      Current         Previous        Stack                 â”‚
â”‚      Frame            Frame          Growth                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         Heap                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   *User     â”‚  â”‚   []byte    â”‚  â”‚   map[...]  â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚    ID: 1    â”‚  â”‚ Large Data  â”‚  â”‚ Key: Value  â”‚          â”‚
â”‚  â”‚ Email: ...  â”‚  â”‚   Buffer    â”‚  â”‚    ...      â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â–²               â–²               â–²                  â”‚
â”‚    Garbage           Escape           Dynamic              â”‚
â”‚    Collected        Analysis         Allocation            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "runtime"
    "unsafe"
)

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğµ backend Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
func demonstratePointers() {
    // 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ
    user := User{
        ID:    1,
        Email: "john@example.com",
        Name:  "John Doe",
    }
    
    userPtr := &user // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° user
    
    fmt.Printf("Value: %+v\n", user)
    fmt.Printf("Pointer: %p\n", userPtr)
    fmt.Printf("Value via pointer: %+v\n", *userPtr)
    
    // 2. ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ vs Ğ¿Ğ¾ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ
    updateUserByValue(user)
    fmt.Printf("After update by value: %s\n", user.Name) // ĞĞµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ
    
    updateUserByPointer(&user)
    fmt.Printf("After update by pointer: %s\n", user.Name) // Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ
    
    // 3. ĞÑƒĞ»ĞµĞ²Ñ‹Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ (nil)
    var nilUser *User
    fmt.Printf("Nil pointer: %v\n", nilUser)
    
    // Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° nil
    if nilUser != nil {
        fmt.Printf("User name: %s\n", nilUser.Name)
    } else {
        fmt.Println("User is nil")
    }
}

func updateUserByValue(u User) {
    u.Name = "Updated Name" // Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ¿Ğ¸Ñ
}

func updateUserByPointer(u *User) {
    u.Name = "Updated Name" // Ğ˜Ğ·Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»
}

// ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ² API
type UpdateUserRequest struct {
    Email *string `json:"email,omitempty"`     // nil = Ğ½Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒ
    Name  *string `json:"name,omitempty"`      // nil = Ğ½Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒ  
    IsActive *bool `json:"is_active,omitempty"` // nil = Ğ½Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒ
}

func updateUser(user *User, req UpdateUserRequest) {
    // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
    if req.Email != nil {
        user.Email = *req.Email
    }
    
    if req.Name != nil {
        user.Name = *req.Name
    }
    
    if req.IsActive != nil {
        user.IsActive = *req.IsActive
    }
}

// Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹
func StringPtr(s string) *string {
    return &s
}

func BoolPtr(b bool) *bool {
    return &b
}

func IntPtr(i int) *int {
    return &i
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ² JSON API
func demonstratePartialUpdate() {
    user := &User{
        ID:       1,
        Email:    "old@example.com",
        Name:     "Old Name",
        IsActive: false,
    }
    
    fmt.Printf("Before update: %+v\n", user)
    
    // Ğ§Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ email Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑ
    updateReq := UpdateUserRequest{
        Email:    StringPtr("new@example.com"),
        IsActive: BoolPtr(true),
        // Name Ğ½Ğµ Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ - Ğ¾ÑÑ‚Ğ°Ğ½ĞµÑ‚ÑÑ ÑÑ‚Ğ°Ñ€Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
    }
    
    updateUser(user, updateReq)
    fmt.Printf("After partial update: %+v\n", user)
}

// Ğ­Ñ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸: ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ vs Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
type LargeStruct struct {
    Data [1000]int // 8KB Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    ID   int64
    Name string
}

func processLargeStructByValue(ls LargeStruct) {
    // ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ 8KB+ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ
    fmt.Printf("Processing large struct with ID: %d\n", ls.ID)
}

func processLargeStructByPointer(ls *LargeStruct) {
    // ĞŸĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ 8 Ğ±Ğ°Ğ¹Ñ‚ (Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ)
    fmt.Printf("Processing large struct with ID: %d\n", ls.ID)
}

func demonstrateMemoryEfficiency() {
    large := LargeStruct{ID: 1, Name: "Test"}
    
    var m1, m2 runtime.MemStats
    
    // Ğ˜Ğ·Ğ¼ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ Ğ´Ğ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    // 1000 Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² Ğ¿Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ (Ğ¼Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹)
    for i := 0; i < 1000; i++ {
        processLargeStructByValue(large)
    }
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    fmt.Printf("Memory used (by value): %d bytes\n", m2.TotalAlloc-m1.TotalAlloc)
    
    // Ğ¡Ğ±Ñ€Ğ¾Ñ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¾Ğ²
    runtime.ReadMemStats(&m1)
    
    // 1000 Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² Ğ¿Ğ¾ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸)
    for i := 0; i < 1000; i++ {
        processLargeStructByPointer(&large)
    }
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    fmt.Printf("Memory used (by pointer): %d bytes\n", m2.TotalAlloc-m1.TotalAlloc)
}

// Ğ¡Ğ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ¿Ğ¸ÑĞºĞ¸ Ñ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
type ListNode struct {
    Value int
    Next  *ListNode
}

type LinkedList struct {
    Head *ListNode
    Size int
}

func (ll *LinkedList) Add(value int) {
    newNode := &ListNode{
        Value: value,
        Next:  ll.Head,
    }
    ll.Head = newNode
    ll.Size++
}

func (ll *LinkedList) Print() {
    current := ll.Head
    for current != nil {
        fmt.Printf("%d -> ", current.Value)
        current = current.Next
    }
    fmt.Println("nil")
}

// Escape analysis - ĞºĞ¾Ğ³Ğ´Ğ° Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ "ÑƒĞ±ĞµĞ³Ğ°ÑÑ‚" Ğ² heap
func createUser() *User {
    // user "ÑƒĞ±ĞµĞ³Ğ°ĞµÑ‚" Ğ² heap, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ
    user := User{
        ID:    1,
        Email: "escape@example.com",
        Name:  "Escaped User",
    }
    return &user // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½ÑƒÑ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ
}

func demonstrateEscapeAnalysis() {
    // user ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ÑÑ Ğ² heap, Ğ½Ğµ Ğ² stack
    user := createUser()
    fmt.Printf("Escaped user: %+v\n", user)
    
    // ĞœĞ¾Ğ¶ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ
    fmt.Printf("Pointer size: %d bytes\n", unsafe.Sizeof(user))
    fmt.Printf("User struct size: %d bytes\n", unsafe.Sizeof(*user))
}

// ĞŸÑƒĞ»Ñ‹ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ¸Ñ Ğ½Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ½Ğ° GC
type UserPool struct {
    pool chan *User
}

func NewUserPool(size int) *UserPool {
    return &UserPool{
        pool: make(chan *User, size),
    }
}

func (p *UserPool) Get() *User {
    select {
    case user := <-p.pool:
        return user
    default:
        return &User{} // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹, ĞµÑĞ»Ğ¸ Ğ¿ÑƒĞ» Ğ¿ÑƒÑÑ‚
    }
}

func (p *UserPool) Put(user *User) {
    // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿ĞµÑ€ĞµĞ´ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ¾Ğ¼ Ğ² Ğ¿ÑƒĞ»
    *user = User{}
    
    select {
    case p.pool <- user:
        // Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ²ĞµÑ€Ğ½ÑƒĞ»Ğ¸ Ğ² Ğ¿ÑƒĞ»
    default:
        // ĞŸÑƒĞ» Ğ¿Ğ¾Ğ»Ğ¾Ğ½, Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµĞ¼ GC Ğ¾Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±ÑŠĞµĞºÑ‚
    }
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹:**
- **Ğ­ĞºĞ¾Ğ½Ğ¾Ğ¼Ğ¸Ñ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸** - Ğ¸Ğ·Ğ±ĞµĞ³Ğ°ĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€
- **ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…** - Ğ¸Ğ·Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹
- **Ğ§Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ** - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ² API
- **ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ** - Ğ¼ĞµĞ½ÑŒÑˆĞµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ´Ğ»Ñ GC

**ğŸ’¡ ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ´Ğ»Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ñ… ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€ (>100 Ğ±Ğ°Ğ¹Ñ‚)
- Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ½Ğ° nil Ğ¿ĞµÑ€ĞµĞ´ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ´Ğ»Ñ optional Ğ¿Ğ¾Ğ»ĞµĞ¹ Ğ² API
- Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ğ¹Ñ‚Ğµ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ¸Ğ· Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ÑĞµĞ¼Ñ‹Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²

#### ğŸ”Œ Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ - Ğ³Ğ¸Ğ±ĞºĞ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ² Ğ² Go

```
Interface Architecture Pattern
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Interface Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Reader    â”‚  â”‚   Writer    â”‚  â”‚   Closer    â”‚          â”‚
â”‚  â”‚ interface   â”‚  â”‚ interface   â”‚  â”‚ interface   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â–²               â–²               â–²                  â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚    Implementation   Implementation   Implementation        â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    File     â”‚  â”‚   Network   â”‚  â”‚   Database  â”‚          â”‚
â”‚  â”‚             â”‚  â”‚   Socket    â”‚  â”‚ Connection  â”‚          â”‚
â”‚  â”‚ Read()      â”‚  â”‚ Write()     â”‚  â”‚ Close()     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Repository Pattern with Interfaces
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Business Logic                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           UserService                                   â”‚ â”‚
â”‚  â”‚  depends on â†’ UserRepository interface                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Interface Layer                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              UserRepository                             â”‚ â”‚
â”‚  â”‚  Create(user *User) error                              â”‚ â”‚
â”‚  â”‚  GetByID(id int64) (*User, error)                      â”‚ â”‚
â”‚  â”‚  Update(user *User) error                              â”‚ â”‚
â”‚  â”‚  Delete(id int64) error                                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â–²                                 â”‚
â”‚                           â”‚                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 Implementation Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ PostgresRepoâ”‚  â”‚  RedisRepo  â”‚  â”‚  MockRepo   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ implements  â”‚  â”‚ implements  â”‚  â”‚ implements  â”‚          â”‚
â”‚  â”‚UserRepositoryâ”‚  â”‚UserRepositoryâ”‚  â”‚UserRepositoryâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "io"
    "log"
    "strings"
    "time"
)

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Go (Ğ²ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ)
func demonstrateBuiltinInterfaces() {
    // io.Reader - Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    var reader io.Reader = strings.NewReader("Hello, Go interfaces!")
    
    data := make([]byte, 10)
    n, err := reader.Read(data)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Read %d bytes: %s\n", n, string(data[:n]))
    
    // io.Writer - Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    var writer io.Writer = &strings.Builder{}
    writer.Write([]byte("Writing to interface"))
    
    // Type assertion Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°
    if builder, ok := writer.(*strings.Builder); ok {
        fmt.Printf("Written: %s\n", builder.String())
    }
}

// ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ² Ğ´Ğ»Ñ backend Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹

// UserRepository - Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id int64) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
    List(ctx context.Context, offset, limit int) ([]*User, error)
}

// CacheRepository - Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type CacheRepository interface {
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
    Get(ctx context.Context, key string, dest interface{}) error
    Delete(ctx context.Context, key string) error
    Exists(ctx context.Context, key string) (bool, error)
}

// EmailService - Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ email
type EmailService interface {
    SendWelcome(ctx context.Context, user *User) error
    SendPasswordReset(ctx context.Context, user *User, token string) error
    SendNotification(ctx context.Context, email, subject, body string) error
}

// Logger - Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Fatal(msg string, fields ...Field)
}

type Field struct {
    Key   string
    Value interface{}
}

// Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ PostgreSQL Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ
type PostgresUserRepository struct {
    db Database // Ğ•Ñ‰Ğµ Ğ¾Ğ´Ğ¸Ğ½ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ!
}

type Database interface {
    Query(ctx context.Context, query string, args ...interface{}) (Rows, error)
    QueryRow(ctx context.Context, query string, args ...interface{}) Row
    Exec(ctx context.Context, query string, args ...interface{}) (Result, error)
    Begin(ctx context.Context) (Transaction, error)
}

type Rows interface {
    Next() bool
    Scan(dest ...interface{}) error
    Close() error
}

type Row interface {
    Scan(dest ...interface{}) error
}

type Result interface {
    LastInsertId() (int64, error)
    RowsAffected() (int64, error)
}

type Transaction interface {
    Database
    Commit() error
    Rollback() error
}

func NewPostgresUserRepository(db Database) UserRepository {
    return &PostgresUserRepository{db: db}
}

func (r *PostgresUserRepository) Create(ctx context.Context, user *User) error {
    query := `
        INSERT INTO users (email, name, password_hash, is_active, role, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id`
    
    now := time.Now()
    err := r.db.QueryRow(ctx, query, 
        user.Email, user.Name, user.Password, user.IsActive, user.Role, now, now,
    ).Scan(&user.ID)
    
    if err != nil {
        return fmt.Errorf("failed to create user: %w", err)
    }
    
    user.CreatedAt = now
    user.UpdatedAt = now
    return nil
}

func (r *PostgresUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    user := &User{}
    query := `
        SELECT id, email, name, is_active, role, created_at, updated_at
        FROM users WHERE id = $1 AND deleted_at IS NULL`
    
    err := r.db.QueryRow(ctx, query, id).Scan(
        &user.ID, &user.Email, &user.Name, &user.IsActive, 
        &user.Role, &user.CreatedAt, &user.UpdatedAt,
    )
    
    if err != nil {
        return nil, fmt.Errorf("failed to get user by id %d: %w", id, err)
    }
    
    return user, nil
}

func (r *PostgresUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    user := &User{}
    query := `
        SELECT id, email, name, is_active, role, created_at, updated_at
        FROM users WHERE email = $1 AND deleted_at IS NULL`
    
    err := r.db.QueryRow(ctx, query, email).Scan(
        &user.ID, &user.Email, &user.Name, &user.IsActive, 
        &user.Role, &user.CreatedAt, &user.UpdatedAt,
    )
    
    if err != nil {
        return nil, fmt.Errorf("failed to get user by email %s: %w", email, err)
    }
    
    return user, nil
}

func (r *PostgresUserRepository) Update(ctx context.Context, user *User) error {
    user.UpdatedAt = time.Now()
    query := `
        UPDATE users 
        SET email = $2, name = $3, is_active = $4, role = $5, updated_at = $6
        WHERE id = $1 AND deleted_at IS NULL`
    
    result, err := r.db.Exec(ctx, query, 
        user.ID, user.Email, user.Name, user.IsActive, user.Role, user.UpdatedAt,
    )
    
    if err != nil {
        return fmt.Errorf("failed to update user: %w", err)
    }
    
    rowsAffected, _ := result.RowsAffected()
    if rowsAffected == 0 {
        return errors.New("user not found or already deleted")
    }
    
    return nil
}

func (r *PostgresUserRepository) Delete(ctx context.Context, id int64) error {
    // Soft delete
    query := `UPDATE users SET deleted_at = $2 WHERE id = $1 AND deleted_at IS NULL`
    
    result, err := r.db.Exec(ctx, query, id, time.Now())
    if err != nil {
        return fmt.Errorf("failed to delete user: %w", err)
    }
    
    rowsAffected, _ := result.RowsAffected()
    if rowsAffected == 0 {
        return errors.New("user not found or already deleted")
    }
    
    return nil
}

func (r *PostgresUserRepository) List(ctx context.Context, offset, limit int) ([]*User, error) {
    query := `
        SELECT id, email, name, is_active, role, created_at, updated_at
        FROM users 
        WHERE deleted_at IS NULL
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2`
    
    rows, err := r.db.Query(ctx, query, limit, offset)
    if err != nil {
        return nil, fmt.Errorf("failed to list users: %w", err)
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        user := &User{}
        err := rows.Scan(
            &user.ID, &user.Email, &user.Name, &user.IsActive,
            &user.Role, &user.CreatedAt, &user.UpdatedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan user: %w", err)
        }
        users = append(users, user)
    }
    
    return users, nil
}

// Redis Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type RedisUserRepository struct {
    client RedisClient
    logger Logger
}

type RedisClient interface {
    Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
    Get(ctx context.Context, key string) (string, error)
    Del(ctx context.Context, keys ...string) error
    Exists(ctx context.Context, keys ...string) (int64, error)
}

func NewRedisUserRepository(client RedisClient, logger Logger) UserRepository {
    return &RedisUserRepository{
        client: client,
        logger: logger,
    }
}

func (r *RedisUserRepository) Create(ctx context.Context, user *User) error {
    return errors.New("redis repository does not support create operations")
}

func (r *RedisUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    key := fmt.Sprintf("user:%d", id)
    
    data, err := r.client.Get(ctx, key)
    if err != nil {
        return nil, fmt.Errorf("failed to get user from redis: %w", err)
    }
    
    var user User
    if err := json.Unmarshal([]byte(data), &user); err != nil {
        return nil, fmt.Errorf("failed to unmarshal user data: %w", err)
    }
    
    r.logger.Debug("User retrieved from cache", Field{Key: "user_id", Value: id})
    return &user, nil
}

// Mock Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type MockUserRepository struct {
    users map[int64]*User
    nextID int64
}

func NewMockUserRepository() UserRepository {
    return &MockUserRepository{
        users: make(map[int64]*User),
        nextID: 1,
    }
}

func (m *MockUserRepository) Create(ctx context.Context, user *User) error {
    user.ID = m.nextID
    m.nextID++
    user.CreatedAt = time.Now()
    user.UpdatedAt = user.CreatedAt
    
    m.users[user.ID] = user
    return nil
}

func (m *MockUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    user, exists := m.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    
    // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ĞºĞ¾Ğ¿Ğ¸Ñ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹
    userCopy := *user
    return &userCopy, nil
}

func (m *MockUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    for _, user := range m.users {
        if user.Email == email {
            userCopy := *user
            return &userCopy, nil
        }
    }
    return nil, errors.New("user not found")
}

func (m *MockUserRepository) Update(ctx context.Context, user *User) error {
    if _, exists := m.users[user.ID]; !exists {
        return errors.New("user not found")
    }
    
    user.UpdatedAt = time.Now()
    m.users[user.ID] = user
    return nil
}

func (m *MockUserRepository) Delete(ctx context.Context, id int64) error {
    if _, exists := m.users[id]; !exists {
        return errors.New("user not found")
    }
    
    delete(m.users, id)
    return nil
}

func (m *MockUserRepository) List(ctx context.Context, offset, limit int) ([]*User, error) {
    var users []*User
    i := 0
    
    for _, user := range m.users {
        if i >= offset && len(users) < limit {
            userCopy := *user
            users = append(users, &userCopy)
        }
        i++
    }
    
    return users, nil
}

// ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹ (ĞºÑÑˆ + Ğ±Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…)
type CachedUserRepository struct {
    primary UserRepository  // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹ (Ğ‘Ğ”)
    cache   UserRepository  // ĞšÑÑˆ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹
    logger  Logger
}

func NewCachedUserRepository(primary, cache UserRepository, logger Logger) UserRepository {
    return &CachedUserRepository{
        primary: primary,
        cache:   cache,
        logger:  logger,
    }
}

func (c *CachedUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    // Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºÑÑˆ
    user, err := c.cache.GetByID(ctx, id)
    if err == nil {
        c.logger.Debug("User found in cache", Field{Key: "user_id", Value: id})
        return user, nil
    }
    
    // Ğ•ÑĞ»Ğ¸ Ğ² ĞºÑÑˆĞµ Ğ½ĞµÑ‚, Ğ¸Ğ´ĞµĞ¼ Ğ² Ğ¾ÑĞ½Ğ¾Ğ²Ğ½ÑƒÑ Ğ‘Ğ”
    user, err = c.primary.GetByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² ĞºÑÑˆ Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
    if cacheErr := c.cache.Create(ctx, user); cacheErr != nil {
        c.logger.Warn("Failed to cache user", 
            Field{Key: "user_id", Value: id},
            Field{Key: "error", Value: cacheErr},
        )
    }
    
    c.logger.Debug("User loaded from primary storage", Field{Key: "user_id", Value: id})
    return user, nil
}

// Ğ”Ğ»Ñ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ primary Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹
func (c *CachedUserRepository) Create(ctx context.Context, user *User) error {
    return c.primary.Create(ctx, user)
}

func (c *CachedUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    return c.primary.GetByEmail(ctx, email)
}

func (c *CachedUserRepository) Update(ctx context.Context, user *User) error {
    // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ‘Ğ”
    if err := c.primary.Update(ctx, user); err != nil {
        return err
    }
    
    // Ğ˜Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ ĞºÑÑˆ
    if err := c.cache.Delete(ctx, user.ID); err != nil {
        c.logger.Warn("Failed to invalidate cache", 
            Field{Key: "user_id", Value: user.ID},
            Field{Key: "error", Value: err},
        )
    }
    
    return nil
}

func (c *CachedUserRepository) Delete(ctx context.Context, id int64) error {
    // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸Ğ· Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ‘Ğ”
    if err := c.primary.Delete(ctx, id); err != nil {
        return err
    }
    
    // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸Ğ· ĞºÑÑˆĞ°
    if err := c.cache.Delete(ctx, id); err != nil {
        c.logger.Warn("Failed to delete from cache", 
            Field{Key: "user_id", Value: id},
            Field{Key: "error", Value: err},
        )
    }
    
    return nil
}

func (c *CachedUserRepository) List(ctx context.Context, offset, limit int) ([]*User, error) {
    return c.primary.List(ctx, offset, limit)
}

// ĞŸÑƒÑÑ‚Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
func handleDynamicData(data interface{}) {
    switch v := data.(type) {
    case string:
        fmt.Printf("String data: %s\n", v)
    case int:
        fmt.Printf("Integer data: %d\n", v)
    case *User:
        fmt.Printf("User data: %s (%s)\n", v.Name, v.Email)
    case []interface{}:
        fmt.Printf("Array with %d elements\n", len(v))
    default:
        fmt.Printf("Unknown data type: %T\n", v)
    }
}

// Ğ”ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°Ğ¼Ğ¸
func demonstrateInterfaces() {
    ctx := context.Background()
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
    mockRepo := NewMockUserRepository()
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ - Ğ½Ğµ Ğ²Ğ°Ğ¶Ğ½Ğ¾, ĞºĞ°ĞºĞ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    user := &User{
        Email: "test@example.com",
        Name:  "Test User",
        IsActive: true,
        Role: RoleUser,
    }
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    if err := mockRepo.Create(ctx, user); err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Created user with ID: %d\n", user.ID)
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    retrievedUser, err := mockRepo.GetByID(ctx, user.ID)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Retrieved user: %+v\n", retrievedUser)
    
    // ĞœĞ¾Ğ¶ĞµĞ¼ Ğ»ĞµĞ³ĞºĞ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    var repo UserRepository = mockRepo // Ğ¢Ğ¸Ğ¿ interface{}
    
    // ĞŸĞ¾Ğ·Ğ¶Ğµ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ° PostgreSQL Ğ¸Ğ»Ğ¸ Redis
    // repo = NewPostgresUserRepository(db)
    // repo = NewRedisUserRepository(redisClient, logger)
    
    users, err := repo.List(ctx, 0, 10)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("Found %d users\n", len(users))
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ²:**
- **Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ»ĞµĞ³ĞºĞ¾ Ğ·Ğ°Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Ğ½Ğ° mock'Ğ¸
- **Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ** - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ´Ğ°
- **Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸** - Ñ‡ĞµÑ‚ĞºĞ¸Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ»Ğ¾ÑĞ¼Ğ¸
- **ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ** - ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹ (ĞºÑÑˆ + Ğ‘Ğ”)

**ğŸ’¡ ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»ÑŒ, Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ
- Ğ”ĞµĞ»Ğ°Ğ¹Ñ‚Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ¸ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡Ğ½Ñ‹Ğ¼Ğ¸
- ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿ "Program to interfaces, not implementations"
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

---

### ĞĞµĞ´ĞµĞ»Ñ 3: ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼ Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

#### ğŸš€ Ğ“Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ - Ğ»ĞµĞ³ĞºĞ¾Ğ²ĞµÑĞ½Ñ‹Ğµ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ¸

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ° Ğ² Go

```
Go Concurrency Model (M:N Threading)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OS Threads (M)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Thread    â”‚  â”‚   Thread    â”‚  â”‚   Thread    â”‚          â”‚
â”‚  â”‚     1       â”‚  â”‚     2       â”‚  â”‚     3       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â–²               â–²               â–²                  â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         â”‚      Go Scheduler (P)         â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         â–¼               â–¼               â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                Goroutines (G)                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚G1 â”‚ â”‚G2 â”‚ â”‚G3 â”‚ â”‚G4 â”‚ â”‚G5 â”‚ â”‚G6 â”‚ â”‚G7 â”‚ â”‚G8 â”‚ ... â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               Goroutine Lifecycle                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Created â†’ Runnable â†’ Running â†’ Blocked â†’ Runnable â†’ Dead   â”‚
â”‚     â”‚         â”‚          â”‚         â”‚         â”‚        â”‚   â”‚
â”‚     â–¼         â–¼          â–¼         â–¼         â–¼        â–¼   â”‚
â”‚   go()    Scheduled   Executing  I/O Wait  Ready    Exit  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

HTTP Server with Goroutines
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HTTP Server                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Accept    â”‚    â”‚           Handler Pool             â”‚  â”‚
â”‚  â”‚   Loop      â”‚â”€â”€â”€â”€â”¤                                     â”‚  â”‚
â”‚  â”‚             â”‚    â”‚  â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  â”‚ H1â”‚ â”‚ H2â”‚ â”‚ H3â”‚ â”‚ H4â”‚ â”‚ H5â”‚ ... â”‚  â”‚
â”‚         â”‚           â”‚  â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜     â”‚  â”‚
â”‚         â–¼           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              Each handler is a goroutine    â”‚
â”‚  â”‚ New Request â”‚                                              â”‚
â”‚  â”‚      â”‚      â”‚                                              â”‚
â”‚  â”‚      â–¼      â”‚                                              â”‚
â”‚  â”‚go handleReq â”‚                                              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "fmt"
    "log"
    "math/rand"
    "net/http"
    "runtime"
    "sync"
    "time"
)

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½
func demonstrateBasicGoroutines() {
    fmt.Printf("Starting with %d goroutines\n", runtime.NumGoroutine())
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½
    for i := 1; i <= 5; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d starting\n", id)
            time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
            fmt.Printf("Goroutine %d finished\n", id)
        }(i) // ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ i ĞºĞ°Ğº Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ closure Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼
    }
    
    // Ğ–Ğ´ĞµĞ¼ Ğ½ĞµĞ¼Ğ½Ğ¾Ğ³Ğ¾, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ğ»Ğ¸ÑÑŒ
    time.Sleep(2 * time.Second)
    fmt.Printf("Ending with %d goroutines\n", runtime.NumGoroutine())
}

// WaitGroup Ğ´Ğ»Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½
func demonstrateWaitGroup() {
    var wg sync.WaitGroup
    
    tasks := []string{"task1", "task2", "task3", "task4", "task5"}
    
    for _, task := range tasks {
        wg.Add(1) // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº
        
        go func(taskName string) {
            defer wg.Done() // Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸
            
            fmt.Printf("Processing %s\n", taskName)
            
            // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹
            time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
            
            fmt.Printf("Completed %s\n", taskName)
        }(task)
    }
    
    fmt.Println("Waiting for all tasks to complete...")
    wg.Wait() // Ğ–Ğ´ĞµĞ¼, Ğ¿Ğ¾ĞºĞ° ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ½Ğµ ÑÑ‚Ğ°Ğ½ĞµÑ‚ 0
    fmt.Println("All tasks completed!")
}

// Worker Pool Pattern Ğ´Ğ»Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡
type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Output string
    Error  error
}

func worker(id int, jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job.ID)
        
        // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹
        time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
        
        result := Result{
            Job:    job,
            Output: fmt.Sprintf("Processed by worker %d: %s", id, job.Data),
        }
        
        // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ (10% Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ)
        if rand.Float32() < 0.1 {
            result.Error = fmt.Errorf("worker %d failed to process job %d", id, job.ID)
        }
        
        results <- result
    }
}

func demonstrateWorkerPool() {
    const numWorkers = 3
    const numJobs = 10
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹
    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ workers
    for w := 1; w <= numWorkers; w++ {
        go worker(w, jobs, results)
    }
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    for j := 1; j <= numJobs; j++ {
        jobs <- Job{
            ID:   j,
            Data: fmt.Sprintf("data-%d", j),
        }
    }
    close(jobs) // Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ğ½Ğ°Ğ» Ğ·Ğ°Ğ´Ğ°Ñ‡
    
    // Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹
    for r := 1; r <= numJobs; r++ {
        result := <-results
        if result.Error != nil {
            fmt.Printf("âŒ Job %d failed: %v\n", result.Job.ID, result.Error)
        } else {
            fmt.Printf("âœ… Job %d: %s\n", result.Job.ID, result.Output)
        }
    }
}

// HTTP ÑĞµÑ€Ğ²ĞµÑ€ Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ğ¼Ğ¸
func handleUserRequest(w http.ResponseWriter, r *http.Request) {
    // ĞšĞ°Ğ¶Ğ´Ñ‹Ğ¹ HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğµ
    goroutineID := getGoroutineID()
    fmt.Printf("Handling request in goroutine %d\n", goroutineID)
    
    // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
    time.Sleep(100 * time.Millisecond)
    
    fmt.Fprintf(w, "Hello from goroutine %d at %s", goroutineID, time.Now().Format(time.RFC3339))
}

func getGoroutineID() int {
    // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ´ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸
    return int(rand.Int31n(10000))
}

// Graceful shutdown Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ğ¼Ğ¸
func demonstrateHTTPServer() {
    http.HandleFunc("/user", handleUserRequest)
    
    server := &http.Server{
        Addr:    ":8080",
        Handler: nil,
    }
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ÑĞµÑ€Ğ²ĞµÑ€ Ğ² Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğµ
    go func() {
        fmt.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal("Server failed:", err)
        }
    }()
    
    // Ğ˜Ğ¼Ğ¸Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ
    time.Sleep(5 * time.Second)
    
    // Graceful shutdown
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := server.Shutdown(ctx); err != nil {
        log.Fatal("Server shutdown failed:", err)
    }
    
    fmt.Println("Server stopped gracefully")
}

// Pipeline pattern Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ğ¼Ğ¸
func generateNumbers(max int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for i := 1; i <= max; i++ {
            out <- i
            time.Sleep(10 * time.Millisecond) // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
        }
    }()
    return out
}

func squareNumbers(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
            time.Sleep(5 * time.Millisecond) // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
        }
    }()
    return out
}

func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

func demonstratePipeline() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ pipeline: generate â†’ square â†’ filter
    numbers := generateNumbers(10)
    squared := squareNumbers(numbers)
    evenSquares := filterEven(squared)
    
    // Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹
    fmt.Println("Even squares:")
    for result := range evenSquares {
        fmt.Printf("%d ", result)
    }
    fmt.Println()
}

// Fan-out/Fan-in pattern
func fanOut(in <-chan Job, numWorkers int) []<-chan Result {
    channels := make([]<-chan Result, numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        out := make(chan Result)
        channels[i] = out
        
        go func() {
            defer close(out)
            for job := range in {
                // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
                time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
                
                result := Result{
                    Job:    job,
                    Output: fmt.Sprintf("Processed: %s", job.Data),
                }
                out <- result
            }
        }()
    }
    
    return channels
}

func fanIn(channels ...<-chan Result) <-chan Result {
    out := make(chan Result)
    var wg sync.WaitGroup
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñƒ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ²Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ°Ğ½Ğ°Ğ»Ğ°
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan Result) {
            defer wg.Done()
            for result := range c {
                out <- result
            }
        }(ch)
    }
    
    // Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ĞºĞ°Ğ½Ğ°Ğ», ĞºĞ¾Ğ³Ğ´Ğ° Ğ²ÑĞµ Ğ²Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func demonstrateFanOutFanIn() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸
    jobs := make(chan Job, 10)
    for i := 1; i <= 10; i++ {
        jobs <- Job{ID: i, Data: fmt.Sprintf("task-%d", i)}
    }
    close(jobs)
    
    // Fan-out: Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ 3 Ğ²Ğ¾Ñ€ĞºĞµÑ€Ğ°Ğ¼Ğ¸
    workerChannels := fanOut(jobs, 3)
    
    // Fan-in: ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ¾Ñ‚ Ğ²ÑĞµÑ… Ğ²Ğ¾Ñ€ĞºĞµÑ€Ğ¾Ğ²
    results := fanIn(workerChannels...)
    
    // Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹
    for result := range results {
        fmt.Printf("Result: %s\n", result.Output)
    }
}

// Race condition Ğ¸ ĞºĞ°Ğº ĞµĞ³Ğ¾ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func demonstrateRaceCondition() {
    // ĞĞµĞ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº
    unsafeCounter := 0
    
    // Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº
    safeCounter := &Counter{}
    
    var wg sync.WaitGroup
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ 100 Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½, ĞºĞ°Ğ¶Ğ´Ğ°Ñ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµÑ‚ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ¸ 1000 Ñ€Ğ°Ğ·
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                unsafeCounter++ // Race condition!
                safeCounter.Increment() // Thread-safe
            }
        }()
    }
    
    wg.Wait()
    
    fmt.Printf("Expected: 100000\n")
    fmt.Printf("Unsafe counter: %d\n", unsafeCounter) // Ğ’ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ Ğ¼ĞµĞ½ÑŒÑˆĞµ 100000
    fmt.Printf("Safe counter: %d\n", safeCounter.Value()) // Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ 100000
}

// Context Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½
func longRunningTask(ctx context.Context, id int) {
    ticker := time.NewTicker(500 * time.Millisecond)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Task %d cancelled: %v\n", id, ctx.Err())
            return
        case <-ticker.C:
            fmt.Printf("Task %d working...\n", id)
        }
    }
}

func demonstrateContext() {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ¾Ğ»Ğ³Ğ¸Ñ… Ğ·Ğ°Ğ´Ğ°Ñ‡
    for i := 1; i <= 3; i++ {
        go longRunningTask(ctx, i)
    }
    
    // Ğ–Ğ´ĞµĞ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ Ğ¿Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ñƒ
    <-ctx.Done()
    fmt.Println("All tasks cancelled")
    
    // Ğ”Ğ°ĞµĞ¼ Ğ²Ñ€ĞµĞ¼Ñ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ğ¼ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒÑÑ
    time.Sleep(100 * time.Millisecond)
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½:**
- **ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²** - ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ² Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğµ
- **ĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…** - worker pools Ğ´Ğ»Ñ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚Ğ¸
- **Pipeline Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°** - ÑÑ‚Ğ°Ğ¿Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğ°Ñ…
- **Background Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸** - Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‡Ğ¸, Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° ĞºÑÑˆĞ°

**ğŸ’¡ Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸:**
- Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ WaitGroup Ğ¸Ğ»Ğ¸ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
- Ğ˜Ğ·Ğ±ĞµĞ³Ğ°Ğ¹Ñ‚Ğµ race conditions Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ² Ğ¸Ğ»Ğ¸ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ²
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ context Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ¸ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ²
- ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°Ğ¹Ñ‚Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½ Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ worker pools

#### ğŸ“¡ ĞšĞ°Ğ½Ğ°Ğ»Ñ‹ - Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### Ğ¢Ğ¸Ğ¿Ñ‹ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸ Ğ¸Ñ… Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

```
Channel Types and Operations
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Unbuffered Channel                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Goroutine A                     Goroutine B                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚   Send      â”‚â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   Receive   â”‚            â”‚
â”‚  â”‚  ch <- val  â”‚   Synchronous   â”‚  val := <-châ”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    Communication â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                                â”‚                  â”‚
â”‚         â–¼                                â–¼                  â”‚
â”‚    Blocks until                     Blocks until            â”‚
â”‚    receiver ready                   sender ready            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Buffered Channel                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚           Buffer (capacity = 3)                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”                              â”‚ â”‚
â”‚  â”‚  â”‚ V1  â”‚  â”‚ V2  â”‚  â”‚ V3  â”‚                              â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â–²                                â–²                  â”‚
â”‚      Send here                      Receive here           â”‚
â”‚   (blocks when full)              (blocks when empty)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Channel Directions                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  chan int        â”‚  Bidirectional (send + receive)         â”‚
â”‚  chan<- int      â”‚  Send-only channel                      â”‚
â”‚  <-chan int      â”‚  Receive-only channel                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "fmt"
    "log"
    "math/rand"
    "sync"
    "time"
)

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸
func demonstrateBasicChannels() {
    // Unbuffered ĞºĞ°Ğ½Ğ°Ğ» (ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¹)
    ch := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch <- "Hello from goroutine!"
    }()
    
    message := <-ch // Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ´Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    fmt.Println("Received:", message)
    
    // Buffered ĞºĞ°Ğ½Ğ°Ğ» (Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğ¹)
    bufferedCh := make(chan int, 3)
    
    // ĞœĞ¾Ğ¶ĞµĞ¼ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ 3 Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ±ĞµĞ· Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸
    bufferedCh <- 1
    bufferedCh <- 2
    bufferedCh <- 3
    
    // Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    for i := 0; i < 3; i++ {
        value := <-bufferedCh
        fmt.Printf("Received: %d\n", value)
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ² ĞºĞ°Ğ½Ğ°Ğ»Ğ°
    fmt.Printf("Channel length: %d, capacity: %d\n", len(bufferedCh), cap(bufferedCh))
}

// ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ¾Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
func producer(out chan<- int) { // send-only
    for i := 1; i <= 5; i++ {
        out <- i
        time.Sleep(100 * time.Millisecond)
    }
    close(out)
}

func consumer(in <-chan int) { // receive-only
    for value := range in {
        fmt.Printf("Consumed: %d\n", value)
    }
}

func demonstrateDirectionalChannels() {
    ch := make(chan int)
    
    go producer(ch)
    consumer(ch)
}

// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
func demonstrateChannelClosing() {
    ch := make(chan int, 5)
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    go func() {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch) // Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ĞºĞ°Ğ½Ğ°Ğ» Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ Ğ²ÑĞµÑ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    }()
    
    // Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ± 1: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ ok
    for {
        value, ok := <-ch
        if !ok {
            fmt.Println("Channel closed")
            break
        }
        fmt.Printf("Received: %d\n", value)
    }
    
    // Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ± 2: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ range (Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµÑ‚ÑÑ Ğ¿Ñ€Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸)
    ch2 := make(chan string, 3)
    ch2 <- "first"
    ch2 <- "second"
    ch2 <- "third"
    close(ch2)
    
    for value := range ch2 {
        fmt.Printf("Range received: %s\n", value)
    }
}

// Request-Response pattern Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸
type Request struct {
    ID       int
    Data     string
    Response chan string // ĞšĞ°Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
}

func requestHandler(requests <-chan Request) {
    for req := range requests {
        // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
        time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
        
        response := fmt.Sprintf("Processed request %d: %s", req.ID, req.Data)
        req.Response <- response
        close(req.Response)
    }
}

func demonstrateRequestResponse() {
    requests := make(chan Request, 10)
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    go requestHandler(requests)
    
    var wg sync.WaitGroup
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ°Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
            responseCh := make(chan string)
            
            // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
            requests <- Request{
                ID:       id,
                Data:     fmt.Sprintf("data-%d", id),
                Response: responseCh,
            }
            
            // Ğ–Ğ´ĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚
            response := <-responseCh
            fmt.Printf("Got response: %s\n", response)
        }(i)
    }
    
    wg.Wait()
    close(requests)
}

// Semaphore pattern Ğ´Ğ»Ñ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ°
type Semaphore chan struct{}

func NewSemaphore(capacity int) Semaphore {
    return make(Semaphore, capacity)
}

func (s Semaphore) Acquire() {
    s <- struct{}{}
}

func (s Semaphore) Release() {
    <-s
}

func demonstrateSemaphore() {
    // ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ´Ğ¾ 2 Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
    sem := NewSemaphore(2)
    var wg sync.WaitGroup
    
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("Task %d started\n", id)
            time.Sleep(1 * time.Second) // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹
            fmt.Printf("Task %d completed\n", id)
        }(i)
    }
    
    wg.Wait()
}

// Notification pattern
type EventBus struct {
    subscribers map[string][]chan Event
    mu          sync.RWMutex
}

type Event struct {
    Type string
    Data interface{}
}

func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]chan Event),
    }
}

func (eb *EventBus) Subscribe(eventType string) <-chan Event {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    ch := make(chan Event, 10)
    eb.subscribers[eventType] = append(eb.subscribers[eventType], ch)
    return ch
}

func (eb *EventBus) Publish(event Event) {
    eb.mu.RLock()
    defer eb.mu.RUnlock()
    
    for _, ch := range eb.subscribers[event.Type] {
        // ĞĞµĞ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒÑÑ‰Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ°
        select {
        case ch <- event:
        default:
            log.Printf("Subscriber channel full, dropping event: %+v", event)
        }
    }
}

func demonstrateEventBus() {
    bus := NewEventBus()
    
    // ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸Ğº 1
    userEvents := bus.Subscribe("user")
    go func() {
        for event := range userEvents {
            fmt.Printf("User subscriber got: %+v\n", event)
        }
    }()
    
    // ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑ‡Ğ¸Ğº 2
    orderEvents := bus.Subscribe("order")
    go func() {
        for event := range orderEvents {
            fmt.Printf("Order subscriber got: %+v\n", event)
        }
    }()
    
    // ĞŸÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµĞ¼ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ
    bus.Publish(Event{Type: "user", Data: "User registered"})
    bus.Publish(Event{Type: "order", Data: "Order created"})
    bus.Publish(Event{Type: "user", Data: "User logged in"})
    
    time.Sleep(100 * time.Millisecond)
}

// Circuit Breaker pattern Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸
type CircuitBreaker struct {
    maxFailures int
    failures    int
    lastFailure time.Time
    timeout     time.Duration
    state       State
    mu          sync.Mutex
}

type State int

const (
    Closed State = iota
    Open
    HalfOpen
)

func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures: maxFailures,
        timeout:     timeout,
        state:       Closed,
    }
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    if cb.state == Open {
        if time.Since(cb.lastFailure) > cb.timeout {
            cb.state = HalfOpen
            cb.failures = 0
        } else {
            return fmt.Errorf("circuit breaker is open")
        }
    }
    
    // Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ
    err := fn()
    
    if err != nil {
        cb.failures++
        cb.lastFailure = time.Now()
        
        if cb.failures >= cb.maxFailures {
            cb.state = Open
        }
        return err
    }
    
    // Ğ£ÑĞ¿ĞµÑ… - ÑĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº
    cb.failures = 0
    cb.state = Closed
    return nil
}

func demonstrateCircuitBreaker() {
    cb := NewCircuitBreaker(3, 2*time.Second)
    
    // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ Ğ¸Ğ½Ğ¾Ğ³Ğ´Ğ° Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚
    unreliableService := func() error {
        if rand.Float32() < 0.7 { // 70% Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
            return fmt.Errorf("service unavailable")
        }
        return nil
    }
    
    // Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ circuit breaker
    for i := 1; i <= 10; i++ {
        err := cb.Call(unreliableService)
        if err != nil {
            fmt.Printf("Call %d failed: %v\n", i, err)
        } else {
            fmt.Printf("Call %d succeeded\n", i)
        }
        time.Sleep(500 * time.Millisecond)
    }
}

// Rate Limiter Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸
type RateLimiter struct {
    tokens chan struct{}
    ticker *time.Ticker
}

func NewRateLimiter(rate int, burst int) *RateLimiter {
    rl := &RateLimiter{
        tokens: make(chan struct{}, burst),
        ticker: time.NewTicker(time.Second / time.Duration(rate)),
    }
    
    // Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ñ‚Ğ¾ĞºĞµĞ½Ğ°Ğ¼Ğ¸
    for i := 0; i < burst; i++ {
        rl.tokens <- struct{}{}
    }
    
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ¿Ğ¾ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ
    go func() {
        for range rl.ticker.C {
            select {
            case rl.tokens <- struct{}{}:
            default:
                // Bucket Ğ¿Ğ¾Ğ»Ğ¾Ğ½, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½
            }
        }
    }()
    
    return rl
}

func (rl *RateLimiter) Allow() bool {
    select {
    case <-rl.tokens:
        return true
    default:
        return false
    }
}

func (rl *RateLimiter) Wait() {
    <-rl.tokens
}

func (rl *RateLimiter) Stop() {
    rl.ticker.Stop()
}

func demonstrateRateLimiter() {
    // 5 Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ² ÑĞµĞºÑƒĞ½Ğ´Ñƒ, burst Ğ´Ğ¾ 10
    rl := NewRateLimiter(5, 10)
    defer rl.Stop()
    
    // Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ 15 Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
    for i := 1; i <= 15; i++ {
        if rl.Allow() {
            fmt.Printf("Request %d: âœ… Allowed\n", i)
        } else {
            fmt.Printf("Request %d: âŒ Rate limited\n", i)
        }
    }
    
    // Ğ–Ğ´ĞµĞ¼ Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ĞµÑ‰Ğµ Ñ€Ğ°Ğ·
    fmt.Println("Waiting 2 seconds...")
    time.Sleep(2 * time.Second)
    
    for i := 16; i <= 20; i++ {
        if rl.Allow() {
            fmt.Printf("Request %d: âœ… Allowed\n", i)
        } else {
            fmt.Printf("Request %d: âŒ Rate limited\n", i)
        }
    }
}

// Timeout pattern Ñ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼Ğ¸
func makeRequestWithTimeout(url string, timeout time.Duration) (string, error) {
    result := make(chan string, 1)
    errors := make(chan error, 1)
    
    // Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ² Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğµ
    go func() {
        // Ğ˜Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ñ HTTP Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°
        time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)
        
        if rand.Float32() < 0.8 { // 80% ÑƒÑĞ¿ĞµÑ…Ğ°
            result <- fmt.Sprintf("Response from %s", url)
        } else {
            errors <- fmt.Errorf("request failed")
        }
    }()
    
    // Ğ–Ğ´ĞµĞ¼ Ğ»Ğ¸Ğ±Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚, Ğ»Ğ¸Ğ±Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚
    select {
    case res := <-result:
        return res, nil
    case err := <-errors:
        return "", err
    case <-time.After(timeout):
        return "", fmt.Errorf("request timed out after %v", timeout)
    }
}

func demonstrateTimeout() {
    urls := []string{
        "http://api1.example.com",
        "http://api2.example.com",
        "http://api3.example.com",
    }
    
    for _, url := range urls {
        response, err := makeRequestWithTimeout(url, 1*time.Second)
        if err != nil {
            fmt.Printf("âŒ %s: %v\n", url, err)
        } else {
            fmt.Printf("âœ… %s: %s\n", url, response)
        }
    }
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ²:**
- **Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ¼ÑƒĞ½Ğ¸ĞºĞ°Ñ†Ğ¸Ñ** - Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ğµ race conditions
- **Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ğ·Ğ¼Ğ°** - Ñ‡ĞµÑ‚ĞºĞ¸Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ
- **ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞ°** - rate limiting, circuit breaker, ÑĞµĞ¼Ğ°Ñ„Ğ¾Ñ€Ñ‹
- **Event-driven Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°** - pub/sub Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

**ğŸ’¡ ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- "Don't communicate by sharing memory; share memory by communicating"
- Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°Ğ¹Ñ‚Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½Ğ° ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ¾Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
- Ğ‘ÑƒÑ„ĞµÑ€Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸, Ğ½ĞµĞ±ÑƒÑ„ĞµÑ€Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

---

## ğŸŒ Ğ­Ñ‚Ğ°Ğ¿ 2: Backend-ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ (3-4 Ğ½ĞµĞ´ĞµĞ»Ğ¸)

### ĞĞµĞ´ĞµĞ»Ñ 4: HTTP ÑĞµÑ€Ğ²ĞµÑ€Ñ‹ Ğ¸ API

#### ğŸŒ HTTP ÑĞµÑ€Ğ²ĞµÑ€ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° HTTP ÑĞµÑ€Ğ²ĞµÑ€Ğ° Ğ² Go

```
HTTP Server Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HTTP Request Lifecycle                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Client    â”‚â”€â”€â”€â”€â”‚  Network    â”‚â”€â”€â”€â”€â”‚    Server   â”‚      â”‚
â”‚  â”‚             â”‚    â”‚   Stack     â”‚    â”‚   Socket    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                                      â”‚            â”‚
â”‚         â–¼                                      â–¼            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚               Go HTTP Server                            â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚                ServeMux Router                      â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  /api/  â”‚  â”‚ /users/ â”‚  â”‚ /health â”‚             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ handler â”‚  â”‚ handler â”‚  â”‚ handler â”‚             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚                         â”‚                               â”‚ â”‚
â”‚  â”‚                         â–¼                               â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚              Middleware Chain                       â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â”‚ Logging â”‚â†’ â”‚  CORS   â”‚â†’ â”‚  Auth   â”‚â†’ Handler   â”‚â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚               Request Processing                        â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚ Parse   â”‚â†’ â”‚Validate â”‚â†’ â”‚Business â”‚â†’ â”‚Response â”‚   â”‚ â”‚
â”‚  â”‚  â”‚Request  â”‚  â”‚  Data   â”‚  â”‚ Logic   â”‚  â”‚ Format  â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Goroutine Per Request Model
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Connection Pool                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Connection  â”‚  â”‚ Connection  â”‚  â”‚ Connection  â”‚          â”‚
â”‚  â”‚     1       â”‚  â”‚     2       â”‚  â”‚     3       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Goroutine   â”‚  â”‚ Goroutine   â”‚  â”‚ Goroutine   â”‚          â”‚
â”‚  â”‚     A       â”‚  â”‚     B       â”‚  â”‚     C       â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ Handle Req  â”‚  â”‚ Handle Req  â”‚  â”‚ Handle Req  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"
    
    "github.com/gorilla/mux"
)

// Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ HTTP ÑĞµÑ€Ğ²ĞµÑ€
func demonstrateBasicHTTPServer() {
    // ĞŸÑ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    http.HandleFunc("/hello", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World! Time: %s", time.Now().Format(time.RFC3339))
    })
    
    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ğ¼Ğ¸ URL
    http.HandleFunc("/user/", func(w http.ResponseWriter, r *http.Request) {
        // Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ ID Ğ¸Ğ· URL path
        path := strings.TrimPrefix(r.URL.Path, "/user/")
        if path == "" {
            http.Error(w, "User ID required", http.StatusBadRequest)
            return
        }
        
        userID, err := strconv.ParseInt(path, 10, 64)
        if err != nil {
            http.Error(w, "Invalid user ID", http.StatusBadRequest)
            return
        }
        
        // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ JSON Ğ¾Ñ‚Ğ²ĞµÑ‚
        response := map[string]interface{}{
            "user_id": userID,
            "name":    fmt.Sprintf("User %d", userID),
            "status":  "active",
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
    })
    
    fmt.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

// ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹ HTTP ÑĞµÑ€Ğ²ĞµÑ€ Ñ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸ĞµĞ¹
type HTTPServer struct {
    server   *http.Server
    router   *mux.Router
    userSvc  UserService
    logger   Logger
}

func NewHTTPServer(addr string, userSvc UserService, logger Logger) *HTTPServer {
    router := mux.NewRouter()
    
    server := &http.Server{
        Addr:         addr,
        Handler:      router,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
    
    httpServer := &HTTPServer{
        server:  server,
        router:  router,
        userSvc: userSvc,
        logger:  logger,
    }
    
    httpServer.setupRoutes()
    httpServer.setupMiddleware()
    
    return httpServer
}

func (s *HTTPServer) setupRoutes() {
    // API v1 routes
    api := s.router.PathPrefix("/api/v1").Subrouter()
    
    // User routes
    users := api.PathPrefix("/users").Subrouter()
    users.HandleFunc("", s.handleCreateUser).Methods("POST")
    users.HandleFunc("", s.handleListUsers).Methods("GET")
    users.HandleFunc("/{id:[0-9]+}", s.handleGetUser).Methods("GET")
    users.HandleFunc("/{id:[0-9]+}", s.handleUpdateUser).Methods("PUT")
    users.HandleFunc("/{id:[0-9]+}", s.handleDeleteUser).Methods("DELETE")
    
    // Auth routes
    auth := api.PathPrefix("/auth").Subrouter()
    auth.HandleFunc("/login", s.handleLogin).Methods("POST")
    auth.HandleFunc("/logout", s.handleLogout).Methods("POST")
    auth.HandleFunc("/refresh", s.handleRefreshToken).Methods("POST")
    
    // Health check
    s.router.HandleFunc("/health", s.handleHealth).Methods("GET")
    s.router.HandleFunc("/ready", s.handleReadiness).Methods("GET")
    
    // Metrics endpoint
    s.router.HandleFunc("/metrics", s.handleMetrics).Methods("GET")
}

func (s *HTTPServer) setupMiddleware() {
    // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ middleware Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ
    s.router.Use(s.loggingMiddleware)
    s.router.Use(s.corsMiddleware)
    s.router.Use(s.rateLimitMiddleware)
    
    // Auth middleware Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‰ĞµĞ½Ğ½Ñ‹Ñ… Ñ€Ğ¾ÑƒÑ‚Ğ¾Ğ²
    api := s.router.PathPrefix("/api/v1").Subrouter()
    api.Use(s.authMiddleware)
}

// Middleware Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
func (s *HTTPServer) loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // ĞĞ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ResponseWriter Ğ´Ğ»Ñ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
        lrw := &loggingResponseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        next.ServeHTTP(lrw, r)
        
        duration := time.Since(start)
        
        s.logger.Info("HTTP request",
            Field{Key: "method", Value: r.Method},
            Field{Key: "path", Value: r.URL.Path},
            Field{Key: "status", Value: lrw.statusCode},
            Field{Key: "duration", Value: duration.Milliseconds()},
            Field{Key: "ip", Value: r.RemoteAddr},
            Field{Key: "user_agent", Value: r.UserAgent()},
        )
    })
}

type loggingResponseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (lrw *loggingResponseWriter) WriteHeader(code int) {
    lrw.statusCode = code
    lrw.ResponseWriter.WriteHeader(code)
}

// CORS middleware
func (s *HTTPServer) corsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// Rate limiting middleware
func (s *HTTPServer) rateLimitMiddleware(next http.Handler) http.Handler {
    // ĞŸÑ€Ğ¾ÑÑ‚ĞµĞ¹ÑˆĞ¸Ğ¹ rate limiter Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ IP
    clients := make(map[string]*RateLimiter)
    var mu sync.RWMutex
    
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ip := r.RemoteAddr
        
        mu.RLock()
        limiter, exists := clients[ip]
        mu.RUnlock()
        
        if !exists {
            mu.Lock()
            limiter = NewRateLimiter(100, 10) // 100 req/sec, burst 10
            clients[ip] = limiter
            mu.Unlock()
        }
        
        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// Authentication middleware
func (s *HTTPServer) authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ endpoints
        if strings.HasSuffix(r.URL.Path, "/login") || 
           strings.HasSuffix(r.URL.Path, "/health") ||
           strings.HasSuffix(r.URL.Path, "/ready") {
            next.ServeHTTP(w, r)
            return
        }
        
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }
        
        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Bearer token
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header", http.StatusUnauthorized)
            return
        }
        
        token := parts[1]
        userID, err := s.validateJWT(token)
        if err != nil {
            http.Error(w, "Invalid token", http.StatusUnauthorized)
            return
        }
        
        // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ user ID Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚
        ctx := context.WithValue(r.Context(), "userID", userID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// User handlers
func (s *HTTPServer) handleCreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        s.respondError(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    if err := s.validateCreateUserRequest(req); err != nil {
        s.respondError(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user, err := s.userSvc.CreateUser(r.Context(), req)
    if err != nil {
        s.logger.Error("Failed to create user", Field{Key: "error", Value: err})
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    s.respondJSON(w, user.ToResponse(), http.StatusCreated)
}

func (s *HTTPServer) handleGetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID, err := strconv.ParseInt(vars["id"], 10, 64)
    if err != nil {
        s.respondError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    user, err := s.userSvc.GetUserByID(r.Context(), userID)
    if err != nil {
        if err == ErrUserNotFound {
            s.respondError(w, "User not found", http.StatusNotFound)
            return
        }
        s.logger.Error("Failed to get user", 
            Field{Key: "user_id", Value: userID},
            Field{Key: "error", Value: err},
        )
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    s.respondJSON(w, user.ToResponse(), http.StatusOK)
}

func (s *HTTPServer) handleListUsers(w http.ResponseWriter, r *http.Request) {
    // ĞŸĞ°Ñ€ÑĞ¸Ğ¼ query parameters Ğ´Ğ»Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ğ¸
    page, _ := strconv.Atoi(r.URL.Query().Get("page"))
    if page < 1 {
        page = 1
    }
    
    limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
    if limit < 1 || limit > 100 {
        limit = 20
    }
    
    offset := (page - 1) * limit
    
    users, total, err := s.userSvc.ListUsers(r.Context(), offset, limit)
    if err != nil {
        s.logger.Error("Failed to list users", Field{Key: "error", Value: err})
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ² response DTOs
    userResponses := make([]UserResponse, len(users))
    for i, user := range users {
        userResponses[i] = user.ToResponse()
    }
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚
    response := NewPaginatedResponse(userResponses, page, limit, total)
    s.respondJSON(w, response, http.StatusOK)
}

func (s *HTTPServer) handleUpdateUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID, err := strconv.ParseInt(vars["id"], 10, 64)
    if err != nil {
        s.respondError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    currentUserID := r.Context().Value("userID").(int64)
    if currentUserID != userID {
        // Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
        if !s.isAdmin(r.Context(), currentUserID) {
            s.respondError(w, "Access denied", http.StatusForbidden)
            return
        }
    }
    
    var req UpdateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        s.respondError(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    user, err := s.userSvc.UpdateUser(r.Context(), userID, req)
    if err != nil {
        if err == ErrUserNotFound {
            s.respondError(w, "User not found", http.StatusNotFound)
            return
        }
        s.logger.Error("Failed to update user",
            Field{Key: "user_id", Value: userID},
            Field{Key: "error", Value: err},
        )
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    s.respondJSON(w, user.ToResponse(), http.StatusOK)
}

func (s *HTTPServer) handleDeleteUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID, err := strconv.ParseInt(vars["id"], 10, 64)
    if err != nil {
        s.respondError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñ‹)
    currentUserID := r.Context().Value("userID").(int64)
    if !s.isAdmin(r.Context(), currentUserID) {
        s.respondError(w, "Access denied", http.StatusForbidden)
        return
    }
    
    err = s.userSvc.DeleteUser(r.Context(), userID)
    if err != nil {
        if err == ErrUserNotFound {
            s.respondError(w, "User not found", http.StatusNotFound)
            return
        }
        s.logger.Error("Failed to delete user",
            Field{Key: "user_id", Value: userID},
            Field{Key: "error", Value: err},
        )
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    w.WriteHeader(http.StatusNoContent)
}

// Auth handlers
func (s *HTTPServer) handleLogin(w http.ResponseWriter, r *http.Request) {
    var req LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        s.respondError(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    // ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
    user, err := s.userSvc.AuthenticateUser(r.Context(), req.Email, req.Password)
    if err != nil {
        if err == ErrInvalidCredentials {
            s.respondError(w, "Invalid credentials", http.StatusUnauthorized)
            return
        }
        s.logger.Error("Failed to authenticate user",
            Field{Key: "email", Value: req.Email},
            Field{Key: "error", Value: err},
        )
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñ‹
    accessToken, err := s.generateAccessToken(user.ID)
    if err != nil {
        s.logger.Error("Failed to generate access token", Field{Key: "error", Value: err})
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    refreshToken, err := s.generateRefreshToken(user.ID)
    if err != nil {
        s.logger.Error("Failed to generate refresh token", Field{Key: "error", Value: err})
        s.respondError(w, "Internal server error", http.StatusInternalServerError)
        return
    }
    
    response := LoginResponse{
        User:         user.ToResponse(),
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        ExpiresIn:    3600, // 1 Ñ‡Ğ°Ñ
    }
    
    s.respondJSON(w, response, http.StatusOK)
}

// Health check handlers
func (s *HTTPServer) handleHealth(w http.ResponseWriter, r *http.Request) {
    health := map[string]interface{}{
        "status":    "healthy",
        "timestamp": time.Now(),
        "version":   "1.0.0",
    }
    
    s.respondJSON(w, health, http.StatusOK)
}

func (s *HTTPServer) handleReadiness(w http.ResponseWriter, r *http.Request) {
    checks := map[string]string{
        "database": "ok",
        "redis":    "ok",
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
    if err := s.userSvc.HealthCheck(r.Context()); err != nil {
        checks["database"] = "failed"
        s.respondJSON(w, map[string]interface{}{
            "status": "not ready",
            "checks": checks,
        }, http.StatusServiceUnavailable)
        return
    }
    
    s.respondJSON(w, map[string]interface{}{
        "status": "ready",
        "checks": checks,
    }, http.StatusOK)
}

// Utility methods
func (s *HTTPServer) respondJSON(w http.ResponseWriter, data interface{}, status int) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    
    if err := json.NewEncoder(w).Encode(data); err != nil {
        s.logger.Error("Failed to encode JSON response", Field{Key: "error", Value: err})
    }
}

func (s *HTTPServer) respondError(w http.ResponseWriter, message string, status int) {
    response := map[string]interface{}{
        "error":   message,
        "status":  status,
        "timestamp": time.Now(),
    }
    
    s.respondJSON(w, response, status)
}

func (s *HTTPServer) validateCreateUserRequest(req CreateUserRequest) error {
    if req.Email == "" {
        return fmt.Errorf("email is required")
    }
    if req.Name == "" {
        return fmt.Errorf("name is required")
    }
    if len(req.Password) < 8 {
        return fmt.Errorf("password must be at least 8 characters")
    }
    return nil
}

func (s *HTTPServer) validateJWT(token string) (int64, error) {
    // Simplified JWT validation - Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ jwt-go
    if token == "valid-token" {
        return 1, nil
    }
    return 0, fmt.Errorf("invalid token")
}

func (s *HTTPServer) isAdmin(ctx context.Context, userID int64) bool {
    user, err := s.userSvc.GetUserByID(ctx, userID)
    if err != nil {
        return false
    }
    return user.Role == RoleAdmin
}

func (s *HTTPServer) generateAccessToken(userID int64) (string, error) {
    // Simplified token generation
    return fmt.Sprintf("access-token-%d", userID), nil
}

func (s *HTTPServer) generateRefreshToken(userID int64) (string, error) {
    // Simplified token generation
    return fmt.Sprintf("refresh-token-%d", userID), nil
}

// Graceful shutdown
func (s *HTTPServer) Start() error {
    s.logger.Info("Starting HTTP server", Field{Key: "addr", Value: s.server.Addr})
    return s.server.ListenAndServe()
}

func (s *HTTPServer) Stop(ctx context.Context) error {
    s.logger.Info("Stopping HTTP server")
    return s.server.Shutdown(ctx)
}

// Request/Response DTOs
type CreateUserRequest struct {
    Email    string `json:"email"`
    Name     string `json:"name"`
    Password string `json:"password"`
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type LoginResponse struct {
    User         UserResponse `json:"user"`
    AccessToken  string       `json:"access_token"`
    RefreshToken string       `json:"refresh_token"`
    ExpiresIn    int          `json:"expires_in"`
}

// Errors
var (
    ErrUserNotFound       = fmt.Errorf("user not found")
    ErrInvalidCredentials = fmt.Errorf("invalid credentials")
)

// User service interface
type UserService interface {
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUserByID(ctx context.Context, id int64) (*User, error)
    ListUsers(ctx context.Context, offset, limit int) ([]*User, int, error)
    UpdateUser(ctx context.Context, id int64, req UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id int64) error
    AuthenticateUser(ctx context.Context, email, password string) (*User, error)
    HealthCheck(ctx context.Context) error
}

// File upload handler
func (s *HTTPServer) handleFileUpload(w http.ResponseWriter, r *http.Request) {
    // ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ñ„Ğ°Ğ¹Ğ»Ğ° (10MB)
    r.ParseMultipartForm(10 << 20)
    
    file, handler, err := r.FormFile("upload")
    if err != nil {
        s.respondError(w, "Error retrieving file", http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ñ‚Ğ¸Ğ¿Ğ° Ñ„Ğ°Ğ¹Ğ»Ğ°
    allowedTypes := map[string]bool{
        "image/jpeg": true,
        "image/png":  true,
        "image/gif":  true,
    }
    
    contentType := handler.Header.Get("Content-Type")
    if !allowedTypes[contentType] {
        s.respondError(w, "File type not allowed", http.StatusBadRequest)
        return
    }
    
    // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ» Ğ±Ñ‹ ĞºĞ¾Ğ´ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°
    s.logger.Info("File uploaded",
        Field{Key: "filename", Value: handler.Filename},
        Field{Key: "size", Value: handler.Size},
        Field{Key: "content_type", Value: contentType},
    )
    
    response := map[string]interface{}{
        "message":  "File uploaded successfully",
        "filename": handler.Filename,
        "size":     handler.Size,
    }
    
    s.respondJSON(w, response, http.StatusOK)
}

// Streaming response example
func (s *HTTPServer) handleStreamingData(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Transfer-Encoding", "chunked")
    
    flusher, ok := w.(http.Flusher)
    if !ok {
        s.respondError(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }
    
    encoder := json.NewEncoder(w)
    
    for i := 1; i <= 10; i++ {
        data := map[string]interface{}{
            "id":        i,
            "message":   fmt.Sprintf("Chunk %d", i),
            "timestamp": time.Now(),
        }
        
        if err := encoder.Encode(data); err != nil {
            s.logger.Error("Failed to encode streaming data", Field{Key: "error", Value: err})
            return
        }
        
        flusher.Flush()
        time.Sleep(500 * time.Millisecond)
    }
}

// WebSocket upgrade (ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ real-time)
func (s *HTTPServer) handleWebSocket(w http.ResponseWriter, r *http.Request) {
    // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ» Ğ±Ñ‹ ĞºĞ¾Ğ´ Ğ´Ğ»Ñ WebSocket upgrade
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ gorilla/websocket Ğ¸Ğ»Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ‡Ğ½ÑƒÑ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµĞºÑƒ
    s.respondError(w, "WebSocket not implemented", http.StatusNotImplemented)
}

// Metrics handler Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ°
func (s *HTTPServer) handleMetrics(w http.ResponseWriter, r *http.Request) {
    metrics := map[string]interface{}{
        "goroutines":    runtime.NumGoroutine(),
        "memory_alloc":  getMemStats().Alloc,
        "memory_sys":    getMemStats().Sys,
        "gc_cycles":     getMemStats().NumGC,
        "uptime":        time.Since(startTime).Seconds(),
    }
    
    s.respondJSON(w, metrics, http.StatusOK)
}

var startTime = time.Now()

func getMemStats() runtime.MemStats {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    return m
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° ÑĞµÑ€Ğ²ĞµÑ€Ğ°
func main() {
    // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ¸ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ğ»Ğ¸ÑÑŒ Ğ±Ñ‹ Ñ‡ĞµÑ€ĞµĞ· DI
    logger := &ConsoleLogger{}
    userRepo := NewMockUserRepository()
    userSvc := NewUserService(userRepo, logger)
    
    server := NewHTTPServer(":8080", userSvc, logger)
    
    // Graceful shutdown
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    go func() {
        if err := server.Start(); err != http.ErrServerClosed {
            log.Fatal("Server failed to start:", err)
        }
    }()
    
    // Ğ–Ğ´ĞµĞ¼ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
    // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ» Ğ±Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    time.Sleep(30 * time.Second)
    
    // Graceful shutdown
    shutdownCtx, shutdownCancel := context.WithTimeout(ctx, 30*time.Second)
    defer shutdownCancel()
    
    if err := server.Stop(shutdownCtx); err != nil {
        log.Fatal("Server failed to stop gracefully:", err)
    }
    
    log.Println("Server stopped gracefully")
}

// Console logger implementation for demo
type ConsoleLogger struct{}

func (c *ConsoleLogger) Debug(msg string, fields ...Field) {
    log.Printf("DEBUG: %s %v", msg, fields)
}

func (c *ConsoleLogger) Info(msg string, fields ...Field) {
    log.Printf("INFO: %s %v", msg, fields)
}

func (c *ConsoleLogger) Warn(msg string, fields ...Field) {
    log.Printf("WARN: %s %v", msg, fields)
}

func (c *ConsoleLogger) Error(msg string, fields ...Field) {
    log.Printf("ERROR: %s %v", msg, fields)
}

func (c *ConsoleLogger) Fatal(msg string, fields ...Field) {
    log.Fatalf("FATAL: %s %v", msg, fields)
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° HTTP ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ²:**
- **ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ñ‹ÑÑÑ‡Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
- **Middleware** - Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒĞ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
- **Ğ¢Ğ¸Ğ¿Ğ¾Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ** - ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ request/response Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑ‚ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
- **ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³** - Ğ²ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ endpoints Ğ´Ğ»Ñ health checks Ğ¸ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº

**ğŸ’¡ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹:**
- Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ»Ğ¾ÑĞ¼Ğ¸
- Middleware Ğ´Ğ»Ñ cross-cutting concerns
- Graceful shutdown Ğ´Ğ»Ñ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
- Comprehensive error handling Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

---

### ĞĞµĞ´ĞµĞ»Ñ 5: Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ±Ğ°Ğ·Ğ°Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

#### ğŸ—„ï¸ Database Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ² Go

### Database Connection Architecture

```
Database Connection Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Service   â”‚  â”‚   Service   â”‚  â”‚   Service   â”‚          â”‚
â”‚  â”‚    Layer    â”‚  â”‚    Layer    â”‚  â”‚    Layer    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Repository Layer                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    User     â”‚  â”‚    Order    â”‚  â”‚   Product   â”‚          â”‚
â”‚  â”‚ Repository  â”‚  â”‚ Repository  â”‚  â”‚ Repository  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 Database Layer                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Connection Pool                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  Conn   â”‚  â”‚  Conn   â”‚  â”‚  Conn   â”‚  â”‚  Conn   â”‚   â”‚ â”‚
â”‚  â”‚  â”‚    1    â”‚  â”‚    2    â”‚  â”‚    3    â”‚  â”‚   ...   â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                PostgreSQL Database                     â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚ â”‚
â”‚  â”‚  â”‚  users  â”‚  â”‚ orders  â”‚  â”‚products â”‚                â”‚ â”‚
â”‚  â”‚  â”‚  table  â”‚  â”‚  table  â”‚  â”‚  table  â”‚                â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Transaction Flow
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Transaction Lifecycle                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚    BEGIN    â”‚ â”€â†’ â”‚  EXECUTE    â”‚ â”€â†’ â”‚   COMMIT    â”‚      â”‚
â”‚  â”‚             â”‚    â”‚  QUERIES    â”‚    â”‚     OR      â”‚      â”‚
â”‚  â”‚             â”‚    â”‚             â”‚    â”‚  ROLLBACK   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                 â”‚                     â”‚           â”‚
â”‚         â–¼                 â–¼                     â–¼           â”‚
â”‚  Start transaction   Execute SQL       Apply changes        â”‚
â”‚  Get connection      within context    or revert all        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"

    _ "github.com/lib/pq" // PostgreSQL driver
    "github.com/jmoiron/sqlx"
)

// Database configuration
type DatabaseConfig struct {
    Host         string
    Port         int
    User         string
    Password     string
    Database     string
    SSLMode      string
    MaxOpenConns int
    MaxIdleConns int
    MaxLifetime  time.Duration
}

func (cfg DatabaseConfig) DSN() string {
    return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Database, cfg.SSLMode)
}

// Database connection wrapper
type Database struct {
    db     *sqlx.DB
    config DatabaseConfig
}

func NewDatabase(config DatabaseConfig) (*Database, error) {
    db, err := sqlx.Connect("postgres", config.DSN())
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }

    // ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° connection pool
    db.SetMaxOpenConns(config.MaxOpenConns)
    db.SetMaxIdleConns(config.MaxIdleConns)
    db.SetConnMaxLifetime(config.MaxLifetime)

    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
    if err := db.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }

    return &Database{
        db:     db,
        config: config,
    }, nil
}

func (d *Database) Close() error {
    return d.db.Close()
}

func (d *Database) HealthCheck(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return d.db.PingContext(ctx)
}

func (d *Database) Stats() sql.DBStats {
    return d.db.Stats()
}

// ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ database Ñ‚ĞµĞ³Ğ°Ğ¼Ğ¸
type User struct {
    ID        int64     `db:"id" json:"id"`
    Email     string    `db:"email" json:"email"`
    Name      string    `db:"name" json:"name"`
    Password  string    `db:"password_hash" json:"-"`
    IsActive  bool      `db:"is_active" json:"is_active"`
    Role      string    `db:"role" json:"role"`
    CreatedAt time.Time `db:"created_at" json:"created_at"`
    UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
    DeletedAt *time.Time `db:"deleted_at" json:"deleted_at,omitempty"`
}

type Order struct {
    ID         int64     `db:"id" json:"id"`
    UserID     int64     `db:"user_id" json:"user_id"`
    TotalAmount float64   `db:"total_amount" json:"total_amount"`
    Status     string    `db:"status" json:"status"`
    CreatedAt  time.Time `db:"created_at" json:"created_at"`
    UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
    
    // Ğ¡Ğ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    User  *User        `json:"user,omitempty"`
    Items []OrderItem  `json:"items,omitempty"`
}

type OrderItem struct {
    ID        int64   `db:"id" json:"id"`
    OrderID   int64   `db:"order_id" json:"order_id"`
    ProductID int64   `db:"product_id" json:"product_id"`
    Quantity  int     `db:"quantity" json:"quantity"`
    Price     float64 `db:"price" json:"price"`
}

// Repository interface
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id int64) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
    List(ctx context.Context, filters UserFilters) ([]*User, error)
    Count(ctx context.Context, filters UserFilters) (int, error)
}

type UserFilters struct {
    IsActive *bool
    Role     string
    Search   string
    Limit    int
    Offset   int
}

// PostgreSQL repository implementation
type PostgresUserRepository struct {
    db *Database
}

func NewPostgresUserRepository(db *Database) UserRepository {
    return &PostgresUserRepository{db: db}
}

func (r *PostgresUserRepository) Create(ctx context.Context, user *User) error {
    query := `
        INSERT INTO users (email, name, password_hash, is_active, role, created_at, updated_at)
        VALUES (:email, :name, :password_hash, :is_active, :role, :created_at, :updated_at)
        RETURNING id`
    
    // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¼ĞµÑ‚ĞºĞ¸
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now
    
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ NamedQuery Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ÑĞ¾ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¾Ğ¹
    rows, err := r.db.db.NamedQuery(query, user)
    if err != nil {
        return fmt.Errorf("failed to create user: %w", err)
    }
    defer rows.Close()
    
    if rows.Next() {
        err = rows.Scan(&user.ID)
        if err != nil {
            return fmt.Errorf("failed to scan user ID: %w", err)
        }
    }
    
    return nil
}

func (r *PostgresUserRepository) GetByID(ctx context.Context, id int64) (*User, error) {
    user := &User{}
    query := `
        SELECT id, email, name, password_hash, is_active, role, created_at, updated_at, deleted_at
        FROM users 
        WHERE id = $1 AND deleted_at IS NULL`
    
    err := r.db.db.GetContext(ctx, user, query, id)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user by id %d: %w", id, err)
    }
    
    return user, nil
}

func (r *PostgresUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    user := &User{}
    query := `
        SELECT id, email, name, password_hash, is_active, role, created_at, updated_at, deleted_at
        FROM users 
        WHERE email = $1 AND deleted_at IS NULL`
    
    err := r.db.db.GetContext(ctx, user, query, email)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user by email %s: %w", email, err)
    }
    
    return user, nil
}

func (r *PostgresUserRepository) Update(ctx context.Context, user *User) error {
    user.UpdatedAt = time.Now()
    
    query := `
        UPDATE users 
        SET email = :email, name = :name, password_hash = :password_hash, 
            is_active = :is_active, role = :role, updated_at = :updated_at
        WHERE id = :id AND deleted_at IS NULL`
    
    result, err := r.db.db.NamedExecContext(ctx, query, user)
    if err != nil {
        return fmt.Errorf("failed to update user: %w", err)
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }
    
    if rowsAffected == 0 {
        return ErrUserNotFound
    }
    
    return nil
}

func (r *PostgresUserRepository) Delete(ctx context.Context, id int64) error {
    // Soft delete
    query := `UPDATE users SET deleted_at = $2 WHERE id = $1 AND deleted_at IS NULL`
    
    result, err := r.db.db.ExecContext(ctx, query, id, time.Now())
    if err != nil {
        return fmt.Errorf("failed to delete user: %w", err)
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }
    
    if rowsAffected == 0 {
        return ErrUserNotFound
    }
    
    return nil
}

func (r *PostgresUserRepository) List(ctx context.Context, filters UserFilters) ([]*User, error) {
    var users []*User
    
    // Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ğ¼ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ
    query := `
        SELECT id, email, name, password_hash, is_active, role, created_at, updated_at, deleted_at
        FROM users 
        WHERE deleted_at IS NULL`
    
    args := []interface{}{}
    argIndex := 1
    
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹
    if filters.IsActive != nil {
        query += fmt.Sprintf(" AND is_active = $%d", argIndex)
        args = append(args, *filters.IsActive)
        argIndex++
    }
    
    if filters.Role != "" {
        query += fmt.Sprintf(" AND role = $%d", argIndex)
        args = append(args, filters.Role)
        argIndex++
    }
    
    if filters.Search != "" {
        query += fmt.Sprintf(" AND (name ILIKE $%d OR email ILIKE $%d)", argIndex, argIndex+1)
        searchPattern := "%" + filters.Search + "%"
        args = append(args, searchPattern, searchPattern)
        argIndex += 2
    }
    
    // Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¸ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ
    query += " ORDER BY created_at DESC"
    
    if filters.Limit > 0 {
        query += fmt.Sprintf(" LIMIT $%d", argIndex)
        args = append(args, filters.Limit)
        argIndex++
    }
    
    if filters.Offset > 0 {
        query += fmt.Sprintf(" OFFSET $%d", argIndex)
        args = append(args, filters.Offset)
    }
    
    err := r.db.db.SelectContext(ctx, &users, query, args...)
    if err != nil {
        return nil, fmt.Errorf("failed to list users: %w", err)
    }
    
    return users, nil
}

func (r *PostgresUserRepository) Count(ctx context.Context, filters UserFilters) (int, error) {
    query := `SELECT COUNT(*) FROM users WHERE deleted_at IS NULL`
    
    args := []interface{}{}
    argIndex := 1
    
    // Ğ¢Ğµ Ğ¶Ğµ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹, Ñ‡Ñ‚Ğ¾ Ğ¸ Ğ² List
    if filters.IsActive != nil {
        query += fmt.Sprintf(" AND is_active = $%d", argIndex)
        args = append(args, *filters.IsActive)
        argIndex++
    }
    
    if filters.Role != "" {
        query += fmt.Sprintf(" AND role = $%d", argIndex)
        args = append(args, filters.Role)
        argIndex++
    }
    
    if filters.Search != "" {
        query += fmt.Sprintf(" AND (name ILIKE $%d OR email ILIKE $%d)", argIndex, argIndex+1)
        searchPattern := "%" + filters.Search + "%"
        args = append(args, searchPattern, searchPattern)
    }
    
    var count int
    err := r.db.db.GetContext(ctx, &count, query, args...)
    if err != nil {
        return 0, fmt.Errorf("failed to count users: %w", err)
    }
    
    return count, nil
}

// Transaction support
type Transactional interface {
    WithTransaction(ctx context.Context, fn func(ctx context.Context, tx *sqlx.Tx) error) error
}

func (d *Database) WithTransaction(ctx context.Context, fn func(ctx context.Context, tx *sqlx.Tx) error) error {
    tx, err := d.db.BeginTxx(ctx, nil)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        }
    }()
    
    if err := fn(ctx, tx); err != nil {
        if rollbackErr := tx.Rollback(); rollbackErr != nil {
            return fmt.Errorf("failed to rollback transaction: %v (original error: %w)", rollbackErr, err)
        }
        return err
    }
    
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }
    
    return nil
}

// Service layer with transaction support
type UserService struct {
    userRepo UserRepository
    db       *Database
    logger   Logger
}

func NewUserService(userRepo UserRepository, db *Database, logger Logger) *UserService {
    return &UserService{
        userRepo: userRepo,
        db:       db,
        logger:   logger,
    }
}

func (s *UserService) CreateUserWithOrder(ctx context.Context, email, name string, orderAmount float64) (*User, *Order, error) {
    var user *User
    var order *Order
    
    err := s.db.WithTransaction(ctx, func(ctx context.Context, tx *sqlx.Tx) error {
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        user = &User{
            Email:    email,
            Name:     name,
            IsActive: true,
            Role:     "user",
        }
        
        // Ğ’ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ Ğ½Ğ°Ğ¼ Ğ½ÑƒĞ¶ĞµĞ½ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹, Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‰Ğ¸Ğ¹ Ñ tx
        txUserRepo := NewTransactionalUserRepository(tx)
        if err := txUserRepo.Create(ctx, user); err != nil {
            return fmt.Errorf("failed to create user: %w", err)
        }
        
        // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
        order = &Order{
            UserID:      user.ID,
            TotalAmount: orderAmount,
            Status:      "pending",
            CreatedAt:   time.Now(),
            UpdatedAt:   time.Now(),
        }
        
        txOrderRepo := NewTransactionalOrderRepository(tx)
        if err := txOrderRepo.Create(ctx, order); err != nil {
            return fmt.Errorf("failed to create order: %w", err)
        }
        
        return nil
    })
    
    if err != nil {
        s.logger.Error("Failed to create user with order",
            Field{Key: "email", Value: email},
            Field{Key: "error", Value: err},
        )
        return nil, nil, err
    }
    
    return user, order, nil
}

// Transactional repository
type TransactionalUserRepository struct {
    tx *sqlx.Tx
}

func NewTransactionalUserRepository(tx *sqlx.Tx) *TransactionalUserRepository {
    return &TransactionalUserRepository{tx: tx}
}

func (r *TransactionalUserRepository) Create(ctx context.Context, user *User) error {
    query := `
        INSERT INTO users (email, name, password_hash, is_active, role, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id`
    
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now
    
    err := r.tx.QueryRowContext(ctx, query, 
        user.Email, user.Name, user.Password, user.IsActive, user.Role, now, now,
    ).Scan(&user.ID)
    
    if err != nil {
        return fmt.Errorf("failed to create user in transaction: %w", err)
    }
    
    return nil
}

// Order repository for transaction example
type OrderRepository interface {
    Create(ctx context.Context, order *Order) error
    GetByID(ctx context.Context, id int64) (*Order, error)
    GetByUserID(ctx context.Context, userID int64) ([]*Order, error)
}

type TransactionalOrderRepository struct {
    tx *sqlx.Tx
}

func NewTransactionalOrderRepository(tx *sqlx.Tx) *TransactionalOrderRepository {
    return &TransactionalOrderRepository{tx: tx}
}

func (r *TransactionalOrderRepository) Create(ctx context.Context, order *Order) error {
    query := `
        INSERT INTO orders (user_id, total_amount, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id`
    
    err := r.tx.QueryRowContext(ctx, query,
        order.UserID, order.TotalAmount, order.Status, order.CreatedAt, order.UpdatedAt,
    ).Scan(&order.ID)
    
    if err != nil {
        return fmt.Errorf("failed to create order in transaction: %w", err)
    }
    
    return nil
}

// Query builder Ğ´Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
type QueryBuilder struct {
    query  string
    args   []interface{}
    argNum int
}

func NewQueryBuilder(baseQuery string) *QueryBuilder {
    return &QueryBuilder{
        query:  baseQuery,
        args:   make([]interface{}, 0),
        argNum: 1,
    }
}

func (qb *QueryBuilder) Where(condition string, args ...interface{}) *QueryBuilder {
    if strings.Contains(qb.query, "WHERE") {
        qb.query += " AND "
    } else {
        qb.query += " WHERE "
    }
    
    // Ğ—Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ ? Ğ½Ğ° $N
    for i := 0; i < len(args); i++ {
        condition = strings.Replace(condition, "?", fmt.Sprintf("$%d", qb.argNum), 1)
        qb.argNum++
    }
    
    qb.query += condition
    qb.args = append(qb.args, args...)
    
    return qb
}

func (qb *QueryBuilder) OrderBy(column, direction string) *QueryBuilder {
    qb.query += fmt.Sprintf(" ORDER BY %s %s", column, direction)
    return qb
}

func (qb *QueryBuilder) Limit(limit int) *QueryBuilder {
    qb.query += fmt.Sprintf(" LIMIT $%d", qb.argNum)
    qb.args = append(qb.args, limit)
    qb.argNum++
    return qb
}

func (qb *QueryBuilder) Offset(offset int) *QueryBuilder {
    qb.query += fmt.Sprintf(" OFFSET $%d", qb.argNum)
    qb.args = append(qb.args, offset)
    qb.argNum++
    return qb
}

func (qb *QueryBuilder) Build() (string, []interface{}) {
    return qb.query, qb.args
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ query builder
func (r *PostgresUserRepository) SearchUsers(ctx context.Context, search string, isActive *bool, limit, offset int) ([]*User, error) {
    qb := NewQueryBuilder("SELECT id, email, name, is_active, role, created_at, updated_at FROM users")
    
    qb.Where("deleted_at IS NULL")
    
    if search != "" {
        qb.Where("(name ILIKE ? OR email ILIKE ?)", "%"+search+"%", "%"+search+"%")
    }
    
    if isActive != nil {
        qb.Where("is_active = ?", *isActive)
    }
    
    qb.OrderBy("created_at", "DESC").Limit(limit).Offset(offset)
    
    query, args := qb.Build()
    
    var users []*User
    err := r.db.db.SelectContext(ctx, &users, query, args...)
    if err != nil {
        return nil, fmt.Errorf("failed to search users: %w", err)
    }
    
    return users, nil
}

// Connection pooling monitoring
func (d *Database) LogStats() {
    stats := d.db.Stats()
    log.Printf("DB Pool Stats: Open=%d InUse=%d Idle=%d WaitCount=%d WaitDuration=%v MaxIdleClosed=%d MaxLifetimeClosed=%d",
        stats.OpenConnections,
        stats.InUse,
        stats.Idle,
        stats.WaitCount,
        stats.WaitDuration,
        stats.MaxIdleClosed,
        stats.MaxLifetimeClosed,
    )
}

// Prepared statements Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
type PreparedStatements struct {
    getUserByID    *sqlx.Stmt
    getUserByEmail *sqlx.Stmt
    createUser     *sqlx.Stmt
}

func NewPreparedStatements(db *sqlx.DB) (*PreparedStatements, error) {
    getUserByID, err := db.Preparex("SELECT id, email, name, is_active, role, created_at, updated_at FROM users WHERE id = $1 AND deleted_at IS NULL")
    if err != nil {
        return nil, err
    }
    
    getUserByEmail, err := db.Preparex("SELECT id, email, name, is_active, role, created_at, updated_at FROM users WHERE email = $1 AND deleted_at IS NULL")
    if err != nil {
        return nil, err
    }
    
    createUser, err := db.Preparex("INSERT INTO users (email, name, is_active, role, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id")
    if err != nil {
        return nil, err
    }
    
    return &PreparedStatements{
        getUserByID:    getUserByID,
        getUserByEmail: getUserByEmail,
        createUser:     createUser,
    }, nil
}

func (ps *PreparedStatements) Close() error {
    ps.getUserByID.Close()
    ps.getUserByEmail.Close()
    ps.createUser.Close()
    return nil
}

// Migration system
type Migration struct {
    Version int
    Name    string
    Up      string
    Down    string
}

var migrations = []Migration{
    {
        Version: 1,
        Name:    "create_users_table",
        Up: `
            CREATE TABLE users (
                id BIGSERIAL PRIMARY KEY,
                email VARCHAR(255) UNIQUE NOT NULL,
                name VARCHAR(255) NOT NULL,
                password_hash VARCHAR(255) NOT NULL,
                is_active BOOLEAN DEFAULT true,
                role VARCHAR(50) DEFAULT 'user',
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                deleted_at TIMESTAMP WITH TIME ZONE
            );
            
            CREATE INDEX idx_users_email ON users(email);
            CREATE INDEX idx_users_deleted_at ON users(deleted_at);
        `,
        Down: `DROP TABLE users;`,
    },
    {
        Version: 2,
        Name:    "create_orders_table",
        Up: `
            CREATE TABLE orders (
                id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL REFERENCES users(id),
                total_amount DECIMAL(10,2) NOT NULL,
                status VARCHAR(50) DEFAULT 'pending',
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            );
            
            CREATE INDEX idx_orders_user_id ON orders(user_id);
            CREATE INDEX idx_orders_status ON orders(status);
        `,
        Down: `DROP TABLE orders;`,
    },
}

func RunMigrations(db *Database) error {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¹
    _, err := db.db.Exec(`
        CREATE TABLE IF NOT EXISTS schema_migrations (
            version INTEGER PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
    `)
    if err != nil {
        return fmt.Errorf("failed to create migrations table: %w", err)
    }
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ğµ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
    appliedVersions := make(map[int]bool)
    rows, err := db.db.Query("SELECT version FROM schema_migrations")
    if err != nil {
        return fmt.Errorf("failed to get applied migrations: %w", err)
    }
    defer rows.Close()
    
    for rows.Next() {
        var version int
        if err := rows.Scan(&version); err != nil {
            return fmt.Errorf("failed to scan migration version: %w", err)
        }
        appliedVersions[version] = true
    }
    
    // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ½ĞµĞ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
    for _, migration := range migrations {
        if appliedVersions[migration.Version] {
            continue
        }
        
        log.Printf("Applying migration %d: %s", migration.Version, migration.Name)
        
        err := db.WithTransaction(context.Background(), func(ctx context.Context, tx *sqlx.Tx) error {
            // Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ
            if _, err := tx.Exec(migration.Up); err != nil {
                return fmt.Errorf("failed to execute migration %d: %w", migration.Version, err)
            }
            
            // Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¹
            _, err := tx.Exec("INSERT INTO schema_migrations (version, name) VALUES ($1, $2)", 
                migration.Version, migration.Name)
            if err != nil {
                return fmt.Errorf("failed to record migration %d: %w", migration.Version, err)
            }
            
            return nil
        })
        
        if err != nil {
            return err
        }
        
        log.Printf("Migration %d applied successfully", migration.Version)
    }
    
    return nil
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
func main() {
    config := DatabaseConfig{
        Host:         "localhost",
        Port:         5432,
        User:         "postgres",
        Password:     "password",
        Database:     "myapp",
        SSLMode:      "disable",
        MaxOpenConns: 25,
        MaxIdleConns: 5,
        MaxLifetime:  time.Hour,
    }
    
    db, err := NewDatabase(config)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    defer db.Close()
    
    // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
    if err := RunMigrations(db); err != nil {
        log.Fatal("Failed to run migrations:", err)
    }
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹
    logger := &ConsoleLogger{}
    userRepo := NewPostgresUserRepository(db)
    userService := NewUserService(userRepo, db, logger)
    
    ctx := context.Background()
    
    // Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ¼ Ğ² Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸
    user, order, err := userService.CreateUserWithOrder(ctx, "test@example.com", "Test User", 99.99)
    if err != nil {
        log.Fatal("Failed to create user with order:", err)
    }
    
    log.Printf("Created user %d with order %d", user.ID, order.ID)
    
    // ĞŸĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ Ğ¿ÑƒĞ»Ğ° ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğ¹
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        db.LogStats()
    }
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ğ‘Ğ”:**
- **Connection pooling** - ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµÑÑƒÑ€ÑĞ¾Ğ²
- **Ğ¢Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸** - Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **Prepared statements** - Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ SQL injection Ğ¸ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ
- **Query builders** - Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
- **Migrations** - Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑÑ…ĞµĞ¼Ñ‹ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

**ğŸ’¡ Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸:**
- Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ´Ğ¾Ğ»Ğ³Ğ¸Ñ… Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
- Ğ Ğ°Ğ·Ğ´ĞµĞ»ÑĞ¹Ñ‚Ğµ read Ğ¸ write Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚Ğ¸
- ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€ÑŒÑ‚Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºÑƒ connection pool
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸

---

### ĞĞµĞ´ĞµĞ»Ñ 6: ORM Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ‘Ğ”

#### ğŸ”§ GORM - Ğ¼Ğ¾Ñ‰Ğ½Ñ‹Ğ¹ ORM Ğ´Ğ»Ñ Go

### GORM Architecture & Features

```
GORM Architecture Overview
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Models    â”‚  â”‚  Services   â”‚  â”‚ Controllers â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ User        â”‚  â”‚ UserService â”‚  â”‚ UserHandler â”‚          â”‚
â”‚  â”‚ Order       â”‚  â”‚ OrderSvc    â”‚  â”‚ OrderHandlerâ”‚          â”‚
â”‚  â”‚ Product     â”‚  â”‚ ProductSvc  â”‚  â”‚ ProductHndlrâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     GORM Layer                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                 GORM Features                           â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚  Auto   â”‚  â”‚  Hooks  â”‚  â”‚  Eager  â”‚  â”‚  Query  â”‚   â”‚ â”‚
â”‚  â”‚  â”‚Migrationâ”‚  â”‚& Events â”‚  â”‚Loading  â”‚  â”‚Builder  â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚Validatonâ”‚  â”‚Relationsâ”‚  â”‚  Soft   â”‚  â”‚  JSON   â”‚   â”‚ â”‚
â”‚  â”‚  â”‚   Tags  â”‚  â”‚ (1:1,1:N)â”‚  â”‚ Delete  â”‚  â”‚  Tags   â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Database Driver                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ PostgreSQL  â”‚  â”‚    MySQL    â”‚  â”‚   SQLite    â”‚          â”‚
â”‚  â”‚   Driver    â”‚  â”‚   Driver    â”‚  â”‚   Driver    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Model Relationships Visualization
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Relationship Types                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  One-to-One (1:1)                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚    User     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   Profile   â”‚                   â”‚
â”‚  â”‚             â”‚  has    â”‚             â”‚                   â”‚
â”‚  â”‚ ID          â”‚  one    â”‚ UserID (FK) â”‚                   â”‚
â”‚  â”‚ Email       â”‚         â”‚ Avatar      â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  One-to-Many (1:N)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚    User     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚    Order    â”‚                   â”‚
â”‚  â”‚             â”‚  has    â”‚             â”‚                   â”‚
â”‚  â”‚ ID          â”‚  many   â”‚ UserID (FK) â”‚                   â”‚
â”‚  â”‚ Email       â”‚         â”‚ Amount      â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Many-to-Many (N:M)                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚    User     â”‚  â”‚  user_roles  â”‚  â”‚    Role     â”‚       â”‚
â”‚  â”‚             â”‚  â”‚              â”‚  â”‚             â”‚       â”‚
â”‚  â”‚ ID          â”‚  â”‚ UserID (FK)  â”‚  â”‚ ID          â”‚       â”‚
â”‚  â”‚ Email       â”‚  â”‚ RoleID (FK)  â”‚  â”‚ Name        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "log"
    "time"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "gorm.io/gorm/clause"
)

// GORM Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ Ñ Ñ‚ĞµĞ³Ğ°Ğ¼Ğ¸ Ğ¸ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸ÑĞ¼Ğ¸
type User struct {
    ID        uint           `gorm:"primaryKey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
    
    // ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ
    Email     string `gorm:"uniqueIndex;not null;size:255" json:"email" validate:"required,email"`
    Name      string `gorm:"not null;size:100" json:"name" validate:"required,min=2,max=100"`
    Password  string `gorm:"not null;size:255" json:"-"` // Ğ¡ĞºÑ€Ñ‹Ñ‚Ğ¾ Ğ² JSON
    IsActive  bool   `gorm:"default:true" json:"is_active"`
    LastLogin *time.Time `json:"last_login,omitempty"`
    
    // ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    Profile Profile `gorm:"foreignKey:UserID" json:"profile,omitempty"`
    Orders  []Order `gorm:"foreignKey:UserID" json:"orders,omitempty"`
    Roles   []Role  `gorm:"many2many:user_roles;" json:"roles,omitempty"`
    
    // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ (Ğ½Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑÑ‚ÑÑ Ğ² Ğ‘Ğ”)
    OrderCount int `gorm:"-" json:"order_count,omitempty"`
    FullName   string `gorm:"-" json:"full_name,omitempty"`
}

// Ğ¥ÑƒĞºĞ¸ GORM Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿ĞµÑ€ĞµĞ´ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸ĞµĞ¼
    if u.Email == "" {
        return errors.New("email is required")
    }
    if len(u.Password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    return nil
}

func (u *User) AfterCreate(tx *gorm.DB) error {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
    profile := Profile{
        UserID: u.ID,
        Avatar: "default-avatar.png",
    }
    return tx.Create(&profile).Error
}

func (u *User) AfterFind(tx *gorm.DB) error {
    // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ¿Ğ¾ÑĞ»Ğµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸
    u.FullName = u.Name
    return nil
}

// ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (1:1 Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ)
type Profile struct {
    ID       uint   `gorm:"primaryKey" json:"id"`
    UserID   uint   `gorm:"uniqueIndex;not null" json:"user_id"`
    Avatar   string `gorm:"size:255" json:"avatar"`
    Bio      string `gorm:"type:text" json:"bio"`
    Website  string `gorm:"size:255" json:"website"`
    Location string `gorm:"size:100" json:"location"`
    
    // ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² JSON
    Settings ProfileSettings `gorm:"type:jsonb" json:"settings"`
    
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    
    // ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ°Ñ ÑĞ²ÑĞ·ÑŒ
    User User `gorm:"foreignKey:UserID" json:"user,omitempty"`
}

type ProfileSettings struct {
    Theme         string `json:"theme"`
    Notifications bool   `json:"notifications"`
    Language      string `json:"language"`
}

// Ğ—Ğ°ĞºĞ°Ğ· (1:N Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ñ User)
type Order struct {
    ID          uint           `gorm:"primaryKey" json:"id"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
    
    UserID      uint           `gorm:"not null;index" json:"user_id"`
    TotalAmount float64        `gorm:"type:decimal(10,2);not null" json:"total_amount"`
    Status      OrderStatus    `gorm:"type:varchar(20);default:'pending'" json:"status"`
    
    // ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    User  User        `gorm:"foreignKey:UserID" json:"user,omitempty"`
    Items []OrderItem `gorm:"foreignKey:OrderID" json:"items,omitempty"`
}

type OrderStatus string

const (
    OrderStatusPending    OrderStatus = "pending"
    OrderStatusProcessing OrderStatus = "processing"
    OrderStatusShipped    OrderStatus = "shipped"
    OrderStatusDelivered  OrderStatus = "delivered"
    OrderStatusCancelled  OrderStatus = "cancelled"
)

// Ğ¢Ğ¾Ğ²Ğ°Ñ€ Ğ² Ğ·Ğ°ĞºĞ°Ğ·Ğµ
type OrderItem struct {
    ID        uint    `gorm:"primaryKey" json:"id"`
    OrderID   uint    `gorm:"not null;index" json:"order_id"`
    ProductID uint    `gorm:"not null;index" json:"product_id"`
    Quantity  int     `gorm:"not null;check:quantity > 0" json:"quantity"`
    Price     float64 `gorm:"type:decimal(10,2);not null" json:"price"`
    
    // ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    Order   Order   `gorm:"foreignKey:OrderID" json:"order,omitempty"`
    Product Product `gorm:"foreignKey:ProductID" json:"product,omitempty"`
}

// Ğ¢Ğ¾Ğ²Ğ°Ñ€
type Product struct {
    ID          uint           `gorm:"primaryKey" json:"id"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
    
    Name        string  `gorm:"not null;size:255" json:"name"`
    Description string  `gorm:"type:text" json:"description"`
    Price       float64 `gorm:"type:decimal(10,2);not null" json:"price"`
    SKU         string  `gorm:"uniqueIndex;size:100" json:"sku"`
    Stock       int     `gorm:"default:0" json:"stock"`
    
    // JSON Ğ¿Ğ¾Ğ»Ğµ Ğ´Ğ»Ñ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚Ğ¾Ğ²
    Attributes ProductAttributes `gorm:"type:jsonb" json:"attributes"`
    
    // M:N Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ñ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼Ğ¸
    Categories []Category `gorm:"many2many:product_categories;" json:"categories,omitempty"`
}

type ProductAttributes struct {
    Color  string   `json:"color"`
    Size   string   `json:"size"`
    Weight float64  `json:"weight"`
    Tags   []string `json:"tags"`
}

// ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ
type Category struct {
    ID          uint           `gorm:"primaryKey" json:"id"`
    Name        string         `gorm:"not null;size:100" json:"name"`
    Slug        string         `gorm:"uniqueIndex;size:100" json:"slug"`
    Description string         `gorm:"type:text" json:"description"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
    
    // Ğ¡Ğ°Ğ¼Ğ¾ÑÑÑ‹Ğ»Ğ°ÑÑ‰Ğ°ÑÑÑ ÑĞ²ÑĞ·ÑŒ Ğ´Ğ»Ñ Ğ¸ĞµÑ€Ğ°Ñ€Ñ…Ğ¸Ğ¸
    ParentID *uint      `gorm:"index" json:"parent_id,omitempty"`
    Parent   *Category  `gorm:"foreignKey:ParentID" json:"parent,omitempty"`
    Children []Category `gorm:"foreignKey:ParentID" json:"children,omitempty"`
    
    // M:N Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚Ğ°Ğ¼Ğ¸
    Products []Product `gorm:"many2many:product_categories;" json:"products,omitempty"`
}

// Ğ Ğ¾Ğ»ÑŒ (M:N Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ñ User)
type Role struct {
    ID          uint           `gorm:"primaryKey" json:"id"`
    Name        string         `gorm:"uniqueIndex;not null;size:50" json:"name"`
    Description string         `gorm:"size:255" json:"description"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    
    // M:N Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
    Users []User `gorm:"many2many:user_roles;" json:"users,omitempty"`
}

// GORM Database wrapper
type GormDB struct {
    db *gorm.DB
}

func NewGormDB(dsn string) (*GormDB, error) {
    // ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ³ĞµÑ€Ğ° GORM
    gormLogger := logger.New(
        log.New(log.Writer(), "\r\n", log.LstdFlags),
        logger.Config{
            SlowThreshold:             200 * time.Millisecond,
            LogLevel:                  logger.Info,
            IgnoreRecordNotFoundError: true,
            Colorful:                  true,
        },
    )
    
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: gormLogger,
        NowFunc: func() time.Time {
            return time.Now().UTC()
        },
    })
    
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }
    
    // ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° connection pool
    sqlDB, err := db.DB()
    if err != nil {
        return nil, fmt.Errorf("failed to get database instance: %w", err)
    }
    
    sqlDB.SetMaxOpenConns(25)
    sqlDB.SetMaxIdleConns(5)
    sqlDB.SetConnMaxLifetime(time.Hour)
    
    return &GormDB{db: db}, nil
}

func (gdb *GormDB) AutoMigrate() error {
    return gdb.db.AutoMigrate(
        &User{},
        &Profile{},
        &Order{},
        &OrderItem{},
        &Product{},
        &Category{},
        &Role{},
    )
}

// Repository Ñ GORM
type GormUserRepository struct {
    db *GormDB
}

func NewGormUserRepository(db *GormDB) *GormUserRepository {
    return &GormUserRepository{db: db}
}

func (r *GormUserRepository) Create(ctx context.Context, user *User) error {
    result := r.db.db.WithContext(ctx).Create(user)
    if result.Error != nil {
        return fmt.Errorf("failed to create user: %w", result.Error)
    }
    return nil
}

func (r *GormUserRepository) GetByID(ctx context.Context, id uint) (*User, error) {
    var user User
    result := r.db.db.WithContext(ctx).
        Preload("Profile").           // Eager loading Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ
        Preload("Orders").           // Eager loading Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
        Preload("Roles").            // Eager loading Ñ€Ğ¾Ğ»ĞµĞ¹
        First(&user, id)
    
    if result.Error != nil {
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user: %w", result.Error)
    }
    
    return &user, nil
}

func (r *GormUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {
    var user User
    result := r.db.db.WithContext(ctx).
        Where("email = ?", email).
        Preload("Profile").
        Preload("Roles").
        First(&user)
    
    if result.Error != nil {
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user by email: %w", result.Error)
    }
    
    return &user, nil
}

func (r *GormUserRepository) Update(ctx context.Context, user *User) error {
    result := r.db.db.WithContext(ctx).Save(user)
    if result.Error != nil {
        return fmt.Errorf("failed to update user: %w", result.Error)
    }
    
    if result.RowsAffected == 0 {
        return ErrUserNotFound
    }
    
    return nil
}

func (r *GormUserRepository) Delete(ctx context.Context, id uint) error {
    result := r.db.db.WithContext(ctx).Delete(&User{}, id)
    if result.Error != nil {
        return fmt.Errorf("failed to delete user: %w", result.Error)
    }
    
    if result.RowsAffected == 0 {
        return ErrUserNotFound
    }
    
    return nil
}

// Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ñ GORM
func (r *GormUserRepository) SearchUsers(ctx context.Context, query UserSearchQuery) ([]User, int64, error) {
    var users []User
    var total int64
    
    db := r.db.db.WithContext(ctx).Model(&User{})
    
    // Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ñ‹
    if query.Search != "" {
        db = db.Where("name ILIKE ? OR email ILIKE ?", "%"+query.Search+"%", "%"+query.Search+"%")
    }
    
    if query.IsActive != nil {
        db = db.Where("is_active = ?", *query.IsActive)
    }
    
    if query.Role != "" {
        db = db.Joins("JOIN user_roles ON users.id = user_roles.user_id").
            Joins("JOIN roles ON user_roles.role_id = roles.id").
            Where("roles.name = ?", query.Role)
    }
    
    if !query.CreatedAfter.IsZero() {
        db = db.Where("created_at > ?", query.CreatedAfter)
    }
    
    // ĞŸĞ¾Ğ´ÑÑ‡ĞµÑ‚ Ğ¾Ğ±Ñ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ°
    if err := db.Count(&total).Error; err != nil {
        return nil, 0, fmt.Errorf("failed to count users: %w", err)
    }
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹
    err := db.Preload("Profile").
        Preload("Roles").
        Order("created_at DESC").
        Limit(query.Limit).
        Offset(query.Offset).
        Find(&users).Error
    
    if err != nil {
        return nil, 0, fmt.Errorf("failed to search users: %w", err)
    }
    
    return users, total, nil
}

type UserSearchQuery struct {
    Search       string
    IsActive     *bool
    Role         string
    CreatedAfter time.Time
    Limit        int
    Offset       int
}

// Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸ÑĞ¼Ğ¸
func (r *GormUserRepository) GetUserWithOrders(ctx context.Context, userID uint, orderStatus OrderStatus) (*User, error) {
    var user User
    
    query := r.db.db.WithContext(ctx).Preload("Profile")
    
    if orderStatus != "" {
        // Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ
        query = query.Preload("Orders", "status = ?", orderStatus)
    } else {
        query = query.Preload("Orders")
    }
    
    // Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°Ğ¼Ğ¸
    query = query.Preload("Orders.Items").Preload("Orders.Items.Product")
    
    result := query.First(&user, userID)
    if result.Error != nil {
        if errors.Is(result.Error, gorm.ErrRecordNotFound) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("failed to get user with orders: %w", result.Error)
    }
    
    return &user, nil
}

// ĞĞ³Ñ€ĞµĞ³Ğ°Ñ†Ğ¸Ñ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
func (r *GormUserRepository) GetUserStatistics(ctx context.Context, userID uint) (*UserStatistics, error) {
    var stats UserStatistics
    
    // ĞŸĞ¾Ğ´ÑÑ‡ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    err := r.db.db.WithContext(ctx).
        Model(&Order{}).
        Where("user_id = ?", userID).
        Count(&stats.TotalOrders).Error
    if err != nil {
        return nil, fmt.Errorf("failed to count orders: %w", err)
    }
    
    // Ğ¡ÑƒĞ¼Ğ¼Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    err = r.db.db.WithContext(ctx).
        Model(&Order{}).
        Where("user_id = ? AND status = ?", userID, OrderStatusDelivered).
        Select("COALESCE(SUM(total_amount), 0)").
        Scan(&stats.TotalSpent).Error
    if err != nil {
        return nil, fmt.Errorf("failed to sum order amounts: %w", err)
    }
    
    // ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·
    var lastOrder Order
    err = r.db.db.WithContext(ctx).
        Where("user_id = ?", userID).
        Order("created_at DESC").
        First(&lastOrder).Error
    if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
        return nil, fmt.Errorf("failed to get last order: %w", err)
    }
    if err == nil {
        stats.LastOrderDate = &lastOrder.CreatedAt
    }
    
    return &stats, nil
}

type UserStatistics struct {
    TotalOrders   int64      `json:"total_orders"`
    TotalSpent    float64    `json:"total_spent"`
    LastOrderDate *time.Time `json:"last_order_date"`
}

// Bulk Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸
func (r *GormUserRepository) BulkUpdateActiveStatus(ctx context.Context, userIDs []uint, isActive bool) error {
    result := r.db.db.WithContext(ctx).
        Model(&User{}).
        Where("id IN ?", userIDs).
        Update("is_active", isActive)
    
    if result.Error != nil {
        return fmt.Errorf("failed to bulk update users: %w", result.Error)
    }
    
    return nil
}

func (r *GormUserRepository) BulkCreate(ctx context.Context, users []User) error {
    // Ğ‘Ğ°Ñ‚Ñ‡ĞµĞ²Ğ°Ñ Ğ²ÑÑ‚Ğ°Ğ²ĞºĞ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
    batchSize := 100
    
    for i := 0; i < len(users); i += batchSize {
        end := i + batchSize
        if end > len(users) {
            end = len(users)
        }
        
        batch := users[i:end]
        if err := r.db.db.WithContext(ctx).Create(&batch).Error; err != nil {
            return fmt.Errorf("failed to bulk create users batch %d-%d: %w", i, end, err)
        }
    }
    
    return nil
}

// Ğ¢Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ Ñ GORM
func (r *GormUserRepository) TransferUserData(ctx context.Context, fromUserID, toUserID uint) error {
    return r.db.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
        var fromUser, toUser User
        if err := tx.First(&fromUser, fromUserID).Error; err != nil {
            return fmt.Errorf("from user not found: %w", err)
        }
        if err := tx.First(&toUser, toUserID).Error; err != nil {
            return fmt.Errorf("to user not found: %w", err)
        }
        
        // ĞŸĞµÑ€ĞµĞ½Ğ¾ÑĞ¸Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
        if err := tx.Model(&Order{}).
            Where("user_id = ?", fromUserID).
            Update("user_id", toUserID).Error; err != nil {
            return fmt.Errorf("failed to transfer orders: %w", err)
        }
        
        // Ğ”ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€ÑƒĞµĞ¼ ÑÑ‚Ğ°Ñ€Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        if err := tx.Model(&fromUser).Update("is_active", false).Error; err != nil {
            return fmt.Errorf("failed to deactivate user: %w", err)
        }
        
        return nil
    })
}

// Raw SQL Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ´Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸
func (r *GormUserRepository) GetTopCustomers(ctx context.Context, limit int) ([]CustomerStats, error) {
    var customers []CustomerStats
    
    query := `
        SELECT 
            u.id,
            u.name,
            u.email,
            COUNT(o.id) as order_count,
            COALESCE(SUM(o.total_amount), 0) as total_spent,
            AVG(o.total_amount) as avg_order_value
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id AND o.deleted_at IS NULL
        WHERE u.deleted_at IS NULL
        GROUP BY u.id, u.name, u.email
        HAVING COUNT(o.id) > 0
        ORDER BY total_spent DESC
        LIMIT ?
    `
    
    err := r.db.db.WithContext(ctx).Raw(query, limit).Scan(&customers).Error
    if err != nil {
        return nil, fmt.Errorf("failed to get top customers: %w", err)
    }
    
    return customers, nil
}

type CustomerStats struct {
    ID              uint    `json:"id"`
    Name            string  `json:"name"`
    Email           string  `json:"email"`
    OrderCount      int     `json:"order_count"`
    TotalSpent      float64 `json:"total_spent"`
    AvgOrderValue   float64 `json:"avg_order_value"`
}

// Scopes Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
func (r *GormUserRepository) ActiveUsers() func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        return db.Where("is_active = ?", true)
    }
}

func (r *GormUserRepository) WithRole(role string) func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        return db.Joins("JOIN user_roles ON users.id = user_roles.user_id").
            Joins("JOIN roles ON user_roles.role_id = roles.id").
            Where("roles.name = ?", role)
    }
}

func (r *GormUserRepository) CreatedInRange(start, end time.Time) func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        return db.Where("created_at BETWEEN ? AND ?", start, end)
    }
}

// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ scopes
func (r *GormUserRepository) GetActiveAdmins(ctx context.Context) ([]User, error) {
    var users []User
    
    err := r.db.db.WithContext(ctx).
        Scopes(r.ActiveUsers(), r.WithRole("admin")).
        Preload("Profile").
        Preload("Roles").
        Find(&users).Error
    
    if err != nil {
        return nil, fmt.Errorf("failed to get active admins: %w", err)
    }
    
    return users, nil
}

// Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ Ñ…ÑƒĞºĞ°Ğ¼Ğ¸
func (u *User) AfterUpdate(tx *gorm.DB) error {
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
    if tx.Statement.Changed("is_active") {
        // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ° Ğ±Ñ‹ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
        log.Printf("User %d status changed to active: %v", u.ID, u.IsActive)
    }
    return nil
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ GORM
func demonstrateGORM() {
    dsn := "host=localhost user=postgres password=password dbname=testdb port=5432 sslmode=disable"
    
    db, err := NewGormDB(dsn)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    
    // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ
    if err := db.AutoMigrate(); err != nil {
        log.Fatal("Failed to migrate:", err)
    }
    
    repo := NewGormUserRepository(db)
    ctx := context.Background()
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ñ Ñ€Ğ¾Ğ»ÑĞ¼Ğ¸
    user := &User{
        Email:    "admin@example.com",
        Name:     "Admin User",
        Password: "hashedpassword",
        IsActive: true,
        Roles: []Role{
            {Name: "admin", Description: "Administrator"},
            {Name: "user", Description: "Regular user"},
        },
    }
    
    if err := repo.Create(ctx, user); err != nil {
        log.Fatal("Failed to create user:", err)
    }
    
    log.Printf("Created user with ID: %d", user.ID)
    
    // ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
    query := UserSearchQuery{
        Search:   "admin",
        IsActive: &[]bool{true}[0],
        Limit:    10,
        Offset:   0,
    }
    
    users, total, err := repo.SearchUsers(ctx, query)
    if err != nil {
        log.Fatal("Failed to search users:", err)
    }
    
    log.Printf("Found %d users (total: %d)", len(users), total)
    
    // Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    stats, err := repo.GetUserStatistics(ctx, user.ID)
    if err != nil {
        log.Fatal("Failed to get user statistics:", err)
    }
    
    log.Printf("User statistics: %+v", stats)
    
    // Ğ¢Ğ¾Ğ¿ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñ‹
    topCustomers, err := repo.GetTopCustomers(ctx, 5)
    if err != nil {
        log.Fatal("Failed to get top customers:", err)
    }
    
    log.Printf("Top customers: %+v", topCustomers)
}
```

**ğŸ¯ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ° GORM:**
- **ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸** - ÑÑ…ĞµĞ¼Ğ° Ğ‘Ğ” ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑĞ¼Ğ¸
- **ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ** - Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ foreign keys Ğ¸ joins
- **Ğ¥ÑƒĞºĞ¸** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **Eager loading** - Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ğµ N+1 Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹
- **Scopes** - Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‡Ğ°ÑÑ‚ĞµĞ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²

**ğŸ’¡ ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸:**
- JSON Ğ¿Ğ¾Ğ»Ñ Ğ´Ğ»Ñ Ğ³Ğ¸Ğ±ĞºĞ¸Ñ… Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚Ğ¾Ğ²
- Soft delete Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸
- Bulk Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸
- Raw SQL Ğ´Ğ»Ñ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸
- Transaction support Ğ´Ğ»Ñ Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

---

### ĞĞµĞ´ĞµĞ»Ñ 7: ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

#### ğŸ›ï¸ Clean Architecture Ğ² Go

### Clean Architecture Layers

```
Clean Architecture Visualization
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    External Interfaces                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚     Web     â”‚  â”‚     CLI     â”‚  â”‚     API     â”‚          â”‚
â”‚  â”‚   Server    â”‚  â”‚   Commands  â”‚  â”‚   Gateway   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Interface Adapters                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Controllers â”‚  â”‚ Presenters  â”‚  â”‚  Gateways   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ HTTP        â”‚  â”‚ JSON/XML    â”‚  â”‚ External    â”‚          â”‚
â”‚  â”‚ Handlers    â”‚  â”‚ Formatters  â”‚  â”‚ APIs        â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Application Business Rules                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   Use Cases â”‚  â”‚ Interactors â”‚  â”‚  Services   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ Application â”‚  â”‚ Workflow    â”‚  â”‚ Application â”‚          â”‚
â”‚  â”‚ Logic       â”‚  â”‚ Orchestrationâ”‚ â”‚ Services    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚               â”‚               â”‚                  â”‚
â”‚         â–¼               â–¼               â–¼                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               Enterprise Business Rules                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Entities   â”‚  â”‚   Domain    â”‚  â”‚  Business   â”‚          â”‚
â”‚  â”‚             â”‚  â”‚   Models    â”‚  â”‚    Rules    â”‚          â”‚
â”‚  â”‚ Core        â”‚  â”‚             â”‚  â”‚             â”‚          â”‚
â”‚  â”‚ Business    â”‚  â”‚ Domain      â”‚  â”‚ Policies    â”‚          â”‚
â”‚  â”‚ Logic       â”‚  â”‚ Logic       â”‚  â”‚             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Dependency Direction
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Dependency Rule                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚   Outer     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚  â”‚   Layers    â”‚         â”‚                                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                                  â”‚
â”‚                          â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ Interface   â”‚ â”€â”€â–¶â”‚ Application â”‚                         â”‚
â”‚  â”‚ Adapters    â”‚    â”‚   Layer     â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                          â”‚                                  â”‚
â”‚                          â–¼                                  â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                    â”‚  Enterprise â”‚                          â”‚
â”‚                    â”‚   Business  â”‚                          â”‚
â”‚                    â”‚    Rules    â”‚                          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                             â”‚
â”‚  Dependencies point INWARD only!                           â”‚
â”‚  Inner layers never depend on outer layers                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "time"
)

// ==================== ENTERPRISE BUSINESS RULES (DOMAIN) ====================

// Domain Entities - ÑĞ°Ğ¼Ñ‹Ğ¹ Ğ²Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¸Ğ¹ ÑĞ»Ğ¾Ğ¹
type User struct {
    ID        UserID    `json:"id"`
    Email     Email     `json:"email"`
    Name      string    `json:"name"`
    Password  Password  `json:"-"`
    IsActive  bool      `json:"is_active"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// Value Objects Ğ´Ğ»Ñ type safety
type UserID uint64
type Email string
type Password string

// Domain validation Ğ² value objects
func NewEmail(email string) (Email, error) {
    if email == "" {
        return "", errors.New("email cannot be empty")
    }
    // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ° Ğ±Ñ‹ Ğ¿Ğ¾Ğ»Ğ½Ğ°Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ email
    if len(email) < 5 || !contains(email, "@") {
        return "", errors.New("invalid email format")
    }
    return Email(email), nil
}

func NewPassword(password string) (Password, error) {
    if len(password) < 8 {
        return "", errors.New("password must be at least 8 characters")
    }
    // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ¾ Ğ±Ñ‹ Ñ…ĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ
    return Password("hashed_" + password), nil
}

func (e Email) String() string {
    return string(e)
}

func (p Password) String() string {
    return string(p)
}

// Domain methods - Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ² entities
func (u *User) Activate() error {
    if u.IsActive {
        return errors.New("user is already active")
    }
    u.IsActive = true
    u.UpdatedAt = time.Now()
    return nil
}

func (u *User) Deactivate() error {
    if !u.IsActive {
        return errors.New("user is already inactive")
    }
    u.IsActive = false
    u.UpdatedAt = time.Now()
    return nil
}

func (u *User) ChangeEmail(newEmail Email) error {
    if u.Email == newEmail {
        return errors.New("new email is the same as current")
    }
    u.Email = newEmail
    u.UpdatedAt = time.Now()
    return nil
}

// Domain specifications Ğ´Ğ»Ñ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»
type UserSpecification interface {
    IsSatisfiedBy(user *User) bool
}

type ActiveUserSpecification struct{}

func (s ActiveUserSpecification) IsSatisfiedBy(user *User) bool {
    return user.IsActive
}

type RecentUserSpecification struct {
    Days int
}

func (s RecentUserSpecification) IsSatisfiedBy(user *User) bool {
    return time.Since(user.CreatedAt) <= time.Duration(s.Days)*24*time.Hour
}

// Domain Events
type DomainEvent interface {
    EventName() string
    OccurredAt() time.Time
}

type UserActivatedEvent struct {
    UserID    UserID    `json:"user_id"`
    Email     Email     `json:"email"`
    Timestamp time.Time `json:"timestamp"`
}

func (e UserActivatedEvent) EventName() string {
    return "user.activated"
}

func (e UserActivatedEvent) OccurredAt() time.Time {
    return e.Timestamp
}

type UserDeactivatedEvent struct {
    UserID    UserID    `json:"user_id"`
    Email     Email     `json:"email"`
    Timestamp time.Time `json:"timestamp"`
}

func (e UserDeactivatedEvent) EventName() string {
    return "user.deactivated"
}

func (e UserDeactivatedEvent) OccurredAt() time.Time {
    return e.Timestamp
}

// ==================== APPLICATION BUSINESS RULES ====================

// Repository interfaces (defined in domain, implemented in infrastructure)
type UserRepository interface {
    Save(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id UserID) (*User, error)
    FindByEmail(ctx context.Context, email Email) (*User, error)
    FindAll(ctx context.Context, spec UserSpecification) ([]*User, error)
    Delete(ctx context.Context, id UserID) error
}

// External service interfaces
type EmailService interface {
    SendWelcomeEmail(ctx context.Context, email Email, name string) error
    SendActivationEmail(ctx context.Context, email Email, name string) error
}

type EventPublisher interface {
    Publish(ctx context.Context, event DomainEvent) error
}

// Use Cases - application logic
type CreateUserUseCase struct {
    userRepo      UserRepository
    emailService  EmailService
    eventPublisher EventPublisher
}

func NewCreateUserUseCase(
    userRepo UserRepository,
    emailService EmailService,
    eventPublisher EventPublisher,
) *CreateUserUseCase {
    return &CreateUserUseCase{
        userRepo:       userRepo,
        emailService:   emailService,
        eventPublisher: eventPublisher,
    }
}

type CreateUserRequest struct {
    Email    string `json:"email"`
    Name     string `json:"name"`
    Password string `json:"password"`
}

type CreateUserResponse struct {
    UserID UserID `json:"user_id"`
    Email  Email  `json:"email"`
    Name   string `json:"name"`
}

func (uc *CreateUserUseCase) Execute(ctx context.Context, req CreateUserRequest) (*CreateUserResponse, error) {
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ²Ñ…Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    email, err := NewEmail(req.Email)
    if err != nil {
        return nil, fmt.Errorf("invalid email: %w", err)
    }
    
    password, err := NewPassword(req.Password)
    if err != nil {
        return nil, fmt.Errorf("invalid password: %w", err)
    }
    
    if req.Name == "" {
        return nil, errors.New("name is required")
    }
    
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ email
    existingUser, err := uc.userRepo.FindByEmail(ctx, email)
    if err == nil && existingUser != nil {
        return nil, errors.New("user with this email already exists")
    }
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user := &User{
        ID:        UserID(generateID()), // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ» Ğ±Ñ‹ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ ID
        Email:     email,
        Name:      req.Name,
        Password:  password,
        IsActive:  false, // Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ
        CreatedAt: time.Now(),
        UpdatedAt: time.Now(),
    }
    
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
    if err := uc.userRepo.Save(ctx, user); err != nil {
        return nil, fmt.Errorf("failed to save user: %w", err)
    }
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° welcome email
    if err := uc.emailService.SendWelcomeEmail(ctx, user.Email, user.Name); err != nil {
        // Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ, Ğ½Ğ¾ Ğ½Ğµ Ğ¾ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ
        fmt.Printf("Failed to send welcome email: %v\n", err)
    }
    
    return &CreateUserResponse{
        UserID: user.ID,
        Email:  user.Email,
        Name:   user.Name,
    }, nil
}

// Activate User Use Case
type ActivateUserUseCase struct {
    userRepo       UserRepository
    emailService   EmailService
    eventPublisher EventPublisher
}

func NewActivateUserUseCase(
    userRepo UserRepository,
    emailService EmailService,
    eventPublisher EventPublisher,
) *ActivateUserUseCase {
    return &ActivateUserUseCase{
        userRepo:       userRepo,
        emailService:   emailService,
        eventPublisher: eventPublisher,
    }
}

func (uc *ActivateUserUseCase) Execute(ctx context.Context, userID UserID) error {
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user, err := uc.userRepo.FindByID(ctx, userID)
    if err != nil {
        return fmt.Errorf("user not found: %w", err)
    }
    
    // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ
    if err := user.Activate(); err != nil {
        return fmt.Errorf("failed to activate user: %w", err)
    }
    
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
    if err := uc.userRepo.Save(ctx, user); err != nil {
        return fmt.Errorf("failed to save user: %w", err)
    }
    
    // ĞŸÑƒĞ±Ğ»Ğ¸ĞºÑƒĞµĞ¼ domain event
    event := UserActivatedEvent{
        UserID:    user.ID,
        Email:     user.Email,
        Timestamp: time.Now(),
    }
    
    if err := uc.eventPublisher.Publish(ctx, event); err != nil {
        // Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ, Ğ½Ğ¾ Ğ½Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ĞµĞµ
        fmt.Printf("Failed to publish user activated event: %v\n", err)
    }
    
    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ
    if err := uc.emailService.SendActivationEmail(ctx, user.Email, user.Name); err != nil {
        fmt.Printf("Failed to send activation email: %v\n", err)
    }
    
    return nil
}

// Get User Use Case
type GetUserUseCase struct {
    userRepo UserRepository
}

func NewGetUserUseCase(userRepo UserRepository) *GetUserUseCase {
    return &GetUserUseCase{userRepo: userRepo}
}

func (uc *GetUserUseCase) Execute(ctx context.Context, userID UserID) (*User, error) {
    user, err := uc.userRepo.FindByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("user not found: %w", err)
    }
    
    return user, nil
}

// List Users Use Case with specifications
type ListUsersUseCase struct {
    userRepo UserRepository
}

func NewListUsersUseCase(userRepo UserRepository) *ListUsersUseCase {
    return &ListUsersUseCase{userRepo: userRepo}
}

type ListUsersQuery struct {
    OnlyActive   bool
    RecentDays   int
}

func (uc *ListUsersUseCase) Execute(ctx context.Context, query ListUsersQuery) ([]*User, error) {
    var spec UserSpecification
    
    if query.OnlyActive && query.RecentDays > 0 {
        // ĞšĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
        spec = &AndSpecification{
            Left:  &ActiveUserSpecification{},
            Right: &RecentUserSpecification{Days: query.RecentDays},
        }
    } else if query.OnlyActive {
        spec = &ActiveUserSpecification{}
    } else if query.RecentDays > 0 {
        spec = &RecentUserSpecification{Days: query.RecentDays}
    }
    
    users, err := uc.userRepo.FindAll(ctx, spec)
    if err != nil {
        return nil, fmt.Errorf("failed to find users: %w", err)
    }
    
    return users, nil
}

// Composite specification pattern
type AndSpecification struct {
    Left, Right UserSpecification
}

func (s *AndSpecification) IsSatisfiedBy(user *User) bool {
    return s.Left.IsSatisfiedBy(user) && s.Right.IsSatisfiedBy(user)
}

type OrSpecification struct {
    Left, Right UserSpecification
}

func (s *OrSpecification) IsSatisfiedBy(user *User) bool {
    return s.Left.IsSatisfiedBy(user) || s.Right.IsSatisfiedBy(user)
}

// ==================== INTERFACE ADAPTERS ====================

// HTTP Controllers
type UserController struct {
    createUserUC   *CreateUserUseCase
    activateUserUC *ActivateUserUseCase
    getUserUC      *GetUserUseCase
    listUsersUC    *ListUsersUseCase
}

func NewUserController(
    createUserUC *CreateUserUseCase,
    activateUserUC *ActivateUserUseCase,
    getUserUC *GetUserUseCase,
    listUsersUC *ListUsersUseCase,
) *UserController {
    return &UserController{
        createUserUC:   createUserUC,
        activateUserUC: activateUserUC,
        getUserUC:      getUserUC,
        listUsersUC:    listUsersUC,
    }
}

// HTTP DTOs (Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°ÑÑ‚ÑÑ Ğ¾Ñ‚ domain entities)
type CreateUserHTTPRequest struct {
    Email    string `json:"email"`
    Name     string `json:"name"`
    Password string `json:"password"`
}

type UserHTTPResponse struct {
    ID        uint64    `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    IsActive  bool      `json:"is_active"`
    CreatedAt time.Time `json:"created_at"`
}

func (c *UserController) CreateUser(ctx context.Context, httpReq CreateUserHTTPRequest) (*UserHTTPResponse, error) {
    // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ HTTP request Ğ² use case request
    req := CreateUserRequest{
        Email:    httpReq.Email,
        Name:     httpReq.Name,
        Password: httpReq.Password,
    }
    
    // Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ use case
    resp, err := c.createUserUC.Execute(ctx, req)
    if err != nil {
        return nil, err
    }
    
    // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ response Ğ² HTTP response
    return &UserHTTPResponse{
        ID:        uint64(resp.UserID),
        Email:     resp.Email.String(),
        Name:      resp.Name,
        IsActive:  false,
        CreatedAt: time.Now(),
    }, nil
}

func (c *UserController) ActivateUser(ctx context.Context, userIDStr string) error {
    // ĞŸĞ°Ñ€ÑĞ¸Ğ¼ ID Ğ¸Ğ· ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    userID, err := parseUserID(userIDStr)
    if err != nil {
        return fmt.Errorf("invalid user ID: %w", err)
    }
    
    return c.activateUserUC.Execute(ctx, userID)
}

func (c *UserController) GetUser(ctx context.Context, userIDStr string) (*UserHTTPResponse, error) {
    userID, err := parseUserID(userIDStr)
    if err != nil {
        return nil, fmt.Errorf("invalid user ID: %w", err)
    }
    
    user, err := c.getUserUC.Execute(ctx, userID)
    if err != nil {
        return nil, err
    }
    
    return &UserHTTPResponse{
        ID:        uint64(user.ID),
        Email:     user.Email.String(),
        Name:      user.Name,
        IsActive:  user.IsActive,
        CreatedAt: user.CreatedAt,
    }, nil
}

// Repository Implementation (Infrastructure Layer)
type PostgresUserRepository struct {
    db Database // database interface
}

func NewPostgresUserRepository(db Database) UserRepository {
    return &PostgresUserRepository{db: db}
}

func (r *PostgresUserRepository) Save(ctx context.Context, user *User) error {
    query := `
        INSERT INTO users (id, email, name, password_hash, is_active, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (id) DO UPDATE SET
            email = EXCLUDED.email,
            name = EXCLUDED.name,
            password_hash = EXCLUDED.password_hash,
            is_active = EXCLUDED.is_active,
            updated_at = EXCLUDED.updated_at
    `
    
    _, err := r.db.ExecContext(ctx, query,
        uint64(user.ID),
        user.Email.String(),
        user.Name,
        user.Password.String(),
        user.IsActive,
        user.CreatedAt,
        user.UpdatedAt,
    )
    
    if err != nil {
        return fmt.Errorf("failed to save user: %w", err)
    }
    
    return nil
}

func (r *PostgresUserRepository) FindByID(ctx context.Context, id UserID) (*User, error) {
    query := `
        SELECT id, email, name, password_hash, is_active, created_at, updated_at
        FROM users
        WHERE id = $1
    `
    
    var user User
    var emailStr, passwordStr string
    var userIDUint uint64
    
    err := r.db.QueryRowContext(ctx, query, uint64(id)).Scan(
        &userIDUint,
        &emailStr,
        &user.Name,
        &passwordStr,
        &user.IsActive,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err != nil {
        return nil, fmt.Errorf("user not found: %w", err)
    }
    
    // ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ² domain types
    user.ID = UserID(userIDUint)
    user.Email = Email(emailStr)
    user.Password = Password(passwordStr)
    
    return &user, nil
}

func (r *PostgresUserRepository) FindByEmail(ctx context.Context, email Email) (*User, error) {
    query := `
        SELECT id, email, name, password_hash, is_active, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    var user User
    var emailStr, passwordStr string
    var userIDUint uint64
    
    err := r.db.QueryRowContext(ctx, query, email.String()).Scan(
        &userIDUint,
        &emailStr,
        &user.Name,
        &passwordStr,
        &user.IsActive,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err != nil {
        return nil, fmt.Errorf("user not found: %w", err)
    }
    
    user.ID = UserID(userIDUint)
    user.Email = Email(emailStr)
    user.Password = Password(passwordStr)
    
    return &user, nil
}

func (r *PostgresUserRepository) FindAll(ctx context.Context, spec UserSpecification) ([]*User, error) {
    query := `
        SELECT id, email, name, password_hash, is_active, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
    `
    
    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("failed to query users: %w", err)
    }
    defer rows.Close()
    
    var users []*User
    
    for rows.Next() {
        var user User
        var emailStr, passwordStr string
        var userIDUint uint64
        
        err := rows.Scan(
            &userIDUint,
            &emailStr,
            &user.Name,
            &passwordStr,
            &user.IsActive,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        
        if err != nil {
            return nil, fmt.Errorf("failed to scan user: %w", err)
        }
        
        user.ID = UserID(userIDUint)
        user.Email = Email(emailStr)
        user.Password = Password(passwordStr)
        
        // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
        if spec == nil || spec.IsSatisfiedBy(&user) {
            users = append(users, &user)
        }
    }
    
    return users, nil
}

func (r *PostgresUserRepository) Delete(ctx context.Context, id UserID) error {
    query := `DELETE FROM users WHERE id = $1`
    
    result, err := r.db.ExecContext(ctx, query, uint64(id))
    if err != nil {
        return fmt.Errorf("failed to delete user: %w", err)
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("failed to get rows affected: %w", err)
    }
    
    if rowsAffected == 0 {
        return errors.New("user not found")
    }
    
    return nil
}

// Email Service Implementation
type SMTPEmailService struct {
    host     string
    port     int
    username string
    password string
}

func NewSMTPEmailService(host string, port int, username, password string) EmailService {
    return &SMTPEmailService{
        host:     host,
        port:     port,
        username: username,
        password: password,
    }
}

func (s *SMTPEmailService) SendWelcomeEmail(ctx context.Context, email Email, name string) error {
    // Ğ—Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ° Ğ±Ñ‹ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° email
    fmt.Printf("Sending welcome email to %s (name: %s)\n", email.String(), name)
    return nil
}

func (s *SMTPEmailService) SendActivationEmail(ctx context.Context, email Email, name string) error {
    fmt.Printf("Sending activation email to %s (name: %s)\n", email.String(), name)
    return nil
}

// Event Publisher Implementation
type InMemoryEventPublisher struct {
    handlers map[string][]func(DomainEvent)
}

func NewInMemoryEventPublisher() EventPublisher {
    return &InMemoryEventPublisher{
        handlers: make(map[string][]func(DomainEvent)),
    }
}

func (p *InMemoryEventPublisher) Publish(ctx context.Context, event DomainEvent) error {
    eventName := event.EventName()
    
    handlers, exists := p.handlers[eventName]
    if !exists {
        return nil
    }
    
    for _, handler := range handlers {
        go handler(event) // ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°
    }
    
    return nil
}

func (p *InMemoryEventPublisher) Subscribe(eventName string, handler func(DomainEvent)) {
    p.handlers[eventName] = append(p.handlers[eventName], handler)
}

// ==================== MAIN (COMPOSITION ROOT) ====================

// Dependency Injection Container
type Container struct {
    userRepo       UserRepository
    emailService   EmailService
    eventPublisher EventPublisher
    
    createUserUC   *CreateUserUseCase
    activateUserUC *ActivateUserUseCase
    getUserUC      *GetUserUseCase
    listUsersUC    *ListUsersUseCase
    
    userController *UserController
}

func NewContainer(db Database) *Container {
    // Infrastructure
    userRepo := NewPostgresUserRepository(db)
    emailService := NewSMTPEmailService("smtp.example.com", 587, "user", "pass")
    eventPublisher := NewInMemoryEventPublisher()
    
    // Use Cases
    createUserUC := NewCreateUserUseCase(userRepo, emailService, eventPublisher)
    activateUserUC := NewActivateUserUseCase(userRepo, emailService, eventPublisher)
    getUserUC := NewGetUserUseCase(userRepo)
    listUsersUC := NewListUsersUseCase(userRepo)
    
    // Controllers
    userController := NewUserController(createUserUC, activateUserUC, getUserUC, listUsersUC)
    
    return &Container{
        userRepo:       userRepo,
        emailService:   emailService,
        eventPublisher: eventPublisher,
        createUserUC:   createUserUC,
        activateUserUC: activateUserUC,
        getUserUC:      getUserUC,
        listUsersUC:    listUsersUC,
        userController: userController,
    }
}

func (c *Container) UserController() *UserController {
    return c.userController
}

// Utility functions
func generateID() uint64 {
    return uint64(time.Now().UnixNano())
}

func parseUserID(s string) (UserID, error) {
    // ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°
    if s == "1" {
        return UserID(1), nil
    }
    return UserID(0), errors.New("invalid user ID")
}

func contains(s, substr string) bool {
    return len(s) > 0 && len(substr) > 0 && 
           len(s) >= len(substr) && 
           findSubstring(s, substr)
}

func findSubstring(s, substr string) bool {
    for i := 0; i <= len(s)-len(substr); i++ {
        if s[i:i+len(substr)] == substr {
            return true
        }
    }
    return false
}

// Database interface Ğ´Ğ»Ñ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸
type Database interface {
    QueryContext(ctx context.Context, query string, args ...interface{}) (Rows, error)
    QueryRowContext(ctx context.Context, query string, args ...interface{}) Row
    ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
}

type Rows interface {
    Next() bool
    Scan(dest ...interface{}) error
    Close() error
}

type Row interface {
    Scan(dest ...interface{}) error
}

type Result interface {
    RowsAffected() (int64, error)
}

// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Clean Architecture
func demonstrateCleanArchitecture() {
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ mock database Ğ´Ğ»Ñ Ğ´ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸
    db := &MockDatabase{}
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ĞºĞ¾Ğ½Ñ‚ĞµĞ¹Ğ½ĞµÑ€ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
    container := NewContainer(db)
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ controller
    userController := container.UserController()
    
    ctx := context.Background()
    
    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    createReq := CreateUserHTTPRequest{
        Email:    "john@example.com",
        Name:     "John Doe",
        Password: "password123",
    }
    
    userResp, err := userController.CreateUser(ctx, createReq)
    if err != nil {
        fmt.Printf("Error creating user: %v\n", err)
        return
    }
    
    fmt.Printf("Created user: %+v\n", userResp)
    
    // ĞĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    err = userController.ActivateUser(ctx, "1")
    if err != nil {
        fmt.Printf("Error activating user: %v\n", err)
        return
    }
    
    fmt.Println("User activated successfully")
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    user, err := userController.GetUser(ctx, "1")
    if err != nil {
        fmt.Printf("Error getting user: %v\n", err)
        return
    }
    
    fmt.Printf("Retrieved user: %+v\n", user)
}

// Mock Database Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
type MockDatabase struct {
    users map[uint64]*User
}

func (m *MockDatabase) QueryContext(ctx context.Context, query string, args ...interface{}) (Rows, error) {
    return &MockRows{}, nil
}

func (m *MockDatabase) QueryRowContext(ctx context.Context, query string, args ...interface{}) Row {
    return &MockRow{
        user: &User{
            ID:        UserID(1),
            Email:     Email("john@example.com"),
            Name:      "John Doe",
            Password:  Password("hashed_password123"),
            IsActive:  true,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        },
    }
}

func (m *MockDatabase) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error) {
    return &MockResult{rowsAffected: 1}, nil
}

type MockRows struct {
    closed bool
}

func (m *MockRows) Next() bool {
    return false
}

func (m *MockRows) Scan(dest ...interface{}) error {
    return nil
}

func (m *MockRows) Close() error {
    m.closed = true
    return nil
}

type MockRow struct {
    user *User
}

func (m *MockRow) Scan(dest ...interface{}) error {
    if len(dest) >= 7 {
        if id, ok := dest[0].(*uint64); ok {
            *id = uint64(m.user.ID)
        }
        if email, ok := dest[1].(*string); ok {
            *email = m.user.Email.String()
        }
        if name, ok := dest[2].(*string); ok {
            *name = m.user.Name
        }
        if password, ok := dest[3].(*string); ok {
            *password = m.user.Password.String()
        }
        if isActive, ok := dest[4].(*bool); ok {
            *isActive = m.user.IsActive
        }
        if createdAt, ok := dest[5].(*time.Time); ok {
            *createdAt = m.user.CreatedAt
        }
        if updatedAt, ok := dest[6].(*time.Time); ok {
            *updatedAt = m.user.UpdatedAt
        }
    }
    return nil
}

type MockResult struct {
    rowsAffected int64
}

func (m *MockResult) RowsAffected() (int64, error) {
    return m.rowsAffected, nil
}
```

**ğŸ¯ ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ° Clean Architecture:**
- **ĞĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¾Ğ²** - Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ½Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ²ĞµĞ±-Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¾Ğ²
- **Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞ»Ğ¾Ğ¹ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ·Ğ¾Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾
- **ĞĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ğ‘Ğ”** - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ‘Ğ” Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸
- **ĞĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ UI** - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ CLI, gRPC, GraphQL Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹
- **ĞĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ¾Ñ‚ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… ÑĞµÑ€Ğ²Ğ¸ÑĞ¾Ğ²** - Ğ»ĞµĞ³ĞºĞ¾ Ğ¼Ğ¾ĞºĞ°Ñ‚ÑŒ email, payment Ğ¸ Ğ´Ñ€.

**ğŸ’¡ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹:**
- Dependency Inversion Principle - Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹ Ğ²Ğ½ÑƒÑ‚Ñ€ÑŒ
- Single Responsibility Principle - ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¾Ğ´Ğ½Ñƒ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ
- Open/Closed Principle - Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ ĞºĞ¾Ğ´Ğ°
- Interface Segregation - Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ, ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹

---

## ğŸš€ Ğ­Ñ‚Ğ°Ğ¿ 3: ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ backend Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ğ¸ (4-5 Ğ½ĞµĞ´ĞµĞ»ÑŒ)

### ĞĞµĞ´ĞµĞ»Ñ 8: API Design Ğ¸ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ

#### ğŸ—ï¸ RESTful API Design Principles

### REST API Design Patterns

```
REST API Design Hierarchy
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     API Design Layers                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                API Documentation                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚   OpenAPI   â”‚  â”‚  Postman    â”‚  â”‚   Insomnia  â”‚     â”‚ â”‚
â”‚  â”‚  â”‚   Swagger   â”‚  â”‚ Collections â”‚  â”‚    Tests    â”‚     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                API Gateway Layer                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚    Rate     â”‚  â”‚    Auth     â”‚  â”‚   Request   â”‚     â”‚ â”‚
â”‚  â”‚  â”‚  Limiting   â”‚  â”‚ Validation  â”‚  â”‚ Validation  â”‚     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                 HTTP Layer                              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚   Headers   â”‚  â”‚    Status   â”‚  â”‚   Content   â”‚     â”‚ â”‚
â”‚  â”‚  â”‚ Management  â”‚  â”‚    Codes    â”‚  â”‚Negotiation  â”‚     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                 â”‚
â”‚                           â–¼                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚               Resource Layer                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ â”‚
â”‚  â”‚  â”‚  Resources  â”‚  â”‚    CRUD     â”‚  â”‚ Relationshipâ”‚     â”‚ â”‚
â”‚  â”‚  â”‚   Design    â”‚  â”‚ Operations  â”‚  â”‚  Handling   â”‚     â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

HTTP Methods & Status Codes
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HTTP Methods Usage                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Method  â”‚    Purpose    â”‚   Idempotent  â”‚    Safe    â”‚     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   GET    â”‚ Retrieve data â”‚      Yes      â”‚    Yes     â”‚     â”‚
â”‚   POST   â”‚ Create new    â”‚      No       â”‚    No      â”‚     â”‚
â”‚   PUT    â”‚ Replace/Createâ”‚      Yes      â”‚    No      â”‚     â”‚
â”‚   PATCH  â”‚ Partial updateâ”‚      No       â”‚    No      â”‚     â”‚
â”‚  DELETE  â”‚ Remove        â”‚      Yes      â”‚    No      â”‚     â”‚
â”‚  HEAD    â”‚ Get headers   â”‚      Yes      â”‚    Yes     â”‚     â”‚
â”‚ OPTIONS  â”‚ Get methods   â”‚      Yes      â”‚    Yes     â”‚     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Status Code Categories                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2xx     â”‚ Success       â”‚ 200 OK, 201 Created, 204 No Content â”‚
â”‚  3xx     â”‚ Redirection   â”‚ 301 Moved, 304 Not Modified      â”‚
â”‚  4xx     â”‚ Client Error  â”‚ 400 Bad Request, 404 Not Found   â”‚
â”‚  5xx     â”‚ Server Error  â”‚ 500 Internal, 503 Unavailable   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
    "time"
    
    "github.com/gorilla/mux"
    "github.com/go-playground/validator/v10"
)

// ==================== API MODELS & DTOs ====================

// Standard API Response wrapper
type APIResponse struct {
    Success   bool        `json:"success"`
    Data      interface{} `json:"data,omitempty"`
    Error     *APIError   `json:"error,omitempty"`
    Meta      *MetaData   `json:"meta,omitempty"`
    Timestamp time.Time   `json:"timestamp"`
}

type APIError struct {
    Code    string                 `json:"code"`
    Message string                 `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
}

type MetaData struct {
    Pagination *PaginationMeta `json:"pagination,omitempty"`
    Total      int             `json:"total,omitempty"`
    RequestID  string          `json:"request_id,omitempty"`
}

type PaginationMeta struct {
    Page       int  `json:"page"`
    Limit      int  `json:"limit"`
    Total      int  `json:"total"`
    TotalPages int  `json:"total_pages"`
    HasNext    bool `json:"has_next"`
    HasPrev    bool `json:"has_prev"`
}

// User resource DTOs
type UserCreateRequest struct {
    Email    string  `json:"email" validate:"required,email,max=255"`
    Name     string  `json:"name" validate:"required,min=2,max=100"`
    Password string  `json:"password" validate:"required,min=8,max=128"`
    Role     *string `json:"role,omitempty" validate:"omitempty,oneof=user admin moderator"`
}

type UserUpdateRequest struct {
    Email    *string `json:"email,omitempty" validate:"omitempty,email,max=255"`
    Name     *string `json:"name,omitempty" validate:"omitempty,min=2,max=100"`
    IsActive *bool   `json:"is_active,omitempty"`
    Role     *string `json:"role,omitempty" validate:"omitempty,oneof=user admin moderator"`
}

type UserResponse struct {
    ID        uint64    `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    IsActive  bool      `json:"is_active"`
    Role      string    `json:"role"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    Links     UserLinks `json:"_links"`
}

// HATEOAS Links
type UserLinks struct {
    Self     Link `json:"self"`
    Orders   Link `json:"orders,omitempty"`
    Profile  Link `json:"profile,omitempty"`
    Activate Link `json:"activate,omitempty"`
}

type Link struct {
    Href   string `json:"href"`
    Method string `json:"method,omitempty"`
    Type   string `json:"type,omitempty"`
}

// Query parameters
type UserListQuery struct {
    Page     int    `query:"page" validate:"min=1"`
    Limit    int    `query:"limit" validate:"min=1,max=100"`
    Search   string `query:"search" validate:"max=255"`
    Role     string `query:"role" validate:"omitempty,oneof=user admin moderator"`
    IsActive *bool  `query:"is_active"`
    Sort     string `query:"sort" validate:"omitempty,oneof=name email created_at updated_at"`
    Order    string `query:"order" validate:"omitempty,oneof=asc desc"`
}

func (q *UserListQuery) SetDefaults() {
    if q.Page == 0 {
        q.Page = 1
    }
    if q.Limit == 0 {
        q.Limit = 20
    }
    if q.Sort == "" {
        q.Sort = "created_at"
    }
    if q.Order == "" {
        q.Order = "desc"
    }
}

// ==================== API CONTROLLER ====================

type UserAPIController struct {
    userService UserService
    validator   *validator.Validate
    baseURL     string
}

func NewUserAPIController(userService UserService, baseURL string) *UserAPIController {
    return &UserAPIController{
        userService: userService,
        validator:   validator.New(),
        baseURL:     baseURL,
    }
}

// GET /api/v1/users
func (c *UserAPIController) ListUsers(w http.ResponseWriter, r *http.Request) {
    // Parse query parameters
    query := &UserListQuery{}
    if err := c.parseQuery(r, query); err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_QUERY", err.Error(), nil)
        return
    }
    
    query.SetDefaults()
    
    // Validate query parameters
    if err := c.validator.Struct(query); err != nil {
        c.respondValidationError(w, err)
        return
    }
    
    // Get users from service
    users, total, err := c.userService.ListUsers(r.Context(), UserFilters{
        Search:   query.Search,
        Role:     query.Role,
        IsActive: query.IsActive,
        Sort:     query.Sort,
        Order:    query.Order,
        Limit:    query.Limit,
        Offset:   (query.Page - 1) * query.Limit,
    })
    
    if err != nil {
        c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
            "Failed to retrieve users", map[string]interface{}{"internal_error": err.Error()})
        return
    }
    
    // Convert to response DTOs
    userResponses := make([]UserResponse, len(users))
    for i, user := range users {
        userResponses[i] = c.userToResponse(user)
    }
    
    // Create pagination metadata
    totalPages := (total + query.Limit - 1) / query.Limit
    paginationMeta := &PaginationMeta{
        Page:       query.Page,
        Limit:      query.Limit,
        Total:      total,
        TotalPages: totalPages,
        HasNext:    query.Page < totalPages,
        HasPrev:    query.Page > 1,
    }
    
    c.respondSuccess(w, http.StatusOK, userResponses, &MetaData{
        Pagination: paginationMeta,
        Total:      total,
        RequestID:  c.getRequestID(r),
    })
}

// POST /api/v1/users
func (c *UserAPIController) CreateUser(w http.ResponseWriter, r *http.Request) {
    var req UserCreateRequest
    
    // Parse JSON body
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_JSON", 
            "Invalid JSON format", map[string]interface{}{"parse_error": err.Error()})
        return
    }
    
    // Validate request
    if err := c.validator.Struct(&req); err != nil {
        c.respondValidationError(w, err)
        return
    }
    
    // Create user through service
    user, err := c.userService.CreateUser(r.Context(), CreateUserRequest{
        Email:    req.Email,
        Name:     req.Name,
        Password: req.Password,
        Role:     c.valueOrDefault(req.Role, "user"),
    })
    
    if err != nil {
        // Handle known business errors
        switch err {
        case ErrEmailAlreadyExists:
            c.respondError(w, http.StatusConflict, "EMAIL_EXISTS", 
                "User with this email already exists", nil)
        case ErrInvalidPassword:
            c.respondError(w, http.StatusBadRequest, "INVALID_PASSWORD", 
                "Password does not meet requirements", nil)
        default:
            c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
                "Failed to create user", map[string]interface{}{"internal_error": err.Error()})
        }
        return
    }
    
    // Set Location header
    location := fmt.Sprintf("%s/api/v1/users/%d", c.baseURL, user.ID)
    w.Header().Set("Location", location)
    
    c.respondSuccess(w, http.StatusCreated, c.userToResponse(user), &MetaData{
        RequestID: c.getRequestID(r),
    })
}

// GET /api/v1/users/{id}
func (c *UserAPIController) GetUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL
    vars := mux.Vars(r)
    idStr := vars["id"]
    
    userID, err := strconv.ParseUint(idStr, 10, 64)
    if err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_USER_ID", 
            "User ID must be a valid number", nil)
        return
    }
    
    // Get user from service
    user, err := c.userService.GetUserByID(r.Context(), userID)
    if err != nil {
        if err == ErrUserNotFound {
            c.respondError(w, http.StatusNotFound, "USER_NOT_FOUND", 
                fmt.Sprintf("User with ID %d not found", userID), nil)
        } else {
            c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
                "Failed to retrieve user", map[string]interface{}{"internal_error": err.Error()})
        }
        return
    }
    
    // Check for conditional requests
    if c.handleConditionalRequest(w, r, user.UpdatedAt) {
        return
    }
    
    c.respondSuccess(w, http.StatusOK, c.userToResponse(user), &MetaData{
        RequestID: c.getRequestID(r),
    })
}

// PUT /api/v1/users/{id}
func (c *UserAPIController) UpdateUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL
    vars := mux.Vars(r)
    idStr := vars["id"]
    
    userID, err := strconv.ParseUint(idStr, 10, 64)
    if err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_USER_ID", 
            "User ID must be a valid number", nil)
        return
    }
    
    var req UserUpdateRequest
    
    // Parse JSON body
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_JSON", 
            "Invalid JSON format", map[string]interface{}{"parse_error": err.Error()})
        return
    }
    
    // Validate request
    if err := c.validator.Struct(&req); err != nil {
        c.respondValidationError(w, err)
        return
    }
    
    // Update user through service
    user, err := c.userService.UpdateUser(r.Context(), userID, UpdateUserRequest{
        Email:    req.Email,
        Name:     req.Name,
        IsActive: req.IsActive,
        Role:     req.Role,
    })
    
    if err != nil {
        switch err {
        case ErrUserNotFound:
            c.respondError(w, http.StatusNotFound, "USER_NOT_FOUND", 
                fmt.Sprintf("User with ID %d not found", userID), nil)
        case ErrEmailAlreadyExists:
            c.respondError(w, http.StatusConflict, "EMAIL_EXISTS", 
                "User with this email already exists", nil)
        default:
            c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
                "Failed to update user", map[string]interface{}{"internal_error": err.Error()})
        }
        return
    }
    
    c.respondSuccess(w, http.StatusOK, c.userToResponse(user), &MetaData{
        RequestID: c.getRequestID(r),
    })
}

// DELETE /api/v1/users/{id}
func (c *UserAPIController) DeleteUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID from URL
    vars := mux.Vars(r)
    idStr := vars["id"]
    
    userID, err := strconv.ParseUint(idStr, 10, 64)
    if err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_USER_ID", 
            "User ID must be a valid number", nil)
        return
    }
    
    // Delete user through service
    err = c.userService.DeleteUser(r.Context(), userID)
    if err != nil {
        if err == ErrUserNotFound {
            c.respondError(w, http.StatusNotFound, "USER_NOT_FOUND", 
                fmt.Sprintf("User with ID %d not found", userID), nil)
        } else {
            c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
                "Failed to delete user", map[string]interface{}{"internal_error": err.Error()})
        }
        return
    }
    
    // Return 204 No Content for successful deletion
    w.WriteHeader(http.StatusNoContent)
}

// PATCH /api/v1/users/{id}/activate
func (c *UserAPIController) ActivateUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    idStr := vars["id"]
    
    userID, err := strconv.ParseUint(idStr, 10, 64)
    if err != nil {
        c.respondError(w, http.StatusBadRequest, "INVALID_USER_ID", 
            "User ID must be a valid number", nil)
        return
    }
    
    err = c.userService.ActivateUser(r.Context(), userID)
    if err != nil {
        switch err {
        case ErrUserNotFound:
            c.respondError(w, http.StatusNotFound, "USER_NOT_FOUND", 
                fmt.Sprintf("User with ID %d not found", userID), nil)
        case ErrUserAlreadyActive:
            c.respondError(w, http.StatusConflict, "USER_ALREADY_ACTIVE", 
                "User is already active", nil)
        default:
            c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
                "Failed to activate user", map[string]interface{}{"internal_error": err.Error()})
        }
        return
    }
    
    // Get updated user to return
    user, err := c.userService.GetUserByID(r.Context(), userID)
    if err != nil {
        c.respondError(w, http.StatusInternalServerError, "SERVICE_ERROR", 
            "User activated but failed to retrieve updated data", nil)
        return
    }
    
    c.respondSuccess(w, http.StatusOK, c.userToResponse(user), &MetaData{
        RequestID: c.getRequestID(r),
    })
}

// HEAD /api/v1/users/{id}
func (c *UserAPIController) HeadUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    idStr := vars["id"]
    
    userID, err := strconv.ParseUint(idStr, 10, 64)
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    
    user, err := c.userService.GetUserByID(r.Context(), userID)
    if err != nil {
        if err == ErrUserNotFound {
            w.WriteHeader(http.StatusNotFound)
        } else {
            w.WriteHeader(http.StatusInternalServerError)
        }
        return
    }
    
    // Set headers without body
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("Last-Modified", user.UpdatedAt.Format(time.RFC1123))
    w.Header().Set("ETag", fmt.Sprintf(`"%d-%d"`, user.ID, user.UpdatedAt.Unix()))
    w.WriteHeader(http.StatusOK)
}

// OPTIONS /api/v1/users
func (c *UserAPIController) OptionsUsers(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Allow", "GET, POST, OPTIONS")
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
    w.WriteHeader(http.StatusOK)
}

// OPTIONS /api/v1/users/{id}
func (c *UserAPIController) OptionsUser(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Allow", "GET, PUT, DELETE, PATCH, HEAD, OPTIONS")
    w.Header().Set("Access-Control-Allow-Methods", "GET, PUT, DELETE, PATCH, HEAD, OPTIONS")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, If-Modified-Since, If-None-Match")
    w.WriteHeader(http.StatusOK)
}

// ==================== HELPER METHODS ====================

func (c *UserAPIController) userToResponse(user *User) UserResponse {
    baseURL := c.baseURL
    userURL := fmt.Sprintf("%s/api/v1/users/%d", baseURL, user.ID)
    
    links := UserLinks{
        Self: Link{
            Href:   userURL,
            Method: "GET",
            Type:   "application/json",
        },
        Orders: Link{
            Href:   fmt.Sprintf("%s/orders", userURL),
            Method: "GET",
            Type:   "application/json",
        },
        Profile: Link{
            Href:   fmt.Sprintf("%s/profile", userURL),
            Method: "GET",
            Type:   "application/json",
        },
    }
    
    // Conditional links based on state
    if !user.IsActive {
        links.Activate = Link{
            Href:   fmt.Sprintf("%s/activate", userURL),
            Method: "PATCH",
            Type:   "application/json",
        }
    }
    
    return UserResponse{
        ID:        user.ID,
        Email:     user.Email,
        Name:      user.Name,
        IsActive:  user.IsActive,
        Role:      user.Role,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
        Links:     links,
    }
}

func (c *UserAPIController) respondSuccess(w http.ResponseWriter, status int, data interface{}, meta *MetaData) {
    response := APIResponse{
        Success:   true,
        Data:      data,
        Meta:      meta,
        Timestamp: time.Now().UTC(),
    }
    
    c.writeJSONResponse(w, status, response)
}

func (c *UserAPIController) respondError(w http.ResponseWriter, status int, code, message string, details map[string]interface{}) {
    response := APIResponse{
        Success: false,
        Error: &APIError{
            Code:    code,
            Message: message,
            Details: details,
        },
        Timestamp: time.Now().UTC(),
    }
    
    c.writeJSONResponse(w, status, response)
}

func (c *UserAPIController) respondValidationError(w http.ResponseWriter, err error) {
    details := make(map[string]interface{})
    
    if validationErrors, ok := err.(validator.ValidationErrors); ok {
        fieldErrors := make(map[string]string)
        for _, fieldError := range validationErrors {
            fieldErrors[strings.ToLower(fieldError.Field())] = c.getValidationErrorMessage(fieldError)
        }
        details["field_errors"] = fieldErrors
    }
    
    c.respondError(w, http.StatusBadRequest, "VALIDATION_ERROR", 
        "Request validation failed", details)
}

func (c *UserAPIController) getValidationErrorMessage(err validator.FieldError) string {
    switch err.Tag() {
    case "required":
        return "This field is required"
    case "email":
        return "Must be a valid email address"
    case "min":
        return fmt.Sprintf("Must be at least %s characters", err.Param())
    case "max":
        return fmt.Sprintf("Must be no more than %s characters", err.Param())
    case "oneof":
        return fmt.Sprintf("Must be one of: %s", err.Param())
    default:
        return "Invalid value"
    }
}

func (c *UserAPIController) writeJSONResponse(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    
    if err := json.NewEncoder(w).Encode(data); err != nil {
        // Log error but don't send another response
        fmt.Printf("Failed to encode JSON response: %v\n", err)
    }
}

func (c *UserAPIController) parseQuery(r *http.Request, dest interface{}) error {
    // Simplified query parsing - in production use gorilla/schema or similar
    query := r.URL.Query()
    
    if q, ok := dest.(*UserListQuery); ok {
        if page := query.Get("page"); page != "" {
            if p, err := strconv.Atoi(page); err == nil {
                q.Page = p
            }
        }
        if limit := query.Get("limit"); limit != "" {
            if l, err := strconv.Atoi(limit); err == nil {
                q.Limit = l
            }
        }
        q.Search = query.Get("search")
        q.Role = query.Get("role")
        q.Sort = query.Get("sort")
        q.Order = query.Get("order")
        
        if isActive := query.Get("is_active"); isActive != "" {
            if active, err := strconv.ParseBool(isActive); err == nil {
                q.IsActive = &active
            }
        }
    }
    
    return nil
}

func (c *UserAPIController) handleConditionalRequest(w http.ResponseWriter, r *http.Request, lastModified time.Time) bool {
    // Handle If-Modified-Since
    if modifiedSince := r.Header.Get("If-Modified-Since"); modifiedSince != "" {
        if t, err := time.Parse(time.RFC1123, modifiedSince); err == nil {
            if lastModified.Before(t.Add(time.Second)) {
                w.WriteHeader(http.StatusNotModified)
                return true
            }
        }
    }
    
    // Handle If-None-Match (ETag)
    if noneMatch := r.Header.Get("If-None-Match"); noneMatch != "" {
        etag := fmt.Sprintf(`"%d"`, lastModified.Unix())
        if noneMatch == etag {
            w.WriteHeader(http.StatusNotModified)
            return true
        }
    }
    
    // Set response headers
    w.Header().Set("Last-Modified", lastModified.Format(time.RFC1123))
    w.Header().Set("ETag", fmt.Sprintf(`"%d"`, lastModified.Unix()))
    
    return false
}

func (c *UserAPIController) getRequestID(r *http.Request) string {
    if id := r.Header.Get("X-Request-ID"); id != "" {
        return id
    }
    return fmt.Sprintf("req_%d", time.Now().UnixNano())
}

func (c *UserAPIController) valueOrDefault(value *string, defaultValue string) string {
    if value != nil {
        return *value
    }
    return defaultValue
}

// ==================== API VERSIONING ====================

type APIVersionMiddleware struct {
    defaultVersion string
    supportedVersions map[string]bool
}

func NewAPIVersionMiddleware(defaultVersion string, supportedVersions []string) *APIVersionMiddleware {
    supported := make(map[string]bool)
    for _, version := range supportedVersions {
        supported[version] = true
    }
    
    return &APIVersionMiddleware{
        defaultVersion:    defaultVersion,
        supportedVersions: supported,
    }
}

func (m *APIVersionMiddleware) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        version := m.extractVersion(r)
        
        if !m.supportedVersions[version] {
            http.Error(w, fmt.Sprintf("API version %s is not supported", version), 
                http.StatusBadRequest)
            return
        }
        
        // Add version to context or headers
        r.Header.Set("X-API-Version", version)
        w.Header().Set("X-API-Version", version)
        
        next.ServeHTTP(w, r)
    })
}

func (m *APIVersionMiddleware) extractVersion(r *http.Request) string {
    // Method 1: URL path versioning (/api/v1/users)
    if strings.HasPrefix(r.URL.Path, "/api/v") {
        parts := strings.Split(r.URL.Path, "/")
        if len(parts) >= 3 && strings.HasPrefix(parts[2], "v") {
            return parts[2]
        }
    }
    
    // Method 2: Header versioning
    if version := r.Header.Get("API-Version"); version != "" {
        return version
    }
    
    // Method 3: Accept header versioning
    if accept := r.Header.Get("Accept"); accept != "" {
        if strings.Contains(accept, "version=") {
            // Parse application/json;version=v1
            parts := strings.Split(accept, "version=")
            if len(parts) > 1 {
                return strings.Split(parts[1], ";")[0]
            }
        }
    }
    
    return m.defaultVersion
}

// ==================== CONTENT NEGOTIATION ====================

type ContentNegotiationMiddleware struct{}

func NewContentNegotiationMiddleware() *ContentNegotiationMiddleware {
    return &ContentNegotiationMiddleware{}
}

func (m *ContentNegotiationMiddleware) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Check Accept header
        accept := r.Header.Get("Accept")
        
        if accept != "" && !strings.Contains(accept, "application/json") && 
           !strings.Contains(accept, "*/*") {
            http.Error(w, "Not Acceptable: only application/json is supported", 
                http.StatusNotAcceptable)
            return
        }
        
        // Check Content-Type for requests with body
        if r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH" {
            contentType := r.Header.Get("Content-Type")
            if contentType != "" && !strings.HasPrefix(contentType, "application/json") {
                http.Error(w, "Unsupported Media Type: only application/json is supported", 
                    http.StatusUnsupportedMediaType)
                return
            }
        }
        
        next.ServeHTTP(w, r)
    })
}

// ==================== ROUTER SETUP ====================

func SetupAPIRoutes(controller *UserAPIController) *mux.Router {
    r := mux.NewRouter()
    
    // Middleware
    versionMiddleware := NewAPIVersionMiddleware("v1", []string{"v1", "v2"})
    contentMiddleware := NewContentNegotiationMiddleware()
    
    r.Use(versionMiddleware.Middleware)
    r.Use(contentMiddleware.Middleware)
    
    // API v1 routes
    v1 := r.PathPrefix("/api/v1").Subrouter()
    
    // Users collection
    v1.HandleFunc("/users", controller.ListUsers).Methods("GET")
    v1.HandleFunc("/users", controller.CreateUser).Methods("POST")
    v1.HandleFunc("/users", controller.OptionsUsers).Methods("OPTIONS")
    
    // Individual user
    v1.HandleFunc("/users/{id:[0-9]+}", controller.GetUser).Methods("GET")
    v1.HandleFunc("/users/{id:[0-9]+}", controller.UpdateUser).Methods("PUT")
    v1.HandleFunc("/users/{id:[0-9]+}", controller.DeleteUser).Methods("DELETE")
    v1.HandleFunc("/users/{id:[0-9]+}", controller.HeadUser).Methods("HEAD")
    v1.HandleFunc("/users/{id:[0-9]+}", controller.OptionsUser).Methods("OPTIONS")
    
    // User actions
    v1.HandleFunc("/users/{id:[0-9]+}/activate", controller.ActivateUser).Methods("PATCH")
    
    return r
}

// Error definitions
var (
    ErrEmailAlreadyExists = fmt.Errorf("email already exists")
    ErrInvalidPassword    = fmt.Errorf("invalid password")
    ErrUserAlreadyActive  = fmt.Errorf("user already active")
)

// Mock service interfaces for compilation
type UserService interface {
    ListUsers(ctx context.Context, filters UserFilters) ([]*User, int, error)
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUserByID(ctx context.Context, id uint64) (*User, error)
    UpdateUser(ctx context.Context, id uint64, req UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, id uint64) error
    ActivateUser(ctx context.Context, id uint64) error
}

type UserFilters struct {
    Search   string
    Role     string
    IsActive *bool
    Sort     string
    Order    string
    Limit    int
    Offset   int
}

type CreateUserRequest struct {
    Email    string
    Name     string
    Password string
    Role     string
}

type UpdateUserRequest struct {
    Email    *string
    Name     *string
    IsActive *bool
    Role     *string
}

type User struct {
    ID        uint64
    Email     string
    Name      string
    IsActive  bool
    Role      string
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**ğŸ¯ ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ API Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ°:**
- **ĞŸÑ€ĞµĞ´ÑĞºĞ°Ğ·ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ HTTP Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¸ ĞºĞ¾Ğ´Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ²
- **Ğ¡Ğ°Ğ¼Ğ¾Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - HATEOAS ÑÑÑ‹Ğ»ĞºĞ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ
- **Ğ’ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ** - Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ğ²ĞµÑ€ÑĞ¸Ğ¹ API
- **Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ** - ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞºÑĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº** - ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸

**ğŸ’¡ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ REST API:**
- Ğ ĞµÑÑƒÑ€ÑÑ‹ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒÑÑ‚ÑÑ URL
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ HTTP Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ¿Ğ¾ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
- Stateless - ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼
- ĞšÑÑˆĞ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· HTTP Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¸
- Layered system - Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ñ€Ğ¾ĞºÑĞ¸, ĞºÑÑˆĞµĞ¹

---

Ğ­Ñ‚Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµÑ‚ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±Ğ·Ğ¾Ñ€ HTTP ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ² Ğ¸ API Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ° Ğ² Go. ĞœĞ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ» Ğ¿Ğ¾ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¾Ñ‚ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ñ… ÑĞµÑ€Ğ²ĞµÑ€Ğ¾Ğ² Ğ´Ğ¾ enterprise-level Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€ Ñ middleware, validation, versioning Ğ¸ HATEOAS. Ğ¥Ğ¾Ñ‚ĞµĞ»Ğ¸ Ğ±Ñ‹ Ğ²Ñ‹ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ñ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ½ĞµĞ´ĞµĞ»ÑĞ¼Ğ¸ Ğ¸Ğ»Ğ¸ ÑƒĞ³Ğ»ÑƒĞ±Ğ¸Ñ‚ÑŒÑÑ Ğ² ĞºĞ°ĞºÑƒÑ-Ñ‚Ğ¾ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½ÑƒÑ Ñ‚ĞµĞ¼Ñƒ?