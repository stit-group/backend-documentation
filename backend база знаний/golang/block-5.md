# 🚀 Блок 5: Продвинутые техники и оптимизация

**⏱️ Длительность:** 2-3 месяца  
**🎯 Цель:** Углубить знания для создания production-ready приложений

---

## 5.1 Тестирование

### 🧪 Философия тестирования в Go

Go имеет встроенную поддержку тестирования, что делает тестирование частью культуры языка, а не дополнительной опцией.

**Пирамида тестирования:**

```
                    ┌─────────────────┐
                    │       E2E       │ ← Мало, медленные, дорогие
                    │     Tests       │
                    └─────────────────┘
                 ┌─────────────────────────┐
                 │    Integration Tests    │ ← Средне, умеренные
                 └─────────────────────────┘
            ┌─────────────────────────────────────┐
            │           Unit Tests                │ ← Много, быстрые, дешевые
            └─────────────────────────────────────┘
```

### 🔧 Типы тестов в Go

#### Unit Tests (Модульные тесты)
**Концепция:** Тестирование отдельных функций/методов в изоляции.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Unit Test Structure                          │
│                                                                 │
│  Function Under Test                                            │
│  ┌─────────────────┐                                            │
│  │   Input Data    │ ────► ┌─────────────────┐ ────► Expected  │
│  │                 │       │    Function     │       Output    │
│  │ • Valid cases   │       │                 │                 │
│  │ • Edge cases    │       └─────────────────┘                 │
│  │ • Error cases   │                                            │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

#### Table-Driven Tests
**Концепция:** Один тест-функция для множества тест-кейсов.

```
┌─────────────────────────────────────────────────────────────────┐
│                 Table-Driven Test Pattern                       │
│                                                                 │
│  Test Cases Table                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Name      │ Input    │ Expected │ ShouldError │         │    │
│  ├─────────────────────────────────────────────────────────┤    │
│  │ "valid"   │ input1   │ result1  │ false       │         │    │
│  │ "empty"   │ ""       │ ""       │ true        │ ────┐   │    │
│  │ "edge"    │ input2   │ result2  │ false       │     │   │    │
│  └─────────────────────────────────────────────────────────┘   │    │
│                                                            │   │    │
│  ┌─────────────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  ▼                                                             │    │
│  for each test case:                                           │    │
│  ├─ Run subtest                                                │    │
│  ├─ Execute function                                           │    │
│  ├─ Compare results                                            │    │
│  └─ Report outcome                                             │    │
└─────────────────────────────────────────────────────────────────┘
```

#### Integration Tests
**Концепция:** Тестирование взаимодействия между компонентами.

```
┌─────────────────────────────────────────────────────────────────┐
│                   Integration Test Scope                        │
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │
│  │  Service A  │───►│  Service B  │───►│  Database   │          │
│  │             │    │             │    │             │          │
│  └─────────────┘    └─────────────┘    └─────────────┘          │
│         ▲                   ▲                   ▲               │
│         │                   │                   │               │
│         └───────────────────┼───────────────────┘               │
│                             │                                   │
│                    Integration Test                             │
│                  (Tests the flow)                              │
└─────────────────────────────────────────────────────────────────┘
```

### 🎭 Mocking и Stubbing

**Концепция:** Замена реальных зависимостей на контролируемые заглушки.

```
┌─────────────────────────────────────────────────────────────────┐
│                      Mock vs Stub                               │
├─────────────────────┬───────────────────────────────────────────┤
│        Mock         │               Stub                        │
├─────────────────────┼───────────────────────────────────────────┤
│ Проверяет поведение │ Предоставляет данные                     │
│ "Был ли вызван?"    │ "Что вернуть?"                           │
│ "С какими аргументы"│ Простая замена                           │
│ Сложная логика      │ Минимальная реализация                   │
└─────────────────────┴───────────────────────────────────────────┘
```

**Архитектура с моками:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Testing with Mocks                           │
│                                                                 │
│  Production Code              Test Code                         │
│  ┌─────────────────┐          ┌─────────────────┐               │
│  │   Service       │          │   Service       │               │
│  │       │         │          │       │         │               │
│  │       ▼         │          │       ▼         │               │
│  │ ┌─────────────┐ │          │ ┌─────────────┐ │               │
│  │ │Real Database│ │    VS    │ │Mock Database│ │               │
│  │ │   (Slow)    │ │          │ │   (Fast)    │ │               │
│  │ └─────────────┘ │          │ └─────────────┘ │               │
│  └─────────────────┘          └─────────────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

### 📊 Benchmark тесты

**Концепция:** Измерение производительности кода.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Benchmark Process                           │
│                                                                 │
│  ┌─────────────────┐                                            │
│  │   Warm-up       │ ──► Подготовка JIT, кешей                 │
│  └─────────────────┘                                            │
│           │                                                     │
│           ▼                                                     │
│  ┌─────────────────┐                                            │
│  │  Measurement    │ ──► Многократное выполнение                │
│  │     Loop        │     функции                               │
│  └─────────────────┘                                            │
│           │                                                     │
│           ▼                                                     │
│  ┌─────────────────┐                                            │
│  │   Statistics    │ ──► ns/op, MB/s, allocs/op                │
│  │   Calculation   │                                            │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

**Метрики бенчмарков:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Benchmark Metrics                            │
├─────────────────┬───────────────────────────────────────────────┤
│     ns/op       │ Наносекунды на операцию                      │
│     MB/s        │ Мегабайт в секунду (throughput)              │
│   allocs/op     │ Аллокации памяти на операцию                 │
│     B/op        │ Байт аллоцировано на операцию                │
└─────────────────┴───────────────────────────────────────────────┘
```

### 📈 Coverage анализ

**Концепция:** Измерение того, какая часть кода покрыта тестами.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Code Coverage Types                         │
│                                                                 │
│  Statement Coverage (Покрытие утверждений)                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ if condition {           ← Проверено?                   │    │
│  │     statement1           ← Проверено?                   │    │
│  │ } else {                                                │    │
│  │     statement2           ← Проверено?                   │    │
│  │ }                                                       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Branch Coverage (Покрытие ветвей)                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              condition                                  │    │
│  │              /      \                                   │    │
│  │         true/        \false                             │    │
│  │            /          \                                 │    │
│  │       branch1      branch2                              │    │
│  │      (Проверено?)  (Проверено?)                         │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5.2 Профилирование и оптимизация

### 🔍 Профилирование с pprof

**Концепция:** pprof - это инструмент для анализа производительности Go приложений.

```
┌─────────────────────────────────────────────────────────────────┐
│                      pprof Architecture                         │
│                                                                 │
│  Go Application                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │    │
│  │  │ CPU Profile │  │Heap Profile │  │Goroutine    │      │    │
│  │  │             │  │             │  │Profile      │      │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘      │    │
│  │         │                 │                 │           │    │
│  └─────────│─────────────────│─────────────────│───────────┘    │
│            │                 │                 │                │
│            ▼                 ▼                 ▼                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                pprof Tool                               │    │
│  │                                                         │    │
│  │  • Web Interface                                        │    │
│  │  • Command Line                                         │    │
│  │  • Flame Graphs                                         │    │
│  │  • Call Graphs                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 📊 Типы профайлинга

#### CPU Profiling
**Концепция:** Анализ того, где программа тратит время процессора.

```
┌─────────────────────────────────────────────────────────────────┐
│                      CPU Profile View                           │
│                                                                 │
│  Function Call Stack     Time Spent                             │
│  ┌─────────────────┐    ┌─────────────────┐                     │
│  │    main()       │───►│ 100% (1000ms)   │                     │
│  │      │          │    └─────────────────┘                     │
│  │      ▼          │                                            │
│  │  processData()  │───►│  80% (800ms)    │                     │
│  │      │          │    └─────────────────┘                     │
│  │      ▼          │                                            │
│  │  heavyFunc()    │───►│  60% (600ms)    │ ← Hotspot!          │
│  │                 │    └─────────────────┘                     │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘
```

#### Memory Profiling
**Концепция:** Анализ использования памяти приложением.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Memory Profile Types                         │
├─────────────────┬───────────────────────────────────────────────┤
│   Heap Profile  │ Активно используемая память                  │
│  Alloc Profile  │ Все аллокации (включая освобожденные)        │
│ Goroutine Prof. │ Стеки всех горутин                           │
│  Mutex Profile  │ Блокировки на мьютексах                      │
│  Block Profile  │ Блокировки на каналах                        │
└─────────────────┴───────────────────────────────────────────────┘
```

### 🔥 Flame Graphs

**Концепция:** Flame Graph - это визуализация профиля производительности.

```
┌─────────────────────────────────────────────────────────────────┐
│                      Flame Graph Structure                      │
│                                                                 │
│  main() ████████████████████████████████████████████████████    │
│    │                                                            │
│    ├─ processData() ██████████████████████████████████████      │
│    │    │                                                       │
│    │    ├─ parseJSON() ████████████                             │
│    │    │                                                       │
│    │    ├─ validateData() ██████                                │
│    │    │                                                       │
│    │    └─ heavyComputation() ████████████████████████ ← Широкий │
│    │                                                      блок  │
│    └─ cleanup() ████                                            │
│                                                                 │
│  Ширина = Время выполнения                                      │
│  Высота = Глубина стека вызовов                                 │
└─────────────────────────────────────────────────────────────────┘
```

### ⚡ Стратегии оптимизации

#### 1. Алгоритмическая оптимизация
**Приоритет #1:** Выбор правильного алгоритма и структуры данных.

```
┌─────────────────────────────────────────────────────────────────┐
│              Algorithm Complexity Comparison                    │
│                                                                 │
│  Time Complexity     Examples                Performance        │
│  ┌─────────────┐    ┌──────────────────┐   ┌────────────────┐   │
│  │    O(1)     │───►│ Hash map lookup  │──►│ Отличная       │   │
│  │  O(log n)   │───►│ Binary search    │──►│ Хорошая        │   │
│  │    O(n)     │───►│ Linear search    │──►│ Приемлемая     │   │
│  │  O(n²)      │───►│ Bubble sort      │──►│ Плохая         │   │
│  │  O(2ⁿ)      │───►│ Recursive fib    │──►│ Ужасная        │   │
│  └─────────────┘    └──────────────────┘   └────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 2. Микро-оптимизации
**Концепция:** Оптимизация на уровне отдельных операций.

```
┌─────────────────────────────────────────────────────────────────┐
│                   Micro-optimizations                           │
├─────────────────────┬───────────────────────────────────────────┤
│ String Building     │ strings.Builder вместо конкатенации      │
│ Slice Allocation    │ make([]T, 0, capacity) заранее           │
│ Map Lookup          │ value, ok := map[key]                    │
│ Interface Calls     │ Избегать в горячих циклах                │ 
│ Boundary Checks     │ Компилятор может их устранить             │
└─────────────────────┴───────────────────────────────────────────┘
```

---

## 5.3 Управление памятью

### 🗑️ Garbage Collection в Go

**Концепция:** Go использует concurrent mark-and-sweep сборщик мусора.

```
┌─────────────────────────────────────────────────────────────────┐
│                    GC Phases in Go                              │
│                                                                 │
│  Program Execution                                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ ████████████████████████████████████████████████████████ │    │
│  └─────────────────────────────────────────────────────────┘    │
│           │              │              │              │        │
│           ▼              ▼              ▼              ▼        │
│      ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐   │
│      │ Mark    │    │ Mark    │    │ Mark    │    │ Mark    │   │
│      │ Phase   │    │ Phase   │    │ Phase   │    │ Phase   │   │
│      │ (~25%)  │    │ (~25%)  │    │ (~25%)  │    │ (~25%)  │   │
│      └─────────┘    └─────────┘    └─────────┘    └─────────┘   │
│           │              │              │              │        │
│           ▼              ▼              ▼              ▼        │
│      ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐   │
│      │ Sweep   │    │ Sweep   │    │ Sweep   │    │ Sweep   │   │
│      │ Phase   │    │ Phase   │    │ Phase   │    │ Phase   │   │
│      └─────────┘    └─────────┘    └─────────┘    └─────────┘   │
│                                                                 │
│  Concurrent: GC работает параллельно с программой               │
└─────────────────────────────────────────────────────────────────┘
```

### 🎯 GC Tuning

**Параметры настройки GC:**

```
┌─────────────────────────────────────────────────────────────────┐
│                     GC Tuning Parameters                        │
├─────────────────────┬───────────────────────────────────────────┤
│     GOGC            │ Триггер GC (default: 100%)               │
│   GOMEMLIMIT        │ Мягкий лимит памяти                      │
│   GODEBUG           │ Отладочная информация GC                 │
│                     │                                           │
│  Trade-offs:                                                    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Lower GOGC  → Больше GC → Меньше памяти → Медленнее    │    │
│  │ Higher GOGC → Меньше GC → Больше памяти → Быстрее      │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 💾 Memory Leaks

**Типичные причины утечек памяти в Go:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    Memory Leak Patterns                         │
│                                                                 │
│  1. Goroutine Leaks                                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  go func() {                                            │    │
│  │      for {                                              │    │
│  │          // Бесконечный цикл без выхода                 │    │
│  │          select {                                       │    │
│  │          case <-ch:                                     │    │
│  │              // обработка                              │    │
│  │          }                                              │    │
│  │      }                                                  │    │
│  │  }()                                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  2. Slice Leaks                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  big := make([]byte, 1000000)                           │    │
│  │  small := big[:10]  // Ссылается на весь массив!       │    │
│  │  return small                                           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  3. Map Leaks                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  // Карта растет, но никогда не очищается               │    │
│  │  cache := make(map[string]*BigData)                     │    │
│  │  // Добавляем, но не удаляем                           │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🔄 sync.Pool

**Концепция:** Пул объектов для переиспользования.

```
┌─────────────────────────────────────────────────────────────────┐
│                     sync.Pool Pattern                           │
│                                                                 │
│  Object Lifecycle                                               │
│  ┌─────────────────┐    ┌─────────────────┐    ┌──────────────┐ │
│  │     Create      │───►│      Use        │───►│   Return     │ │
│  │   (Expensive)   │    │   (Fast)        │    │  (to Pool)   │ │
│  └─────────────────┘    └─────────────────┘    └──────────────┘ │
│           │                                            │        │
│           ▼                                            ▼        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                 sync.Pool                            │    │
│  │  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐        │    │
│  │  │Obj1 │  │Obj2 │  │Obj3 │  │Obj4 │  │Obj5 │  ...   │    │
│  │  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘        │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Benefits:                                                      │
│  • Снижение GC pressure                                        │
│  • Переиспользование дорогих объектов                          │
│  • Автоматическая очистка при GC                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5.4 Рефлексия

### 🪞 Концепция рефлексии

**Рефлексия** позволяет программе исследовать, интроспектировать и модифицировать свою собственную структуру во время выполнения.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Reflection in Go                             │
│                                                                 │
│  Compile Time              Runtime                              │
│  ┌─────────────────┐      ┌─────────────────┐                   │
│  │   Type Info     │ ────►│  reflect.Type   │                   │
│  │   (Static)      │      │   (Dynamic)     │                   │
│  └─────────────────┘      └─────────────────┘                   │
│                                     │                           │
│  ┌─────────────────┐      ┌─────────────────┐                   │
│  │     Value       │ ────►│ reflect.Value   │                   │
│  │   (Static)      │      │   (Dynamic)     │                   │
│  └─────────────────┘      └─────────────────┘                   │
│                                                                 │
│  Interface{} ────► reflect.TypeOf() ────► Type                  │
│            ────► reflect.ValueOf() ────► Value                  │
└─────────────────────────────────────────────────────────────────┘
```

### 🔍 Type и Value

**reflect.Type vs reflect.Value:**

```
┌─────────────────────────────────────────────────────────────────┐
│                   Type vs Value                                 │
├─────────────────────┬───────────────────────────────────────────┤
│   reflect.Type      │         reflect.Value                     │
├─────────────────────┼───────────────────────────────────────────┤
│ Информация о типе   │ Конкретное значение                      │
│ • Kind()            │ • Interface()                            │
│ • Name()            │ • Int(), String()                        │
│ • NumField()        │ • Field()                                │
│ • Method()          │ • Call()                                 │
│ • Implements()      │ • Set*()                                 │
│                     │ • CanSet()                               │
│                     │                                           │
│ Описывает "что"     │ Содержит "значение"                      │
└─────────────────────┴───────────────────────────────────────────┘
```

### 🏷️ Структурные теги

**Концепция:** Метаданные для полей структур.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Struct Tags Usage                            │
│                                                                 │
│  type User struct {                                             │
│      ID    int    `json:"id" db:"user_id" validate:"required"`  │
│      Name  string `json:"name" db:"username" validate:"min=2"`  │
│      Email string `json:"email" db:"email" validate:"email"`    │
│  }                                                              │
│                                                                 │
│  Tag Parsing:                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Field.Tag.Get("json")     → "id"                        │    │
│  │ Field.Tag.Get("db")       → "user_id"                   │    │
│  │ Field.Tag.Get("validate") → "required"                  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Common Use Cases:                                              │
│  • JSON serialization                                          │
│  • Database mapping                                             │
│  • Validation rules                                             │
│  • Form binding                                                 │
│  • Documentation                                                │
└─────────────────────────────────────────────────────────────────┘
```

### ⚠️ Ограничения рефлексии

```
┌─────────────────────────────────────────────────────────────────┐
│                 Reflection Limitations                          │
├─────────────────────┬───────────────────────────────────────────┤
│   Performance       │ Медленнее прямого доступа                │
│   Type Safety       │ Ошибки во время выполнения               │
│   Complexity        │ Сложнее для понимания                    │
│   Compile-time      │ Некоторые ошибки не видны до runtime     │
│   Optimization      │ Компилятор не может оптимизировать        │
└─────────────────────┴───────────────────────────────────────────┘
```

---

## 5.5 Unsafe операции

### ⚠️ Пакет unsafe

**Концепция:** unsafe позволяет обойти систему типов Go для низкоуровневых операций.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Memory Layout                               │
│                                                                 │
│  Safe Go                                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                Type System                              │    │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │    │
│  │  │   int   │  │ string  │  │ []byte  │  │  struct │     │    │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼                                  │
│  Unsafe                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │               Raw Memory                                │    │
│  │  ┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐┌─────┐      │    │
│  │  │byte ││byte ││byte ││byte ││byte ││byte ││byte │ ...  │    │
│  │  └─────┘└─────┘└─────┘└─────┘└─────┘└─────┘└─────┘      │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🗂️ Основные типы unsafe

```
┌─────────────────────────────────────────────────────────────────┐
│                    unsafe Package Types                         │
├─────────────────────┬───────────────────────────────────────────┤
│   unsafe.Pointer    │ Указатель на любой тип                   │
│   uintptr          │ Указатель как целое число                │
│   unsafe.Sizeof()   │ Размер типа в байтах                     │
│   unsafe.Offsetof() │ Смещение поля в структуре                │
│   unsafe.Alignof()  │ Выравнивание типа                        │
└─────────────────────┴───────────────────────────────────────────┘
```

### 🔗 CGO интеграция

**Концепция:** Вызов C кода из Go.

```
┌─────────────────────────────────────────────────────────────────┐
│                      CGO Architecture                           │
│                                                                 │
│  Go Program                                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                                                         │    │
│  │  import "C"                                             │    │
│  │                                                         │    │
│  │  func GoFunction() {                                    │    │
│  │      result := C.c_function(C.int(42))                 │    │
│  │      // Type conversion Go ↔ C                         │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼                                  │
│  C Library                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  /*                                                     │    │
│  │  #include <stdio.h>                                     │    │
│  │                                                         │    │
│  │  int c_function(int x) {                                │    │
│  │      return x * 2;                                      │    │
│  │  }                                                      │    │
│  │  */                                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

**Ограничения CGO:**
- Потеря переносимости
- Сложность сборки
- Проблемы с GC
- Performance overhead
- Сложность дебага

---

## 5.6 Generics (Go 1.18+)

### 🧬 Концепция дженериков

**Дженерики** позволяют писать код, который работает с разными типами, сохраняя типобезопасность.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Before vs After Generics                     │
│                                                                 │
│  Before (Go < 1.18)                                             │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  func MaxInt(a, b int) int                              │    │
│  │  func MaxFloat64(a, b float64) float64                  │    │
│  │  func MaxString(a, b string) string                     │    │
│  │  // Дублирование кода для каждого типа                 │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼                                  │
│  After (Go 1.18+)                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  func Max[T comparable](a, b T) T {                     │    │
│  │      if a > b { return a }                              │    │
│  │      return b                                           │    │
│  │  }                                                      │    │
│  │  // Один код для всех сравнимых типов                  │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🏷️ Type Parameters и Constraints

```
┌─────────────────────────────────────────────────────────────────┐
│                   Type Parameters Syntax                        │
│                                                                 │
│  func Function[T Constraint](param T) T                         │
│              │ │     │           │    │                         │
│              │ │     │           │    └─ Return type            │
│              │ │     │           └─ Parameter of type T         │
│              │ │     └─ Constraint (что T может делать)         │
│              │ └─ Type parameter name                           │
│              └─ Generic function marker                         │
│                                                                 │
│  Examples:                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  func Print[T any](v T)                    // Любой тип │    │
│  │  func Add[T ~int | ~float64](a, b T) T     // Числа    │    │
│  │  func Sort[T comparable](slice []T)        // Сравнимые │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🔗 Встроенные constraints

```
┌─────────────────────────────────────────────────────────────────┐
│                   Built-in Constraints                          │
├─────────────────────┬───────────────────────────────────────────┤
│        any          │ interface{} - любой тип                   │
│    comparable       │ Типы, поддерживающие == и !=             │
│                     │                                           │
│  golang.org/x/exp/constraints:                                  │
│     Signed          │ Знаковые целые числа                     │
│     Unsigned        │ Беззнаковые целые числа                  │
│     Integer         │ Все целые числа                          │
│     Float           │ Числа с плавающей точкой                 │
│     Ordered         │ Упорядочиваемые типы                     │
└─────────────────────┴───────────────────────────────────────────┘
```

### 🏗️ Generic типы

```
┌─────────────────────────────────────────────────────────────────┐
│                    Generic Data Structures                      │
│                                                                 │
│  Generic Stack                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  type Stack[T any] struct {                             │    │
│  │      items []T                                          │    │
│  │  }                                                      │    │
│  │                                                         │    │
│  │  func (s *Stack[T]) Push(item T)                        │    │
│  │  func (s *Stack[T]) Pop() (T, bool)                     │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Usage:                                                         │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  intStack := Stack[int]{}                               │    │
│  │  stringStack := Stack[string]{}                         │    │
│  │  // Типобезопасно!                                     │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🎯 Type Inference

**Концепция:** Компилятор может автоматически определить типы.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Type Inference                              │
│                                                                 │
│  Explicit:                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  result := Max[int](10, 20)                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼                                  │
│  Inferred:                                                      │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  result := Max(10, 20)  // Компилятор знает: int       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  When Inference Works:                                          │
│  • Function arguments provide type info                         │
│  • Return value assignment provides type info                   │
│  • Method calls on generic types                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5.7 Обработка ошибок

### 🚨 Философия ошибок в Go

**Концепция:** Ошибки в Go - это значения, а не исключения.

```
┌─────────────────────────────────────────────────────────────────┐
│              Error Handling Philosophy                          │
│                                                                 │
│  Traditional (Java, C#)          Go Approach                    │
│  ┌─────────────────────┐        ┌─────────────────────┐         │
│  │   try {             │        │  result, err :=     │         │
│  │     operation()     │   VS   │      operation()    │         │
│  │   } catch (ex) {    │        │  if err != nil {    │         │
│  │     handle(ex)      │        │      handle(err)    │         │
│  │   }                 │        │  }                  │         │
│  └─────────────────────┘        └─────────────────────┘         │
│                                                                 │
│  Exceptions (скрытые)             Errors (явные)                │
│  • Могут пропустить              • Невозможно игнорировать     │
│  • Сложно отследить               • Явный control flow         │
│  • Performance overhead           • Предсказуемость            │
└─────────────────────────────────┘ └─────────────────────────────┘
```

### 🔗 Error Wrapping

**Концепция:** Добавление контекста к ошибкам без потери оригинальной информации.

```
┌─────────────────────────────────────────────────────────────────┐
│                     Error Wrapping Chain                        │
│                                                                 │
│  Original Error                                                 │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  "connection refused"                                   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼ fmt.Errorf("database: %w", err)  │
│  Wrapped Error 1                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  "database: connection refused"                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│                              ▼ fmt.Errorf("user service: %w")   │
│  Wrapped Error 2                                                │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  "user service: database: connection refused"          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Unwrapping:                                                    │
│  errors.Unwrap() → получить underlying error                    │
│  errors.Is()     → проверить тип ошибки                        │
│  errors.As()     → извлечь ошибку определенного типа           │
└─────────────────────────────────────────────────────────────────┘
```

### 🎯 Кастомные ошибки

```
┌─────────────────────────────────────────────────────────────────┐
│                    Custom Error Types                           │
│                                                                 │
│  Simple Error                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  type ValidationError struct {                          │    │
│  │      Field   string                                     │    │
│  │      Message string                                     │    │
│  │  }                                                      │    │
│  │                                                         │    │
│  │  func (e ValidationError) Error() string {              │    │
│  │      return fmt.Sprintf("%s: %s", e.Field, e.Message)  │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Rich Error with Context                                        │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  type DatabaseError struct {                            │    │
│  │      Op       string    // Операция                    │    │
│  │      Table    string    // Таблица                     │    │
│  │      Err      error     // Underlying error            │    │
│  │      Code     int       // Error code                  │    │
│  │      Retryable bool     // Можно ли повторить          │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 🛡️ Panic и Recovery

**Концепция:** Panic для критических ошибок, Recovery для их перехвата.

```
┌─────────────────────────────────────────────────────────────────┐
│                    Panic/Recovery Flow                          │
│                                                                 │
│  Normal Execution                                               │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  func A() {                                             │    │
│  │      defer func() {                                     │    │
│  │          if r := recover(); r != nil {                  │    │
│  │              log.Printf("Recovered: %v", r)             │    │
│  │          }                                              │    │
│  │      }()                                                │    │
│  │      B()  // Может вызвать panic                       │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│  Panic Occurs               ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  func B() {                                             │    │
│  │      panic("something went wrong")                      │    │
│  │  }                                                      │    │
│  └─────────────────────────────────────────────────────────┘    │
│                              │                                  │
│  Stack Unwinding            ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  B() → panic → defer в A() → recover → continue         │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

**Когда использовать panic:**
- Программные ошибки (bugs)
- Критические состояния системы
- Инициализация приложения
- Библиотечный код (очень редко)

---

## 🎯 Заключение блока

В этом блоке мы изучили продвинутые техники Go разработки:

- **Тестирование** - создание надежных тестовых наборов
- **Профилирование** - анализ и оптимизация производительности  
- **Управление памятью** - эффективная работа с GC и memory leaks
- **Рефлексия** - метапrogramming возможности
- **Unsafe операции** - низкоуровневые техники
- **Generics** - типобезопасный полиморфизм
- **Обработка ошибок** - надежная error handling стратегия

### 🏆 Ключевые принципы production-ready кода:

1. **Тестируемость** - каждая функция должна быть покрыта тестами
2. **Наблюдаемость** - профилирование и мониторинг встроены
3. **Надежность** - graceful обработка всех ошибок
4. **Производительность** - оптимизация на основе измерений
5. **Поддерживаемость** - читаемый и документированный код

### 📝 Практические задания для закрепления:

1. **Высоконагруженный HTTP сервер** - с полной тестовой покрытностью
2. **Система с метриками и мониторингом** - pprof интеграция
3. **Generic библиотека структур данных** - типобезопасные коллекции
4. **Оптимизация существующего приложения** - профилирование и улучшения

Следующий блок будет посвящен экосистеме и DevOps практикам для завершения полного цикла разработки на Go.