# –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∏–Ω—Ç–µ—Ä–≤—å—é Go Backend —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞
## 100 –≤–æ–ø—Ä–æ—Å–æ–≤ —Å —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–º–∏ –æ—Ç–≤–µ—Ç–∞–º–∏

---

## üéØ –†–∞–∑–¥–µ–ª 1: –û—Å–Ω–æ–≤—ã Go (–û—Ç–≤–µ—Ç—ã 1-20)

### 1. –ß—Ç–æ —Ç–∞–∫–æ–µ Go –∏ –∫–∞–∫–æ–≤—ã –µ–≥–æ –æ—Å–Ω–æ–≤–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go (Golang) ‚Äî –∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –≤ Google –≤ 2009 –≥–æ–¥—É. –û—Å–Ω–æ–≤–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:

- **–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è** —Å –≤—ã–≤–æ–¥–æ–º —Ç–∏–ø–æ–≤
- **–ö–æ–º–ø–∏–ª—è—Ü–∏—è –≤ –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥** ‚Äî –±—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
- **Garbage Collector** ‚Äî –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é
- **–í—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ concurrency** —á–µ—Ä–µ–∑ –≥–æ—Ä—É—Ç–∏–Ω—ã –∏ –∫–∞–Ω–∞–ª—ã
- **–ü—Ä–æ—Å—Ç–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å** ‚Äî –º–∏–Ω–∏–º–∞–ª–∏–∑–º –∏ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å
- **–ë—ã—Å—Ç—Ä–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è** ‚Äî —Å–µ–∫—É–Ω–¥—ã –¥–∞–∂–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤
- **–ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç—å** ‚Äî –æ–¥–∏–Ω –∫–æ–¥ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –û–°

```go
// –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å—Ç–æ—Ç—ã —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
package main

import "fmt"

func main() {
    message := "Hello, Go!" // –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–≤–æ–¥ —Ç–∏–ø–∞
    fmt.Println(message)
}
```

### 2. –ö–∞–∫–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –µ—Å—Ç—å –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go –∏–º–µ–µ—Ç –±–æ–≥–∞—Ç—ã–π –Ω–∞–±–æ—Ä –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤:

**–ë—É–ª–µ–≤—ã:** `bool` (true/false)
**–°—Ç—Ä–æ–∫–æ–≤—ã–µ:** `string` (UTF-8)
**–¶–µ–ª—ã–µ —á–∏—Å–ª–∞:**
- –ó–Ω–∞–∫–æ–≤—ã–µ: `int`, `int8`, `int16`, `int32`, `int64`
- –ë–µ–∑–∑–Ω–∞–∫–æ–≤—ã–µ: `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr`
**–ß–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π:** `float32`, `float64`
**–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ —á–∏—Å–ª–∞:** `complex64`, `complex128`
**–ê–ª–∏–∞—Å—ã:** `byte` (uint8), `rune` (int32 –¥–ª—è Unicode)

```go
var (
    active     bool    = true
    count      int     = 42
    percentage float64 = 98.6
    name       string  = "Go"
    symbol     rune    = 'üöÄ'
)
```

### 3. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É `var`, `:=` –∏ `const`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**`var`** ‚Äî –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:
- –ú–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —É—Ä–æ–≤–Ω–µ –ø–∞–∫–µ—Ç–∞ –∏ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–æ–∑–≤–æ–ª—è–µ—Ç —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ç–∏–ø
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è zero value

**`:=`** ‚Äî –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π:
- –¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–≤–æ–¥ —Ç–∏–ø–∞
- –¢—Ä–µ–±—É–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏

**`const`** ‚Äî –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç:
- –ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏–∑–≤–µ—Å—Ç–Ω–æ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –ù–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

```go
var globalVar int              // zero value: 0
var initializedVar int = 10    // —è–≤–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è

func example() {
    localVar := 20             // –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    const maxRetries = 3       // –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞
    
    var dynamicVar int
    if condition {
        dynamicVar = 42
    }
}
```

### 4. –û–±—ä—è—Å–Ω–∏—Ç–µ zero values –≤ Go

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–í Go –∫–∞–∂–¥—ã–π —Ç–∏–ø –∏–º–µ–µ—Ç –Ω—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (zero value) ‚Äî –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:

- **–ß–∏—Å–ª–æ–≤—ã–µ —Ç–∏–ø—ã**: `0`
- **bool**: `false`
- **string**: `""` (–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞)
- **–£–∫–∞–∑–∞—Ç–µ–ª–∏, —Å–ª–∞–π—Å—ã, –º–∞–ø—ã, –∫–∞–Ω–∞–ª—ã, —Ñ—É–Ω–∫—Ü–∏–∏, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã**: `nil`
- **–ú–∞—Å—Å–∏–≤—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã**: zero value –≤—Å–µ—Ö –ø–æ–ª–µ–π

```go
var (
    num    int         // 0
    active bool        // false
    name   string      // ""
    ptr    *int        // nil
    slice  []int       // nil
    m      map[string]int // nil
)

type User struct {
    ID   int    // 0
    Name string // ""
}
var user User // {ID: 0, Name: ""}
```

### 5. –ß—Ç–æ —Ç–∞–∫–æ–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤ Go? –ö–∞–∫ –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–£–∫–∞–∑–∞—Ç–µ–ª–∏ –≤ Go —Å–æ–¥–µ—Ä–∂–∞—Ç –∞–¥—Ä–µ—Å –ø–∞–º—è—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. Go –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª–∏, –Ω–æ –Ω–µ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É —É–∫–∞–∑–∞—Ç–µ–ª–µ–π (–∫–∞–∫ –≤ C/C++).

**–û–ø–µ—Ä–∞—Ç–æ—Ä—ã:**
- `&` ‚Äî –ø–æ–ª—É—á–∏—Ç—å –∞–¥—Ä–µ—Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
- `*` ‚Äî —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–µ (–ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ –∞–¥—Ä–µ—Å—É)

```go
func pointerExample() {
    x := 42
    var p *int = &x    // p —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ x
    
    fmt.Println(x)     // 42
    fmt.Println(p)     // –∞–¥—Ä–µ—Å –≤ –ø–∞–º—è—Ç–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0xc000014098)
    fmt.Println(*p)    // 42 (–∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ –∞–¥—Ä–µ—Å—É)
    
    *p = 100           // –∏–∑–º–µ–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ x —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞—Ç–µ–ª—å
    fmt.Println(x)     // 100
}

// –ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ —Å—Å—ã–ª–∫–µ
func increment(n *int) {
    *n++
}
```

### 6. –ö–∞–∫–∏–µ –µ—Å—Ç—å —Ü–∏–∫–ª—ã –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–í Go –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ç–∏–ø —Ü–∏–∫–ª–∞ ‚Äî `for`, –Ω–æ –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ö:

**1. –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª:**
```go
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

**2. –¶–∏–∫–ª-—É—Å–ª–æ–≤–∏–µ (–∞–Ω–∞–ª–æ–≥ while):**
```go
i := 0
for i < 10 {
    fmt.Println(i)
    i++
}
```

**3. –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª:**
```go
for {
    // –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
    if condition {
        break
    }
}
```

**4. Range —Ü–∏–∫–ª (–¥–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–π):**
```go
slice := []int{1, 2, 3}
for index, value := range slice {
    fmt.Printf("%d: %d\n", index, value)
}

m := map[string]int{"a": 1, "b": 2}
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

### 7. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `switch` –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
`switch` –≤ Go –±–æ–ª–µ–µ –º–æ—â–Ω—ã–π, —á–µ–º –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö:

**–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:**
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π `break` (–Ω–µ—Ç fallthrough –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
- –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª—é–±—ã–µ —Ç–∏–ø—ã
- –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ case
- Switch –±–µ–∑ –≤—ã—Ä–∞–∂–µ–Ω–∏—è (–∫–∞–∫ if-else —Ü–µ–ø–æ—á–∫–∞)

```go
// –û–±—ã—á–Ω—ã–π switch
func gradeSwitch(score int) string {
    switch score / 10 {
    case 10, 9:
        return "A"
    case 8:
        return "B"
    case 7:
        return "C"
    default:
        return "F"
    }
}

// Switch –±–µ–∑ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
func checkNumber(x int) {
    switch {
    case x < 0:
        fmt.Println("negative")
    case x == 0:
        fmt.Println("zero")
    case x > 0:
        fmt.Println("positive")
    }
}

// Type switch
func processValue(v interface{}) {
    switch v := v.(type) {
    case string:
        fmt.Printf("String: %s\n", v)
    case int:
        fmt.Printf("Integer: %d\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}
```

### 8. –ß—Ç–æ —Ç–∞–∫–æ–µ `defer` –∏ –∫–∞–∫ –æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
`defer` –æ—Ç–∫–ª–∞–¥—ã–≤–∞–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ –º–æ–º–µ–Ω—Ç–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∏–∑ —Ç–µ–∫—É—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏. –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤ –ø–æ—Ä—è–¥–∫–µ LIFO (–ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ—à–µ–ª ‚Äî –ø–µ—Ä–≤—ã–π –≤—ã—à–µ–ª).

**–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ:**
- –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
- –ó–∞–∫—Ä—ã—Ç–∏–µ —Ñ–∞–π–ª–æ–≤/—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
- –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –º—å—é—Ç–µ–∫—Å–æ–≤
- –¢—Ä–µ–π—Å–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

```go
func resourceManagement() error {
    file, err := os.Open("data.txt")
    if err != nil {
        return err
    }
    defer file.Close() // –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –∑–∞–∫—Ä–æ–µ—Ç—Å—è, –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    mu.Lock()
    defer mu.Unlock() // –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    
    // —Ä–∞–±–æ—Ç–∞ —Å —Ä–µ—Å—É—Ä—Å–∞–º–∏
    return processFile(file)
}

// –ü–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è defer
func deferOrder() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    fmt.Println("function body")
}
// –í—ã–≤–æ–¥: function body, 3, 2, 1
```

### 9. –ö–∞–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—à–∏–±–∫–∏ –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —è–≤–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ —á–µ—Ä–µ–∑ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∞ –Ω–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è:

**–ü—Ä–∏–Ω—Ü–∏–ø—ã:**
- –û—à–∏–±–∫–∏ ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø–∞ `error`
- –Ø–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥–æ–π –æ—à–∏–±–∫–∏
- –í–æ–∑–≤—Ä–∞—Ç –æ—à–∏–±–∫–∏ –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è

```go
// –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func example() error {
    result, err := divide(10, 0)
    if err != nil {
        return fmt.Errorf("calculation failed: %w", err)
    }
    
    fmt.Printf("Result: %f\n", result)
    return nil
}

// –ö–∞—Å—Ç–æ–º–Ω—ã–π —Ç–∏–ø –æ—à–∏–±–∫–∏
type ValidationError struct {
    Field string
    Value string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("invalid %s: %s", e.Field, e.Value)
}
```

### 10. –ß—Ç–æ —Ç–∞–∫–æ–µ –ø—É—Å—Ç–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å `interface{}`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ü—É—Å—Ç–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å `interface{}` (—Å Go 1.18 ‚Äî `any`) –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ª—é–±–æ–≥–æ —Ç–∏–ø–∞, —Ç–∞–∫ –∫–∞–∫ –≤—Å–µ —Ç–∏–ø—ã —Ä–µ–∞–ª–∏–∑—É—é—Ç –ø—É—Å—Ç–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å.

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**
- Generic-like –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –¥–∂–µ–Ω–µ—Ä–∏–∫–æ–≤
- –†–∞–±–æ—Ç–∞ —Å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏
- JSON –æ–±—Ä–∞–±–æ—Ç–∫–∞

```go
// any ‚Äî –∞–ª–∏–∞—Å –¥–ª—è interface{} —Å Go 1.18
func printAny(value any) {
    fmt.Printf("Value: %v, Type: %T\n", value, value)
}

func example() {
    printAny(42)
    printAny("hello")
    printAny([]int{1, 2, 3})
    printAny(map[string]int{"a": 1})
}

// –†–∞–±–æ—Ç–∞ —Å JSON
func processJSON(data []byte) (any, error) {
    var result any
    err := json.Unmarshal(data, &result)
    return result, err
}
```

### 11. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤ –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–≤–∞ –≤–∏–¥–∞ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è —Ç–∏–ø–æ–≤:

**1. Type assertion** ‚Äî –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤:
```go
var i interface{} = "hello"

// –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ (–º–æ–∂–µ—Ç panic)
s := i.(string)

// –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ
s, ok := i.(string)
if ok {
    fmt.Println("String:", s)
}

// Type switch –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤
switch v := i.(type) {
case string:
    fmt.Println("String:", v)
case int:
    fmt.Println("Int:", v)
default:
    fmt.Println("Unknown type")
}
```

**2. Type conversion** ‚Äî –º–µ–∂–¥—É —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º–∏ —Ç–∏–ø–∞–º–∏:
```go
var i int = 42
var f float64 = float64(i)  // —è–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
var s string = string(rune(i)) // int to rune to string

// –ú–µ–∂–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º–∏ —Ç–∏–ø–∞–º–∏
type UserId int
type ProductId int

var uid UserId = 123
var pid ProductId = ProductId(uid) // —è–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
```

### 12. –ß—Ç–æ —Ç–∞–∫–æ–µ struct embedding?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Struct embedding –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤—Å—Ç—Ä–∞–∏–≤–∞—Ç—å –æ–¥–∏–Ω struct –≤ –¥—Ä—É–≥–æ–π, –ø–æ–ª—É—á–∞—è –µ–≥–æ –ø–æ–ª—è –∏ –º–µ—Ç–æ–¥—ã –Ω–∞–ø—Ä—è–º—É—é (–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –≤–º–µ—Å—Ç–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è).

```go
type Person struct {
    Name string
    Age  int
}

func (p Person) Greet() string {
    return fmt.Sprintf("Hi, I'm %s", p.Name)
}

type Employee struct {
    Person   // –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ
    Position string
    Salary   int
}

func (e Employee) Work() string {
    return fmt.Sprintf("%s is working as %s", e.Name, e.Position)
}

func example() {
    emp := Employee{
        Person:   Person{Name: "John", Age: 30},
        Position: "Developer",
        Salary:   100000,
    }
    
    // –î–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    fmt.Println(emp.Name)      // –Ω–∞–ø—Ä—è–º—É—é
    fmt.Println(emp.Person.Name) // —á–µ—Ä–µ–∑ —è–≤–Ω–æ–µ —É–∫–∞–∑–∞–Ω–∏–µ
    
    // –î–æ—Å—Ç—É–ø –∫ –º–µ—Ç–æ–¥–∞–º
    fmt.Println(emp.Greet())   // –º–µ—Ç–æ–¥ Person
    fmt.Println(emp.Work())    // –º–µ—Ç–æ–¥ Employee
}
```

### 13. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –º–µ—Ç–æ–¥–∞–º–∏ —Å value –∏ pointer receiver?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Value receiver** ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –∫–æ–ø–∏–µ–π:
- –ù–µ –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
- –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –∫–æ–ø–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è read-only –æ–ø–µ—Ä–∞—Ü–∏–π

**Pointer receiver** ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–æ–º:
- –ú–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
- –ë–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
- –û–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –º–µ—Ç–æ–¥–æ–≤, –∏–∑–º–µ–Ω—è—é—â–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–µ

```go
type Counter struct {
    count int
}

// Value receiver - –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª
func (c Counter) GetCount() int {
    return c.count
}

// Pointer receiver - –∏–∑–º–µ–Ω—è–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª
func (c *Counter) Increment() {
    c.count++
}

func (c *Counter) Reset() {
    c.count = 0
}

func example() {
    counter := Counter{count: 5}
    
    fmt.Println(counter.GetCount()) // 5
    counter.Increment()
    fmt.Println(counter.GetCount()) // 6
    
    // Go –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –º–µ–∂–¥—É & –∏ *
    counterPtr := &counter
    counterPtr.Increment() // —Ç–æ –∂–µ, —á—Ç–æ (*counterPtr).Increment()
}
```

### 14. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤ Go –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ:

**1. Package-level –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ** –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è –≤ –ø–æ—Ä—è–¥–∫–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
**2. init() —Ñ—É–Ω–∫—Ü–∏–∏** –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
**3. main() —Ñ—É–Ω–∫—Ü–∏—è** –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ main –ø–∞–∫–µ—Ç–µ

```go
// –ü–æ—Ä—è–¥–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
var (
    a = b + c  // 3-–π
    b = f()    // 2-–π  
    c = 1      // 1-–π
)

func f() int { return c + 1 }

func init() {
    // init —Ñ—É–Ω–∫—Ü–∏–π –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ
    fmt.Println("First init")
}

func init() {
    fmt.Println("Second init")
}

func main() {
    fmt.Println("main function")
}

// –ü–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:
// 1. c = 1
// 2. b = f() = 2
// 3. a = b + c = 3
// 4. First init
// 5. Second init
// 6. main function
```

### 15. –ß—Ç–æ —Ç–∞–∫–æ–µ type alias –∏ type definition?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Type alias** —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –∏–º—è –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–∏–ø–∞:
**Type definition** —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Ç–∏–ø –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ:

```go
// Type alias - –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–∑–∞–∏–º–æ–∑–∞–º–µ–Ω—è–µ–º—ã
type StringAlias = string
type IntAlias = int

// Type definition - –Ω–æ–≤—ã–µ —Ç–∏–ø—ã
type UserId int
type ProductId int
type Email string

func processUser(id UserId) { /* ... */ }
func processProduct(id ProductId) { /* ... */ }

func example() {
    // Alias - –≤–∑–∞–∏–º–æ–∑–∞–º–µ–Ω—è–µ–º—ã
    var s string = "hello"
    var sa StringAlias = s  // OK
    s = sa                  // OK
    
    // Definition - —Ç—Ä–µ–±—É–µ—Ç —è–≤–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
    var userId UserId = 123
    var productId ProductId = 456
    
    // userId = productId        // Error!
    userId = UserId(productId)   // OK - —è–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
    
    // –ú–µ—Ç–æ–¥—ã –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–æ–ª—å–∫–æ –∫ –Ω–æ–≤—ã–º —Ç–∏–ø–∞–º
    func (e Email) IsValid() bool {
        return strings.Contains(string(e), "@")
    }
}
```

### 16. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–í–∞—Ä–∏–∞—Ç–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏–Ω–∏–º–∞—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞:

```go
// –û–±—ä—è–≤–ª–µ–Ω–∏–µ –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
func sum(nums ...int) int {
    total := 0
    for _, num := range nums {
        total += num
    }
    return total
}

func printf(format string, args ...interface{}) {
    fmt.Printf(format, args...)
}

func example() {
    // –†–∞–∑–ª–∏—á–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –≤—ã–∑–æ–≤–∞
    fmt.Println(sum())           // 0
    fmt.Println(sum(1))          // 1
    fmt.Println(sum(1, 2, 3))    // 6
    
    // –ü–µ—Ä–µ–¥–∞—á–∞ —Å–ª–∞–π—Å–∞
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println(sum(numbers...)) // 15
    
    // –°–º–µ—à–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    printf("Name: %s, Age: %d\n", "John", 30)
}

// –†–µ–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏–∑ –∫–æ–¥–∞
func logWithFields(message string, fields ...interface{}) {
    logger := getLogger()
    logger.WithFields(fields...).Info(message)
}
```

### 17. –ß—Ç–æ —Ç–∞–∫–æ–µ blank identifier `_`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Blank identifier `_` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –Ω—É–∂–Ω—ã:

```go
// –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
_, err := fmt.Printf("Hello, World!")
if err != nil {
    return err
}

// –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ range
for _, value := range slice {
    process(value) // –∏–Ω–¥–µ–∫—Å –Ω–µ –Ω—É–∂–µ–Ω
}

for index := range slice {
    processIndex(index) // –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ
}

// –ò–º–ø–æ—Ä—Ç –ø–∞–∫–µ—Ç–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è init()
import _ "database/sql/driver"

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
var _ io.Writer = (*bytes.Buffer)(nil)

// –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–µ–π –≤ struct
type Config struct {
    Host     string
    Port     int
    _        struct{} // –∑–∞–ø—Ä–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª–µ–π
    Password string
}
```

### 18. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –±–ª–æ—á–Ω—É—é –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏ –ø—Ä–∞–≤–∏–ª–æ —ç–∫—Å–ø–æ—Ä—Ç–∞:

**–£—Ä–æ–≤–Ω–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏:**
1. **Universe scope** ‚Äî –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏
2. **Package scope** ‚Äî –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω—è –ø–∞–∫–µ—Ç–∞
3. **File scope** ‚Äî –∏–º–ø–æ—Ä—Ç—ã
4. **Function scope** ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
5. **Block scope** ‚Äî –≤–Ω—É—Ç—Ä–∏ `{}`

**–≠–∫—Å–ø–æ—Ä—Ç:** –∑–∞–≥–ª–∞–≤–Ω–∞—è –±—É–∫–≤–∞ –¥–µ–ª–∞–µ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø—É–±–ª–∏—á–Ω—ã–º

```go
package example

// –ü—É–±–ª–∏—á–Ω—ã–µ (—ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã–µ)
var PublicVar = "visible outside package"
type PublicStruct struct {
    PublicField    string
    privateField   int  // –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ –ø–æ–ª–µ
}

func PublicFunction() {}

// –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ
var privateVar = "only in package"
func privateFunction() {}

func scopeExample() {
    var functionVar = "function scope"
    
    for i := 0; i < 10; i++ {
        var blockVar = "block scope"
        
        if i > 5 {
            var nestedBlockVar = "nested block"
            // –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –∑–¥–µ—Å—å
        }
        // nestedBlockVar –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∑–¥–µ—Å—å
    }
    // i –∏ blockVar –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –∑–¥–µ—Å—å
}
```

### 19. –û–±—ä—è—Å–Ω–∏—Ç–µ –ø–æ–Ω—è—Ç–∏–µ "shadowing" –≤ Go

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Shadowing –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –∫–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏ "–∑–∞—Ç–µ–Ω—è–µ—Ç" –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é —Å —Ç–µ–º –∂–µ –∏–º–µ–Ω–µ–º –∏–∑ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏:

```go
var global = "global variable"

func shadowingExample() {
    var local = "function variable"
    
    fmt.Println(global) // "global variable"
    
    {
        var global = "block variable" // –∑–∞—Ç–µ–Ω—è–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—É—é
        var local = "inner block"     // –∑–∞—Ç–µ–Ω—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é
        
        fmt.Println(global) // "block variable"
        fmt.Println(local)  // "inner block"
    }
    
    fmt.Println(global) // "global variable" (—Å–Ω–æ–≤–∞ –¥–æ—Å—Ç—É–ø–Ω–∞)
    fmt.Println(local)  // "function variable"
}

// –û–ø–∞—Å–Ω–æ–µ shadowing —Å –∫–æ—Ä–æ—Ç–∫–∏–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ–º
func dangerousShadowing() error {
    var err error
    
    if condition {
        data, err := readData() // err –∑–∞—Ç–µ–Ω–µ–Ω–∞!
        process(data)
        // –ª–æ–∫–∞–ª—å–Ω–∞—è err –∏—Å—á–µ–∑–∞–µ—Ç –∑–¥–µ—Å—å
    }
    
    return err // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é err (nil)
}

// –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
func correctVersion() error {
    var err error
    
    if condition {
        var data []byte
        data, err = readData() // –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é err
        process(data)
    }
    
    return err
}
```

### 20. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `iota`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
`iota` ‚Äî –ø—Ä–µ–¥–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç:

```go
// –ü—Ä–æ—Å—Ç–æ–π —Å—á–µ—Ç—á–∏–∫
const (
    Sunday = iota  // 0
    Monday         // 1
    Tuesday        // 2
    Wednesday      // 3
)

// –ü—Ä–æ–ø—É—Å–∫ –∑–Ω–∞—á–µ–Ω–∏–π
const (
    _ = iota      // 0 (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º)
    KB = 1 << (10 * iota) // 1024
    MB                    // 1048576
    GB                    // 1073741824
)

// –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const (
    Read = 1 << iota   // 1 (001)
    Write              // 2 (010)
    Execute            // 4 (100)
)

// –°–±—Ä–æ—Å iota –≤ –Ω–æ–≤–æ–º –±–ª–æ–∫–µ const
const (
    Apple = iota   // 0
    Orange         // 1
)

const (
    Red = iota     // 0 (—Å–±—Ä–æ—Å)
    Green          // 1
    Blue           // 2
)

// –°–ª–æ–∂–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
const (
    First = iota * 2 + 1  // 1
    Second                // 3
    Third                 // 5
)

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ
type Status int

const (
    StatusPending Status = iota
    StatusRunning
    StatusCompleted
    StatusFailed
)

func (s Status) String() string {
    names := []string{"Pending", "Running", "Completed", "Failed"}
    if s < 0 || int(s) >= len(names) {
        return "Unknown"
    }
    return names[s]
}
```

---

## üìä –†–∞–∑–¥–µ–ª 2: –ú–∞—Å—Å–∏–≤—ã, —Å–ª–∞–π—Å—ã, –º–∞–ø—ã (–û—Ç–≤–µ—Ç—ã 21-35)

### 21. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –º–∞—Å—Å–∏–≤–æ–º –∏ —Å–ª–∞–π—Å–æ–º?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**–ú–∞—Å—Å–∏–≤:**
- –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, —á–∞—Å—Ç—å —Ç–∏–ø–∞
- –ü–µ—Ä–µ–¥–∞–µ—Ç—Å—è –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é (–∫–æ–ø–∏—Ä—É–µ—Ç—Å—è)
- –†–∞–∑–º–µ—Ä –∏–∑–≤–µ—Å—Ç–µ–Ω –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –•—Ä–∞–Ω–∏—Ç—Å—è –≤ —Å—Ç–µ–∫–µ (–µ—Å–ª–∏ –Ω–µ–±–æ–ª—å—à–æ–π)

**–°–ª–∞–π—Å:**
- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä
- –ü–µ—Ä–µ–¥–∞–µ—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ (—É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã–µ)
- –†–∞–∑–º–µ—Ä –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å—Å—è –≤ runtime
- –°—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –º–∞—Å—Å–∏–≤ –≤ heap

```go
// –ú–∞—Å—Å–∏–≤—ã
var arr1 [5]int                    // –º–∞—Å—Å–∏–≤ –∏–∑ 5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
var arr2 [10]int                   // –¥—Ä—É–≥–æ–π —Ç–∏–ø!
// arr1 = arr2                     // Error: —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã

func modifyArray(arr [5]int) {
    arr[0] = 100 // –∏–∑–º–µ–Ω—è–µ—Ç –∫–æ–ø–∏—é
}

// –°–ª–∞–π—Å—ã
var slice1 []int                   // nil slice
var slice2 = make([]int, 5)        // slice –¥–ª–∏–Ω–æ–π 5
var slice3 = []int{1, 2, 3}        // slice –ª–∏—Ç–µ—Ä–∞–ª

func modifySlice(s []int) {
    s[0] = 100 // –∏–∑–º–µ–Ω—è–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
}

func example() {
    arr := [3]int{1, 2, 3}
    slice := []int{1, 2, 3}
    
    modifyArray(arr)   // arr –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è
    modifySlice(slice) // slice[0] == 100
}
```

### 22. –ö–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω —Å–ª–∞–π—Å –≤–Ω—É—Ç—Ä–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–°–ª–∞–π—Å —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Ç—Ä–µ—Ö –ø–æ–ª–µ–π:
- **ptr** ‚Äî —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã–µ –≤ –º–∞—Å—Å–∏–≤–µ
- **len** ‚Äî —Ç–µ–∫—É—â–∞—è –¥–ª–∏–Ω–∞ —Å–ª–∞–π—Å–∞
- **cap** ‚Äî –µ–º–∫–æ—Å—Ç—å (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –±–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏)

```go
// –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–ª–∞–π—Å–∞
type slice struct {
    array unsafe.Pointer // —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã–µ
    len   int            // –¥–ª–∏–Ω–∞
    cap   int            // –µ–º–∫–æ—Å—Ç—å
}

func sliceInternals() {
    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–∞–π—Å–∞
    s := make([]int, 3, 5) // len=3, cap=5
    s = []int{1, 2, 3}
    
    fmt.Printf("len=%d cap=%d\n", len(s), cap(s))
    
    // –ü–æ–¥—Å–ª–∞–π—Å—ã —Ä–∞–∑–¥–µ–ª—è—é—Ç –¥–∞–Ω–Ω—ã–µ
    s1 := s[1:3]  // {2, 3}, len=2, cap=4
    s2 := s[:2]   // {1, 2}, len=2, cap=5
    
    s1[0] = 100   // –∏–∑–º–µ–Ω—è–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤
    fmt.Println(s) // [1, 100, 3]
}

// –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
func visualizeSlice() {
    arr := [8]int{0, 1, 2, 3, 4, 5, 6, 7}
    slice := arr[2:5]
    
    // slice —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ arr[2:5]
    // ptr -> arr[2]
    // len = 3 (—ç–ª–µ–º–µ–Ω—Ç—ã 2, 3, 4)
    // cap = 6 (–¥–æ –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞)
}
```

### 23. –ß—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –≤ —ç—Ç–æ–º –∫–æ–¥–µ?

```go
s1 := []int{1, 2, 3}
s2 := s1[1:2]
s2[0] = 999
fmt.Println(s1) // —á—Ç–æ –≤—ã–≤–µ–¥–µ—Ç?
```

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–í—ã–≤–µ–¥–µ—Ç `[1 999 3]`, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å–ª–∞–π—Å—ã —Ä–∞–∑–¥–µ–ª—è—é—Ç –æ–¥–∏–Ω –±–∞–∑–æ–≤—ã–π –º–∞—Å—Å–∏–≤.

```go
func sliceSharing() {
    s1 := []int{1, 2, 3}
    s2 := s1[1:2]    // s2 = [2], –Ω–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ s1[1]
    
    // –ò–∑–º–µ–Ω–µ–Ω–∏–µ s2 –≤–ª–∏—è–µ—Ç –Ω–∞ s1
    s2[0] = 999
    fmt.Println(s1)  // [1 999 3]
    fmt.Println(s2)  // [999]
    
    // –ö–∞–∫ –∏–∑–±–µ–∂–∞—Ç—å:
    s3 := make([]int, len(s2))
    copy(s3, s2)     // s3 - –Ω–µ–∑–∞–≤–∏—Å–∏–º–∞—è –∫–æ–ø–∏—è
    s3[0] = 777
    fmt.Println(s1)  // [1 999 3] (–Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è)
    fmt.Println(s3)  // [777]
}

// –ï—â–µ –æ–¥–∏–Ω –ø—Ä–∏–º–µ—Ä
func appendDanger() {
    original := []int{1, 2, 3, 4, 5}
    sub := original[0:3]  // [1, 2, 3], cap=5
    
    sub = append(sub, 999) // –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç original[3]
    fmt.Println(original)  // [1 2 3 999 5]
}
```

### 24. –ö–æ–≥–¥–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è —Å–ª–∞–π—Å–∞?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–†–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø—Ä–∏ `append`, –∫–æ–≥–¥–∞ `len` –ø—Ä–µ–≤—ã—à–∞–µ—Ç `cap`:

**–°—Ç—Ä–∞—Ç–µ–≥–∏—è —Ä–æ—Å—Ç–∞:**
- –ü—Ä–∏ cap < 1024: —É–¥–≤–∞–∏–≤–∞–Ω–∏–µ
- –ü—Ä–∏ cap >= 1024: —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –Ω–∞ 25%

```go
func reallocationDemo() {
    var s []int
    
    for i := 0; i < 20; i++ {
        oldCap := cap(s)
        s = append(s, i)
        newCap := cap(s)
        
        if newCap != oldCap {
            fmt.Printf("Reallocation: %d -> %d\n", oldCap, newCap)
        }
    }
    // –í—ã–≤–æ–¥: 0 -> 1, 1 -> 2, 2 -> 4, 4 -> 8, 8 -> 16
}

// –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
func efficientAppend() {
    // –ü–ª–æ—Ö–æ: –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
    var s []int
    for i := 0; i < 1000; i++ {
        s = append(s, i) // —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑
    }
    
    // –•–æ—Ä–æ—à–æ: –∑–∞—Ä–∞–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω–∞ –µ–º–∫–æ—Å—Ç—å
    s2 := make([]int, 0, 1000) // cap=1000
    for i := 0; i < 1000; i++ {
        s2 = append(s2, i) // –±–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
}

// –ü–æ—Ç–µ—Ä—è —Å—Å—ã–ª–∫–∏ –ø—Ä–∏ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
func reallocationProblem() {
    s1 := make([]int, 0, 2)
    s1 = append(s1, 1, 2)
    
    s2 := s1        // s2 —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ—Ç –∂–µ –º–∞—Å—Å–∏–≤
    s1 = append(s1, 3) // —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è! s1 —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤
    
    s2[0] = 999     // –∏–∑–º–µ–Ω—è–µ—Ç —Å—Ç–∞—Ä—ã–π –º–∞—Å—Å–∏–≤
    fmt.Println(s1) // [1 2 3] (–Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è)
    fmt.Println(s2) // [999 2]
}
```

### 25. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å–ª–∞–π—Å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ï—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–æ—Å–æ–±–æ–≤ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ª–∞–π—Å–æ–≤:

```go
func copySlice() {
    src := []int{1, 2, 3, 4, 5}
    
    // –°–ø–æ—Å–æ–± 1: copy() - —Å–∞–º—ã–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π
    dst1 := make([]int, len(src))
    copy(dst1, src)
    
    // –°–ø–æ—Å–æ–± 2: append —Å nil
    dst2 := append([]int(nil), src...)
    
    // –°–ø–æ—Å–æ–± 3: append —Å –ø—É—Å—Ç—ã–º —Å–ª–∞–π—Å–æ–º
    dst3 := append([]int{}, src...)
    
    // –°–ø–æ—Å–æ–± 4: range (–º–µ–Ω–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ)
    dst4 := make([]int, len(src))
    for i, v := range src {
        dst4[i] = v
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
    dst1[0] = 999
    fmt.Println(src)  // [1 2 3 4 5] (–Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è)
    fmt.Println(dst1) // [999 2 3 4 5]
}

// –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥—Å–ª–∞–π—Å–∞
func copySubslice() {
    src := []int{1, 2, 3, 4, 5}
    
    // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∞—Å—Ç–∏
    sub := make([]int, 3)
    copy(sub, src[1:4]) // –∫–æ–ø–∏—Ä—É–µ—Ç [2, 3, 4]
    
    // copy –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    n := copy(sub, src)
    fmt.Printf("Copied %d elements\n", n)
}

// –ì–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–∞–π—Å–∞ —Å–ª–∞–π—Å–æ–≤
func deepCopySliceOfSlices() {
    src := [][]int{
        {1, 2}, {3, 4}, {5, 6},
    }
    
    dst := make([][]int, len(src))
    for i, inner := range src {
        dst[i] = append([]int(nil), inner...)
    }
}
```

### 26. –ß—Ç–æ —Ç–∞–∫–æ–µ nil slice –∏ empty slice? –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**Nil slice:**
- –ù–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –º–∞—Å—Å–∏–≤
- len=0, cap=0
- –†–∞–≤–µ–Ω nil

**Empty slice:**
- –£–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
- len=0, cap –º–æ–∂–µ—Ç –±—ã—Ç—å > 0
- –ù–µ —Ä–∞–≤–µ–Ω nil

```go
func nilVsEmpty() {
    // Nil slice
    var nilSlice []int
    
    // Empty slices
    emptySlice1 := []int{}
    emptySlice2 := make([]int, 0)
    emptySlice3 := make([]int, 0, 5)
    
    fmt.Printf("nilSlice: %v, len=%d, cap=%d, nil=%t\n", 
        nilSlice, len(nilSlice), cap(nilSlice), nilSlice == nil)
    // nilSlice: [], len=0, cap=0, nil=true
    
    fmt.Printf("emptySlice1: %v, len=%d, cap=%d, nil=%t\n",
        emptySlice1, len(emptySlice1), cap(emptySlice1), emptySlice1 == nil)
    // emptySlice1: [], len=0, cap=0, nil=false
    
    // –í—Å–µ –≤–µ–¥—É—Ç —Å–µ–±—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ –ø—Ä–∏ append
    nilSlice = append(nilSlice, 1)
    emptySlice1 = append(emptySlice1, 1)
    
    // JSON –º–∞—Ä—à–∞–ª–∏–Ω–≥ —Ä–∞–∑–ª–∏—á–∞–µ—Ç—Å—è
    nilJSON, _ := json.Marshal(nilSlice)     // "null"
    emptyJSON, _ := json.Marshal(emptySlice1) // "[]"
}

// –ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
func preferredPatterns() {
    // –î–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –ø—É—Å—Ç–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ nil
    func getUsers() []User {
        if noUsers {
            return nil // –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ return []User{}
        }
        return users
    }
    
    // –î–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –∏–∑–≤–µ—Å—Ç–Ω–æ–π –µ–º–∫–æ—Å—Ç—å—é
    items := make([]Item, 0, expectedSize)
}
```

### 27. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `append` —Å–æ —Å–ª–∞–π—Å–∞–º–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
`append` –¥–æ–±–∞–≤–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –≤ –∫–æ–Ω–µ—Ü —Å–ª–∞–π—Å–∞, –≤–æ–∑–≤—Ä–∞—â–∞—è –Ω–æ–≤—ã–π —Å–ª–∞–π—Å:

```go
func appendBehavior() {
    // –ë–∞–∑–æ–≤–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    slice := []int{1, 2, 3}
    slice = append(slice, 4, 5)        // [1, 2, 3, 4, 5]
    slice = append(slice, []int{6, 7}...) // —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ —Å–ª–∞–π—Å–∞
    
    // append –≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ–≤—ã–π —Å–ª–∞–π—Å (–º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ—Ç –∂–µ –±–∞–∑–æ–≤—ã–π –º–∞—Å—Å–∏–≤)
    original := make([]int, 3, 10) // len=3, cap=10
    original[0], original[1], original[2] = 1, 2, 3
    
    result := append(original, 4) // –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–æ—Ç –∂–µ –º–∞—Å—Å–∏–≤
    fmt.Printf("Same array: %t\n", &original[0] == &result[0]) // true
    
    // –ö–æ–≥–¥–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è
    small := []int{1, 2}
    fmt.Printf("Before: cap=%d\n", cap(small)) // cap=2
    
    small = append(small, 3) // —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏—è
    fmt.Printf("After: cap=%d\n", cap(small))  // cap=4
}

// Append –∫ nil slice
func appendToNil() {
    var slice []int // nil slice
    slice = append(slice, 1, 2, 3) // —Ä–∞–±–æ—Ç–∞–µ—Ç!
    fmt.Println(slice) // [1, 2, 3]
}

// –û–ø–∞—Å–Ω–æ—Å—Ç–∏ append
func appendDangers() {
    // –ü—Ä–æ–±–ª–µ–º–∞ 1: –ø–æ—Ç–µ—Ä—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –ø—Ä–∏ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
    func modifySlice(s []int) {
        s = append(s, 999) // –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤
        s[0] = 777         // –∏–∑–º–µ–Ω—è–µ—Ç –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
    }
    
    slice := []int{1, 2, 3}
    modifySlice(slice)
    fmt.Println(slice) // [1, 2, 3] - –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è
    
    // –†–µ—à–µ–Ω–∏–µ: –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Å–ª–∞–π—Å
    func correctModify(s []int) []int {
        s = append(s, 999)
        s[0] = 777
        return s
    }
}

// –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ append
func efficientAppend() {
    // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
    result := make([]int, 0, expectedSize)
    for _, item := range items {
        result = append(result, process(item))
    }
    
    // Batch append
    var batch []int
    for _, item := range items {
        batch = append(batch, item)
        if len(batch) >= batchSize {
            processBatch(batch)
            batch = batch[:0] // —Å–±—Ä–æ—Å –¥–ª–∏–Ω—ã, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–º–∫–æ—Å—Ç—å
        }
    }
}
```

### 28. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ª–∞–π—Å–∞?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ï—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —É–¥–∞–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤:

```go
// –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –ø–æ—Ä—è–¥–∫–∞
func removeWithOrder(slice []int, index int) []int {
    if index < 0 || index >= len(slice) {
        return slice
    }
    return append(slice[:index], slice[index+1:]...)
}

// –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ (–±—ã—Å—Ç—Ä–µ–µ)
func removeSwapLast(slice []int, index int) []int {
    if index < 0 || index >= len(slice) {
        return slice
    }
    slice[index] = slice[len(slice)-1] // –∑–∞–º–µ–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–º
    return slice[:len(slice)-1]        // —É–±–∏—Ä–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π
}

// –£–¥–∞–ª–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
func removeRange(slice []int, start, end int) []int {
    return append(slice[:start], slice[end:]...)
}

// –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é
func removeValue(slice []int, value int) []int {
    for i, v := range slice {
        if v == value {
            return removeWithOrder(slice, i)
        }
    }
    return slice
}

// –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –≤—Ö–æ–∂–¥–µ–Ω–∏–π –∑–Ω–∞—á–µ–Ω–∏—è
func removeAllValues(slice []int, value int) []int {
    result := slice[:0] // –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π –º–∞—Å—Å–∏–≤
    for _, v := range slice {
        if v != value {
            result = append(result, v)
        }
    }
    return result
}

// –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º
func filter(slice []int, predicate func(int) bool) []int {
    result := slice[:0]
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

func example() {
    nums := []int{1, 2, 3, 4, 5, 3, 6}
    
    // –£–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É 2
    nums = removeWithOrder(nums, 2) // [1, 2, 4, 5, 3, 6]
    
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ç—Ä–æ–π–∫–∏
    nums = removeAllValues(nums, 3) // [1, 2, 4, 5, 6]
    
    // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —á–µ—Ç–Ω—ã–µ
    nums = filter(nums, func(n int) bool { return n%2 == 0 })
}
```

### 29. –ß—Ç–æ —Ç–∞–∫–æ–µ string slicing –∏ –∫–∞–∫ –æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–°—Ç—Ä–æ–∫–∏ –≤ Go –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã –∏ —Å–æ—Å—Ç–æ—è—Ç –∏–∑ –±–∞–π—Ç–æ–≤ UTF-8. String slicing —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É:

```go
func stringSlicing() {
    s := "Hello, ‰∏ñÁïå"
    
    // –°–ª–∞–π—Å–∏–Ω–≥ –ø–æ –±–∞–π—Ç–∞–º
    sub := s[0:5]   // "Hello" (5 –±–∞–π—Ç)
    sub = s[7:]     // "‰∏ñÁïå" (6 –±–∞–π—Ç - –ø–æ 3 –±–∞–π—Ç–∞ –Ω–∞ —Å–∏–º–≤–æ–ª)
    
    // –û—Å—Ç–æ—Ä–æ–∂–Ω–æ —Å Unicode!
    fmt.Println(len(s))           // 13 (–±–∞–π—Ç)
    fmt.Println(utf8.RuneCountInString(s)) // 9 (—Å–∏–º–≤–æ–ª–æ–≤)
    
    // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ: –º–æ–∂–µ—Ç —Ä–∞–∑—Ä–µ–∑–∞—Ç—å UTF-8 —Å–∏–º–≤–æ–ª
    // bad := s[7:8] // –º–æ–∂–µ—Ç –¥–∞—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π UTF-8
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å Unicode
    runes := []rune(s)
    unicodeSafe := string(runes[7:9]) // "‰∏ñÁïå"
}

// –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏
func stringOperations() {
    // –ö–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è - –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    result := ""
    for _, word := range words {
        result += word + " " // —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É –∫–∞–∂–¥—ã–π —Ä–∞–∑
    }
    
    // –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ: strings.Builder
    var builder strings.Builder
    for _, word := range words {
        builder.WriteString(word)
        builder.WriteString(" ")
    }
    result = builder.String()
    
    // –ò–ª–∏ strings.Join
    result = strings.Join(words, " ")
}

// –ü–æ–∏—Å–∫ –ø–æ–¥—Å—Ç—Ä–æ–∫
func stringSearch() {
    text := "The quick brown fox"
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ—Ñ–∏–∫—Å–∞/—Å—É—Ñ—Ñ–∏–∫—Å–∞
    if strings.HasPrefix(text, "The") {
        fmt.Println("Starts with 'The'")
    }
    
    // –ü–æ–∏—Å–∫ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏
    if index := strings.Index(text, "quick"); index != -1 {
        fmt.Printf("Found 'quick' at position %d\n", index)
    }
    
    // –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ
    words := strings.Split(text, " ")
    fmt.Println(words) // ["The", "quick", "brown", "fox"]
}
```

### 30. –ö–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω—ã –º–∞–ø—ã –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ú–∞–ø—ã –≤ Go —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã —Å –æ—Ç–∫—Ä—ã—Ç–æ–π –∞–¥—Ä–µ—Å–∞—Ü–∏–µ–π:

**–í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ:**
- Bucket-based —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
- –ö–∞–∂–¥—ã–π bucket —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–æ 8 key-value –ø–∞—Ä
- –ü—Ä–∏ –∫–æ–ª–ª–∏–∑–∏—è—Ö –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è overflow buckets
- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞

```go
// –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
type hmap struct {
    count     int    // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    flags     uint8  // —Ñ–ª–∞–≥–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    B         uint8  // log_2 —á–∏—Å–ª–∞ buckets
    noverflow uint16 // overflow buckets
    hash0     uint32 // seed –¥–ª—è hash —Ñ—É–Ω–∫—Ü–∏–∏
    buckets   unsafe.Pointer // –º–∞—Å—Å–∏–≤ buckets
    oldbuckets unsafe.Pointer // –¥–ª—è incremental resizing
}

type bmap struct {
    tophash [bucketCnt]uint8  // –≤—ã—Å—à–∏–µ 8 –±–∏—Ç —Ö–µ—à–µ–π
    // keys –∏ values —Ö—Ä–∞–Ω—è—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
    keys   [bucketCnt]keytype
    values [bucketCnt]valuetype
    overflow *bmap            // —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ overflow bucket
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
func mapOperations() {
    // –†–∞–∑–ª–∏—á–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —Å–æ–∑–¥–∞–Ω–∏—è
    var m1 map[string]int                    // nil map
    m2 := make(map[string]int)               // –ø—É—Å—Ç–∞—è map
    m3 := make(map[string]int, 100)          // —Å –Ω–∞—á–∞–ª—å–Ω–æ–π –µ–º–∫–æ—Å—Ç—å—é
    m4 := map[string]int{"a": 1, "b": 2}     // map literal
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–ª—é—á–∞
    value, ok := m2["key"]
    if ok {
        fmt.Printf("Value: %d\n", value)
    }
}
```

### 31. –ß—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É –∫–ª—é—á—É?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ü—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É –∫–ª—é—á—É –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è zero value —Ç–∏–ø–∞ –∑–Ω–∞—á–µ–Ω–∏—è:

```go
func mapAccess() {
    m := map[string]int{"a": 1, "b": 2}
    
    // –û–±—Ä–∞—â–µ–Ω–∏–µ –∫ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É –∫–ª—é—á—É
    value := m["c"]        // 0 (zero value –¥–ª—è int)
    fmt.Println(value)     // 0
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
    value, ok := m["c"]
    if ok {
        fmt.Printf("Found: %d\n", value)
    } else {
        fmt.Println("Key not found")
    }
    
    // –†–∞–∑–ª–∏—á–∏–µ –º–µ–∂–¥—É "–∫–ª—é—á –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" –∏ "–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–≤–Ω–æ zero value"
    m["zero"] = 0
    
    fmt.Println(m["zero"])     // 0
    fmt.Println(m["missing"])  // 0 —Ç–æ–∂–µ!
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    if val, exists := m["zero"]; exists {
        fmt.Printf("Key exists with value: %d\n", val)
    }
    
    if val, exists := m["missing"]; exists {
        fmt.Printf("Key exists with value: %d\n", val)
    } else {
        fmt.Println("Key does not exist")
    }
}

// –†–∞–±–æ—Ç–∞ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏
func differentValueTypes() {
    // –î–ª—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
    m1 := make(map[string]*int)
    ptr := m1["missing"] // nil
    
    // –î–ª—è —Å–ª–∞–π—Å–æ–≤
    m2 := make(map[string][]int)
    slice := m2["missing"] // nil slice
    
    // –î–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä
    type User struct { Name string; Age int }
    m3 := make(map[string]User)
    user := m3["missing"] // User{Name: "", Age: 0}
}
```

### 32. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–∞ –≤ –º–∞–ø–µ?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Go –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∏–¥–∏–æ–º—É "comma ok" –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–ª—é—á–µ–π:

```go
func keyExistence() {
    m := map[string]int{
        "exists": 42,
        "zero":   0,
    }
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è
    if value, ok := m["exists"]; ok {
        fmt.Printf("Key exists: %d\n", value)
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è
    if _, ok := m["exists"]; ok {
        fmt.Println("Key exists")
    }
    
    // –£–¥–∞–ª–µ–Ω–∏–µ –∫–ª—é—á–∞
    delete(m, "exists")
    if _, ok := m["exists"]; !ok {
        fmt.Println("Key deleted")
    }
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –ø—Ä–æ–≤–µ—Ä–∫–∏
func checkPatterns() {
    cache := make(map[string]string)
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    if value, found := cache["key"]; found {
        return value
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –¥–ª—è –ª–æ–≥–∏–∫–∏
    _, userExists := users["john"]
    _, adminExists := admins["john"]
    
    if userExists && !adminExists {
        promoteToAdmin("john")
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    if _, ok := config["timeout"]; !ok {
        config["timeout"] = "30s"
    }
}

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –∫–∞—Ä—Ç–∞–º–∏
func nestedMaps() {
    data := make(map[string]map[string]int)
    
    // –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ
    // data["outer"]["inner"] = 42 // panic –µ—Å–ª–∏ data["outer"] == nil
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ
    if inner, ok := data["outer"]; ok {
        inner["inner"] = 42
    } else {
        data["outer"] = map[string]int{"inner": 42}
    }
    
    // –ï—â–µ –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ —Å helper —Ñ—É–Ω–∫—Ü–∏–µ–π
    func setNested(outer, inner string, value int) {
        if data[outer] == nil {
            data[outer] = make(map[string]int)
        }
        data[outer][inner] = value
    }
}
```

### 33. –ü–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã –ª–∏ –º–∞–ø—ã –≤ Go?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–û–±—ã—á–Ω—ã–µ –º–∞–ø—ã –≤ Go –ù–ï –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã. –û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ –∏ –∑–∞–ø–∏—Å—å –≤—ã–∑—ã–≤–∞–µ—Ç fatal error:

```go
// –ù–ï–ë–ï–ó–û–ü–ê–°–ù–û: –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å fatal error
func unsafeMapAccess() {
    m := make(map[int]int)
    
    // Goroutine 1: –∑–∞–ø–∏—Å—å
    go func() {
        for i := 0; i < 1000; i++ {
            m[i] = i
        }
    }()
    
    // Goroutine 2: —á—Ç–µ–Ω–∏–µ
    go func() {
        for i := 0; i < 1000; i++ {
            _ = m[i]
        }
    }()
    
    time.Sleep(time.Second)
    // –ú–æ–∂–µ—Ç –≤—ã–≤–µ—Å—Ç–∏: fatal error: concurrent map read and map write
}

// –†–µ—à–µ–Ω–∏–µ 1: Mutex
type SafeMap struct {
    mu sync.RWMutex
    m  map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        m: make(map[string]int),
    }
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    val, ok := sm.m[key]
    return val, ok
}

func (sm *SafeMap) Set(key string, val int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.m[key] = val
}

func (sm *SafeMap) Delete(key string) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    delete(sm.m, key)
}

// –†–µ—à–µ–Ω–∏–µ 2: sync.Map (–¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤)
func syncMapExample() {
    var sm sync.Map
    
    // –ó–∞–ø–∏—Å—å
    sm.Store("key", "value")
    
    // –ß—Ç–µ–Ω–∏–µ
    if value, ok := sm.Load("key"); ok {
        fmt.Printf("Value: %v\n", value)
    }
    
    // –£–¥–∞–ª–µ–Ω–∏–µ
    sm.Delete("key")
    
    // –ò—Ç–µ—Ä–∞—Ü–∏—è
    sm.Range(func(key, value interface{}) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true // –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é
    })
}

// –†–µ—à–µ–Ω–∏–µ 3: –ö–∞–Ω–∞–ª—ã –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏
func channelBasedMap() {
    type MapOp struct {
        key    string
        value  int
        result chan int
        op     string // "get", "set", "delete"
    }
    
    ops := make(chan MapOp)
    
    // Map manager goroutine
    go func() {
        m := make(map[string]int)
        for op := range ops {
            switch op.op {
            case "get":
                op.result <- m[op.key]
            case "set":
                m[op.key] = op.value
                close(op.result)
            case "delete":
                delete(m, op.key)
                close(op.result)
            }
        }
    }()
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    getFromMap := func(key string) int {
        result := make(chan int)
        ops <- MapOp{key: key, result: result, op: "get"}
        return <-result
    }
}
```

### 34. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –º–∞–ø–µ?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ –º–∞–ø–µ –≤ Go –∏–º–µ–µ—Ç –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:

```go
func mapIteration() {
    m := map[string]int{
        "apple":  5,
        "banana": 3,
        "cherry": 8,
    }
    
    // –ë–∞–∑–æ–≤–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è (–ø–æ—Ä—è–¥–æ–∫ –ù–ï –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω!)
    for key, value := range m {
        fmt.Printf("%s: %d\n", key, value)
    }
    
    // –¢–æ–ª—å–∫–æ –∫–ª—é—á–∏
    for key := range m {
        fmt.Printf("Key: %s\n", key)
    }
    
    // –¢–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏—è
    for _, value := range m {
        fmt.Printf("Value: %d\n", value)
    }
}

// –°–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
func sortedIteration() {
    m := map[string]int{
        "zebra": 1, "apple": 2, "banana": 3,
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á–∏ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
    keys := make([]string, 0, len(m))
    for key := range m {
        keys = append(keys, key)
    }
    sort.Strings(keys)
    
    // –ò—Ç–µ—Ä–∏—Ä—É–µ–º—Å—è –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    for _, key := range keys {
        fmt.Printf("%s: %d\n", key, m[key])
    }
}

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
func safeModification() {
    m := map[string]int{"a": 1, "b": 2, "c": 3}
    
    // –ù–ï–ë–ï–ó–û–ü–ê–°–ù–û: –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
    // for key := range m {
    //     if key == "b" {
    //         delete(m, key) // –º–æ–∂–µ—Ç –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã
    //     }
    // }
    
    // –ë–ï–ó–û–ü–ê–°–ù–û: —Å–æ–±–∏—Ä–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    var toDelete []string
    for key, value := range m {
        if value%2 == 0 {
            toDelete = append(toDelete, key)
        }
    }
    
    // –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
    for _, key := range toDelete {
        delete(m, key)
    }
}

// –ò—Ç–µ—Ä–∞—Ü–∏—è —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º
func controlledIteration() {
    m := map[string]int{
        "one": 1, "two": 2, "three": 3, "four": 4,
    }
    
    // –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
    found := false
    for key, value := range m {
        if value == 3 {
            fmt.Printf("Found: %s\n", key)
            found = true
            break
        }
    }
    
    // –ü–æ–¥—Å—á–µ—Ç –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
    count := 0
    sum := 0
    for _, value := range m {
        count++
        sum += value
        if count >= 2 { // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
            break
        }
    }
}

// –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞–ø—ã
func parallelProcessing() {
    m := map[string]int{
        "task1": 1, "task2": 2, "task3": 3,
    }
    
    var wg sync.WaitGroup
    
    for key, value := range m {
        wg.Add(1)
        go func(k string, v int) {
            defer wg.Done()
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
            processItem(k, v)
        }(key, value) // –≤–∞–∂–Ω–æ: –∫–æ–ø–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
    }
    
    wg.Wait()
}
```

### 35. –í —á–µ–º –ø—Ä–æ–±–ª–µ–º–∞ —ç—Ç–æ–≥–æ –∫–æ–¥–∞?

```go
var m map[string]int
m["key"] = 1 // runtime panic!
```

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ nil map –≤—ã–∑—ã–≤–∞–µ—Ç runtime panic:

```go
func mapInitialization() {
    // –ü—Ä–æ–±–ª–µ–º–∞: nil map
    var m map[string]int
    fmt.Printf("m == nil: %t\n", m == nil) // true
    
    // –ß—Ç–µ–Ω–∏–µ –∏–∑ nil map –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç zero value
    value := m["key"] // 0, –Ω–æ –Ω–µ panic
    fmt.Printf("Reading from nil map: %d\n", value)
    
    // –ó–∞–ø–∏—Å—å –≤ nil map –≤—ã–∑—ã–≤–∞–µ—Ç panic
    // m["key"] = 1 // panic: assignment to entry in nil map
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    m = make(map[string]int)
    m["key"] = 1 // OK
    
    // –ò–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –ª–∏—Ç–µ—Ä–∞–ª–æ–º
    m2 := map[string]int{}
    m2["key"] = 1 // OK
    
    // –ò–ª–∏ —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    m3 := map[string]int{"key": 1}
    fmt.Println(m3["key"]) // 1
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ–π —Ä–∞–±–æ—Ç—ã
func safeMapPatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: lazy initialization
    var cache map[string]string
    
    func getFromCache(key string) string {
        if cache == nil {
            cache = make(map[string]string)
        }
        return cache[key]
    }
    
    func setToCache(key, value string) {
        if cache == nil {
            cache = make(map[string]string)
        }
        cache[key] = value
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ –Ω–∞—á–∞–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏
    func processMap(m map[string]int) error {
        if m == nil {
            return errors.New("map cannot be nil")
        }
        
        for key, value := range m {
            process(key, value)
        }
        return nil
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: —Å–æ–∑–¥–∞–Ω–∏–µ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ
    type Config struct {
        settings map[string]string
    }
    
    func NewConfig() *Config {
        return &Config{
            settings: make(map[string]string),
        }
    }
    
    func (c *Config) Set(key, value string) {
        c.settings[key] = value // –±–µ–∑–æ–ø–∞—Å–Ω–æ
    }
}

// –†–∞–∑–ª–∏—á–∏—è –º–µ–∂–¥—É nil –∏ –ø—É—Å—Ç–æ–π map
func nilVsEmptyMap() {
    var nilMap map[string]int
    emptyMap := make(map[string]int)
    
    fmt.Printf("nil map len: %d\n", len(nilMap))     // 0
    fmt.Printf("empty map len: %d\n", len(emptyMap)) // 0
    
    // –ß—Ç–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –æ–±–æ–∏—Ö —Å–ª—É—á–∞—è—Ö
    fmt.Printf("nil map read: %d\n", nilMap["key"])     // 0
    fmt.Printf("empty map read: %d\n", emptyMap["key"]) // 0
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç
    _, ok1 := nilMap["key"]   // false
    _, ok2 := emptyMap["key"] // false
    
    // –ò—Ç–µ—Ä–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–≤–æ–¥–∏—Ç)
    for k, v := range nilMap {
        fmt.Printf("%s: %d\n", k, v) // –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
    }
    
    // –¢–æ–ª—å–∫–æ –∑–∞–ø–∏—Å—å –≤—ã–∑—ã–≤–∞–µ—Ç panic –¥–ª—è nil map
    // nilMap["key"] = 1    // panic!
    emptyMap["key"] = 1     // OK
}
```

---

## üöÄ –†–∞–∑–¥–µ–ª 3: Concurrency - –ì–æ—Ä—É—Ç–∏–Ω—ã –∏ –∫–∞–Ω–∞–ª—ã (–û—Ç–≤–µ—Ç—ã 36-55)

### 36. –ß—Ç–æ —Ç–∞–∫–æ–µ –≥–æ—Ä—É—Ç–∏–Ω—ã –∏ —á–µ–º –æ–Ω–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –æ—Ç –ø–æ—Ç–æ–∫–æ–≤ –û–°?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ì–æ—Ä—É—Ç–∏–Ω—ã ‚Äî —ç—Ç–æ –ª–µ–≥–∫–æ–≤–µ—Å–Ω—ã–µ –ø–æ—Ç–æ–∫–∏, —É–ø—Ä–∞–≤–ª—è–µ–º—ã–µ Go runtime:

**–û—Ç–ª–∏—á–∏—è –æ—Ç OS threads:**
- **–†–∞–∑–º–µ—Ä —Å—Ç–µ–∫–∞**: 2KB (vs 2MB –¥–ª—è OS thread)
- **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**: Go scheduler (vs OS scheduler)  
- **–°–æ–∑–¥–∞–Ω–∏–µ**: –æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ–µ (vs –º–µ–¥–ª–µ–Ω–Ω–æ–µ)
- **–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞**: –±—ã—Å—Ç—Ä–æ–µ (vs –º–µ–¥–ª–µ–Ω–Ω–æ–µ)
- **–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ**: –º–∏–ª–ª–∏–æ–Ω—ã (vs —Ç—ã—Å—è—á–∏)

```go
func goroutineBasics() {
    // –°–æ–∑–¥–∞–Ω–∏–µ –≥–æ—Ä—É—Ç–∏–Ω—ã
    go func() {
        fmt.Println("Hello from goroutine!")
    }()
    
    // –ì–æ—Ä—É—Ç–∏–Ω–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    name := "World"
    go func(n string) {
        fmt.Printf("Hello, %s!\n", n)
    }(name) // –≤–∞–∂–Ω–æ: –ø–µ—Ä–µ–¥–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
    
    // –û–ø–∞—Å–Ω–æ: –∑–∞—Ö–≤–∞—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Ü–∏–∫–ª–∞
    for i := 0; i < 3; i++ {
        go func() {
            fmt.Println(i) // –º–æ–∂–µ—Ç –≤—ã–≤–µ—Å—Ç–∏ 3, 3, 3
        }()
    }
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–æ
    for i := 0; i < 3; i++ {
        go func(id int) {
            fmt.Println(id) // –≤—ã–≤–µ–¥–µ—Ç 0, 1, 2
        }(i)
    }
    
    time.Sleep(time.Second) // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω
}

// –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª –≥–æ—Ä—É—Ç–∏–Ω—ã
func goroutineLifecycle() {
    // –ì–æ—Ä—É—Ç–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞:
    // 1. –§—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ
    // 2. –ü—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç panic (—É–±–∏–≤–∞–µ—Ç –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É)
    // 3. main —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è (—É–±–∏–≤–∞–µ—Ç –≤—Å–µ –≥–æ—Ä—É—Ç–∏–Ω—ã)
    
    done := make(chan bool)
    
    go func() {
        defer func() {
            done <- true // —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
        }()
        
        // —Ä–∞–±–æ—Ç–∞ –≥–æ—Ä—É—Ç–∏–Ω—ã
        time.Sleep(500 * time.Millisecond)
        fmt.Println("Goroutine finished")
    }()
    
    <-done // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    fmt.Println("Main finished")
}

// –ì–æ—Ä—É—Ç–∏–Ω—ã vs OS threads –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
func performanceComparison() {
    // –°–æ–∑–¥–∞–Ω–∏–µ –º–∏–ª–ª–∏–æ–Ω–∞ –≥–æ—Ä—É—Ç–∏–Ω (–≤–æ–∑–º–æ–∂–Ω–æ)
    const numGoroutines = 1000000
    var wg sync.WaitGroup
    
    start := time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
            _ = 1 + 1
        }()
    }
    
    wg.Wait()
    fmt.Printf("Created %d goroutines in %v\n", numGoroutines, time.Since(start))
    
    // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ–µ —Å OS threads –±—ã–ª–æ –±—ã –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ
}
```

### 37. –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–æ—Ä—É—Ç–∏–Ω—É?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ì–æ—Ä—É—Ç–∏–Ω—ã —Å–æ–∑–¥–∞—é—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ `go`:

```go
// –û—Å–Ω–æ–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —Å–æ–∑–¥–∞–Ω–∏—è
func createGoroutines() {
    // 1. –ê–Ω–æ–Ω–∏–º–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    go func() {
        fmt.Println("Anonymous goroutine")
    }()
    
    // 2. –ò–º–µ–Ω–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    go namedFunction()
    
    // 3. –ú–µ—Ç–æ–¥ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    worker := &Worker{id: 1}
    go worker.Process()
    
    // 4. –° –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    go processData("input", 42)
}

type Worker struct {
    id int
}

func (w *Worker) Process() {
    fmt.Printf("Worker %d processing\n", w.id)
}

func namedFunction() {
    fmt.Println("Named function goroutine")
}

func processData(input string, count int) {
    fmt.Printf("Processing %s %d times\n", input, count)
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –∑–∞–ø—É—Å–∫–∞ –≥–æ—Ä—É—Ç–∏–Ω
func goroutinePatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: Fire and forget
    go logEvent("User logged in")
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: Worker pool
    jobs := make(chan Job, 100)
    results := make(chan Result, 100)
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: –ö–æ–æ—Ä–¥–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            processTask(id)
        }(i)
    }
    wg.Wait()
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 4: –° –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –¥–ª—è –æ—Ç–º–µ–Ω—ã
    ctx, cancel := context.WithCancel(context.Background())
    go backgroundWorker(ctx)
    
    time.Sleep(5 * time.Second)
    cancel() // –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º worker
}

func worker(id int, jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        result := processJob(job)
        results <- result
    }
}

func backgroundWorker(ctx context.Context) {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            doWork()
        case <-ctx.Done():
            fmt.Println("Worker stopped")
            return
        }
    }
}
```

### 38. –ß—Ç–æ —Ç–∞–∫–æ–µ –∫–∞–Ω–∞–ª—ã –∏ –∫–∞–∫ –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ö–∞–Ω–∞–ª—ã ‚Äî —ç—Ç–æ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ conduits –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö –º–µ–∂–¥—É –≥–æ—Ä—É—Ç–∏–Ω–∞–º–∏, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–µ CSP (Communicating Sequential Processes):

```go
// –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤
func channelBasics() {
    // –ù–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
    ch1 := make(chan int)
    
    // –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
    ch2 := make(chan string, 10)
    
    // –¢–æ–ª—å–∫–æ –¥–ª—è —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏
    var readOnly <-chan int = ch1
    var writeOnly chan<- int = ch1
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ
    go func() {
        ch1 <- 42        // –æ—Ç–ø—Ä–∞–≤–∫–∞ (–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è)
        ch2 <- "hello"   // –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ –±—É—Ñ–µ—Ä
    }()
    
    value := <-ch1       // –ø–æ–ª—É—á–µ–Ω–∏–µ (–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –æ—Ç–ø—Ä–∞–≤–∫–∏)
    message := <-ch2     // –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –±—É—Ñ–µ—Ä–∞
    
    fmt.Printf("Received: %d, %s\n", value, message)
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã
func channelSynchronization() {
    done := make(chan bool)
    
    go func() {
        time.Sleep(2 * time.Second)
        fmt.Println("Work completed")
        done <- true // —Å–∏–≥–Ω–∞–ª –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    }()
    
    fmt.Println("Waiting for work to complete...")
    <-done // –±–ª–æ–∫–∏—Ä—É–µ–º—Å—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞
    fmt.Println("All done!")
}

// –ü–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö
func dataTransfer() {
    numbers := make(chan int, 5)
    results := make(chan int, 5)
    
    // Producer
    go func() {
        defer close(numbers)
        for i := 1; i <= 5; i++ {
            numbers <- i
        }
    }()
    
    // Processor
    go func() {
        defer close(results)
        for num := range numbers {
            results <- num * num // –≤–æ–∑–≤–æ–¥–∏–º –≤ –∫–≤–∞–¥—Ä–∞—Ç
        }
    }()
    
    // Consumer
    for result := range results {
        fmt.Printf("Result: %d\n", result)
    }
}

// –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
func nonBlockingOperations() {
    ch := make(chan int, 1)
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞
    select {
    case ch <- 42:
        fmt.Println("Sent successfully")
    default:
        fmt.Println("Channel full, couldn't send")
    }
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ
    select {
    case value := <-ch:
        fmt.Printf("Received: %d\n", value)
    default:
        fmt.Println("No data available")
    }
}
```

### 39. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º–∏ –∏ –Ω–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º–∏ –∫–∞–Ω–∞–ª–∞–º–∏?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**

**–ù–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª:**
- –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö
- –û—Ç–ø—Ä–∞–≤–∫–∞ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è
- –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –æ—Ç–ø—Ä–∞–≤–∫–∏
- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é

**–ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª:**
- –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ (–¥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –±—É—Ñ–µ—Ä–∞)
- –û—Ç–ø—Ä–∞–≤–∫–∞ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–æ–ª–Ω–æ–º –±—É—Ñ–µ—Ä–µ
- –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø—É—Å—Ç–æ–º –±—É—Ñ–µ—Ä–µ

```go
func bufferingComparison() {
    // –ù–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π - —Ç—Ä–µ–±—É–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
    unbuffered := make(chan int)
    
    go func() {
        fmt.Println("Sending to unbuffered...")
        unbuffered <- 1 // –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è
        fmt.Println("Sent to unbuffered")
    }()
    
    time.Sleep(100 * time.Millisecond) // –≥–æ—Ä—É—Ç–∏–Ω–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞
    value := <-unbuffered // —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É
    fmt.Printf("Received from unbuffered: %d\n", value)
    
    // –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π - –ø–æ–∑–≤–æ–ª—è–µ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å
    buffered := make(chan int, 2)
    
    fmt.Println("Sending to buffered...")
    buffered <- 1 // –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è
    buffered <- 2 // –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è
    fmt.Println("Sent to buffered (no blocking)")
    
    // buffered <- 3 // –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–æ—Å—å –±—ã (–±—É—Ñ–µ—Ä –ø–æ–ª–æ–Ω)
    
    fmt.Printf("Received: %d\n", <-buffered)
    fmt.Printf("Received: %d\n", <-buffered)
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
func bufferPerformance() {
    const numMessages = 1000000
    
    // –ù–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π - –º–µ–¥–ª–µ–Ω–Ω–µ–µ
    start := time.Now()
    unbuffered := make(chan int)
    
    go func() {
        for i := 0; i < numMessages; i++ {
            unbuffered <- i
        }
        close(unbuffered)
    }()
    
    for range unbuffered {
        // –æ–±—Ä–∞–±–æ—Ç–∫–∞
    }
    unbufferedTime := time.Since(start)
    
    // –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π - –±—ã—Å—Ç—Ä–µ–µ
    start = time.Now()
    buffered := make(chan int, 1000) // –±—É—Ñ–µ—Ä —É–º–µ–Ω—å—à–∞–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
    
    go func() {
        for i := 0; i < numMessages; i++ {
            buffered <- i
        }
        close(buffered)
    }()
    
    for range buffered {
        // –æ–±—Ä–∞–±–æ—Ç–∫–∞
    }
    bufferedTime := time.Since(start)
    
    fmt.Printf("Unbuffered: %v, Buffered: %v\n", unbufferedTime, bufferedTime)
}

// –°–µ–º–∞–Ω—Ç–∏–∫–∞ –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–∏
func bufferSemantics() {
    // –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ = 0 (–Ω–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π)
    sync := make(chan int)    // –∫–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
    
    // –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ = 1 (—Å–µ–º–∞—Ñ–æ—Ä)
    semaphore := make(chan int, 1) // –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ
    
    // –†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ > 1 (–æ—á–µ—Ä–µ–¥—å)
    queue := make(chan int, 10)    // –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å 10 –∑–Ω–∞—á–µ–Ω–∏–π
    
    // –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    
    // –°–µ–º–∞—Ñ–æ—Ä –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞
    semaphore <- 1 // –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Ä–µ—Å—É—Ä—Å
    // –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
    <-semaphore    // –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Ä–µ—Å—É—Ä—Å
    
    // –û—á–µ—Ä–µ–¥—å –¥–ª—è batch –æ–±—Ä–∞–±–æ—Ç–∫–∏
    for i := 0; i < 5; i++ {
        queue <- i // –∑–∞–ø–æ–ª–Ω—è–µ–º –æ—á–µ—Ä–µ–¥—å
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º batch
    for i := 0; i < 5; i++ {
        item := <-queue
        process(item)
    }
}
```

### 40. –ö–∞–∫ –∑–∞–∫—Ä—ã—Ç—å –∫–∞–Ω–∞–ª –∏ –∑–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–æ–ª—É—á–∞—Ç–µ–ª—è–º, —á—Ç–æ –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –±—É–¥–µ—Ç:

```go
func channelClosing() {
    // –û—Å–Ω–æ–≤—ã –∑–∞–∫—Ä—ã—Ç–∏—è
    ch := make(chan int, 2)
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    ch <- 1
    ch <- 2
    
    // –ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞
    close(ch) // —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –∑–∞–∫—Ä—ã–≤–∞—Ç—å –∫–∞–Ω–∞–ª
    
    // –ß—Ç–µ–Ω–∏–µ –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    v1 := <-ch          // 1 (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ —á—Ç–µ–Ω–∏–µ)
    v2 := <-ch          // 2 (–Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ —á—Ç–µ–Ω–∏–µ)
    v3 := <-ch          // 0 (zero value)
    v4, ok := <-ch      // 0, false (–∫–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç –∏ –ø—É—Å—Ç)
    
    fmt.Printf("Values: %d, %d, %d, %d (ok=%t)\n", v1, v2, v3, v4, ok)
}

// –ó–∞—á–µ–º –Ω—É–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç–∏–µ
func whyClose() {
    // 1. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ range —Ü–∏–∫–ª–∞
    numbers := make(chan int)
    
    go func() {
        defer close(numbers) // –≤–∞–∂–Ω–æ: –∑–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª
        for i := 1; i <= 5; i++ {
            numbers <- i
        }
    }()
    
    // range –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –∫–æ–≥–¥–∞ –∫–∞–Ω–∞–ª –∑–∞–∫—Ä–æ–µ—Ç—Å—è
    for num := range numbers {
        fmt.Printf("Number: %d\n", num)
    }
    
    // 2. –°–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏—è –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã
    done := make(chan struct{})
    
    go func() {
        defer close(done) // —Å–∏–≥–Ω–∞–ª –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
        // –≤—ã–ø–æ–ª–Ω—è–µ–º —Ä–∞–±–æ—Ç—É
        time.Sleep(time.Second)
    }()
    
    <-done // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    
    // 3. Graceful shutdown
    quit := make(chan struct{})
    
    go func() {
        // —Ä–∞–±–æ—á–∏–π —Ü–∏–∫–ª
        for {
            select {
            case <-quit:
                fmt.Println("Worker stopping...")
                return
            default:
                // —Ä–∞–±–æ—Ç–∞
                time.Sleep(100 * time.Millisecond)
            }
        }
    }()
    
    time.Sleep(500 * time.Millisecond)
    close(quit) // —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å –∑–∞–∫—Ä—ã—Ç–∏–µ–º
func closingPatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: Fan-out —Å –∑–∞–∫—Ä—ã—Ç–∏–µ–º
    input := make(chan int)
    output1 := make(chan int)
    output2 := make(chan int)
    
    // Fan-out worker
    go func() {
        defer close(output1)
        defer close(output2)
        
        for value := range input {
            output1 <- value
            output2 <- value * 2
        }
    }()
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏ –∑–∞–∫—Ä—ã–≤–∞–µ–º
    go func() {
        defer close(input)
        for i := 1; i <= 3; i++ {
            input <- i
        }
    }()
    
    // –ß–∏—Ç–∞–µ–º –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
    for v := range output1 {
        fmt.Printf("Output1: %d\n", v)
    }
    
    for v := range output2 {
        fmt.Printf("Output2: %d\n", v)
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: Pipeline —Å –∑–∞–∫—Ä—ã—Ç–∏–µ–º
    stage1 := make(chan int)
    stage2 := make(chan int)
    
    // Stage 1
    go func() {
        defer close(stage1)
        for i := 1; i <= 5; i++ {
            stage1 <- i
        }
    }()
    
    // Stage 2
    go func() {
        defer close(stage2)
        for num := range stage1 {
            stage2 <- num * num
        }
    }()
    
    // Final consumer
    for result := range stage2 {
        fmt.Printf("Final result: %d\n", result)
    }
}

// –û—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
func closingErrors() {
    ch := make(chan int)
    
    // –û—à–∏–±–∫–∞ 1: –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª
    close(ch)
    // ch <- 1 // panic: send on closed channel
    
    // –û—à–∏–±–∫–∞ 2: –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ
    // close(ch) // panic: close of closed channel
    
    // –û—à–∏–±–∫–∞ 3: –∑–∞–∫—Ä—ã—Ç–∏–µ nil –∫–∞–Ω–∞–ª–∞
    var nilCh chan int
    // close(nilCh) // panic: close of nil channel
    
    // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
    func safeSend(ch chan<- int, value int) (sent bool) {
        defer func() {
            if recover() != nil {
                sent = false
            }
        }()
        
        ch <- value
        return true
    }
}
```

### 41. –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
–ß—Ç–µ–Ω–∏–µ –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –∏–º–µ–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é —Å–µ–º–∞–Ω—Ç–∏–∫—É:

```go
func readFromClosedChannel() {
    ch := make(chan int, 3)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
    ch <- 1
    ch <- 2
    ch <- 3
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª
    close(ch)
    
    // –ß–∏—Ç–∞–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –¥–∞–Ω–Ω—ã–µ
    fmt.Println(<-ch) // 1
    fmt.Println(<-ch) // 2
    fmt.Println(<-ch) // 3
    
    // –ß–∏—Ç–∞–µ–º –∏–∑ –ø—É—Å—Ç–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    fmt.Println(<-ch) // 0 (zero value –¥–ª—è int)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–Ω–∞–ª–∞
    value, ok := <-ch
    fmt.Printf("Value: %d, OK: %t\n", value, ok) // Value: 0, OK: false
}

// –†–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –∏ zero values
func zeroValuesFromClosed() {
    // –î–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ zero values —Ä–∞–∑–ª–∏—á–∞—é—Ç—Å—è
    intCh := make(chan int)
    close(intCh)
    fmt.Printf("int: %d\n", <-intCh) // 0
    
    stringCh := make(chan string)
    close(stringCh)
    fmt.Printf("string: '%s'\n", <-stringCh) // ""
    
    boolCh := make(chan bool)
    close(boolCh)
    fmt.Printf("bool: %t\n", <-boolCh) // false
    
    sliceCh := make(chan []int)
    close(sliceCh)
    slice := <-sliceCh
    fmt.Printf("slice: %v (nil: %t)\n", slice, slice == nil) // [] (nil: true)
    
    ptrCh := make(chan *int)
    close(ptrCh)
    ptr := <-ptrCh
    fmt.Printf("pointer: %v (nil: %t)\n", ptr, ptr == nil) // <nil> (nil: true)
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è
func safeReadingPatterns() {
    ch := make(chan int, 2)
    ch <- 1
    ch <- 2
    close(ch)
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å ok
    for {
        value, ok := <-ch
        if !ok {
            fmt.Println("Channel closed")
            break
        }
        fmt.Printf("Value: %d\n", value)
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: range (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏)
    ch2 := make(chan int, 2)
    ch2 <- 10
    ch2 <- 20
    close(ch2)
    
    for value := range ch2 {
        fmt.Printf("Range value: %d\n", value)
    }
    // —Ü–∏–∫–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: select —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
    ch3 := make(chan int)
    close(ch3)
    
    select {
    case value, ok := <-ch3:
        if ok {
            fmt.Printf("Received: %d\n", value)
        } else {
            fmt.Println("Channel closed in select")
        }
    default:
        fmt.Println("No data available")
    }
}

// –û—Ç–ª–∏—á–∏–µ –æ—Ç nil –∫–∞–Ω–∞–ª–∞
func closedVsNilChannel() {
    // Nil –∫–∞–Ω–∞–ª
    var nilCh chan int
    
    // –ó–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª
    closedCh := make(chan int)
    close(closedCh)
    
    // –ü–æ–≤–µ–¥–µ–Ω–∏–µ –≤ select
    select {
    case <-nilCh:
        fmt.Println("Nil channel") // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
    case <-closedCh:
        fmt.Println("Closed channel") // –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
    case <-time.After(100 * time.Millisecond):
        fmt.Println("Timeout")
    }
    
    // –í —Ü–∏–∫–ª–µ
    // for range nilCh {} // –∑–∞–≤–∏—Å–Ω–µ—Ç –Ω–∞–≤—Å–µ–≥–¥–∞
    for range closedCh {} // –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: drain channel
func drainChannel() {
    ch := make(chan int, 10)
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–∞–Ω–∞–ª
    for i := 0; i < 5; i++ {
        ch <- i
    }
    close(ch)
    
    // –ü–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–∞–µ–º –∫–∞–Ω–∞–ª
    func drain(ch <-chan int) {
        for {
            select {
            case _, ok := <-ch:
                if !ok {
                    return // –∫–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç –∏ –ø—É—Å—Ç
                }
                // –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–ª–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
            default:
                return // –∫–∞–Ω–∞–ª –ø—É—Å—Ç
            }
        }
    }
    
    drain(ch)
    fmt.Println("Channel drained")
}
```

### 42. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `select` statement?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
`select` –ø–æ–∑–≤–æ–ª—è–µ—Ç –≥–æ—Ä—É—Ç–∏–Ω–µ –æ–∂–∏–¥–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –∫–∞–Ω–∞–ª–∞–º–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ:

```go
func selectBasics() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(100 * time.Millisecond)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(200 * time.Millisecond)
        ch2 <- "from ch2"
    }()
    
    // select –≤—ã–±–µ—Ä–µ—Ç –ø–µ—Ä–≤—ã–π –≥–æ—Ç–æ–≤—ã–π case
    select {
    case msg1 := <-ch1:
        fmt.Println("Received:", msg1)
    case msg2 := <-ch2:
        fmt.Println("Received:", msg2)
    }
}

// –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å default
func nonBlockingSelect() {
    ch := make(chan string, 1)
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞
    select {
    case ch <- "hello":
        fmt.Println("Sent successfully")
    default:
        fmt.Println("Channel full")
    }
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–µ —á—Ç–µ–Ω–∏–µ
    select {
    case msg := <-ch:
        fmt.Println("Received:", msg)
    default:
        fmt.Println("No data available")
    }
}

// Timeout –ø–∞—Ç—Ç–µ—Ä–Ω
func timeoutPattern() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "slow response"
    }()
    
    select {
    case result := <-ch:
        fmt.Println("Got result:", result)
    case <-time.After(1 * time.Second):
        fmt.Println("Timeout!")
    }
}

// –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
func multipleOperations() {
    input := make(chan int)
    output := make(chan int)
    quit := make(chan bool)
    
    go func() {
        for i := 0; i < 5; i++ {
            input <- i
            time.Sleep(100 * time.Millisecond)
        }
        close(input)
    }()
    
    for {
        select {
        case value, ok := <-input:
            if !ok {
                fmt.Println("Input channel closed")
                return
            }
            output <- value * 2
            
        case result := <-output:
            fmt.Printf("Processed: %d\n", result)
            
        case <-quit:
            fmt.Println("Quitting...")
            return
            
        default:
            // –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω case –Ω–µ –≥–æ—Ç–æ–≤
            time.Sleep(10 * time.Millisecond)
        }
    }
}

// Select –≤ —Ü–∏–∫–ª–µ –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è
func selectMultiplexing() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    done := make(chan bool)
    
    // Producer 1
    go func() {
        for i := 0; i < 3; i++ {
            ch1 <- fmt.Sprintf("ch1-%d", i)
            time.Sleep(300 * time.Millisecond)
        }
        close(ch1)
    }()
    
    // Producer 2
    go func() {
        for i := 0; i < 3; i++ {
            ch2 <- fmt.Sprintf("ch2-%d", i)
            time.Sleep(500 * time.Millisecond)
        }
        close(ch2)
    }()
    
    // Multiplexer
    go func() {
        openChannels := 2
        for openChannels > 0 {
            select {
            case msg, ok := <-ch1:
                if ok {
                    fmt.Println("From ch1:", msg)
                } else {
                    ch1 = nil // –æ—Ç–∫–ª—é—á–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª
                    openChannels--
                }
            case msg, ok := <-ch2:
                if ok {
                    fmt.Println("From ch2:", msg)
                } else {
                    ch2 = nil // –æ—Ç–∫–ª—é—á–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª
                    openChannels--
                }
            }
        }
        done <- true
    }()
    
    <-done
}

// –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π select
func prioritySelect() {
    high := make(chan string, 10)
    low := make(chan string, 10)
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–∞–Ω–∞–ª—ã
    high <- "high priority 1"
    high <- "high priority 2"
    low <- "low priority 1"
    low <- "low priority 2"
    
    for {
        select {
        case msg := <-high:
            fmt.Println("HIGH:", msg)
        default:
            // –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ high –∫–∞–Ω–∞–ª –ø—É—Å—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º low
            select {
            case msg := <-low:
                fmt.Println("LOW:", msg)
            default:
                fmt.Println("No work available")
                return
            }
        }
    }
}

// Select —Å nil –∫–∞–Ω–∞–ª–∞–º–∏
func selectWithNilChannels() {
    var ch1, ch2 chan string
    
    // nil –∫–∞–Ω–∞–ª—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≥–æ—Ç–æ–≤—ã –≤ select
    select {
    case <-ch1: // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
        fmt.Println("ch1")
    case <-ch2: // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
        fmt.Println("ch2")
    default:
        fmt.Println("No channels ready") // –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
    }
    
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤
    active1, active2 := true, true
    
    for active1 || active2 {
        var c1, c2 chan string
        
        if active1 {
            c1 = make(chan string, 1)
            c1 <- "message1"
        }
        if active2 {
            c2 = make(chan string, 1)
            c2 <- "message2"
        }
        
        select {
        case msg := <-c1:
            fmt.Println("From c1:", msg)
            active1 = false
        case msg := <-c2:
            fmt.Println("From c2:", msg)
            active2 = false
        }
    }
}
```

### 43. –ß—Ç–æ —Ç–∞–∫–æ–µ channel directions?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Channel directions –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –∫–∞–Ω–∞–ª–∞–º–∏ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤:

```go
// –¢–∏–ø—ã –∫–∞–Ω–∞–ª–æ–≤ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é
func channelDirections() {
    // –î–≤—É–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
    bidir := make(chan int)
    
    // –¢–æ–ª—å–∫–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    var sendOnly chan<- int = bidir
    
    // –¢–æ–ª—å–∫–æ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è
    var receiveOnly <-chan int = bidir
    
    // sendOnly <- 42     // OK
    // receiveOnly <- 42  // Error: cannot send
    // <-sendOnly         // Error: cannot receive
    // <-receiveOnly      // OK
}

// –§—É–Ω–∫—Ü–∏–∏ —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –∫–∞–Ω–∞–ª–∞–º–∏
func producer(out chan<- int) {
    defer close(out)
    for i := 0; i < 5; i++ {
        out <- i
        time.Sleep(100 * time.Millisecond)
    }
}

func consumer(in <-chan int) {
    for value := range in {
        fmt.Printf("Consumed: %d\n", value)
    }
}

func pipeline() {
    numbers := make(chan int)
    
    go producer(numbers)  // –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å
    consumer(numbers)     // –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –ø–æ–ª—É—á–∞—Ç—å
}

// Pipeline —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
func processingPipeline() {
    // Stage 1: –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    func generate(out chan<- int) {
        defer close(out)
        for i := 1; i <= 10; i++ {
            out <- i
        }
    }
    
    // Stage 2: –æ–±—Ä–∞–±–æ—Ç–∫–∞
    func process(in <-chan int, out chan<- int) {
        defer close(out)
        for num := range in {
            out <- num * num
        }
    }
    
    // Stage 3: —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
    func filter(in <-chan int, out chan<- int) {
        defer close(out)
        for num := range in {
            if num%2 == 0 {
                out <- num
            }
        }
    }
    
    // –°–æ–∑–¥–∞–µ–º pipeline
    stage1 := make(chan int)
    stage2 := make(chan int)
    stage3 := make(chan int)
    
    go generate(stage1)
    go process(stage1, stage2)
    go filter(stage2, stage3)
    
    // –ß–∏—Ç–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    for result := range stage3 {
        fmt.Printf("Result: %d\n", result)
    }
}

// Fan-out/Fan-in –ø–∞—Ç—Ç–µ—Ä–Ω—ã
func fanPatterns() {
    // Fan-out: –æ–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫, –º–Ω–æ–≥–æ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π
    func fanOut(in <-chan int, out1, out2, out3 chan<- int) {
        defer close(out1)
        defer close(out2) 
        defer close(out3)
        
        for value := range in {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –ø–æ–ª—É—á–∞—Ç–µ–ª—è–º
            out1 <- value
            out2 <- value
            out3 <- value
        }
    }
    
    // Fan-in: –º–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤, –æ–¥–∏–Ω –ø–æ–ª—É—á–∞—Ç–µ–ª—å
    func fanIn(in1, in2, in3 <-chan int, out chan<- int) {
        var wg sync.WaitGroup
        
        sendFromChannel := func(ch <-chan int) {
            defer wg.Done()
            for value := range ch {
                out <- value
            }
        }
        
        wg.Add(3)
        go sendFromChannel(in1)
        go sendFromChannel(in2)
        go sendFromChannel(in3)
        
        go func() {
            wg.Wait()
            close(out)
        }()
    }
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
func channelConversion() {
    // –î–≤—É–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–∞–Ω–∞–ª –º–æ–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ –æ–¥–Ω–æ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π
    bidir := make(chan string)
    
    var sendOnly chan<- string = bidir  // OK
    var recvOnly <-chan string = bidir  // OK
    
    // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ
    // var bidir2 chan string = sendOnly // Error
    
    // –ù–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å type assertion (–Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ)
    // unsafeBidir := (chan string)(sendOnly) // –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ!
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: Worker pool
func workerPool() {
    type Job struct {
        ID   int
        Data string
    }
    
    type Result struct {
        JobID int
        Value string
    }
    
    // Worker —Ñ—É–Ω–∫—Ü–∏—è
    func worker(id int, jobs <-chan Job, results chan<- Result) {
        for job := range jobs {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á–∏
            result := Result{
                JobID: job.ID,
                Value: fmt.Sprintf("Processed by worker %d: %s", id, job.Data),
            }
            results <- result
        }
    }
    
    // –°–æ–∑–¥–∞–µ–º –∫–∞–Ω–∞–ª—ã
    jobs := make(chan Job, 100)
    results := make(chan Result, 100)
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º workers
    const numWorkers = 3
    for w := 1; w <= numWorkers; w++ {
        go worker(w, jobs, results) // jobs —Ç–æ–ª—å–∫–æ –¥–ª—è —á—Ç–µ–Ω–∏—è, results —Ç–æ–ª—å–∫–æ –¥–ª—è –∑–∞–ø–∏—Å–∏
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏
    go func() {
        defer close(jobs)
        for i := 1; i <= 10; i++ {
            jobs <- Job{ID: i, Data: fmt.Sprintf("job_%d", i)}
        }
    }()
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    for i := 0; i < 10; i++ {
        result := <-results
        fmt.Printf("Result: %+v\n", result)
    }
}
```

### 44. –ö–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å worker pool?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Worker pool ‚Äî —ç—Ç–æ –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –≤—ã–ø–æ–ª–Ω—è—é—â–∏—Ö—Å—è –∑–∞–¥–∞—á:

```go
// –ë–∞–∑–æ–≤—ã–π worker pool
func basicWorkerPool() {
    type Job struct {
        ID       int
        Payload  string
        Duration time.Duration
    }
    
    type Result struct {
        JobID     int
        Output    string
        Worker    int
        StartTime time.Time
        EndTime   time.Time
    }
    
    // Worker —Ñ—É–Ω–∫—Ü–∏—è
    worker := func(workerID int, jobs <-chan Job, results chan<- Result) {
        for job := range jobs {
            startTime := time.Now()
            
            // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
            time.Sleep(job.Duration)
            
            result := Result{
                JobID:     job.ID,
                Output:    fmt.Sprintf("Processed '%s'", job.Payload),
                Worker:    workerID,
                StartTime: startTime,
                EndTime:   time.Now(),
            }
            
            results <- result
        }
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ pool
    const numWorkers = 3
    const numJobs = 10
    
    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)
    
    // –ó–∞–ø—É—Å–∫ workers
    for w := 1; w <= numWorkers; w++ {
        go worker(w, jobs, results)
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–¥–∞—á
    for j := 1; j <= numJobs; j++ {
        job := Job{
            ID:       j,
            Payload:  fmt.Sprintf("task_%d", j),
            Duration: time.Duration(rand.Intn(1000)) * time.Millisecond,
        }
        jobs <- job
    }
    close(jobs)
    
    // –°–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    for r := 1; r <= numJobs; r++ {
        result := <-results
        fmt.Printf("Job %d completed by worker %d in %v\n",
            result.JobID, result.Worker, result.EndTime.Sub(result.StartTime))
    }
}

// –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π worker pool —Å graceful shutdown
func advancedWorkerPool() {
    type WorkerPool struct {
        workerCount int
        jobQueue    chan Job
        resultQueue chan Result
        quit        chan bool
        wg          sync.WaitGroup
    }
    
    func NewWorkerPool(workerCount, jobQueueSize int) *WorkerPool {
        return &WorkerPool{
            workerCount: workerCount,
            jobQueue:    make(chan Job, jobQueueSize),
            resultQueue: make(chan Result, jobQueueSize),
            quit:        make(chan bool),
        }
    }
    
    func (wp *WorkerPool) Start() {
        // –ó–∞–ø—É—Å–∫–∞–µ–º workers
        for i := 0; i < wp.workerCount; i++ {
            wp.wg.Add(1)
            go wp.worker(i + 1)
        }
    }
    
    func (wp *WorkerPool) worker(id int) {
        defer wp.wg.Done()
        
        for {
            select {
            case job := <-wp.jobQueue:
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á–∏
                startTime := time.Now()
                time.Sleep(job.Duration) // –∏–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
                
                result := Result{
                    JobID:     job.ID,
                    Output:    fmt.Sprintf("Worker %d processed: %s", id, job.Payload),
                    Worker:    id,
                    StartTime: startTime,
                    EndTime:   time.Now(),
                }
                
                select {
                case wp.resultQueue <- result:
                case <-wp.quit:
                    return
                }
                
            case <-wp.quit:
                return
            }
        }
    }
    
    func (wp *WorkerPool) Submit(job Job) bool {
        select {
        case wp.jobQueue <- job:
            return true
        case <-wp.quit:
            return false
        default:
            return false // queue full
        }
    }
    
    func (wp *WorkerPool) Results() <-chan Result {
        return wp.resultQueue
    }
    
    func (wp *WorkerPool) Stop() {
        close(wp.quit)
        wp.wg.Wait()
        close(wp.resultQueue)
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    pool := NewWorkerPool(3, 10)
    pool.Start()
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏
    go func() {
        for i := 1; i <= 5; i++ {
            job := Job{
                ID:       i,
                Payload:  fmt.Sprintf("task_%d", i),
                Duration: 500 * time.Millisecond,
            }
            if !pool.Submit(job) {
                fmt.Printf("Failed to submit job %d\n", i)
            }
        }
    }()
    
    // –ß–∏—Ç–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    go func() {
        for result := range pool.Results() {
            fmt.Printf("Completed: %s\n", result.Output)
        }
    }()
    
    time.Sleep(3 * time.Second)
    pool.Stop()
}

// Worker pool —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
func contextWorkerPool() {
    type ContextJob struct {
        ctx context.Context
        Job
    }
    
    worker := func(ctx context.Context, id int, jobs <-chan ContextJob, results chan<- Result) {
        for {
            select {
            case job := <-jobs:
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏
                select {
                case <-job.ctx.Done():
                    fmt.Printf("Worker %d: job %d cancelled\n", id, job.ID)
                    continue
                default:
                }
                
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –æ—Ç–º–µ–Ω—ã
                done := make(chan Result, 1)
                go func() {
                    time.Sleep(job.Duration)
                    done <- Result{
                        JobID:  job.ID,
                        Output: fmt.Sprintf("Worker %d completed job %d", id, job.ID),
                        Worker: id,
                    }
                }()
                
                select {
                case result := <-done:
                    results <- result
                case <-job.ctx.Done():
                    fmt.Printf("Worker %d: job %d cancelled during execution\n", id, job.ID)
                case <-ctx.Done():
                    return
                }
                
            case <-ctx.Done():
                return
            }
        }
    }
    
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    jobs := make(chan ContextJob, 10)
    results := make(chan Result, 10)
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º workers
    for i := 1; i <= 2; i++ {
        go worker(ctx, i, jobs, results)
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º–∏
    for i := 1; i <= 3; i++ {
        jobCtx := ctx
        if i == 2 {
            // –ó–∞–¥–∞—á–∞ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            var jobCancel context.CancelFunc
            jobCtx, jobCancel = context.WithTimeout(ctx, 100*time.Millisecond)
            defer jobCancel()
        }
        
        jobs <- ContextJob{
            ctx: jobCtx,
            Job: Job{
                ID:       i,
                Payload:  fmt.Sprintf("task_%d", i),
                Duration: 200 * time.Millisecond,
            },
        }
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    time.Sleep(time.Second)
}

// –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π worker pool
func dynamicWorkerPool() {
    type DynamicPool struct {
        minWorkers    int
        maxWorkers    int
        currentWorkers int
        jobQueue      chan Job
        resultQueue   chan Result
        workerQueue   chan chan Job
        quit          chan bool
        mu            sync.RWMutex
    }
    
    func (dp *DynamicPool) addWorker() {
        dp.mu.Lock()
        defer dp.mu.Unlock()
        
        if dp.currentWorkers < dp.maxWorkers {
            go dp.worker()
            dp.currentWorkers++
            fmt.Printf("Added worker, current: %d\n", dp.currentWorkers)
        }
    }
    
    func (dp *DynamicPool) worker() {
        jobChannel := make(chan Job)
        
        defer func() {
            dp.mu.Lock()
            dp.currentWorkers--
            dp.mu.Unlock()
        }()
        
        for {
            // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º worker –∫–∞–∫ –¥–æ—Å—Ç—É–ø–Ω—ã–π
            dp.workerQueue <- jobChannel
            
            select {
            case job := <-jobChannel:
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Ä–∞–±–æ—Ç—É
                time.Sleep(job.Duration)
                dp.resultQueue <- Result{
                    JobID:  job.ID,
                    Output: fmt.Sprintf("Processed job %d", job.ID),
                }
                
            case <-dp.quit:
                return
            }
        }
    }
    
    func (dp *DynamicPool) dispatcher() {
        for {
            select {
            case job := <-dp.jobQueue:
                // –ò—â–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ worker
                select {
                case workerChannel := <-dp.workerQueue:
                    workerChannel <- job
                default:
                    // –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö workers, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–≥–æ
                    dp.addWorker()
                    workerChannel := <-dp.workerQueue
                    workerChannel <- job
                }
                
            case <-dp.quit:
                return
            }
        }
    }
}
```

### 45. –ß—Ç–æ —Ç–∞–∫–æ–µ deadlock –∏ –∫–∞–∫ –µ–≥–æ –∏–∑–±–µ–∂–∞—Ç—å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Deadlock ‚Äî –≤–∑–∞–∏–º–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≥–æ—Ä—É—Ç–∏–Ω, –æ–∂–∏–¥–∞—é—â–∏—Ö –¥—Ä—É–≥ –¥—Ä—É–≥–∞:

```go
// –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã deadlock
func deadlockExamples() {
    // –ü—Ä–∏–º–µ—Ä 1: –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –Ω–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–º –∫–∞–Ω–∞–ª–µ
    func simpleDeadlock() {
        ch := make(chan int)
        ch <- 1 // –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞, –Ω–µ—Ç –ø–æ–ª—É—á–∞—Ç–µ–ª—è
        // fatal error: all goroutines are asleep - deadlock!
    }
    
    // –ü—Ä–∏–º–µ—Ä 2: —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤
    func cyclicDeadlock() {
        ch1 := make(chan int)
        ch2 := make(chan int)
        
        go func() {
            ch1 <- 1  // –≥–æ—Ä—É—Ç–∏–Ω–∞ 1 –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤ ch1
            <-ch2     // –≥–æ—Ä—É—Ç–∏–Ω–∞ 1 –∂–¥–µ—Ç –∏–∑ ch2
        }()
        
        go func() {
            ch2 <- 2  // –≥–æ—Ä—É—Ç–∏–Ω–∞ 2 –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤ ch2
            <-ch1     // –≥–æ—Ä—É—Ç–∏–Ω–∞ 2 –∂–¥–µ—Ç –∏–∑ ch1
        }()
        
        time.Sleep(time.Second) // deadlock - –≥–æ—Ä—É—Ç–∏–Ω—ã –∂–¥—É—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞
    }
    
    // –ü—Ä–∏–º–µ—Ä 3: deadlock —Å –º—å—é—Ç–µ–∫—Å–∞–º–∏
    func mutexDeadlock() {
        var mu1, mu2 sync.Mutex
        
        go func() {
            mu1.Lock()
            time.Sleep(100 * time.Millisecond)
            mu2.Lock() // –∂–¥–µ—Ç mu2
            mu2.Unlock()
            mu1.Unlock()
        }()
        
        go func() {
            mu2.Lock()
            time.Sleep(100 * time.Millisecond)
            mu1.Lock() // –∂–¥–µ—Ç mu1
            mu1.Unlock()
            mu2.Unlock()
        }()
        
        time.Sleep(time.Second) // deadlock
    }
}

// –ú–µ—Ç–æ–¥—ã –∏–∑–±–µ–∂–∞–Ω–∏—è deadlock
func avoidDeadlock() {
    // –ú–µ—Ç–æ–¥ 1: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
    func useBufferedChannels() {
        ch := make(chan int, 1) // –±—É—Ñ–µ—Ä –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
        ch <- 1                 // –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è
        value := <-ch           // –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
        fmt.Println(value)
    }
    
    // –ú–µ—Ç–æ–¥ 2: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
    func consistentLockOrder() {
        var mu1, mu2 sync.Mutex
        
        lockInOrder := func(first, second *sync.Mutex) {
            first.Lock()
            defer first.Unlock()
            second.Lock()
            defer second.Unlock()
            // –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
        }
        
        go lockInOrder(&mu1, &mu2)
        go lockInOrder(&mu1, &mu2) // —Ç–æ—Ç –∂–µ –ø–æ—Ä—è–¥–æ–∫ - –Ω–µ—Ç deadlock
    }
    
    // –ú–µ—Ç–æ–¥ 3: timeout –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π
    func useTimeout() {
        ch := make(chan int)
        
        select {
        case ch <- 1:
            fmt.Println("Sent successfully")
        case <-time.After(100 * time.Millisecond):
            fmt.Println("Timeout - potential deadlock avoided")
        }
    }
    
    // –ú–µ—Ç–æ–¥ 4: –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å default
    func useDefault() {
        ch := make(chan int)
        
        select {
        case ch <- 1:
            fmt.Println("Sent successfully")
        default:
            fmt.Println("Channel not ready, doing something else")
        }
    }
}

// –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ deadlock –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
func deadlockDetection() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: –ø—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–∞–Ω–∞–ª–∞
    func isChannelReady(ch chan int) bool {
        select {
        case ch <- 0:
            <-ch // —É–±–∏—Ä–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            return true
        default:
            return false
        }
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≥–æ—Ä—É—Ç–∏–Ω
    func monitorGoroutines() {
        initial := runtime.NumGoroutine()
        
        // –∑–∞–ø—É—Å–∫–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é
        done := make(chan bool)
        go func() {
            defer func() { done <- true }()
            // –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è
            time.Sleep(100 * time.Millisecond)
        }()
        
        select {
        case <-done:
            fmt.Println("Operation completed")
        case <-time.After(500 * time.Millisecond):
            current := runtime.NumGoroutine()
            if current > initial {
                fmt.Printf("Potential deadlock: %d goroutines stuck\n", current-initial)
            }
        }
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: graceful shutdown —Å context
    func gracefulShutdown() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        
        // –û–ø–µ—Ä–∞—Ü–∏–∏ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –æ—Ç–º–µ–Ω—ã
        done := make(chan bool)
        
        go func() {
            defer func() { done <- true }()
            
            // –î–æ–ª–≥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π context
            for i := 0; i < 100; i++ {
                select {
                case <-ctx.Done():
                    fmt.Println("Operation cancelled")
                    return
                default:
                    time.Sleep(10 * time.Millisecond)
                }
            }
        }()
        
        select {
        case <-done:
            fmt.Println("Operation completed normally")
        case <-time.After(200 * time.Millisecond):
            fmt.Println("Operation taking too long, cancelling...")
            cancel()
            <-done // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Å–ª–µ –æ—Ç–º–µ–Ω—ã
        }
    }
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è deadlock –ø—Ä–æ–±–ª–µ–º
func practicalSolutions() {
    // –†–µ—à–µ–Ω–∏–µ 1: Producer-Consumer —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π
    func producerConsumer() {
        buffer := make(chan int, 10) // –±—É—Ñ–µ—Ä –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç deadlock
        
        // Producer
        go func() {
            defer close(buffer)
            for i := 0; i < 20; i++ {
                buffer <- i
            }
        }()
        
        // Consumer
        for value := range buffer {
            fmt.Printf("Consumed: %d\n", value)
            time.Sleep(10 * time.Millisecond)
        }
    }
    
    // –†–µ—à–µ–Ω–∏–µ 2: Coordinator –≥–æ—Ä—É—Ç–∏–Ω–∞
    func coordinator() {
        requests := make(chan string)
        responses := make(chan string)
        
        // Coordinator –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø—Ä—è–º—ã–µ deadlock –º–µ–∂–¥—É –∫–ª–∏–µ–Ω—Ç–∞–º–∏
        go func() {
            for request := range requests {
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
                response := fmt.Sprintf("Processed: %s", request)
                responses <- response
            }
            close(responses)
        }()
        
        // –ö–ª–∏–µ–Ω—Ç—ã
        go func() {
            requests <- "request1"
        }()
        
        go func() {
            requests <- "request2"
        }()
        
        close(requests)
        
        // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç—ã
        for response := range responses {
            fmt.Println(response)
        }
    }
    
    // –†–µ—à–µ–Ω–∏–µ 3: Resource pool
    func resourcePool() {
        type Resource struct {
            id int
        }
        
        pool := make(chan *Resource, 3)
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º pool
        for i := 1; i <= 3; i++ {
            pool <- &Resource{id: i}
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ä–µ—Å—É—Ä—Å–∞
        useResource := func(name string) {
            select {
            case resource := <-pool:
                fmt.Printf("%s acquired resource %d\n", name, resource.id)
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ—Å—É—Ä—Å
                time.Sleep(100 * time.Millisecond)
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ pool
                pool <- resource
                fmt.Printf("%s released resource %d\n", name, resource.id)
                
            case <-time.After(200 * time.Millisecond):
                fmt.Printf("%s: timeout acquiring resource\n", name)
            }
        }
        
        // –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        var wg sync.WaitGroup
        for i := 1; i <= 5; i++ {
            wg.Add(1)
            go func(id int) {
                defer wg.Done()
                useResource(fmt.Sprintf("User%d", id))
            }(i)
        }
        
        wg.Wait()
    }
}
```

### 46. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω fan-in/fan-out?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Fan-out —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ä–∞–±–æ—Ç—É –º–µ–∂–¥—É –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –≥–æ—Ä—É—Ç–∏–Ω–∞–º–∏, fan-in —Å–æ–±–∏—Ä–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:

```go
// Fan-out: –æ–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫ -> –º–Ω–æ–≥–æ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π
func fanOut() {
    input := make(chan int)
    output1 := make(chan int)
    output2 := make(chan int)
    output3 := make(chan int)
    
    // –†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å (fan-out)
    go func() {
        defer close(output1)
        defer close(output2)
        defer close(output3)
        
        for value := range input {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º workers
            go func(v int) { output1 <- v }(value)
            go func(v int) { output2 <- v }(value)
            go func(v int) { output3 <- v }(value)
        }
    }()
    
    // Workers
    worker := func(id int, in <-chan int) {
        for value := range in {
            fmt.Printf("Worker %d processing %d\n", id, value)
            time.Sleep(100 * time.Millisecond)
        }
    }
    
    go worker(1, output1)
    go worker(2, output2)
    go worker(3, output3)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
    go func() {
        defer close(input)
        for i := 1; i <= 5; i++ {
            input <- i
        }
    }()
    
    time.Sleep(2 * time.Second)
}

// Fan-in: –º–Ω–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ -> –æ–¥–∏–Ω –ø–æ–ª—É—á–∞—Ç–µ–ª—å
func fanIn() {
    // –§—É–Ω–∫—Ü–∏—è fan-in –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤
    merge := func(channels ...<-chan int) <-chan int {
        out := make(chan int)
        var wg sync.WaitGroup
        
        // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
        for _, ch := range channels {
            wg.Add(1)
            go func(c <-chan int) {
                defer wg.Done()
                for value := range c {
                    out <- value
                }
            }(ch)
        }
        
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—ã—Ö–æ–¥–Ω–æ–π –∫–∞–Ω–∞–ª –∫–æ–≥–¥–∞ –≤—Å–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –∑–∞–≤–µ—Ä—à–µ–Ω—ã
        go func() {
            wg.Wait()
            close(out)
        }()
        
        return out
    }
    
    // –°–æ–∑–¥–∞–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    source1 := make(chan int)
    source2 := make(chan int)
    source3 := make(chan int)
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º producers
    go func() {
        defer close(source1)
        for i := 1; i <= 3; i++ {
            source1 <- i * 10
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    go func() {
        defer close(source2)
        for i := 1; i <= 3; i++ {
            source2 <- i * 100
            time.Sleep(150 * time.Millisecond)
        }
    }()
    
    go func() {
        defer close(source3)
        for i := 1; i <= 3; i++ {
            source3 <- i * 1000
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏
    merged := merge(source1, source2, source3)
    
    // –ß–∏—Ç–∞–µ–º –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    for value := range merged {
        fmt.Printf("Merged value: %d\n", value)
    }
}

// –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π fan-out/fan-in pipeline
func fanOutInPipeline() {
    type Job struct {
        ID   int
        Data int
    }
    
    type Result struct {
        JobID  int
        Output int
    }
    
    // Stage 1: Generator
    generator := func() <-chan Job {
        out := make(chan Job)
        go func() {
            defer close(out)
            for i := 1; i <= 10; i++ {
                out <- Job{ID: i, Data: i * 10}
            }
        }()
        return out
    }
    
    // Stage 2: Fan-out to workers
    fanOutToWorkers := func(input <-chan Job, numWorkers int) []<-chan Result {
        outputs := make([]<-chan Result, numWorkers)
        
        for i := 0; i < numWorkers; i++ {
            out := make(chan Result)
            outputs[i] = out
            
            go func(workerID int, jobs <-chan Job, results chan<- Result) {
                defer close(results)
                for job := range jobs {
                    // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
                    time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
                    
                    result := Result{
                        JobID:  job.ID,
                        Output: job.Data * job.Data,
                    }
                    results <- result
                }
            }(i, input, out)
        }
        
        return outputs
    }
    
    // Stage 3: Fan-in results
    fanInResults := func(inputs []<-chan Result) <-chan Result {
        out := make(chan Result)
        var wg sync.WaitGroup
        
        for _, input := range inputs {
            wg.Add(1)
            go func(in <-chan Result) {
                defer wg.Done()
                for result := range in {
                    out <- result
                }
            }(input)
        }
        
        go func() {
            wg.Wait()
            close(out)
        }()
        
        return out
    }
    
    // –°–æ–∑–¥–∞–µ–º pipeline
    jobs := generator()
    workerOutputs := fanOutToWorkers(jobs, 3)
    results := fanInResults(workerOutputs)
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    for result := range results {
        fmt.Printf("Job %d result: %d\n", result.JobID, result.Output)
    }
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤–µ–±-–∑–∞–ø—Ä–æ—Å–æ–≤
func parallelWebRequests() {
    urls := []string{
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/2", 
        "https://httpbin.org/delay/1",
    }
    
    type Request struct {
        URL string
        ID  int
    }
    
    type Response struct {
        ID     int
        URL    string
        Status int
        Error  error
    }
    
    // Fan-out requests
    requestChan := make(chan Request)
    responseChan := make(chan Response)
    
    // Worker pool
    const numWorkers = 3
    for i := 0; i < numWorkers; i++ {
        go func(workerID int) {
            client := &http.Client{Timeout: 5 * time.Second}
            
            for req := range requestChan {
                resp, err := client.Get(req.URL)
                
                response := Response{
                    ID:  req.ID,
                    URL: req.URL,
                }
                
                if err != nil {
                    response.Error = err
                } else {
                    response.Status = resp.StatusCode
                    resp.Body.Close()
                }
                
                responseChan <- response
            }
        }(i)
    }
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å—ã
    go func() {
        defer close(requestChan)
        for i, url := range urls {
            requestChan <- Request{URL: url, ID: i}
        }
    }()
    
    // –°–æ–±–∏—Ä–∞–µ–º –æ—Ç–≤–µ—Ç—ã
    for i := 0; i < len(urls); i++ {
        response := <-responseChan
        if response.Error != nil {
            fmt.Printf("Request %d failed: %v\n", response.ID, response.Error)
        } else {
            fmt.Printf("Request %d completed: %d\n", response.ID, response.Status)
        }
    }
}
```

### 47. –ß—Ç–æ —Ç–∞–∫–æ–µ context –∏ –∑–∞—á–µ–º –æ–Ω –Ω—É–∂–µ–Ω?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Context –ø–µ—Ä–µ–¥–∞–µ—Ç deadline, —Å–∏–≥–Ω–∞–ª—ã –æ—Ç–º–µ–Ω—ã –∏ –∑–Ω–∞—á–µ–Ω–∏—è –º–µ–∂–¥—É –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ API –∏ –≥–æ—Ä—É—Ç–∏–Ω–∞–º–∏:

```go
// –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ context
func contextBasics() {
    // 1. Background context - –∫–æ—Ä–Ω–µ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
    ctx := context.Background()
    
    // 2. TODO context - –∫–æ–≥–¥–∞ –Ω–µ—è—Å–Ω–æ –∫–∞–∫–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
    ctx = context.TODO()
    
    // 3. WithCancel - –¥–ª—è –æ—Ç–º–µ–Ω—ã –æ–ø–µ—Ä–∞—Ü–∏–π
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // –≤—Å–µ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–π—Ç–µ cancel
    
    // 4. WithTimeout - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Ç–º–µ–Ω–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 5. WithDeadline - –æ—Ç–º–µ–Ω–∞ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è
    deadline := time.Now().Add(10 * time.Second)
    ctx, cancel = context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    // 6. WithValue - –ø–µ—Ä–µ–¥–∞—á–∞ –∑–Ω–∞—á–µ–Ω–∏–π
    ctx = context.WithValue(ctx, "userID", 12345)
}

// –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–π
func cancellationExample() {
    ctx, cancel := context.WithCancel(context.Background())
    
    go func() {
        // –ò–º–∏—Ç–∏—Ä—É–µ–º –¥–æ–ª–≥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
        for i := 0; i < 10; i++ {
            select {
            case <-ctx.Done():
                fmt.Printf("Operation cancelled: %v\n", ctx.Err())
                return
            default:
                fmt.Printf("Working... step %d\n", i)
                time.Sleep(500 * time.Millisecond)
            }
        }
        fmt.Println("Operation completed")
    }()
    
    // –û—Ç–º–µ–Ω—è–µ–º —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
    time.Sleep(2 * time.Second)
    cancel()
    
    time.Sleep(1 * time.Second) // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
}

// Timeout –æ–ø–µ—Ä–∞—Ü–∏–π
func timeoutExample() {
    // –§—É–Ω–∫—Ü–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π context
    doWork := func(ctx context.Context) error {
        // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        for i := 0; i < 5; i++ {
            select {
            case <-ctx.Done():
                return ctx.Err() // context.DeadlineExceeded –∏–ª–∏ context.Canceled
            default:
                time.Sleep(time.Second)
                fmt.Printf("Work step %d completed\n", i+1)
            }
        }
        return nil
    }
    
    // –û–ø–µ—Ä–∞—Ü–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    if err := doWork(ctx); err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            fmt.Println("Operation timed out")
        } else if errors.Is(err, context.Canceled) {
            fmt.Println("Operation was cancelled")
        }
    } else {
        fmt.Println("Operation completed successfully")
    }
}

// –ü–µ—Ä–µ–¥–∞—á–∞ –∑–Ω–∞—á–µ–Ω–∏–π —á–µ—Ä–µ–∑ context
func contextValues() {
    type key string
    
    const (
        userIDKey    key = "userID"
        requestIDKey key = "requestID"
    )
    
    // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    ctx := context.WithValue(context.Background(), userIDKey, 12345)
    ctx = context.WithValue(ctx, requestIDKey, "req-abc-123")
    
    // –§—É–Ω–∫—Ü–∏—è, –∏—Å–ø–æ–ª—å–∑—É—é—â–∞—è –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    processRequest := func(ctx context.Context) {
        userID := ctx.Value(userIDKey)
        requestID := ctx.Value(requestIDKey)
        
        if userID != nil {
            fmt.Printf("Processing request for user: %v\n", userID)
        }
        
        if requestID != nil {
            fmt.Printf("Request ID: %v\n", requestID)
        }
        
        // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å type assertion
        if uid, ok := userID.(int); ok {
            fmt.Printf("User ID as int: %d\n", uid)
        }
    }
    
    processRequest(ctx)
}

// Context –≤ HTTP —Å–µ—Ä–≤–µ—Ä–∞—Ö
func httpContextExample() {
    handler := func(w http.ResponseWriter, r *http.Request) {
        // –ö–æ–Ω—Ç–µ–∫—Å—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
        ctx := r.Context()
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        ctx = context.WithValue(ctx, "startTime", time.Now())
        
        // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å —Ç–∞–π–º–∞—É—Ç–æ–º –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö –≤—ã–∑–æ–≤–æ–≤
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        
        // –ò–º–∏—Ç–∞—Ü–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ API –≤—ã–∑–æ–≤–∞
        if err := callExternalAPI(ctx); err != nil {
            if errors.Is(err, context.DeadlineExceeded) {
                http.Error(w, "External API timeout", http.StatusRequestTimeout)
                return
            }
            http.Error(w, "External API error", http.StatusInternalServerError)
            return
        }
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("Success"))
    }
    
    callExternalAPI := func(ctx context.Context) error {
        // –ò–º–∏—Ç–∞—Ü–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ –≤—ã–∑–æ–≤–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –æ—Ç–º–µ–Ω—ã
        done := make(chan error, 1)
        
        go func() {
            // –ò–º–∏—Ç–∞—Ü–∏—è –¥–æ–ª–≥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
            time.Sleep(3 * time.Second)
            done <- nil
        }()
        
        select {
        case err := <-done:
            return err
        case <-ctx.Done():
            return ctx.Err()
        }
    }
}

// Context propagation –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞—Ö
func microserviceContext() {
    type Service struct {
        name string
    }
    
    // –ö–∞–∂–¥—ã–π —Å–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–∞–ª—å—à–µ
    func (s *Service) ProcessRequest(ctx context.Context, data string) error {
        // –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É
        ctx = context.WithValue(ctx, "service", s.name)
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–º–µ–Ω–µ–Ω –ª–∏ –∑–∞–ø—Ä–æ—Å
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
        
        fmt.Printf("[%s] Processing: %s\n", s.name, data)
        
        // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
        time.Sleep(100 * time.Millisecond)
        
        // –í—ã–∑–æ–≤ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
        if s.name == "service1" {
            nextService := &Service{name: "service2"}
            return nextService.ProcessRequest(ctx, data)
        }
        
        return nil
    }
    
    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    service := &Service{name: "service1"}
    if err := service.ProcessRequest(ctx, "important data"); err != nil {
        fmt.Printf("Request failed: %v\n", err)
    }
}
```

### 48. –ö–∞–∫ —Å–æ–∑–¥–∞—Ç—å context —Å timeout?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Context —Å timeout –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–º–µ–Ω—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ –∑–∞–¥–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è:

```go
func timeoutContexts() {
    // –û—Å–Ω–æ–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã —Å–æ–∑–¥–∞–Ω–∏—è timeout context
    
    // 1. WithTimeout - –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
    ctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel1()
    
    // 2. WithDeadline - –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –≤—Ä–µ–º—è
    deadline := time.Now().Add(10 * time.Second)
    ctx2, cancel2 := context.WithDeadline(context.Background(), deadline)
    defer cancel2()
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ timeout context
    doWorkWithTimeout := func(ctx context.Context, workDuration time.Duration) error {
        done := make(chan struct{})
        
        go func() {
            defer close(done)
            time.Sleep(workDuration) // –∏–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
        }()
        
        select {
        case <-done:
            return nil // —Ä–∞–±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
        case <-ctx.Done():
            return ctx.Err() // —Ç–∞–π–º–∞—É—Ç –∏–ª–∏ –æ—Ç–º–µ–Ω–∞
        }
    }
    
    // –¢–µ—Å—Ç —Å —É—Å–ø–µ—à–Ω—ã–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ–º
    fmt.Println("Testing successful completion...")
    err := doWorkWithTimeout(ctx1, 1*time.Second)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Println("Work completed successfully")
    }
    
    // –¢–µ—Å—Ç —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    fmt.Println("Testing timeout...")
    ctx3, cancel3 := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel3()
    
    err = doWorkWithTimeout(ctx3, 3*time.Second)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            fmt.Println("Work timed out as expected")
        } else {
            fmt.Printf("Unexpected error: %v\n", err)
        }
    }
}

// –ö–∞—Å–∫–∞–¥–Ω—ã–µ timeout'—ã
func cascadingTimeouts() {
    // –†–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å –±–æ–ª—å—à–∏–º —Ç–∞–π–º–∞—É—Ç–æ–º
    parentCtx, parentCancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer parentCancel()
    
    // –î–æ—á–µ—Ä–Ω–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å –º–µ–Ω—å—à–∏–º —Ç–∞–π–º–∞—É—Ç–æ–º
    childCtx, childCancel := context.WithTimeout(parentCtx, 2*time.Second)
    defer childCancel()
    
    // –û–ø–µ—Ä–∞—Ü–∏—è –±—É–¥–µ—Ç –æ—Ç–º–µ–Ω–µ–Ω–∞ —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã (–º–µ–Ω—å—à–∏–π —Ç–∞–π–º–∞—É—Ç)
    startTime := time.Now()
    
    select {
    case <-childCtx.Done():
        elapsed := time.Since(startTime)
        fmt.Printf("Child context cancelled after %v: %v\n", elapsed, childCtx.Err())
    case <-parentCtx.Done():
        elapsed := time.Since(startTime)
        fmt.Printf("Parent context cancelled after %v: %v\n", elapsed, parentCtx.Err())
    }
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å timeout
func practicalTimeoutPatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: HTTP –∫–ª–∏–µ–Ω—Ç —Å timeout
    func makeHTTPRequest(url string, timeout time.Duration) error {
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil {
            return err
        }
        
        client := &http.Client{}
        resp, err := client.Do(req)
        if err != nil {
            return err
        }
        defer resp.Body.Close()
        
        fmt.Printf("Response status: %s\n", resp.Status)
        return nil
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Å timeout
    func queryDatabase(query string, timeout time.Duration) error {
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        // –ò–º–∏—Ç–∞—Ü–∏—è DB –∑–∞–ø—Ä–æ—Å–∞
        done := make(chan error, 1)
        
        go func() {
            // –°–∏–º—É–ª—è—Ü–∏—è DB –æ–ø–µ—Ä–∞—Ü–∏–∏
            time.Sleep(1 * time.Second)
            done <- nil
        }()
        
        select {
        case err := <-done:
            if err == nil {
                fmt.Println("Database query completed")
            }
            return err
        case <-ctx.Done():
            fmt.Println("Database query timed out")
            return ctx.Err()
        }
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: Retry —Å timeout
    func retryWithTimeout(operation func() error, maxRetries int, timeout time.Duration) error {
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        for attempt := 1; attempt <= maxRetries; attempt++ {
            select {
            case <-ctx.Done():
                return fmt.Errorf("retry timeout after %d attempts: %w", attempt-1, ctx.Err())
            default:
            }
            
            err := operation()
            if err == nil {
                fmt.Printf("Operation succeeded on attempt %d\n", attempt)
                return nil
            }
            
            fmt.Printf("Attempt %d failed: %v\n", attempt, err)
            
            if attempt < maxRetries {
                // Exponential backoff
                backoff := time.Duration(attempt) * 100 * time.Millisecond
                
                select {
                case <-time.After(backoff):
                case <-ctx.Done():
                    return ctx.Err()
                }
            }
        }
        
        return fmt.Errorf("operation failed after %d attempts", maxRetries)
    }
    
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    err := queryDatabase("SELECT * FROM users", 2*time.Second)
    if err != nil {
        fmt.Printf("DB error: %v\n", err)
    }
    
    // Retry –ø—Ä–∏–º–µ—Ä
    failingOperation := func() error {
        if rand.Float64() < 0.7 { // 70% –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –Ω–µ—É–¥–∞—á–∏
            return errors.New("random failure")
        }
        return nil
    }
    
    err = retryWithTimeout(failingOperation, 5, 3*time.Second)
    if err != nil {
        fmt.Printf("Retry failed: %v\n", err)
    }
}

// Advanced timeout —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
func advancedTimeoutManagement() {
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π timeout –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–≥—Ä—É–∑–∫–∏
    func dynamicTimeout(baseTimeout time.Duration, load float64) time.Duration {
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º timeout –ø—Ä–∏ –≤—ã—Å–æ–∫–æ–π –Ω–∞–≥—Ä—É–∑–∫–µ
        multiplier := 1.0 + load
        return time.Duration(float64(baseTimeout) * multiplier)
    }
    
    // Timeout —Å –ø—Ä–æ–≥—Ä–µ—Å—Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º
    func operationWithProgress(ctx context.Context) error {
        const totalSteps = 10
        progressChan := make(chan int, totalSteps)
        
        go func() {
            defer close(progressChan)
            for i := 1; i <= totalSteps; i++ {
                select {
                case <-ctx.Done():
                    return
                default:
                    time.Sleep(200 * time.Millisecond)
                    progressChan <- i
                }
            }
        }()
        
        for {
            select {
            case progress, ok := <-progressChan:
                if !ok {
                    fmt.Println("Operation completed 100%")
                    return nil
                }
                fmt.Printf("Progress: %d%%\n", progress*10)
                
            case <-ctx.Done():
                fmt.Printf("Operation cancelled at some progress level\n")
                return ctx.Err()
            }
        }
    }
    
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    currentLoad := 0.5 // 50% –Ω–∞–≥—Ä—É–∑–∫–∞
    timeout := dynamicTimeout(2*time.Second, currentLoad)
    
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    
    err := operationWithProgress(ctx)
    if err != nil {
        fmt.Printf("Operation error: %v\n", err)
    }
}
```

### 49. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ context?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Context values —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è request-scoped –¥–∞–Ω–Ω—ã—Ö, –∞ –Ω–µ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π:

```go
// –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ context values
func contextValuesGoodPractices() {
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏
    type contextKey string
    
    const (
        userIDKey     contextKey = "userID"
        requestIDKey  contextKey = "requestID"
        correlationKey contextKey = "correlationID"
        traceIDKey    contextKey = "traceID"
    )
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    createRequestContext := func(userID int, requestID string) context.Context {
        ctx := context.Background()
        ctx = context.WithValue(ctx, userIDKey, userID)
        ctx = context.WithValue(ctx, requestIDKey, requestID)
        ctx = context.WithValue(ctx, correlationKey, generateCorrelationID())
        return ctx
    }
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
    getUserID := func(ctx context.Context) (int, bool) {
        userID, ok := ctx.Value(userIDKey).(int)
        return userID, ok
    }
    
    getRequestID := func(ctx context.Context) (string, bool) {
        requestID, ok := ctx.Value(requestIDKey).(string)
        return requestID, ok
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    ctx := createRequestContext(12345, "req-abc-123")
    
    if userID, ok := getUserID(ctx); ok {
        fmt.Printf("User ID: %d\n", userID)
    }
    
    if requestID, ok := getRequestID(ctx); ok {
        fmt.Printf("Request ID: %s\n", requestID)
    }
}

// –ß—Ç–æ –ù–ï —Å–ª–µ–¥—É–µ—Ç –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —á–µ—Ä–µ–∑ context
func contextAntiPatterns() {
    // –ü–õ–û–•–û: –ø–µ—Ä–µ–¥–∞—á–∞ –æ–±—ã—á–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏
    func badExample(ctx context.Context) {
        // –ù–µ –¥–µ–ª–∞–π—Ç–µ —Ç–∞–∫!
        ctx = context.WithValue(ctx, "database", db)
        ctx = context.WithValue(ctx, "config", config)
        ctx = context.WithValue(ctx, "logger", logger)
        
        processData(ctx) // –ø–µ—Ä–µ–¥–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ context
    }
    
    // –•–û–†–û–®–û: –ø–µ—Ä–µ–¥–∞—á–∞ —á–µ—Ä–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    func goodExample(ctx context.Context, db Database, config Config, logger Logger) {
        processDataCorrectly(ctx, db, config, logger)
    }
    
    // –ü–õ–û–•–û: –∏–∑–º–µ–Ω—è–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ context
    func mutableDataBad(ctx context.Context) {
        data := make(map[string]interface{})
        ctx = context.WithValue(ctx, "mutableData", data)
        
        // –ü—Ä–æ–±–ª–µ–º–∞: –Ω–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω –º–æ–≥—É—Ç –∏–∑–º–µ–Ω—è—Ç—å data
        go func() {
            data["key1"] = "value1" // race condition!
        }()
        
        go func() {
            data["key2"] = "value2" // race condition!
        }()
    }
    
    // –•–û–†–û–®–û: –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ
    func immutableDataGood(ctx context.Context) {
        readOnlyData := map[string]string{
            "version": "1.0",
            "region":  "us-east-1",
        }
        ctx = context.WithValue(ctx, "metadata", readOnlyData)
        // –ë–µ–∑–æ–ø–∞—Å–Ω–æ: –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è —á—Ç–µ–Ω–∏—è
    }
}

// –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è request-scoped –¥–∞–Ω–Ω—ã—Ö
func requestScopedPatterns() {
    // Middleware pattern –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π
    func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞
            token := r.Header.Get("Authorization")
            
            // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∏ –ø–æ–ª—É—á–∞–µ–º user ID
            userID, err := validateToken(token)
            if err != nil {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º user ID –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
            ctx := context.WithValue(r.Context(), "userID", userID)
            r = r.WithContext(ctx)
            
            next(w, r)
        }
    }
    
    func loggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º request ID
            requestID := generateRequestID()
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
            ctx := context.WithValue(r.Context(), "requestID", requestID)
            r = r.WithContext(ctx)
            
            // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ –∑–∞–ø—Ä–æ—Å–∞
            fmt.Printf("[%s] %s %s\n", requestID, r.Method, r.URL.Path)
            
            next(w, r)
        }
    }
    
    // Handler –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    func profileHandler(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        
        // –ò–∑–≤–ª–µ–∫–∞–µ–º user ID
        userID, ok := ctx.Value("userID").(int)
        if !ok {
            http.Error(w, "User ID not found", http.StatusInternalServerError)
            return
        }
        
        // –ò–∑–≤–ª–µ–∫–∞–µ–º request ID –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        requestID, _ := ctx.Value("requestID").(string)
        
        fmt.Printf("[%s] Getting profile for user %d\n", requestID, userID)
        
        // –õ–æ–≥–∏–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è...
        profile := getUserProfile(ctx, userID)
        json.NewEncoder(w).Encode(profile)
    }
}

// –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ context
func tracingThroughContext() {
    type TraceInfo struct {
        TraceID string
        SpanID  string
        Baggage map[string]string
    }
    
    // Middleware –¥–ª—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏
    func tracingMiddleware(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –∏–∑–≤–ª–µ–∫–∞–µ–º trace –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            traceID := r.Header.Get("X-Trace-ID")
            if traceID == "" {
                traceID = generateTraceID()
            }
            
            spanID := generateSpanID()
            
            trace := TraceInfo{
                TraceID: traceID,
                SpanID:  spanID,
                Baggage: make(map[string]string),
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
            ctx := context.WithValue(r.Context(), "trace", trace)
            r = r.WithContext(ctx)
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞
            w.Header().Set("X-Trace-ID", traceID)
            w.Header().Set("X-Span-ID", spanID)
            
            next(w, r)
        }
    }
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è child span
    func createChildSpan(ctx context.Context, operationName string) context.Context {
        if trace, ok := ctx.Value("trace").(TraceInfo); ok {
            childTrace := TraceInfo{
                TraceID: trace.TraceID,
                SpanID:  generateSpanID(),
                Baggage: trace.Baggage, // –Ω–∞—Å–ª–µ–¥—É–µ–º baggage
            }
            
            fmt.Printf("Starting span: %s (trace: %s, span: %s)\n", 
                operationName, childTrace.TraceID, childTrace.SpanID)
            
            return context.WithValue(ctx, "trace", childTrace)
        }
        
        return ctx
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Å–µ—Ä–≤–∏—Å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö
    func databaseQuery(ctx context.Context, query string) error {
        ctx = createChildSpan(ctx, "database.query")
        
        if trace, ok := ctx.Value("trace").(TraceInfo); ok {
            fmt.Printf("[%s:%s] Executing query: %s\n", 
                trace.TraceID, trace.SpanID, query)
        }
        
        // –ò–º–∏—Ç–∞—Ü–∏—è DB –∑–∞–ø—Ä–æ—Å–∞
        time.Sleep(100 * time.Millisecond)
        return nil
    }
    
    func externalAPICall(ctx context.Context, endpoint string) error {
        ctx = createChildSpan(ctx, "http.client")
        
        // –ü–µ—Ä–µ–¥–∞–µ–º trace ID –≤ –∏—Å—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–∞—Ö
        if trace, ok := ctx.Value("trace").(TraceInfo); ok {
            fmt.Printf("[%s:%s] Calling external API: %s\n", 
                trace.TraceID, trace.SpanID, endpoint)
            
            // –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –¥–æ–±–∞–≤–∏–ª–∏ –±—ã –∑–∞–≥–æ–ª–æ–≤–æ–∫ X-Trace-ID
        }
        
        time.Sleep(200 * time.Millisecond)
        return nil
    }
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
func generateCorrelationID() string {
    return fmt.Sprintf("corr-%d", time.Now().UnixNano())
}

func generateRequestID() string {
    return fmt.Sprintf("req-%d", time.Now().UnixNano())
}

func generateTraceID() string {
    return fmt.Sprintf("trace-%d", time.Now().UnixNano())
}

func generateSpanID() string {
    return fmt.Sprintf("span-%d", time.Now().UnixNano())
}

func validateToken(token string) (int, error) {
    // –ò–º–∏—Ç–∞—Ü–∏—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞
    if token == "" {
        return 0, errors.New("empty token")
    }
    return 12345, nil // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º mock user ID
}

func getUserProfile(ctx context.Context, userID int) map[string]interface{} {
    return map[string]interface{}{
        "id":   userID,
        "name": "John Doe",
        "email": "john@example.com",
    }
}
```

### 50. –ß—Ç–æ —Ç–∞–∫–æ–µ channel axioms (–ø—Ä–∞–≤–∏–ª–∞ –∫–∞–Ω–∞–ª–æ–≤)?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Channel axioms ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤ –≤ Go:

```go
// –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∫–∞–Ω–∞–ª–æ–≤
func channelAxioms() {
    fmt.Println("=== Channel Axioms Demo ===")
    
    // –ü—Ä–∞–≤–∏–ª–æ 1: –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ nil –∫–∞–Ω–∞–ª –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞
    func nilChannelSend() {
        var ch chan int // nil –∫–∞–Ω–∞–ª
        
        go func() {
            fmt.Println("Attempting to send to nil channel...")
            ch <- 1 // –∑–∞–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞
            fmt.Println("This will never print")
        }()
        
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Send to nil channel is blocked (as expected)")
    }
    
    // –ü—Ä–∞–≤–∏–ª–æ 2: –ß—Ç–µ–Ω–∏–µ –∏–∑ nil –∫–∞–Ω–∞–ª–∞ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞
    func nilChannelReceive() {
        var ch chan int // nil –∫–∞–Ω–∞–ª
        
        go func() {
            fmt.Println("Attempting to receive from nil channel...")
            <-ch // –∑–∞–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –Ω–∞–≤—Å–µ–≥–¥–∞
            fmt.Println("This will never print")
        }()
        
        time.Sleep(100 * time.Millisecond)
        fmt.Println("Receive from nil channel is blocked (as expected)")
    }
    
    // –ü—Ä–∞–≤–∏–ª–æ 3: –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª –≤—ã–∑—ã–≤–∞–µ—Ç panic
    func closedChannelSend() {
        ch := make(chan int, 1)
        close(ch)
        
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("Panic caught: %v\n", r)
            }
        }()
        
        fmt.Println("Attempting to send to closed channel...")
        ch <- 1 // panic: send on closed channel
    }
    
    // –ü—Ä–∞–≤–∏–ª–æ 4: –ß—Ç–µ–Ω–∏–µ –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç zero value
    func closedChannelReceive() {
        ch := make(chan int, 2)
        ch <- 1
        ch <- 2
        close(ch)
        
        fmt.Printf("Reading from closed channel: %d\n", <-ch) // 1
        fmt.Printf("Reading from closed channel: %d\n", <-ch) // 2
        fmt.Printf("Reading from closed channel: %d\n", <-ch) // 0 (zero value)
        
        // –° –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—Ç–∞—Ç—É—Å–∞
        value, ok := <-ch
        fmt.Printf("Value: %d, OK: %t\n", value, ok) // 0, false
    }
    
    // –ü—Ä–∞–≤–∏–ª–æ 5: –ó–∞–∫—Ä—ã—Ç–∏–µ nil –∫–∞–Ω–∞–ª–∞ –≤—ã–∑—ã–≤–∞–µ—Ç panic
    func closeNilChannel() {
        var ch chan int // nil –∫–∞–Ω–∞–ª
        
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("Panic caught: %v\n", r)
            }
        }()
        
        fmt.Println("Attempting to close nil channel...")
        close(ch) // panic: close of nil channel
    }
    
    // –ü—Ä–∞–≤–∏–ª–æ 6: –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ –≤—ã–∑—ã–≤–∞–µ—Ç panic
    func doubleClose() {
        ch := make(chan int)
        close(ch)
        
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("Panic caught: %v\n", r)
            }
        }()
        
        fmt.Println("Attempting to close already closed channel...")
        close(ch) // panic: close of closed channel
    }
    
    // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø—Ä–∞–≤–∏–ª
    fmt.Println("\n1. Nil channel operations:")
    nilChannelSend()
    nilChannelReceive()
    
    fmt.Println("\n2. Closed channel operations:")
    closedChannelSend()
    closedChannelReceive()
    
    fmt.Println("\n3. Closing operations:")
    closeNilChannel()
    doubleClose()
}

// –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ axioms
func practicalChannelAxioms() {
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ nil –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –≤ select
    func selectWithNilChannels() {
        ch1 := make(chan string, 1)
        ch2 := make(chan string, 1)
        
        ch1 <- "message1"
        ch2 <- "message2"
        
        // –°–∏–º—É–ª–∏—Ä—É–µ–º –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤
        for i := 0; i < 3; i++ {
            select {
            case msg := <-ch1:
                fmt.Printf("Received from ch1: %s\n", msg)
                ch1 = nil // –æ—Ç–∫–ª—é—á–∞–µ–º ch1 –≤ select
                
            case msg := <-ch2:
                fmt.Printf("Received from ch2: %s\n", msg)
                ch2 = nil // –æ—Ç–∫–ª—é—á–∞–µ–º ch2 –≤ select
                
            default:
                fmt.Println("No more messages")
                return
            }
        }
    }
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–æ–≤
    func safeChannelClose() {
        type SafeChannel struct {
            ch     chan int
            closed bool
            mu     sync.Mutex
        }
        
        func (sc *SafeChannel) Send(value int) bool {
            sc.mu.Lock()
            defer sc.mu.Unlock()
            
            if sc.closed {
                return false
            }
            
            select {
            case sc.ch <- value:
                return true
            default:
                return false // –∫–∞–Ω–∞–ª –ø–æ–ª–æ–Ω
            }
        }
        
        func (sc *SafeChannel) Close() {
            sc.mu.Lock()
            defer sc.mu.Unlock()
            
            if !sc.closed {
                close(sc.ch)
                sc.closed = true
            }
        }
        
        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        safeCh := &SafeChannel{
            ch: make(chan int, 2),
        }
        
        fmt.Println("Safe send:", safeCh.Send(1))  // true
        fmt.Println("Safe send:", safeCh.Send(2))  // true
        
        safeCh.Close()
        
        fmt.Println("Safe send after close:", safeCh.Send(3)) // false
        safeCh.Close() // –±–µ–∑–æ–ø–∞—Å–Ω–æ - –Ω–µ –≤—ã–∑–æ–≤–µ—Ç panic
    }
    
    // Graceful shutdown –ø–∞—Ç—Ç–µ—Ä–Ω
    func gracefulShutdown() {
        work := make(chan int, 10)
        done := make(chan struct{})
        quit := make(chan struct{})
        
        // Worker
        go func() {
            defer close(done)
            
            for {
                select {
                case job, ok := <-work:
                    if !ok {
                        // –ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç, –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É
                        fmt.Println("Work channel closed, worker stopping")
                        return
                    }
                    fmt.Printf("Processing job: %d\n", job)
                    time.Sleep(100 * time.Millisecond)
                    
                case <-quit:
                    // –°–∏–≥–Ω–∞–ª –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
                    fmt.Println("Quit signal received, worker stopping")
                    return
                }
            }
        }()
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–∞–±–æ—Ç—É
        for i := 1; i <= 3; i++ {
            work <- i
        }
        
        // Graceful shutdown - –∑–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª —Ä–∞–±–æ—Ç—ã
        close(work)
        
        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
        <-done
        fmt.Println("Worker finished gracefully")
    }
    
    selectWithNilChannels()
    safeChannelClose()
    gracefulShutdown()
}

// Channel –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ axioms
func channelDirectionsAxioms() {
    // –ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
    
    // Send-only –∫–∞–Ω–∞–ª
    func sendOnlyExample(ch chan<- int) {
        ch <- 42
        // <-ch // Compilation error: cannot receive from send-only channel
        // close(ch) // OK: –º–æ–∂–Ω–æ –∑–∞–∫—Ä—ã–≤–∞—Ç—å send-only –∫–∞–Ω–∞–ª
    }
    
    // Receive-only –∫–∞–Ω–∞–ª
    func receiveOnlyExample(ch <-chan int) {
        <-ch
        // ch <- 42 // Compilation error: cannot send to receive-only channel
        // close(ch) // Compilation error: cannot close receive-only channel
    }
    
    // Producer-Consumer —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏
    func producerConsumer() {
        ch := make(chan int, 3)
        
        // Producer - –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å
        producer := func(out chan<- int) {
            defer close(out) // Producer –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –∫–∞–Ω–∞–ª
            for i := 1; i <= 5; i++ {
                out <- i
            }
        }
        
        // Consumer - –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ –ø–æ–ª—É—á–∞—Ç—å
        consumer := func(in <-chan int) {
            for value := range in { // range –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
                fmt.Printf("Consumed: %d\n", value)
            }
        }
        
        go producer(ch)
        consumer(ch)
    }
}
```

---

## üîí –†–∞–∑–¥–µ–ª 4: –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è (–û—Ç–≤–µ—Ç—ã 56-70)

### 56. –ß—Ç–æ —Ç–∞–∫–æ–µ data race –∏ –∫–∞–∫ –µ–≥–æ –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Data race –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∫–æ–≥–¥–∞ –¥–≤–µ –∏–ª–∏ –±–æ–ª–µ–µ –≥–æ—Ä—É—Ç–∏–Ω –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±—Ä–∞—â–∞—é—Ç—Å—è –∫ –æ–¥–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, –∏ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–∞ –∏–∑ –Ω–∏—Ö –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç:

```go
// –ü—Ä–∏–º–µ—Ä data race
func dataRaceExample() {
    var counter int
    var wg sync.WaitGroup
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º 1000 –≥–æ—Ä—É—Ç–∏–Ω, –∫–∞–∂–¥–∞—è —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç counter
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++ // DATA RACE: –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–ø–∏—Å—å –±–µ–∑ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final counter (with race): %d\n", counter) // —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º
}

// –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é race detector
func raceDetection() {
    // –ó–∞–ø—É—Å–∫ —Å race detector: go run -race main.go
    // –ò–ª–∏ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ: go build -race
    
    var shared int
    
    go func() {
        shared = 1 // –∑–∞–ø–∏—Å—å
    }()
    
    go func() {
        fmt.Println(shared) // —á—Ç–µ–Ω–∏–µ
    }()
    
    time.Sleep(100 * time.Millisecond)
    // Race detector –≤—ã–¥–∞—Å—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
}

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ data race
func fixedVersion() {
    var counter int
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++ // –∑–∞—â–∏—â–µ–Ω–æ –º—å—é—Ç–µ–∫—Å–æ–º
            mu.Unlock()
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final counter (race-free): %d\n", counter) // –≤—Å–µ–≥–¥–∞ 1000
}

// –¢–∏–ø–∏—á–Ω—ã–µ –º–µ—Å—Ç–∞ data race
func commonRaceConditions() {
    // 1. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ map
    func mapRace() {
        m := make(map[int]int)
        
        // –ù–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω –∑–∞–ø–∏—Å—ã–≤–∞—é—Ç –≤ –º–∞–ø—É
        for i := 0; i < 10; i++ {
            go func(id int) {
                m[id] = id * id // RACE: concurrent map writes
            }(i)
        }
        
        time.Sleep(100 * time.Millisecond)
    }
    
    // 2. –ó–∞—Ö–≤–∞—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Ü–∏–∫–ª–∞
    func loopVariableRace() {
        var wg sync.WaitGroup
        
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                fmt.Println(i) // RACE: –≤—Å–µ –≥–æ—Ä—É—Ç–∏–Ω—ã —á–∏—Ç–∞—é—Ç –æ–¥–Ω—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é i
            }()
        }
        
        wg.Wait()
    }
    
    // 3. Slice append race
    func sliceRace() {
        var slice []int
        var wg sync.WaitGroup
        
        for i := 0; i < 10; i++ {
            wg.Add(1)
            go func(val int) {
                defer wg.Done()
                slice = append(slice, val) // RACE: append –Ω–µ atomic
            }(i)
        }
        
        wg.Wait()
        fmt.Printf("Slice length: %d\n", len(slice)) // –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ
    }
}

// –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è races
func raceDetectionTools() {
    // 1. –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π race detector
    // go run -race program.go
    // go test -race
    // go build -race
    
    // 2. –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
    // go vet program.go
    
    // 3. –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    func checkDataRace() {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º runtime –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("Panic detected (possible race): %v\n", r)
            }
        }()
        
        // –∫–æ–¥ —Å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–º race
    }
}
```

### 57. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `sync.Mutex`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Mutex (mutual exclusion) –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ —Ä–µ—Å—É—Ä—Å—É:

```go
// –û—Å–Ω–æ–≤—ã Mutex
func mutexBasics() {
    var mu sync.Mutex
    var counter int
    
    // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
    increment := func() {
        mu.Lock()         // –∑–∞—Ö–≤–∞—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        defer mu.Unlock() // –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ (–¥–∞–∂–µ –ø—Ä–∏ panic)
        counter++
    }
    
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("Counter: %d\n", counter) // –≤—Å–µ–≥–¥–∞ 1000
}

// Mutex –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö
func mutexInStructs() {
    type SafeCounter struct {
        mu    sync.Mutex
        value int
    }
    
    func (c *SafeCounter) Increment() {
        c.mu.Lock()
        defer c.mu.Unlock()
        c.value++
    }
    
    func (c *SafeCounter) Value() int {
        c.mu.Lock()
        defer c.mu.Unlock()
        return c.value
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    counter := &SafeCounter{}
    
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("Safe counter: %d\n", counter.Value())
}

// –ü—Ä–æ–±–ª–µ–º—ã —Å Mutex
func mutexProblems() {
    // 1. Deadlock
    func deadlockExample() {
        var mu1, mu2 sync.Mutex
        
        go func() {
            mu1.Lock()
            time.Sleep(100 * time.Millisecond)
            mu2.Lock() // –º–æ–∂–µ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å—Å—è
            mu2.Unlock()
            mu1.Unlock()
        }()
        
        go func() {
            mu2.Lock()
            time.Sleep(100 * time.Millisecond)
            mu1.Lock() // –º–æ–∂–µ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å—Å—è
            mu1.Unlock()
            mu2.Unlock()
        }()
        
        time.Sleep(500 * time.Millisecond)
    }
    
    // 2. –ó–∞–±—ã–ª–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å
    func forgotUnlock() {
        var mu sync.Mutex
        var data int
        
        badFunction := func() {
            mu.Lock()
            if data < 0 {
                return // –û–®–ò–ë–ö–ê: –Ω–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏!
            }
            data++
            mu.Unlock()
        }
        
        // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å defer
        goodFunction := func() {
            mu.Lock()
            defer mu.Unlock() // –≤—Å–µ–≥–¥–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
            
            if data < 0 {
                return // –±–µ–∑–æ–ø–∞—Å–Ω–æ
            }
            data++
        }
    }
    
    // 3. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ mutex
    func copyMutex() {
        type Counter struct {
            mu    sync.Mutex
            value int
        }
        
        c1 := Counter{}
        c2 := c1 // –û–®–ò–ë–ö–ê: –∫–æ–ø–∏—Ä—É–µ–º mutex!
        
        // go vet –æ–±–Ω–∞—Ä—É–∂–∏—Ç —ç—Ç—É –æ—à–∏–±–∫—É
        // –ü—Ä–∞–≤–∏–ª—å–Ω–æ: –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª–∏
        c3 := &Counter{}
        c4 := c3 // OK: –∫–æ–ø–∏—Ä—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å
    }
}

// –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å Mutex
func advancedMutexPatterns() {
    // 1. Try-lock –ø–∞—Ç—Ç–µ—Ä–Ω
    func tryLock() {
        var mu sync.Mutex
        
        // Go –Ω–µ –∏–º–µ–µ—Ç TryLock, –Ω–æ –º–æ–∂–Ω–æ —ç–º—É–ª–∏—Ä–æ–≤–∞—Ç—å
        type TryMutex struct {
            sync.Mutex
            ch chan struct{}
        }
        
        func NewTryMutex() *TryMutex {
            return &TryMutex{
                ch: make(chan struct{}, 1),
            }
        }
        
        func (tm *TryMutex) TryLock() bool {
            select {
            case tm.ch <- struct{}{}:
                return true
            default:
                return false
            }
        }
        
        func (tm *TryMutex) Unlock() {
            <-tm.ch
        }
        
        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        tryMu := NewTryMutex()
        if tryMu.TryLock() {
            defer tryMu.Unlock()
            // –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
            fmt.Println("Lock acquired")
        } else {
            fmt.Println("Could not acquire lock")
        }
    }
    
    // 2. Timeout lock
    func timeoutLock() {
        type TimeoutMutex struct {
            ch chan struct{}
        }
        
        func NewTimeoutMutex() *TimeoutMutex {
            return &TimeoutMutex{
                ch: make(chan struct{}, 1),
            }
        }
        
        func (tm *TimeoutMutex) LockTimeout(timeout time.Duration) bool {
            select {
            case tm.ch <- struct{}{}:
                return true
            case <-time.After(timeout):
                return false
            }
        }
        
        func (tm *TimeoutMutex) Unlock() {
            <-tm.ch
        }
        
        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        timeoutMu := NewTimeoutMutex()
        if timeoutMu.LockTimeout(100 * time.Millisecond) {
            defer timeoutMu.Unlock()
            fmt.Println("Lock acquired within timeout")
        } else {
            fmt.Println("Lock timeout")
        }
    }
    
    // 3. Mutex —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
    func contextMutex() {
        type ContextMutex struct {
            ch chan struct{}
        }
        
        func NewContextMutex() *ContextMutex {
            return &ContextMutex{
                ch: make(chan struct{}, 1),
            }
        }
        
        func (cm *ContextMutex) LockContext(ctx context.Context) error {
            select {
            case cm.ch <- struct{}{}:
                return nil
            case <-ctx.Done():
                return ctx.Err()
            }
        }
        
        func (cm *ContextMutex) Unlock() {
            <-cm.ch
        }
        
        // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        
        ctxMu := NewContextMutex()
        if err := ctxMu.LockContext(ctx); err == nil {
            defer ctxMu.Unlock()
            fmt.Println("Lock acquired with context")
        } else {
            fmt.Printf("Failed to acquire lock: %v\n", err)
        }
    }
}
```

### 58. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É `Mutex` –∏ `RWMutex`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
RWMutex –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ, –Ω–æ —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—É—é –∑–∞–ø–∏—Å—å:

```go
// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ Mutex –∏ RWMutex
func mutexVsRWMutex() {
    data := make(map[string]int)
    
    // 1. –û–±—ã—á–Ω—ã–π Mutex - —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –¥–æ—Å—Ç—É–ø
    type MutexMap struct {
        mu sync.Mutex
        m  map[string]int
    }
    
    func (mm *MutexMap) Read(key string) int {
        mm.mu.Lock()         // –±–ª–æ–∫–∏—Ä—É–µ—Ç –í–°–ï –æ–ø–µ—Ä–∞—Ü–∏–∏
        defer mm.mu.Unlock()
        return mm.m[key]
    }
    
    func (mm *MutexMap) Write(key string, value int) {
        mm.mu.Lock()         // –±–ª–æ–∫–∏—Ä—É–µ—Ç –í–°–ï –æ–ø–µ—Ä–∞—Ü–∏–∏
        defer mm.mu.Unlock()
        mm.m[key] = value
    }
    
    // 2. RWMutex - —á–∏—Ç–∞—Ç–µ–ª–∏ –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞
    type RWMutexMap struct {
        mu sync.RWMutex
        m  map[string]int
    }
    
    func (rwm *RWMutexMap) Read(key string) int {
        rwm.mu.RLock()         // –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∏—Ç–∞—Ç–µ–ª–∏ OK
        defer rwm.mu.RUnlock()
        return rwm.m[key]
    }
    
    func (rwm *RWMutexMap) Write(key string, value int) {
        rwm.mu.Lock()          // —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–∞—è –∑–∞–ø–∏—Å—å
        defer rwm.mu.Unlock()
        rwm.m[key] = value
    }
}

// –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å RWMutex vs Mutex
func performanceComparison() {
    const (
        numReaders = 10
        numWrites  = 1000
        numReads   = 10000
    )
    
    data := make(map[int]int)
    for i := 0; i < 100; i++ {
        data[i] = i
    }
    
    // –¢–µ—Å—Ç —Å Mutex
    func testMutex() time.Duration {
        var mu sync.Mutex
        var wg sync.WaitGroup
        
        start := time.Now()
        
        // –ß–∏—Ç–∞—Ç–µ–ª–∏
        for i := 0; i < numReaders; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                for j := 0; j < numReads/numReaders; j++ {
                    mu.Lock()
                    _ = data[j%100]
                    mu.Unlock()
                }
            }()
        }
        
        // –ü–∏—Å–∞—Ç–µ–ª—å
        wg.Add(1)
        go func() {
            defer wg.Done()
            for i := 0; i < numWrites; i++ {
                mu.Lock()
                data[i%100] = i
                mu.Unlock()
            }
        }()
        
        wg.Wait()
        return time.Since(start)
    }
    
    // –¢–µ—Å—Ç —Å RWMutex
    func testRWMutex() time.Duration {
        var rwmu sync.RWMutex
        var wg sync.WaitGroup
        
        start := time.Now()
        
        // –ß–∏—Ç–∞—Ç–µ–ª–∏
        for i := 0; i < numReaders; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                for j := 0; j < numReads/numReaders; j++ {
                    rwmu.RLock()
                    _ = data[j%100]
                    rwmu.RUnlock()
                }
            }()
        }
        
        // –ü–∏—Å–∞—Ç–µ–ª—å
        wg.Add(1)
        go func() {
            defer wg.Done()
            for i := 0; i < numWrites; i++ {
                rwmu.Lock()
                data[i%100] = i
                rwmu.Unlock()
            }
        }()
        
        wg.Wait()
        return time.Since(start)
    }
    
    mutexTime := testMutex()
    rwMutexTime := testRWMutex()
    
    fmt.Printf("Mutex time: %v\n", mutexTime)
    fmt.Printf("RWMutex time: %v\n", rwMutexTime)
    fmt.Printf("RWMutex speedup: %.2fx\n", float64(mutexTime)/float64(rwMutexTime))
}

// –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å RWMutex
func whenToUseRWMutex() {
    // RWMutex —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –∫–æ–≥–¥–∞:
    // 1. –ú–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π, –º–∞–ª–æ –ø–∏—Å–∞—Ç–µ–ª–µ–π
    // 2. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–µ–∫—Ü–∏–∏ —á—Ç–µ–Ω–∏—è –¥–æ–ª–≥–∏–µ
    // 3. –î–∞–Ω–Ω—ã–µ —á–∏—Ç–∞—é—Ç—Å—è —á–∞—Å—Ç–æ
    
    // –ü—Ä–∏–º–µ—Ä: –∫—ç—à —Å —Ä–µ–¥–∫–∏–º–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏
    type Cache struct {
        mu   sync.RWMutex
        data map[string]interface{}
    }
    
    func NewCache() *Cache {
        return &Cache{
            data: make(map[string]interface{}),
        }
    }
    
    func (c *Cache) Get(key string) (interface{}, bool) {
        c.mu.RLock()         // –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∏—Ç–∞—Ç–µ–ª–∏
        defer c.mu.RUnlock()
        
        value, exists := c.data[key]
        return value, exists
    }
    
    func (c *Cache) Set(key string, value interface{}) {
        c.mu.Lock()          // —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–∞—è –∑–∞–ø–∏—Å—å
        defer c.mu.Unlock()
        
        c.data[key] = value
    }
    
    func (c *Cache) GetOrCompute(key string, compute func() interface{}) interface{} {
        // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å
        c.mu.RLock()
        if value, exists := c.data[key]; exists {
            c.mu.RUnlock()
            return value
        }
        c.mu.RUnlock()
        
        // –ï—Å–ª–∏ –Ω–µ—Ç, –≤—ã—á–∏—Å–ª—è–µ–º –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ–º
        c.mu.Lock()
        defer c.mu.Unlock()
        
        // Double-check –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è write lock
        if value, exists := c.data[key]; exists {
            return value
        }
        
        value := compute()
        c.data[key] = value
        return value
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    cache := NewCache()
    
    // –ú–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key_%d", id%10)
            
            value := cache.GetOrCompute(key, func() interface{} {
                time.Sleep(10 * time.Millisecond) // –∏–º–∏—Ç–∞—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
                return fmt.Sprintf("computed_value_%s", key)
            })
            
            fmt.Printf("Goroutine %d got: %v\n", id, value)
        }(i)
    }
    
    wg.Wait()
}

// –ü—Ä–æ–±–ª–µ–º—ã —Å RWMutex
func rwMutexProblems() {
    // 1. Writer starvation
    func writerStarvation() {
        var rwmu sync.RWMutex
        var data int
        
        // –ú–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π
        for i := 0; i < 10; i++ {
            go func() {
                for {
                    rwmu.RLock()
                    _ = data
                    time.Sleep(1 * time.Millisecond)
                    rwmu.RUnlock()
                }
            }()
        }
        
        // –ü–∏—Å–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –¥–æ–ª–≥–æ –∂–¥–∞—Ç—å
        go func() {
            for {
                rwmu.Lock()
                data++
                fmt.Printf("Writer updated data to: %d\n", data)
                rwmu.Unlock()
                time.Sleep(100 * time.Millisecond)
            }
        }()
        
        time.Sleep(1 * time.Second)
    }
    
    // 2. Lock upgrade –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω
    func lockUpgradeIssue() {
        var rwmu sync.RWMutex
        var data map[string]int = make(map[string]int)
        
        // –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –Ω–µ–ª—å–∑—è –æ–±–Ω–æ–≤–∏—Ç—å read lock –¥–æ write lock
        badFunction := func(key string) {
            rwmu.RLock()
            if _, exists := data[key]; !exists {
                // rwmu.Lock() // DEADLOCK! –£–∂–µ –¥–µ—Ä–∂–∏–º RLock
                // data[key] = 1
                // rwmu.Unlock()
            }
            rwmu.RUnlock()
        }
        
        // –ü–†–ê–í–ò–õ–¨–ù–û: —Å–Ω–∞—á–∞–ª–∞ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º read lock
        goodFunction := func(key string) {
            rwmu.RLock()
            _, exists := data[key]
            rwmu.RUnlock()
            
            if !exists {
                rwmu.Lock()
                // Double-check pattern
                if _, exists := data[key]; !exists {
                    data[key] = 1
                }
                rwmu.Unlock()
            }
        }
    }
}
```

### 59. –ß—Ç–æ —Ç–∞–∫–æ–µ `sync.WaitGroup` –∏ –∫–∞–∫ –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
WaitGroup –∂–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã –≥–æ—Ä—É—Ç–∏–Ω:

```go
// –û—Å–Ω–æ–≤—ã WaitGroup
func waitGroupBasics() {
    var wg sync.WaitGroup
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω
    for i := 1; i <= 5; i++ {
        wg.Add(1) // —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –Ω–∞ 1
        
        go func(id int) {
            defer wg.Done() // —É–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
            
            fmt.Printf("Goroutine %d starting\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
            fmt.Printf("Goroutine %d finished\n", id)
        }(i)
    }
    
    fmt.Println("Waiting for all goroutines to finish...")
    wg.Wait() // –∂–¥–µ–º –ø–æ–∫–∞ —Å—á–µ—Ç—á–∏–∫ –Ω–µ —Å—Ç–∞–Ω–µ—Ç 0
    fmt.Println("All goroutines finished!")
}

// –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
func waitGroupPatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: Add –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –≥–æ—Ä—É—Ç–∏–Ω—ã
    func correctPattern() {
        var wg sync.WaitGroup
        
        for i := 0; i < 3; i++ {
            wg.Add(1) // –ü–†–ê–í–ò–õ–¨–ù–û: Add –ø–µ—Ä–µ–¥ go
            go func(id int) {
                defer wg.Done()
                time.Sleep(100 * time.Millisecond)
                fmt.Printf("Task %d completed\n", id)
            }(i)
        }
        
        wg.Wait()
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: WaitGroup –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
    type WorkerPool struct {
        wg       sync.WaitGroup
        jobQueue chan Job
    }
    
    type Job struct {
        ID   int
        Data string
    }
    
    func (wp *WorkerPool) Start(numWorkers int) {
        for i := 0; i < numWorkers; i++ {
            wp.wg.Add(1)
            go wp.worker(i)
        }
    }
    
    func (wp *WorkerPool) worker(id int) {
        defer wp.wg.Done()
        
        for job := range wp.jobQueue {
            fmt.Printf("Worker %d processing job %d: %s\n", id, job.ID, job.Data)
            time.Sleep(100 * time.Millisecond)
        }
    }
    
    func (wp *WorkerPool) Wait() {
        close(wp.jobQueue) // –∑–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è workers
        wp.wg.Wait()       // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö workers
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    pool := &WorkerPool{
        jobQueue: make(chan Job, 10),
    }
    
    pool.Start(3) // –∑–∞–ø—É—Å–∫–∞–µ–º 3 workers
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏
    for i := 1; i <= 5; i++ {
        pool.jobQueue <- Job{ID: i, Data: fmt.Sprintf("task_%d", i)}
    }
    
    pool.Wait() // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
}

// –û—à–∏–±–∫–∏ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ WaitGroup
func waitGroupErrors() {
    // –û—à–∏–±–∫–∞ 1: Add –≤–Ω—É—Ç—Ä–∏ –≥–æ—Ä—É—Ç–∏–Ω—ã
    func wrongAddPlacement() {
        var wg sync.WaitGroup
        
        for i := 0; i < 3; i++ {
            go func(id int) {
                wg.Add(1) // –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å race condition
                defer wg.Done()
                time.Sleep(100 * time.Millisecond)
            }(i)
        }
        
        wg.Wait() // –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ –≤—Å–µ Add –≤—ã–∑–æ–≤—É—Ç—Å—è
    }
    
    // –û—à–∏–±–∫–∞ 2: –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ WaitGroup
    func copyWaitGroup() {
        var wg1 sync.WaitGroup
        wg2 := wg1 // –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –∫–æ–ø–∏—Ä—É–µ–º WaitGroup
        
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            time.Sleep(100 * time.Millisecond)
        }()
        
        wg2.Wait() // –±—É–¥–µ—Ç –∂–¥–∞—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞, —Ç–∞–∫ –∫–∞–∫ wg2 - —ç—Ç–æ –∫–æ–ø–∏—è
    }
    
    // –û—à–∏–±–∫–∞ 3: –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ WaitGroup
    func reuseWaitGroup() {
        var wg sync.WaitGroup
        
        // –ü–µ—Ä–≤–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        wg.Add(1)
        go func() {
            defer wg.Done()
            time.Sleep(50 * time.Millisecond)
        }()
        wg.Wait()
        
        // –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ - –û–ü–ê–°–ù–û
        // –ï—Å–ª–∏ —Å—á–µ—Ç—á–∏–∫ —Å—Ç–∞–ª –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º, –±—É–¥–µ—Ç panic
        wg.Add(1)
        go func() {
            defer wg.Done()
            time.Sleep(50 * time.Millisecond)
        }()
        wg.Wait()
    }
}

// –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å WaitGroup
func advancedWaitGroupPatterns() {
    // –ü–∞—Ç—Ç–µ—Ä–Ω 1: –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º
    func limitedParallelism() {
        const maxGoroutines = 3
        tasks := make([]int, 20)
        for i := range tasks {
            tasks[i] = i + 1
        }
        
        var wg sync.WaitGroup
        semaphore := make(chan struct{}, maxGoroutines)
        
        for _, task := range tasks {
            wg.Add(1)
            
            go func(taskID int) {
                defer wg.Done()
                
                semaphore <- struct{}{} // –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Å–µ–º–∞—Ñ–æ—Ä
                defer func() { <-semaphore }() // –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Å–µ–º–∞—Ñ–æ—Ä
                
                fmt.Printf("Processing task %d\n", taskID)
                time.Sleep(200 * time.Millisecond)
                fmt.Printf("Task %d completed\n", taskID)
            }(task)
        }
        
        wg.Wait()
        fmt.Println("All tasks completed")
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 2: Pipeline —Å WaitGroup
    func pipeline() {
        // Stage 1: —á–∏—Å–ª–∞
        numbers := make(chan int, 10)
        
        // Stage 2: –∫–≤–∞–¥—Ä–∞—Ç—ã
        squares := make(chan int, 10)
        
        // Stage 3: —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        results := make(chan int, 10)
        
        var wg sync.WaitGroup
        
        // Generator
        wg.Add(1)
        go func() {
            defer wg.Done()
            defer close(numbers)
            
            for i := 1; i <= 10; i++ {
                numbers <- i
            }
        }()
        
        // Squarer
        wg.Add(1)
        go func() {
            defer wg.Done()
            defer close(squares)
            
            for num := range numbers {
                squares <- num * num
            }
        }()
        
        // Filter (—Ç–æ–ª—å–∫–æ —á–µ—Ç–Ω—ã–µ)
        wg.Add(1)
        go func() {
            defer wg.Done()
            defer close(results)
            
            for square := range squares {
                if square%2 == 0 {
                    results <- square
                }
            }
        }()
        
        // Consumer
        go func() {
            for result := range results {
                fmt.Printf("Even square: %d\n", result)
            }
        }()
        
        wg.Wait() // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö stages
        time.Sleep(100 * time.Millisecond) // –¥–∞–µ–º –≤—Ä–µ–º—è consumer'—É
    }
    
    // –ü–∞—Ç—Ç–µ—Ä–Ω 3: Graceful shutdown
    func gracefulShutdown() {
        var wg sync.WaitGroup
        quit := make(chan struct{})
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º workers
        for i := 1; i <= 3; i++ {
            wg.Add(1)
            go func(workerID int) {
                defer wg.Done()
                
                ticker := time.NewTicker(100 * time.Millisecond)
                defer ticker.Stop()
                
                for {
                    select {
                    case <-ticker.C:
                        fmt.Printf("Worker %d is working...\n", workerID)
                    case <-quit:
                        fmt.Printf("Worker %d shutting down\n", workerID)
                        return
                    }
                }
            }(i)
        }
        
        // –°–∏–º—É–ª–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É
        time.Sleep(500 * time.Millisecond)
        
        // –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
        fmt.Println("Initiating shutdown...")
        close(quit)
        
        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö workers
        wg.Wait()
        fmt.Println("All workers stopped")
    }
    
    limitedParallelism()
    pipeline()
    gracefulShutdown()
}

// WaitGroup —Å —Ç–∞–π–º–∞—É—Ç–æ–º
func waitGroupWithTimeout() {
    var wg sync.WaitGroup
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    waitTimeout := func(wg *sync.WaitGroup, timeout time.Duration) bool {
        c := make(chan struct{})
        go func() {
            defer close(c)
            wg.Wait()
        }()
        
        select {
        case <-c:
            return false // –∑–∞–≤–µ—Ä—à–∏–ª–æ—Å—å –≤–æ–≤—Ä–µ–º—è
        case <-time.After(timeout):
            return true // —Ç–∞–π–º–∞—É—Ç
        }
    }
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –¥–æ–ª–≥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é
    wg.Add(1)
    go func() {
        defer wg.Done()
        time.Sleep(2 * time.Second) // –¥–æ–ª–≥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è
    }()
    
    // –ñ–¥–µ–º —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    if waitTimeout(&wg, 1*time.Second) {
        fmt.Println("Operation timed out")
    } else {
        fmt.Println("Operation completed")
    }
}
```

### 60. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `sync.Once`?

**–†–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç:**
Once –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑, –¥–∞–∂–µ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≥–æ—Ä—É—Ç–∏–Ω:

```go
// –û—Å–Ω–æ–≤—ã sync.Once
func onceBasics() {
    var once sync.Once
    var result string
    
    // –§—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –¥–æ–ª–∂–Ω–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
    initFunction := func() {
        fmt.Println("Initializing...")
        time.Sleep(100 * time.Millisecond) // –∏–º–∏—Ç–∞—Ü–∏—è –¥–æ—Ä–æ–≥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏
        result = "initialized"
        fmt.Println("Initialization complete")
    }
    
    var wg sync.WaitGroup
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            fmt.Printf("Goroutine %d calling Do\n", id)
            once.Do(initFunction) // –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
            fmt.Printf("Goroutine %d got result: %s\n", id, result)
        }(i)
    }
    
    wg.Wait()
    // –í—ã–≤–æ–¥ –ø–æ–∫–∞–∂–µ—Ç, —á—Ç–æ "Initializing..." –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
}

// –¢–∏–ø–∏—á–Ω—ã–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è sync.Once
func onceUseCases() {
    // 1. Singleton –ø–∞—Ç—Ç–µ—Ä–Ω
    type Database struct {
        connection string
    }
    
    var (
        dbInstance *Database
        dbOnce     sync.Once
    )
    
    func GetDatabase() *Database {
        dbOnce.Do(func() {
            fmt.Println("Creating database connection...")
            time.Sleep(50 * time.Millisecond) // –∏–º–∏—Ç–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            dbInstance = &Database{connection: "connected"}
        })
        return dbInstance
    }
    
    // –¢–µ—Å—Ç–∏—Ä—É–µ–º singleton
    var wg sync.WaitGroup
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            db := GetDatabase()
            fmt.Printf("Goroutine %d got DB: %p\n", id, db)
        }(i)
    }
    wg.Wait()
    // –í—Å–µ –≥–æ—Ä—É—Ç–∏–Ω—ã –ø–æ–ª—É—á–∞—Ç –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ —ç–∫–∑–µ–º–ø–ª—è—Ä
    
    // 2. –õ–µ–Ω–∏–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    type Config struct {
        Settings map[string]string
    }
    
    var (
        config     *Config
        configOnce sync.Once
    )
    
    func loadConfig() *Config {
        configOnce.Do(func() {
            fmt.Println("Loading configuration...")
            config = &Config{
                Settings: map[string]string{
                    "host": "localhost",
                    "port": "8080",
                },
            }
        })
        return config
    }
    
    // 3. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    var (
        handlersRegistered bool
        registerOnce       sync.Once
    )
    
    func registerHandlers() {
        registerOnce.Do(func() {
            fmt.Println("Registering HTTP handlers...")
            // —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–æ–≤
            handlersRegistered = true
        })
    }
}

// –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å Once
func advancedOncePatterns() {
    // 1. Once —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –æ—à–∏–±–∫–∏
    type OnceWithError struct {
        once sync.Once
        err  error
    }
    
    func (o *OnceWithError) Do(f func() error) error {
        o.once.Do(func() {
            o.err = f()
        })
        return o.err
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
    var initOnce OnceWithError
    
    initializeService := func() error {
        fmt.Println("Initializing service...")
        // –ò–º–∏—Ç–∞—Ü–∏—è –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –æ—à–∏–±–∫–∏
        if rand.Float64() < 0.3 {
            return errors.New("initialization failed")
        }
        return nil
    }
    
    var wg sync.WaitGroup
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            err := initOnce.Do(initializeService)
            fmt.Printf("Goroutine %d: init error = %v\n", id, err)
        }(i)
    }
    wg.Wait()
    
    // 2. Once —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º
    type OnceValue[T any] struct {
        once  sync.Once
        value T
    }
    
    func (o *OnceValue[T]) Do(f func() T) T {
        o.once.Do(func() {
            o.value = f()
        })
        return o.value
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å –¥–∂–µ–Ω–µ—Ä–∏–∫–∞–º–∏ (Go 1.18+)
    var expensiveComputation OnceValue[int]
    
    compute := func() int {
        fmt.Println("Performing expensive computation...")
        time.Sleep(100 * time.Millisecond)
        return 42
    }
    
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            result := expensiveComputation.Do(compute)
            fmt.Printf("Goroutine %d got result: %d\n", id, result)
        }(i)
    }
    wg.Wait()
    
    // 3. –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ Once –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
    type ResourceManager struct {
        dbOnce     sync.Once
        cacheOnce  sync.Once
        loggerOnce sync.Once
        
        db     *Database
        cache  *Cache
        logger *Logger
    }
    
    func (rm *ResourceManager) GetDB() *Database {
        rm.dbOnce.Do(func() {
            fmt.Println("Initializing database...")
            rm.db = &Database{connection: "db_connected"}
        })
        return rm.db
    }
    
    func (rm *ResourceManager) GetCache() *Cache {
        rm.cacheOnce.Do(func() {
            fmt.Println("Initializing cache...")
            rm.cache = &Cache{data: make(map[string]interface{})}
        })
        return rm.cache
    }
    
    func (rm *ResourceManager) GetLogger() *Logger {
        rm.loggerOnce.Do(func() {
            fmt.Println("Initializing logger...")
            rm.logger = &Logger{level: "INFO"}
        })
        return rm.logger
    }
}

// –û—à–∏–±–∫–∏ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ Once
func onceErrors() {
    // –û—à–∏–±–∫–∞ 1: –ü–∞–Ω–∏—á–µ—Å–∫–∏–π –≤—ã–∑–æ–≤ Once.Do
    func panicInOnce() {
        var once sync.Once
        
        defer func() {
            if r := recover(); r != nil {
                fmt.Printf("Recovered from panic: %v\n", r)
            }
        }()
        
        once.Do(func() {
            panic("something went wrong")
        })
        
        // –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è, –¥–∞–∂–µ –ø–æ—Å–ª–µ panic
        once.Do(func() {
            fmt.Println("This will not execute")
        })
    }
    
    // –û—à–∏–±–∫–∞ 2: –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ Once
    func copyOnce() {
        var once1 sync.Once
        once2 := once1 // –∫–æ–ø–∏—Ä—É–µ–º Once
        
        once1.Do(func() {
            fmt.Println("Called on once1")
        })
        
        // once2 - —ç—Ç–æ –∫–æ–ø–∏—è, –Ω–µ–∑–∞–≤–∏—Å–∏–º–∞—è –æ—Ç once1
        once2.Do(func() {
            fmt.Println("Called on once2") // –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è!
        })
    }
    
    // –û—à–∏–±–∫–∞ 3: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤ Once.Do
    func recursiveOnce() {
        var once sync.Once
        
        var f func()
        f = func() {
            fmt.Println("In function f")
            once.Do(f) // DEADLOCK! –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤
        }
        
        // once.Do(f) // —ç—Ç–æ –≤—ã–∑–æ–≤–µ—Ç deadlock
    }
    
    panicInOnce()
    copyOnce()
    // recursiveOnce() // –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å deadlock
}

// –†–µ–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è HTTP –∫–ª–∏–µ–Ω—Ç–∞
func httpClientOnce() {
    var (
        httpClient *http.Client
        clientOnce sync.Once
    )
    
    func getHTTPClient() *http.Client {
        clientOnce.Do(func() {
            fmt.Println("Creating HTTP client...")
            httpClient = &http.Client{
                Timeout: 30 * time.Second,
                Transport: &http.Transport{
                    MaxIdleConns:        100,
                    MaxIdleConnsPerHost: 10,
                    IdleConnTimeout:     90 * time.Second,
                },
            }
        })
        return httpClient
    }
    
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≥–æ—Ä—É—Ç–∏–Ω–∞—Ö
    var wg sync.WaitGroup
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            client := getHTTPClient()
            fmt.Printf("Goroutine %d got HTTP client: %p\n", id, client)
            
            // –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ)
            // resp, err := client.Get("https://example.com")
        }(i)
    }
    wg.Wait()
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ç–∏–ø—ã –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤
type Cache struct {
    data map[string]interface{}
}

type Logger struct {
    level string
}
```

*–ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å–æ —Å–ª–µ–¥—É—é—â–∏–º–∏ —Ä–∞–∑–¥–µ–ª–∞–º–∏...*