# Собеседование: Структуры данных и управление памятью (2025)

## Блок 1: Основы структур данных

### 1. Какая временная сложность доступа к элементу в хеш-таблице в худшем случае?
**Ответ:** O(n) в худшем случае, когда все элементы попадают в одну и ту же корзину из-за коллизий.

**Углубление:** Объясните разницу между отдельным цепочкой (separate chaining) и открытой адресацией (open addressing). Как бы вы реализовали хеш-таблицу с автоматическим изменением размера (rehashing)?

### 2. В чем принципиальная разница между ArrayList и LinkedList в контексте управления памятью?
**Ответ:** ArrayList хранит элементы в непрерывном блоке памяти, что обеспечивает лучшую локальность данных для кеша процессора. LinkedList использует отдельные узлы в разных областях памяти, что приводит к фрагментации и большему количеству промахов кеша.

**Углубление:** Как влияет cache-friendly природа ArrayList на производительность при итерации по 1 миллиону элементов? Приведите пример, когда LinkedList может быть предпочтительнее.

### 3. Объясните принцип работы B-дерева и почему именно эта структура используется в СУБД.
**Ответ:** B-дерево - это сбалансированное дерево поиска, где каждый узел может содержать множество ключей и детей. Это минимизирует количество операций чтения с диска, так как один узел помещается в одну страницу диска.

**Углубление:** Почему в современных SSD-накопителях все еще актуальны B-деревья? Как изменились параметры B-деревьев с переходом от HDD к SSD?

## Блок 2: Управление памятью

### 4. Чем отличается управление памятью в heap и stack?
**Ответ:** Stack - автоматически управляемая память LIFO для локальных переменных и параметров функций. Heap - динамически управляемая область для объектов, требующая явного освобождения или сборки мусора.

**Углубление:** Объясните, что происходит на уровне памяти при рекурсивном вызове функции глубиной 10000 уровней. Как это влияет на производительность и безопасность?

### 5. Что такое memory leak и как его можно обнаружить в production-системе?
**Ответ:** Memory leak - это ситуация, когда программа выделяет память, но не освобождает ее после использования. В production можно использовать профайлеры памяти, мониторинг heap dump'ов, и инструменты вроде VisualVM или профайлеры приложения.

**Углубление:** Приведите три конкретных сценария, которые могут привести к memory leak в веб-приложении с микросервисной архитектурой.

### 6. Объясните принцип работы generational garbage collection.
**Ответ:** Память heap разделена на поколения: Young Generation (Eden + Survivor spaces) и Old Generation. Новые объекты создаются в Eden, выжившие объекты переходят в Survivor, а долгоживущие - в Old Generation.

**Углубление:** Как бы вы настроили JVM для приложения с большим количеством кратковременных объектов vs. приложения с долгоживущими объектами кеша?

## Блок 3: Продвинутые структуры данных

### 7. Когда стоит использовать Trie вместо HashMap для поиска строк?
**Ответ:** Trie эффективнее при операциях с префиксами, автодополнении, поиске по частичному совпадению. HashMap быстрее для точного поиска по ключу.

**Углубление:** Реализуйте compressed trie (Patricia tree) и объясните, как это экономит память при хранении большого количества строк с общими префиксами.

### 8. Объясните принцип работы LSM-деревьев и их применение в NoSQL базах данных.
**Ответ:** LSM (Log-Structured Merge) деревья оптимизированы для записи. Данные сначала записываются в in-memory структуру, затем сбрасываются на диск в отсортированных файлах, которые периодически объединяются.

**Углубление:** Почему LSM-деревья хорошо подходят для write-heavy нагрузок? Как компактификация влияет на производительность чтения?

### 9. В чем разница между consistent hashing и обычным хешированием в распределенных системах?
**Ответ:** Consistent hashing минимизирует количество перемещаемых данных при добавлении/удалении узлов. Данные и узлы размещаются на кольце, каждый элемент принадлежит ближайшему по часовой стрелке узлу.

**Углубление:** Как virtual nodes решают проблему неравномерного распределения данных в consistent hashing? Реализуйте простой алгоритм.

## Блок 4: Кеширование и производительность

### 10. Объясните разницу между L1, L2, L3 кешами процессора и как это влияет на дизайн алгоритмов.
**Ответ:** L1 - самый быстрый и маленький (32KB), L2 - средний (256KB-1MB), L3 - самый большой и медленный (8-32MB). Алгоритмы должны учитывать локальность данных для эффективного использования кеша.

**Углубление:** Как принцип cache-oblivious алгоритмов помогает создавать эффективный код? Приведите пример оптимизации матричного умножения.

### 11. Какие стратегии кеширования вы знаете и когда каждую применять?
**Ответ:** Write-through (запись в кеш и хранилище одновременно), Write-back (отложенная запись), Write-around (обход кеша при записи). Cache-aside для приложений, Write-through для критичных данных.

**Углубление:** Как реализовать многоуровневое кеширование с TTL и LRU eviction policy в микросервисной архитектуре?

### 12. Что такое false sharing и как с этим бороться?
**Ответ:** False sharing возникает, когда разные потоки обращаются к переменным в одной cache line, вызывая ненужные синхронизации кеша между CPU ядрами.

**Углубление:** Как padding и выравнивание данных решают проблему false sharing? Приведите пример кода с измерениями производительности.

## Блок 5: Конкурентность и синхронизация

### 13. Объясните разницу между lock-free и wait-free структурами данных.
**Ответ:** Lock-free гарантирует, что хотя бы один поток всегда может продвигаться вперед. Wait-free гарантирует, что каждый поток завершит операцию за конечное число шагов.

**Углубление:** Реализуйте lock-free стек используя Compare-And-Swap. Какие проблемы возникают с ABA problem?

### 14. Как работает copy-on-write и где это применяется?
**Ответ:** COW откладывает копирование данных до момента записи. Несколько процессов/потоков могут разделять одну область памяти до тех пор, пока кто-то не попытается ее изменить.

**Углубление:** Как COW используется в fork() системном вызове? Объясните применение в persistent data structures.

### 15. Что такое memory barriers и зачем они нужны?
**Ответ:** Memory barriers предотвращают переупорядочивание операций памяти компилятором или процессором, обеспечивая правильную видимость изменений между потоками.

**Углубление:** Объясните разницу между acquire, release и full memory barriers. Как volatile в Java связано с memory barriers?

## Блок 6: Специализированные структуры

### 16. Когда использовать Bloom filter и каковы его ограничения?
**Ответ:** Bloom filter - это вероятностная структура для проверки принадлежности множеству. Может давать false positives, но не false negatives. Используется для предварительной фильтрации перед дорогими операциями.

**Углубление:** Как рассчитать оптимальное количество хеш-функций и размер битового массива для заданной вероятности false positive?

### 17. Объясните принцип работы Skip List и его преимущества над сбалансированными деревьями.
**Ответ:** Skip List - это вероятностная структура с несколькими уровнями связанных списков. Обеспечивает O(log n) операции без сложной балансировки деревьев.

**Углубление:** Как Lock-free Skip List обеспечивает concurrent доступ? Сравните производительность с ConcurrentHashMap.

### 18. Что такое segment tree и когда его использовать?
**Ответ:** Segment tree позволяет эффективно выполнять запросы на диапазонах и обновления элементов за O(log n). Используется для range queries: сумма, минимум, максимум на отрезке.

**Углубление:** Как lazy propagation оптимизирует range updates в segment tree? Реализуйте range sum queries с range updates.

## Блок 7: Память в распределенных системах

### 19. Как работает distributed caching и какие проблемы это решает?
**Ответ:** Distributed caching распределяет данные кеша между несколькими узлами, увеличивая общий объем кеша и обеспечивая горизонтальное масштабирование.

**Углубление:** Сравните архитектуры Redis Cluster vs Memcached. Как обеспечить consistency при cache invalidation в distributed setup?

### 20. Что такое memory-mapped files и когда их использовать?
**Ответ:** Memory-mapped files позволяют работать с файлами как с областью памяти, что эффективно для больших файлов и межпроцессного взаимодействия.

**Углубление:** Как OS обеспечивает consistency при concurrent доступе к memory-mapped files? Объясните применение в базах данных.

### 21. Объясните принципы работы NUMA архитектуры и ее влияние на производительность.
**Ответ:** Non-Uniform Memory Access - архитектура, где процессоры имеют разную скорость доступа к разным областям памяти в зависимости от их физического расположения.

**Углубление:** Как NUMA-aware приложения оптимизируют размещение данных? Приведите пример настройки JVM для NUMA.

## Блок 8: Профилирование и оптимизация

### 22. Как вы будете профилировать memory usage в production приложении?
**Ответ:** Использование heap dumps, профайлеров (JProfiler, async-profiler), мониторинг метрик GC, анализ memory pools через JMX.

**Углубление:** Как анализировать heap dump размером 10GB? Какие паттерны утечек памяти можно выявить автоматически?

### 23. Что такое memory fragmentation и как с ней бороться?
**Ответ:** Фрагментация памяти - это состояние, когда доступная память разбита на маленькие несмежные блоки, которые нельзя использовать для больших аллокаций.

**Углубление:** Как object pooling и arena allocation помогают бороться с фрагментацией? Реализуйте простой arena allocator.

### 24. Объясните принципы garbage collection tuning в production системах.
**Ответ:** Настройка размеров heap regions, выбор подходящего GC алгоритма (G1, ZGC, Shenandoah), мониторинг GC логов и метрик pause time.

**Углубление:** Как выбрать между throughput-oriented (Parallel GC) и latency-oriented (ZGC) сборщиками мусора для high-load системы?

## Блок 9: Архитектурные решения

### 25. Как бы вы спроектировали in-memory database?
**Ответ:** Использование optimized data structures (hash indexes, tree indexes), memory pooling, transaction logging, compression для cold data, persistent checkpoints.

**Углубление:** Как обеспечить durability в in-memory DB? Сравните write-ahead logging vs shadow paging approaches.

### 26. Объясните архитектуру columnar storage и ее преимущества.
**Ответ:** Columnar storage хранит данные по колонкам, что обеспечивает лучшую компрессию и производительность для аналитических запросов, которые обычно обращаются к подмножеству колонок.

**Углубление:** Как vectorized execution engine использует columnar layout для SIMD оптимизаций? Объясните batch processing в Apache Arrow.

### 27. Как реализовать efficient пагинацию для миллионов записей?
**Ответ:** Cursor-based pagination вместо offset-based, использование индексов, avoid COUNT(*) queries, caching metadata о total count.

**Углубление:** Как keyset pagination решает проблемы consistency при concurrent modifications? Реализуйте безопасную пагинацию для real-time feed.

## Блок 10: Современные тренды (2025)

### 28. Как persistent memory (Intel Optane) меняет подходы к структурам данных?
**Ответ:** Persistent memory обеспечивает byte-addressable access с durability, что позволяет создавать структуры данных, которые сохраняются между перезапусками без serialization.

**Углубление:** Как cache-line flush operations обеспечивают consistency в persistent memory? Объясните failure-atomic sections.

### 29. Объясните принципы работы machine learning accelerated data structures.
**Ответ:** ML может предсказывать patterns доступа к данным, оптимизировать размещение в кеше, динамически выбирать лучшие алгоритмы на основе workload characteristics.

**Углубление:** Как learned indexes используют ML модели для замены традиционных B-деревьев? Приведите пример adaptive data structure.

### 30. Как quantum computing может повлиять на алгоритмы поиска и сортировки?
**Ответ:** Квантовые алгоритмы как Grover's search могут обеспечить квадратичное ускорение для неструктурированного поиска, а Shor's algorithm революционизирует криптографию.

**Углубление:** Как quantum-resistant хеширование изменит дизайн hash-based структур данных? Объясните влияние на blockchain и distributed systems.

---

## Критерии оценки ответов:

**Отлично (5/5):**
- Полное понимание концепций и их взаимосвязей
- Способность применять знания к реальным задачам
- Понимание trade-offs и performance implications
- Знание современных тенденций и best practices

**Хорошо (4/5):**
- Правильное понимание основных концепций
- Способность объяснить применение в практических сценариях
- Понимание основных trade-offs

**Удовлетворительно (3/5):**
- Базовое понимание концепций
- Способность объяснить простые случаи использования
- Некоторые пробелы в деталях реализации

**Неудовлетворительно (2/5 и ниже):**
- Поверхностное понимание или значительные пробелы
- Неспособность связать теорию с практикой
- Отсутствие понимания performance implications