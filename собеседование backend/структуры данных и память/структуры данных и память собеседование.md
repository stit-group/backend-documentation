# Техническое собеседование Backend разработчика
## Глубокое понимание структур данных и управления памятью

### Инструкции для интервьюера
- Задавайте основные вопросы последовательно
- Используйте углубляющие вопросы для проверки глубины понимания
- Обращайте внимание на объяснение алгоритмической сложности
- Просите приводить примеры из реальной практики

---

## 1. Массивы и строки

### 1.1 Основной вопрос: Объясните разницу между статическими и динамическими массивами. Как они хранятся в памяти?

**Углубляющие вопросы:**
1. Что происходит при добавлении элемента в динамический массив, когда он заполнен?
2. Почему доступ к элементу массива по индексу имеет O(1) временную сложность?
3. Как устроена память при хранении многомерных массивов? Row-major vs Column-major.
4. Объясните понятие locality of reference и как массивы его используют.
5. В чем разница между массивом и списком в контексте управления памятью?

### 1.2 Основной вопрос: Как устроены строки в разных языках программирования? Что такое string interning?

**Углубляющие вопросы:**
1. Почему строки в Java неизменяемы и как это влияет на память?
2. Объясните разницу между StringBuilder и String concatenation с точки зрения памяти.
3. Как работает UTF-8 encoding и почему важно понимать это при работе со строками?
4. Что такое Copy-on-Write для строк и где это применяется?
5. Как реализован поиск подстроки в алгоритме KMP с точки зрения использования памяти?

### 1.3 Основной вопрос: Объясните принцип работы динамического массива (ArrayList, Vector). Какие стратегии роста используются?

**Углубляющие вопросы:**
1. Почему коэффициент роста обычно 1.5 или 2? Какие плюсы и минусы каждого?
2. Как реализовать shrinking динамического массива, чтобы избежать thrashing?
3. Объясните amortized analysis для операций вставки в динамический массив.
4. Как работает memory fragmentation при многократном расширении массивов?
5. В каких случаях лучше использовать preallocated array вместо динамического?

### 1.4 Основной вопрос: Что такое memory alignment и как он влияет на производительность работы с массивами?

**Углубляющие вопросы:**
1. Объясните понятие cache line и как размещение данных влияет на cache miss.
2. Что такое structure padding и как это влияет на массивы структур?
3. Как SIMD инструкции работают с выровненными данными?
4. Объясните разницу между stack allocation и heap allocation для массивов.
5. Что такое memory prefetching и как компилятор может его оптимизировать?

### 1.5 Основной вопрос: Реализуйте эффективный алгоритм поворота массива на k позиций. Объясните использование памяти.

**Углубляющие вопросы:**
1. Как решить эту задачу с O(1) дополнительной памятью?
2. Объясните алгоритм разворота для rotation и его временную сложность.
3. Как cyclic replacement работает и почему нужен GCD?
4. В каких случаях лучше использовать дополнительную память O(n)?
5. Как эта операция будет работать с memory-mapped файлами?

### 1.6 Основной вопрос: Объясните различные способы реализации sparse arrays и их применение.

**Углубляющие вопросы:**
1. Когда использовать hash map vs compressed sparse row format?
2. Как работает bit vector для представления sparse data?
3. Объясните trade-off между памятью и временем доступа в sparse structures.
4. Как реализовать эффективное умножение sparse matrices?
5. В каких случаях sparse array может быть медленнее обычного массива?

### 1.7 Основной вопрос: Что такое circular buffer и как он экономит память? Где применяется?

**Углубляющие вопросы:**
1. Как избежать false sharing в многопоточном circular buffer?
2. Объясните разницу между overwrite и blocking поведением при переполнении.
3. Как определить оптимальный размер буфера для конкретного приложения?
4. Что такое lock-free circular buffer и как он работает?
5. Как реализовать variable-size elements в circular buffer?

### 1.8 Основной вопрос: Объясните принцип работы rope data structure для работы с большими строками.

**Углубляющие вопросы:**
1. В каких случаях rope эффективнее обычных строк?
2. Как balancing влияет на производительность операций?
3. Объясните lazy evaluation в rope operations.
4. Как реализовать эффективное substring для rope?
5. Сравните rope с gap buffer для текстовых редакторов.

### 1.9 Основной вопрос: Как работает copy-on-write для массивов и когда это полезно?

**Углубляющие вопросы:**
1. Объясните implementation details COW в системных языках.
2. Как page fault handling работает с COW pages?
3. В каких случаях COW может ухудшить производительность?
4. Как reference counting сочетается с COW?
5. Объясните проблемы COW в многопоточном окружении.

### 1.10 Основной вопрос: Реализуйте алгоритм для нахождения всех анаграмм в массиве строк с минимальным использованием памяти.

**Углубляющие вопросы:**
1. Как использовать хеширование для группировки анаграмм?
2. Объясните rolling hash для эффективного сравнения.
3. Как sorting characters влияет на memory usage?
4. В каких случаях лучше использовать trie для анаграмм?
5. Как оптимизировать алгоритм для очень длинных строк?

---

## 2. Связные списки

### 2.1 Основной вопрос: Объясните разницу между односвязным, двусвязным и циклическим списками. Сравните использование памяти.

**Углубляющие вопросы:**
1. Почему pointer overhead может быть критичным для маленьких элементов?
2. Как cache locality влияет на производительность связных списков?
3. Объясните memory fragmentation при работе со связными списками.
4. Когда использование XOR linked list оправдано?
5. Как skip list улучшает поиск по сравнению с обычным связным списком?

### 2.2 Основной вопрос: Реализуйте алгоритм определения цикла в связном списке (Floyd's algorithm). Объясните использование памяти.

**Углубляющие вопросы:**
1. Почему алгоритм Флойда использует O(1) памяти?
2. Как найти начало цикла после обнаружения его существования?
3. Сравните с подходом использования hash set - когда какой лучше?
4. Как работает алгоритм Брента и чем он отличается?
5. Что делать, если список может изменяться во время проверки на цикл?

### 2.3 Основной вопрос: Как реализовать memory pool для узлов связного списка? Какие преимущества это дает?

**Углубляющие вопросы:**
1. Объясните разницу между object pool и memory pool.
2. Как избежать memory fragmentation при использовании pool?
3. Что такое slab allocator и как он работает?
4. Как реализовать thread-safe memory pool?
5. В каких случаях memory pool может ухудшить производительность?

### 2.4 Основной вопрос: Объясните проблемы с cache miss в связных списках и способы их решения.

**Углубляющие вопросы:**
1. Что такое pointer chasing и как это влияет на производительность?
2. Как unrolled linked list улучшает cache locality?
3. Объясните принцип работы array of structures vs structure of arrays.
4. Как prefetching может помочь при обходе связного списка?
5. В каких случаях связный список все же лучше массива?

### 2.5 Основной вопрос: Реализуйте lock-free linked list. Какие проблемы с памятью нужно решить?

**Углубляющие вопросы:**
1. Что такое ABA problem и как с ним бороться?
2. Объясните hazard pointers для safe memory reclamation.
3. Как work-stealing queues используют lock-free lists?
4. Что такое epoch-based memory management?
5. Сравните RCU (Read-Copy-Update) с другими подходами.

### 2.6 Основной вопрос: Как реализовать persistent (immutable) linked list? Объясните sharing стратегии.

**Углубляющие вопросы:**
1. Что такое structural sharing и как это экономит память?
2. Как garbage collection влияет на persistent structures?
3. Объясните copy-on-write для linked list modifications.
4. Как path copying работает в persistent data structures?
5. В каких случаях persistent structures эффективнее mutable?

### 2.7 Основной вопрос: Объясните устройство и применение skip list. Как он использует память?

**Углубляющие вопросы:**
1. Как определить оптимальную вероятность для уровней?
2. Объясните space-time trade-off в skip list.
3. Как concurrent skip list решает проблемы synchronization?
4. Сравните skip list с B-tree по использованию памяти.
5. В каких случаях deterministic skip list предпочтительнее?

### 2.8 Основной вопрос: Реализуйте алгоритм слияния k отсортированных связных списков с минимальным использованием памяти.

**Углубляющие вопросы:**
1. Сравните подходы: priority queue vs divide-and-conquer.
2. Как in-place merging влияет на сложность алгоритма?
3. Объясните использование минимальной кучи для k-way merge.
4. Как оптимизировать для случая, когда списки очень разной длины?
5. Что делать, если списки не помещаются в память целиком?

---

## 3. Стеки и очереди

### 3.1 Основной вопрос: Объясните различные способы реализации стека и их влияние на память.

**Углубляющие вопросы:**
1. Сравните array-based vs linked list-based реализации стека.
2. Как growth strategy влияет на memory fragmentation?
3. Что такое segmented stack и когда он полезен?
4. Объясните проблемы со stack overflow и способы их предотвращения.
5. Как реализовать bounded stack с efficient memory usage?

### 3.2 Основной вопрос: Реализуйте stack с поддержкой getMin() за O(1) время и объясните использование памяти.

**Углубляющие вопросы:**
1. Сравните подходы: auxiliary stack vs encoding в основном стеке.
2. Как оптимизировать память при множественных одинаковых минимумах?
3. Объясните разницу в memory overhead между разными подходами.
4. Как реализовать аналогичную функциональность для getMax()?
5. Что если нужно поддерживать и getMin() и getMax() одновременно?

### 3.3 Основной вопрос: Объясните различные типы очередей и их memory layout.

**Углубляющие вопросы:**
1. Как circular queue экономит память по сравнению с обычной очередью?
2. Объясните проблему определения full vs empty в circular queue.
3. Что такое deque и как он реализуется эффективно по памяти?
4. Сравните linked list vs circular buffer для реализации очереди.
5. Как double-ended queue может использовать segmented buffer?

### 3.4 Основной вопрос: Реализуйте priority queue и объясните heap data structure с точки зрения памяти.

**Углубляющие вопросы:**
1. Почему binary heap имеет хорошую cache locality?
2. Сравните d-ary heap с binary heap по использованию памяти.
3. Как binomial heap экономит память при merge операциях?
4. Объясните Fibonacci heap и его amortized memory usage.
5. В каких случаях pairing heap предпочтительнее?

### 3.5 Основной вопрос: Как реализовать thread-safe queue без блокировок? Какие проблемы с памятью возникают?

**Углубляющие вопросы:**
1. Объясните Michael & Scott lock-free queue algorithm.
2. Что такое memory ordering и как оно влияет на concurrent queues?
3. Как решить проблему memory reclamation в lock-free structures?
4. Объясните разницу wait-free vs lock-free implementations.
5. Как bounded lock-free queue отличается от unbounded?

### 3.6 Основной вопрос: Реализуйте monotonic stack и объясните его применение.

**Углубляющие вопросы:**
1. Как monotonic stack помогает в задачах с next greater element?
2. Объясните memory efficiency по сравнению с naive approaches.
3. Как sliding window maximum использует monotonic deque?
4. В каких задачах monotonic stack дает оптимальное время и память?
5. Как реализовать monotonic stack для custom comparison?

### 3.7 Основной вопрос: Объясните устройство call stack и его влияние на память программы.

**Углубляющие вопросы:**
1. Как stack frame организован в памяти?
2. Что такое stack overflow и как его предотвратить?
3. Объясните tail call optimization с точки зрения memory usage.
4. Как continuation-passing style влияет на использование стека?
5. Что такое split stack и как он работает в Go?

### 3.8 Основной вопрос: Реализуйте queue используя два стека. Проанализируйте amortized complexity и memory usage.

**Углубляющие вопросы:**
1. Объясните почему dequeue имеет amortized O(1) complexity.
2. Как worst-case scenario влияет на memory consumption?
3. Сравните с реализацией через один стек и recursion.
4. Как оптимизировать для случая преимущественно enqueue операций?
5. Что изменится если стеки имеют bounded capacity?

---

## 4. Деревья и графы

### 4.1 Основной вопрос: Объясните различные типы бинарных деревьев и их memory layout.

**Углубляющие вопросы:**
1. Сравните pointer-based vs array-based представления бинарного дерева.
2. Как implicit heap organization экономит память?
3. Объясните memory fragmentation при работе с pointer-based деревьями.
4. Что такое threaded binary tree и как он экономит память при обходе?
5. Как compact binary tree representation работает с bit manipulation?

### 4.2 Основной вопрос: Реализуйте AVL дерево и объясните overhead ротаций на память.

**Углубляющие вопросы:**
1. Как хранение balance factor влияет на memory usage?
2. Сравните memory overhead AVL vs Red-Black tree.
3. Объясните lazy rebalancing strategies для экономии памяти.
4. Как bulk loading может оптимизировать memory layout?
5. В каких случаях unbalanced tree может быть предпочтительнее?

### 4.3 Основной вопрос: Объясните принцип работы B-tree и его оптимизации для дисковой памяти.

**Углубляющие вопросы:**
1. Как выбрать оптимальный order для B-tree исходя из page size?
2. Объясните copy-on-write B-trees для versioned data.
3. Что такое B+ tree и как он оптимизирует range queries?
4. Как fractional cascading улучшает поиск в B-trees?
5. Объясните log-structured merge trees и их memory usage.

### 4.4 Основной вопрос: Реализуйте trie (prefix tree) и проанализируйте его memory consumption.

**Углубляющие вопросы:**
1. Сравните array-based vs hash-based дочерние узлы в trie.
2. Что такое compressed trie (radix tree) и как он экономит память?
3. Объясните succinct trie representations.
4. Как burst trie оптимизирует memory usage для sparse data?
5. В каких случаях suffix tree предпочтительнее trie?

### 4.5 Основной вопрос: Объясните различные способы представления графов в памяти.

**Углубляющие вопросы:**
1. Сравните adjacency matrix vs adjacency list по memory usage.
2. Когда использовать edge list representation?
3. Что такое compressed sparse row (CSR) для графов?
4. Как parallel adjacency arrays оптимизируют cache usage?
5. Объясните graph streaming algorithms для больших графов.

### 4.6 Основной вопрос: Реализуйте DFS и BFS с оптимальным использованием памяти.

**Углубляющие вопросы:**
1. Как итеративный DFS экономит память по сравнению с рекурсивным?
2. Объясните bidirectional search для экономии памяти.
3. Что такое iterative deepening и когда он полезен?
4. Как A* algorithm управляет памятью в open/closed sets?
5. Объясните frontier search techniques для больших графов.

### 4.7 Основной вопрос: Как работают persistent data structures на примере persistent tree?

**Углубляющие вопросы:**
1. Объясните path copying vs fat node methods.
2. Как structural sharing минимизирует memory overhead?
3. Что такое confluently persistent structures?
4. Как garbage collection влияет на persistent structures?
5. Сравните persistent structures с copy-on-write approaches.

### 4.8 Основной вопрос: Реализуйте Union-Find (Disjoint Set) с path compression и union by rank.

**Углубляющие вопросы:**
1. Как path compression влияет на memory access patterns?
2. Объясните почему union by rank better than union by size.
3. Что такое linking by index и его memory implications?
4. Как persistent Union-Find структуры работают?
5. Объясните randomized linking strategies.

### 4.9 Основной вопрос: Объясните segment tree и его memory usage для range queries.

**Углубляющие вопросы:**
1. Сравните implicit vs explicit segment tree representations.
2. Как lazy propagation оптимизирует memory в segment trees?
3. Что такое persistent segment tree и его memory complexity?
4. Объясните fractional cascading в segment trees.
5. Как sparse segment trees работают с большими диапазонами?

### 4.10 Основной вопрос: Реализуйте Fenwick tree (Binary Indexed Tree) и объясните его компактность.

**Углубляющие вопросы:**
1. Почему Fenwick tree более memory-efficient чем segment tree?
2. Объясните bit manipulation tricks в Fenwick tree.
3. Как 2D Fenwick tree организует память?
4. Что такое range update Fenwick tree?
5. Сравните Fenwick tree с sparse table для static queries.

### 4.11 Основной вопрос: Объясните топологическую сортировку и memory-efficient алгоритмы.

**Углубляющие вопросы:**
1. Сравните Kahn's algorithm vs DFS-based approach по памяти.
2. Как in-place topological sort может работать?
3. Объясните space-time trade-offs в parallel topological sorting.
4. Что делать с циклами в контексте memory management?
5. Как streaming topological sort работает с большими графами?

### 4.12 Основной вопрос: Реализуйте алгоритм поиска кратчайших путей (Dijkstra) с оптимальным использованием памяти.

**Углубляющие вопросы:**
1. Как выбор priority queue влияет на memory consumption?
2. Объясните bidirectional Dijkstra и его memory benefits.
3. Что такое A* memory-bounded search?
4. Как работает differential A* для reducing memory?
5. Объясните hierarchical path planning approaches.

---

## 5. Хеш-таблицы

### 5.1 Основной вопрос: Объясните различные методы разрешения коллизий в хеш-таблицах и их влияние на память.

**Углубляющие вопросы:**
1. Сравните chaining vs open addressing по memory usage.
2. Как load factor влияет на memory efficiency?
3. Объясните Robin Hood hashing и его memory benefits.
4. Что такое cuckoo hashing и его memory guarantees?
5. Как consistent hashing управляет памятью в distributed systems?

### 5.2 Основной вопрос: Реализуйте hash table с linear probing и объясните кластеризацию.

**Углубляющие вопросы:**
1. Как tombstone entries влияют на memory usage?
2. Объясните backward shift deletion для экономии памяти.
3. Что такое hopscotch hashing и его cache performance?
4. Как parallel hash tables справляются с false sharing?
5. Объясните memory-mapped hash tables для больших данных.

### 5.3 Основной вопрос: Как работает динамическое изменение размера хеш-таблицы?

**Углубляющие вопросы:**
1. Объясните incremental rehashing для avoiding memory spikes.
2. Как extendible hashing минимизирует memory reorganization?
3. Что такое linear hashing и его memory growth pattern?
4. Как concurrent resizing влияет на memory consistency?
5. Объясните memory-conscious hash table shrinking.

### 5.4 Основной вопрос: Объясните Bloom filter и его memory efficiency.

**Углубляющие вопросы:**
1. Как выбрать оптимальное количество hash functions?
2. Объясните counting Bloom filter и его memory overhead.
3. Что такое cuckoo filter и как он сравнивается с Bloom filter?
4. Как scalable Bloom filter управляет ростом памяти?
5. Объясните quotient filter как compact alternative.

### 5.5 Основной вопрос: Реализуйте LRU cache используя hash table + doubly linked list.

**Углубляющие вопросы:**
1. Как минимизировать memory overhead pointer structures?
2. Объясните memory layout optimization для cache lines.
3. Что такое clock algorithm и его memory benefits?
4. Как 2Q algorithm улучшает memory efficiency?
5. Объясните adaptive replacement cache (ARC) memory management.

### 5.6 Основной вопрос: Объясните consistent hashing и его применение в distributed systems.

**Углубляющие вопросы:**
1. Как virtual nodes влияют на memory usage?
2. Объясните rendezvous hashing как alternative.
3. Что такое jump consistent hash и его memory efficiency?
4. Как consistent hashing with bounded loads работает?
5. Объясните memory implications of hash ring replication.

### 5.7 Основной вопрос: Реализуйте hash table для string keys с оптимизацией памяти.

**Углубляющие вопросы:**
1. Как string interning экономит память в hash tables?
2. Объясните rolling hash для efficient string comparison.
3. Что такое minimal perfect hashing для static strings?
4. Как trie-based hashing комбинирует prefix compression?
5. Объясните succinct hash tables для string keys.

### 5.8 Основной вопрос: Объясните проблемы hash table в многопоточном окружении.

**Углубляющие вопросы:**
1. Как lock-free hash table управляет memory ordering?
2. Объясните memory barriers в concurrent hash operations.
3. Что такое split-ordered hashing для lock-free tables?
4. Как hazard pointers работают в concurrent hash tables?
5. Объясните epoch-based memory reclamation в hash tables.

---

## 6. Управление памятью

### 6.1 Основной вопрос: Объясните различные стратегии управления памятью: stack, heap, garbage collection.

**Углубляющие вопросы:**
1. Как stack allocation быстрее heap allocation?
2. Объясните fragmentation в heap memory и способы борьбы.
3. Что такое memory pool и когда его использовать?
4. Как работает slab allocator в операционных системах?
5. Объясните buddy system для memory allocation.

### 6.2 Основной вопрос: Реализуйте простой memory allocator. Объясните стратегии размещения.

**Углубляющие вопросы:**
1. Сравните first-fit, best-fit, worst-fit strategies.
2. Как coalescing свободных блоков влияет на производительность?
3. Объясните segregated free lists для разных размеров.
4. Что такое memory alignment и как его обеспечить?
5. Как реализовать thread-safe allocator без глобальных блокировок?

### 6.3 Основной вопрос: Объясните различные алгоритмы garbage collection.

**Углубляющие вопросы:**
1. Сравните mark-and-sweep vs copying garbage collection.
2. Как generational GC оптимизирует memory management?
3. Объясните incremental GC для reducing pause times.
4. Что такое concurrent GC и его challenges?
5. Как region-based memory management работает?

### 6.4 Основной вопрос: Что такое memory leak и как их обнаружить и предотвратить?

**Углубляющие вопросы:**
1. Объясните циклические ссылки и способы их разрешения.
2. Как weak references помогают предотвратить memory leaks?
3. Что такое dangling pointer и use-after-free?
4. Объясните tools для detection memory leaks (valgrind, AddressSanitizer).
5. Как RAII pattern помогает с memory management?

### 6.5 Основной вопрос: Объясните virtual memory и как она влияет на программы.

**Углубляющие вопросы:**
1. Что такое page fault и как он обрабатывается?
2. Объясните copy-on-write механизм в fork().
3. Как memory-mapped files оптимизируют I/O?
4. Что такое swapping и его влияние на performance?
5. Объясните NUMA и его влияние на memory allocation.

### 6.6 Основной вопрос: Реализуйте reference counting с учетом циклических ссылок.

**Углубляющие вопросы:**
1. Как cycle detection алгоритмы работают с reference counting?
2. Объясните weak references и их implementation.
3. Что такое deferred reference counting?
4. Как combine reference counting с tracing GC?
5. Объясните memory overhead of reference counting.

### 6.7 Основной вопрос: Что такое memory-mapped I/O и когда его использовать?

**Углубляющие вопросы:**
1. Сравните mmap vs traditional read/write по memory usage.
2. Как shared memory segments работают между процессами?
3. Объясните copy-on-write для memory-mapped files.
4. Что такое memory-mapped databases и их преимущества?
5. Как handling large files влияет на virtual memory?

### 6.8 Основной вопрос: Объясните проблемы memory corruption и способы защиты.

**Углубляющие вопросы:**
1. Что такое buffer overflow и как его предотвратить?
2. Объясните stack canaries и как они работают.
3. Что такое ASLR (Address Space Layout Randomization)?
4. Как memory tagging помогает обнаружить corruption?
5. Объясните control flow integrity и его memory implications.

### 6.9 Основной вопрос: Реализуйте object pool для управления памятью объектов.

**Углубляющие вопросы:**
1. Как определить оптимальный размер pool?
2. Объясните lazy initialization vs pre-allocation strategies.
3. Что делать при pool exhaustion?
4. Как thread-safe object pool минимизирует contention?
5. Объясните object pool vs flyweight pattern differences.

### 6.10 Основной вопрос: Объясните escape analysis и его роль в оптимизации памяти.

**Углубляющие вопросы:**
1. Как компилятор определяет, что объект может быть stack-allocated?
2. Объясните scalar replacement optimization.
3. Что такое lock elision через escape analysis?
4. Как inlining влияет на escape analysis?
5. В каких случаях escape analysis может быть неточным?

### 6.11 Основной вопрос: Что такое memory barriers и memory ordering?

**Углубляющие вопросы:**
1. Объясните difference между acquire и release semantics.
2. Что такое memory reordering и когда оно происходит?
3. Как volatile keyword влияет на memory ordering?
4. Объясните sequential consistency vs relaxed memory models.
5. Что такое data race и как memory barriers его предотвращают?

### 6.12 Основной вопрос: Реализуйте lock-free memory allocator и объясните его сложности.

**Углубляющие вопросы:**
1. Что такое ABA problem в context of memory allocation?
2. Как hazard pointers защищают from premature deallocation?
3. Объясните epoch-based memory reclamation.
4. Что такое memory reclamation vs memory reuse?
5. Как minimize contention в многопоточном allocator?

---

## 7. Алгоритмы сортировки и поиска

### 7.1 Основной вопрос: Сравните различные алгоритмы сортировки по использованию памяти.

**Углубляющие вопросы:**
1. Почему merge sort требует O(n) дополнительной памяти?
2. Как реализовать in-place merge для merge sort?
3. Объясните memory access patterns в quick sort vs heap sort.
4. Что такое cache-oblivious sorting algorithms?
5. Как external sorting работает с ограниченной памятью?

### 7.2 Основной вопрос: Реализуйте quick sort с оптимизацией для memory usage.

**Углубляющие вопросы:**
1. Как tail recursion optimization экономит stack space?
2. Объясните iterative quick sort для avoiding stack overflow.
3. Что такое 3-way partitioning и его memory benefits?
4. Как introsort комбинирует different sorting algorithms?
5. Объясните dual-pivot quick sort memory characteristics.

### 7.3 Основной вопрос: Объясните counting sort и radix sort. Когда они memory-efficient?

**Углубляющие вопросы:**
1. Как optimize counting sort для large range values?
2. Объясните LSD vs MSD radix sort memory usage.
3. Что такое flash sort и его memory characteristics?
4. Как bucket sort distributes memory usage?
5. Объясните in-place radix sort techniques.

### 7.4 Основной вопрос: Реализуйте binary search и его вариации с минимальным memory footprint.

**Углубляющие вопросы:**
1. Как избежать integer overflow в binary search?
2. Объясните exponential search для unbounded arrays.
3. Что такое interpolation search и когда он эффективен?
4. Как ternary search работает с unimodal functions?
5. Объясните fractional cascading для multiple searches.

### 7.5 Основной вопрос: Объясните external sorting для данных, не помещающихся в память.

**Углубляющие вопросы:**
1. Как выбрать оптимальный размер chunks для external merge?
2. Объясните polyphase merge и его memory benefits.
3. Что такое replacement selection для generating runs?
4. Как minimize I/O в external sorting?
5. Объясните parallel external sorting strategies.

### 7.6 Основной вопрос: Реализуйте k-way merge с приоритетной очередью.

**Углубляющие вопросы:**
1. Сравните heap-based vs tournament tree approaches.
2. Как loser tree оптимизирует k-way merge?
3. Объясните memory locality в k-way merge.
4. Что делать когда k очень большое?
5. Как streaming k-way merge экономит память?

### 7.7 Основной вопрос: Объясните алгоритмы поиска в строках и их memory usage.

**Углубляющие вопросы:**
1. Сравните KMP vs Boyer-Moore по использованию памяти.
2. Как Rabin-Karp экономит память при multiple pattern search?
3. Объясните suffix array vs suffix tree memory trade-offs.
4. Что такое Aho-Corasick algorithm для multiple patterns?
5. Как compressed suffix arrays работают?

### 7.8 Основной вопрос: Реализуйте approximate string matching с ограниченной памятью.

**Углубляющие вопросы:**
1. Как optimize edit distance computation для long strings?
2. Объясните Hirschberg algorithm для linear space alignment.
3. Что такое bit-parallel approximate matching?
4. Как q-gram indexing балансирует memory и accuracy?
5. Объясните locality-sensitive hashing для similarity search.

### 7.9 Основной вопрос: Объясните compressed data structures и их поисковые свойства.

**Углубляющие вопросы:**
1. Что такое succinct data structures?
2. Как rank/select queries работают на compressed data?
3. Объясните wavelet trees и их applications.
4. Что такое FM-index и его memory characteristics?
5. Как compressed suffix arrays support pattern matching?

### 7.10 Основной вопрос: Реализуйте top-k queries с ограниченной памятью.

**Углубляющие вопросы:**
1. Сравните min-heap vs quickselect для top-k.
2. Как reservoir sampling работает для streaming top-k?
3. Объясните space-time trade-offs в approximate top-k.
4. Что такое threshold algorithm для top-k queries?
5. Как distribute top-k computation across machines?

---

## 8. Системы баз данных и индексы

### 8.1 Основной вопрос: Объясните различные типы индексов и их memory characteristics.

**Углубляющие вопросы:**
1. Сравните B-tree vs hash index по memory usage.
2. Как clustered vs non-clustered indexes влияют на память?
3. Объясните bitmap indexes и их memory efficiency.
4. Что такое covering index и его memory benefits?
5. Как partial indexes экономят память?

### 8.2 Основной вопрос: Реализуйте B+ tree для database indexing.

**Углубляющие вопросы:**
1. Как выбрать optimal fan-out для минимизации I/O?
2. Объясните bulk loading techniques для B+ trees.
3. Что такое prefix compression в B+ tree nodes?
4. Как concurrent B+ tree operations управляют памятью?
5. Объясните log-structured B+ trees.

### 8.3 Основной вопрос: Объясните buffer pool management в СУБД.

**Углубляющие вопросы:**
1. Сравните LRU vs Clock replacement policies.
2. Как dirty page management влияет на memory usage?
3. Объясните adaptive buffer pool sizing.
4. Что такое buffer pool bypass для large scans?
5. Как multiple buffer pools улучшают performance?

### 8.4 Основной вопрос: Реализуйте hash join и объясните его memory requirements.

**Углубляющие вопросы:**
1. Как выбрать build vs probe table для memory efficiency?
2. Объясните grace hash join для large tables.
3. Что такое hybrid hash join и его adaptive nature?
4. Как parallel hash join распределяет память?
5. Объясните bloom filter optimization в hash joins.

### 8.5 Основной вопрос: Объясните column-oriented storage и его memory benefits.

**Углубляющие вопросы:**
1. Как column compression улучшает memory efficiency?
2. Объясните vectorized processing в columnar stores.
3. Что такое delta compression для sorted columns?
4. Как dictionary encoding экономит память?
5. Объясните run-length encoding для sparse data.

### 8.6 Основной вопрос: Реализуйте LSM-tree (Log-Structured Merge Tree).

**Углубляющие вопросы:**
1. Как leveling vs tiering влияет на memory usage?
2. Объясните bloom filters в LSM-tree levels.
3. Что такое write amplification и memory implications?
4. Как compaction strategies балансируют memory и I/O?
5. Объясните partitioned LSM-trees для better parallelism.

### 8.7 Основной вопрос: Объясните query optimization с точки зрения memory usage.

**Углубляющие вопросы:**
1. Как cost-based optimizer учитывает memory constraints?
2. Объясните memory-aware join ordering.
3. Что такое materialization vs pipelining trade-offs?
4. Как sort-merge join управляет memory при больших данных?
5. Объясните adaptive query execution и memory.

### 8.8 Основной вопрос: Реализуйте distributed hash table с consistent hashing.

**Углубляющие вопросы:**
1. Как replication factor влияет на memory usage?
2. Объясните anti-entropy mechanisms и их memory cost.
3. Что такое merkle trees для efficient synchronization?
4. Как gossip protocols распространяют metadata?
5. Объясните memory implications of eventual consistency.

---

## 9. Кэширование и производительность

### 9.1 Основной вопрос: Объясните различные уровни кэша и их влияние на программы.

**Углубляющие вопросы:**
1. Как cache line size влияет на data structure design?
2. Объясните false sharing и способы его избежания.
3. Что такое cache-oblivious algorithms?
4. Как prefetching улучшает cache performance?
5. Объясните NUMA effects на cache hierarchy.

### 9.2 Основной вопрос: Реализуйте cache-friendly data layout для struct of arrays.

**Углубляющие вопросы:**
1. Сравните AoS vs SoA для different access patterns.
2. Как data padding влияет на cache utilization?
3. Объясните hot/cold data separation strategies.
4. Что такое structure splitting для better locality?
5. Как compiler optimizations помогают с data layout?

### 9.3 Основной вопрос: Объясните различные cache replacement policies и их implementation.

**Углубляющие вопросы:**
1. Сравните LRU vs LFU vs Random replacement.
2. Как implement efficient LRU с O(1) operations?
3. Объясните adaptive replacement cache (ARC).
4. Что такое scan-resistant cache policies?
5. Как multi-level cache hierarchies выбирают replacement?

### 9.4 Основной вопрос: Реализуйте distributed cache с consistent hashing.

**Углубляющие вопросы:**
1. Как handle cache node failures gracefully?
2. Объясните cache warming strategies.
3. Что такое cache coherence в distributed systems?
4. Как implement cache partitioning для hot data?
5. Объясните memory vs network trade-offs в distributed caching.

---

## Заключение

Этот набор вопросов покрывает все ключевые аспекты понимания структур данных и управления памятью для backend разработчика. Вопросы организованы по возрастанию сложности в каждой категории и включают как теоретические знания, так и практические навыки реализации.

### Рекомендации по проведению интервью:
- Начинайте с базовых концепций перед переходом к углубляющим вопросам
- Просите кандидата объяснять временную и пространственную сложность
- Обращайте внимание на понимание trade-offs между различными подходами
- Просите приводить примеры из реальной практики
- Оценивайте способность оптимизировать код для конкретных ограничений памяти

### Критерии оценки:
- **Отлично**: Четкое понимание всех концепций, может объяснить implementation details и оптимизации
- **Хорошо**: Понимает основные принципы, может решить большинство задач с подсказками
- **Удовлетворительно**: Знает базовые структуры данных, но затрудняется с оптимизацией памяти
- **Неудовлетворительно**: Слабое понимание фундаментальных концепций